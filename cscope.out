cscope 15 $HOME/newip/stream/quicly -c               0002050938
	@CMakeFiles/3.22.1/CompilerIdC/CMakeCCompilerId.c

1 #ifdef 
__cplusplus


5 #if 
defined
(
__18CXX
)

6 #define 
	#ID_VOID_MAIN


	)

8 #if 
defined
(
__CLASSIC_C__
)

10 #define const

	)

11 #define volatile

	)

14 #if !
defined
(
__has_include
)

17 #define 
	#__has_include
(
x
) 0

	)

24 #if 
defined
(
__INTEL_COMPILER
) || defined(
__ICC
)

25 #define 
	#COMPILER_ID
 "Intel"

	)

26 #if 
defined
(
_MSC_VER
)

27 #define 
	#SIMULATE_ID
 "MSVC"

	)

29 #if 
defined
(
__GNUC__
)

30 #define 
	#SIMULATE_ID
 "GNU"

	)

34 #if 
__INTEL_COMPILER
 < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111

35 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
/100)

	)

36 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER
/10 % 10)

	)

37 #if 
defined
(
__INTEL_COMPILER_UPDATE
)

38 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

40 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER
 % 10)

	)

43 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
)

	)

44 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

47 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(0)

	)

49 #if 
defined
(
__INTEL_COMPILER_BUILD_DATE
)

51 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__INTEL_COMPILER_BUILD_DATE
)

	)

53 #if 
defined
(
_MSC_VER
)

55 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

56 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

58 #if 
defined
(
__GNUC__
)

59 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

60 #elif 
defined
(
__GNUG__
)

61 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

63 #if 
defined
(
__GNUC_MINOR__
)

64 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

66 #if 
defined
(
__GNUC_PATCHLEVEL__
)

67 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

70 #elif (
defined
(
__clang__
) && defined(
__INTEL_CLANG_COMPILER
)) || defined(
__INTEL_LLVM_COMPILER
)

71 #define 
	#COMPILER_ID
 "IntelLLVM"

	)

72 #if 
defined
(
_MSC_VER
)

73 #define 
	#SIMULATE_ID
 "MSVC"

	)

75 #if 
defined
(
__GNUC__
)

76 #define 
	#SIMULATE_ID
 "GNU"

	)

82 #if 
__INTEL_LLVM_COMPILER
 < 1000000L

83 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100)

	)

84 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10 % 10)

	)

85 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 10)

	)

87 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10000)

	)

88 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100 % 100)

	)

89 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 100)

	)

91 #if 
defined
(
_MSC_VER
)

93 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

94 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

96 #if 
defined
(
__GNUC__
)

97 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

98 #elif 
defined
(
__GNUG__
)

99 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

101 #if 
defined
(
__GNUC_MINOR__
)

102 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

104 #if 
defined
(
__GNUC_PATCHLEVEL__
)

105 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

108 #elif 
defined
(
__PATHCC__
)

109 #define 
	#COMPILER_ID
 "PathScale"

	)

110 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PATHCC__
)

	)

111 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PATHCC_MINOR__
)

	)

112 #if 
defined
(
__PATHCC_PATCHLEVEL__
)

113 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PATHCC_PATCHLEVEL__
)

	)

116 #elif 
defined
(
__BORLANDC__
) && defined(
__CODEGEARC_VERSION__
)

117 #define 
	#COMPILER_ID
 "Embarcadero"

	)

118 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>24 & 0x00FF)

	)

119 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>16 & 0x00FF)

	)

120 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__CODEGEARC_VERSION__
 & 0xFFFF)

	)

122 #elif 
defined
(
__BORLANDC__
)

123 #define 
	#COMPILER_ID
 "Borland"

	)

125 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__BORLANDC__
>>8)

	)

126 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__BORLANDC__
 & 0xFF)

	)

128 #elif 
defined
(
__WATCOMC__
) && __WATCOMC__ < 1200

129 #define 
	#COMPILER_ID
 "Watcom"

	)

131 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__WATCOMC__
 / 100)

	)

132 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

133 #if (
__WATCOMC__
 % 10) > 0

134 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

137 #elif 
defined
(
__WATCOMC__
)

138 #define 
	#COMPILER_ID
 "OpenWatcom"

	)

140 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__WATCOMC__
 - 1100) / 100)

	)

141 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

142 #if (
__WATCOMC__
 % 10) > 0

143 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

146 #elif 
defined
(
__SUNPRO_C
)

147 #define 
	#COMPILER_ID
 "SunPro"

	)

148 #if 
__SUNPRO_C
 >= 0x5100

150 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_C
>>12)

	)

151 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_C
>>4 & 0xFF)

	)

152 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_C
 & 0xF)

	)

155 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_C
>>8)

	)

156 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_C
>>4 & 0xF)

	)

157 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_C
 & 0xF)

	)

160 #elif 
defined
(
__HP_cc
)

161 #define 
	#COMPILER_ID
 "HP"

	)

163 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__HP_cc
/10000)

	)

164 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__HP_cc
/100 % 100)

	)

165 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__HP_cc
 % 100)

	)

167 #elif 
defined
(
__DECC
)

168 #define 
	#COMPILER_ID
 "Compaq"

	)

170 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__DECC_VER
/10000000)

	)

171 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__DECC_VER
/100000 % 100)

	)

172 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__DECC_VER
 % 10000)

	)

174 #elif 
defined
(
__IBMC__
) && defined(
__COMPILER_VER__
)

175 #define 
	#COMPILER_ID
 "zOS"

	)

177 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

178 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

179 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

181 #elif 
defined
(
__ibmxl__
) && defined(
__clang__
)

182 #define 
	#COMPILER_ID
 "XLClang"

	)

183 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ibmxl_version__
)

	)

184 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ibmxl_release__
)

	)

185 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ibmxl_modification__
)

	)

186 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__ibmxl_ptf_fix_level__
)

	)

189 #elif 
defined
(
__IBMC__
) && !defined(
__COMPILER_VER__
) && __IBMC__ >= 800

190 #define 
	#COMPILER_ID
 "XL"

	)

192 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

193 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

194 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

196 #elif 
defined
(
__IBMC__
) && !defined(
__COMPILER_VER__
) && __IBMC__ < 800

197 #define 
	#COMPILER_ID
 "VisualAge"

	)

199 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMC__
/100)

	)

200 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMC__
/10 % 10)

	)

201 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMC__
 % 10)

	)

203 #elif 
defined
(
__NVCOMPILER
)

204 #define 
	#COMPILER_ID
 "NVHPC"

	)

205 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__NVCOMPILER_MAJOR__
)

	)

206 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__NVCOMPILER_MINOR__
)

	)

207 #if 
defined
(
__NVCOMPILER_PATCHLEVEL__
)

208 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__NVCOMPILER_PATCHLEVEL__
)

	)

211 #elif 
defined
(
__PGI
)

212 #define 
	#COMPILER_ID
 "PGI"

	)

213 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PGIC__
)

	)

214 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PGIC_MINOR__
)

	)

215 #if 
defined
(
__PGIC_PATCHLEVEL__
)

216 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PGIC_PATCHLEVEL__
)

	)

219 #elif 
defined
(
_CRAYC
)

220 #define 
	#COMPILER_ID
 "Cray"

	)

221 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_RELEASE_MAJOR
)

	)

222 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_RELEASE_MINOR
)

	)

224 #elif 
defined
(
__TI_COMPILER_VERSION__
)

225 #define 
	#COMPILER_ID
 "TI"

	)

227 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000000)

	)

228 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000 % 1000)

	)

229 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__TI_COMPILER_VERSION__
 % 1000)

	)

231 #elif 
defined
(
__CLANG_FUJITSU
)

232 #define 
	#COMPILER_ID
 "FujitsuClang"

	)

233 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

234 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

235 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

236 #define 
	#COMPILER_VERSION_INTERNAL_STR
 
__clang_version__


	)

239 #elif 
defined
(
__FUJITSU
)

240 #define 
	#COMPILER_ID
 "Fujitsu"

	)

241 #if 
defined
(
__FCC_version__
)

242 #define 
	#COMPILER_VERSION
 
__FCC_version__


	)

243 #elif 
defined
(
__FCC_major__
)

244 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

245 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

246 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

248 #if 
defined
(
__fcc_version
)

249 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__fcc_version
)

	)

250 #elif 
defined
(
__FCC_VERSION
)

251 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__FCC_VERSION
)

	)

255 #elif 
defined
(
__ghs__
)

256 #define 
	#COMPILER_ID
 "GHS"

	)

258 #ifdef 
__GHS_VERSION_NUMBER


259 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 100)

	)

260 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 10 % 10)

	)

261 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GHS_VERSION_NUMBER
 % 10)

	)

264 #elif 
defined
(
__TINYC__
)

265 #define 
	#COMPILER_ID
 "TinyCC"

	)

267 #elif 
defined
(
__BCC__
)

268 #define 
	#COMPILER_ID
 "Bruce"

	)

270 #elif 
defined
(
__SCO_VERSION__
)

271 #define 
	#COMPILER_ID
 "SCO"

	)

273 #elif 
defined
(
__ARMCC_VERSION
) && !defined(
__clang__
)

274 #define 
	#COMPILER_ID
 "ARMCC"

	)

275 #if 
__ARMCC_VERSION
 >= 1000000

277 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/1000000)

	)

278 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 100)

	)

279 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

282 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/100000)

	)

283 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 10)

	)

284 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

288 #elif 
defined
(
__clang__
) && defined(
__apple_build_version__
)

289 #define 
	#COMPILER_ID
 "AppleClang"

	)

290 #if 
defined
(
_MSC_VER
)

291 #define 
	#SIMULATE_ID
 "MSVC"

	)

293 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

294 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

295 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

296 #if 
defined
(
_MSC_VER
)

298 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

299 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

301 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__apple_build_version__
)

	)

303 #elif 
defined
(
__clang__
) && defined(
__ARMCOMPILER_VERSION
)

304 #define 
	#COMPILER_ID
 "ARMClang"

	)

305 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/1000000)

	)

306 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/10000 % 100)

	)

307 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCOMPILER_VERSION
 % 10000)

	)

308 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__ARMCOMPILER_VERSION
)

	)

310 #elif 
defined
(
__clang__
)

311 #define 
	#COMPILER_ID
 "Clang"

	)

312 #if 
defined
(
_MSC_VER
)

313 #define 
	#SIMULATE_ID
 "MSVC"

	)

315 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

316 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

317 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

318 #if 
defined
(
_MSC_VER
)

320 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

321 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

324 #elif 
defined
(
__GNUC__
)

325 #define 
	#COMPILER_ID
 "GNU"

	)

326 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

327 #if 
defined
(
__GNUC_MINOR__
)

328 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

330 #if 
defined
(
__GNUC_PATCHLEVEL__
)

331 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

334 #elif 
defined
(
_MSC_VER
)

335 #define 
	#COMPILER_ID
 "MSVC"

	)

337 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

338 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

339 #if 
defined
(
_MSC_FULL_VER
)

340 #if 
_MSC_VER
 >= 1400

342 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 100000)

	)

345 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 10000)

	)

348 #if 
defined
(
_MSC_BUILD
)

349 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
_MSC_BUILD
)

	)

352 #elif 
defined
(
__VISUALDSPVERSION__
) || defined(
__ADSPBLACKFIN__
) || defined(
__ADSPTS__
) || defined(
__ADSP21000__
)

353 #define 
	#COMPILER_ID
 "ADSP"

	)

354 #if 
defined
(
__VISUALDSPVERSION__
)

356 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__VISUALDSPVERSION__
>>24)

	)

357 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__VISUALDSPVERSION__
>>16 & 0xFF)

	)

358 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__VISUALDSPVERSION__
>>8 & 0xFF)

	)

361 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

362 #define 
	#COMPILER_ID
 "IAR"

	)

363 #if 
defined
(
__VER__
) && defined(
__ICCARM__
)

364 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 1000000)

	)

365 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(((
__VER__
) / 1000) % 1000)

	)

366 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
((
__VER__
) % 1000)

	)

367 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

368 #elif 
defined
(
__VER__
) && (defined(
__ICCAVR__
) || defined(
__ICCRX__
) || defined(
__ICCRH850__
) || defined(
__ICCRL78__
) || defined(
__ICC430__
) || defined(
__ICCRISCV__
) || defined(
__ICCV850__
) || defined(
__ICC8051__
) || defined(
__ICCSTM8__
))

369 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 100)

	)

370 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__VER__
) - (((__VER__) / 100)*100))

	)

371 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__SUBVERSION__
)

	)

372 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

375 #elif 
defined
(
__SDCC_VERSION_MAJOR
) || defined(
SDCC
)

376 #define 
	#COMPILER_ID
 "SDCC"

	)

377 #if 
defined
(
__SDCC_VERSION_MAJOR
)

378 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__SDCC_VERSION_MAJOR
)

	)

379 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__SDCC_VERSION_MINOR
)

	)

380 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__SDCC_VERSION_PATCH
)

	)

383 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
SDCC
/100)

	)

384 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
SDCC
/10 % 10)

	)

385 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
SDCC
 % 10)

	)

392 #elif 
defined
(
__hpux
) || defined(
__hpua
)

393 #define 
	#COMPILER_ID
 "HP"

	)

396 #define 
	#COMPILER_ID
 ""

	)

403 char const* 
	ginfo_compiler
 = "INFO" ":" "compiler[" 
COMPILER_ID
 "]";

404 #ifdef 
SIMULATE_ID


405 char const* 
	ginfo_simulate
 = "INFO" ":" "simulate[" 
SIMULATE_ID
 "]";

408 #ifdef 
__QNXNTO__


409 char const* 
	gqnxnto
 = "INFO" ":" "qnxnto[]";

412 #if 
defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

413 char const *
	ginfo_cray
 = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";

416 #define 
	#STRINGIFY_HELPER
(
X
) #X

	)

417 #define 
	#STRINGIFY
(
X
) 
	`STRINGIFY_HELPER
(X)

	)

420 #if 
defined
(
__linux
) || defined(
__linux__
) || defined(
linux
)

421 #define 
	#PLATFORM_ID
 "Linux"

	)

423 #elif 
defined
(
__MSYS__
)

424 #define 
	#PLATFORM_ID
 "MSYS"

	)

426 #elif 
defined
(
__CYGWIN__
)

427 #define 
	#PLATFORM_ID
 "Cygwin"

	)

429 #elif 
defined
(
__MINGW32__
)

430 #define 
	#PLATFORM_ID
 "MinGW"

	)

432 #elif 
defined
(
__APPLE__
)

433 #define 
	#PLATFORM_ID
 "Darwin"

	)

435 #elif 
defined
(
_WIN32
) || defined(
__WIN32__
) || defined(
WIN32
)

436 #define 
	#PLATFORM_ID
 "Windows"

	)

438 #elif 
defined
(
__FreeBSD__
) || defined(
__FreeBSD
)

439 #define 
	#PLATFORM_ID
 "FreeBSD"

	)

441 #elif 
defined
(
__NetBSD__
) || defined(
__NetBSD
)

442 #define 
	#PLATFORM_ID
 "NetBSD"

	)

444 #elif 
defined
(
__OpenBSD__
) || defined(
__OPENBSD
)

445 #define 
	#PLATFORM_ID
 "OpenBSD"

	)

447 #elif 
defined
(
__sun
) || defined(
sun
)

448 #define 
	#PLATFORM_ID
 "SunOS"

	)

450 #elif 
defined
(
_AIX
) || defined(
__AIX
) || defined(
__AIX__
) || defined(
__aix
) || defined(
__aix__
)

451 #define 
	#PLATFORM_ID
 "AIX"

	)

453 #elif 
defined
(
__hpux
) || defined(
__hpux__
)

454 #define 
	#PLATFORM_ID
 "HP-UX"

	)

456 #elif 
defined
(
__HAIKU__
)

457 #define 
	#PLATFORM_ID
 "Haiku"

	)

459 #elif 
defined
(
__BeOS
) || defined(
__BEOS__
) || defined(
_BEOS
)

460 #define 
	#PLATFORM_ID
 "BeOS"

	)

462 #elif 
defined
(
__QNX__
) || defined(
__QNXNTO__
)

463 #define 
	#PLATFORM_ID
 "QNX"

	)

465 #elif 
defined
(
__tru64
) || defined(
_tru64
) || defined(
__TRU64__
)

466 #define 
	#PLATFORM_ID
 "Tru64"

	)

468 #elif 
defined
(
__riscos
) || defined(
__riscos__
)

469 #define 
	#PLATFORM_ID
 "RISCos"

	)

471 #elif 
defined
(
__sinix
) || defined(
__sinix__
) || defined(
__SINIX__
)

472 #define 
	#PLATFORM_ID
 "SINIX"

	)

474 #elif 
defined
(
__UNIX_SV__
)

475 #define 
	#PLATFORM_ID
 "UNIX_SV"

	)

477 #elif 
defined
(
__bsdos__
)

478 #define 
	#PLATFORM_ID
 "BSDOS"

	)

480 #elif 
defined
(
_MPRAS
) || defined(
MPRAS
)

481 #define 
	#PLATFORM_ID
 "MP-RAS"

	)

483 #elif 
defined
(
__osf
) || defined(
__osf__
)

484 #define 
	#PLATFORM_ID
 "OSF1"

	)

486 #elif 
defined
(
_SCO_SV
) || defined(
SCO_SV
) || defined(
sco_sv
)

487 #define 
	#PLATFORM_ID
 "SCO_SV"

	)

489 #elif 
defined
(
__ultrix
) || defined(
__ultrix__
) || defined(
_ULTRIX
)

490 #define 
	#PLATFORM_ID
 "ULTRIX"

	)

492 #elif 
defined
(
__XENIX__
) || defined(
_XENIX
) || defined(
XENIX
)

493 #define 
	#PLATFORM_ID
 "Xenix"

	)

495 #elif 
defined
(
__WATCOMC__
)

496 #if 
defined
(
__LINUX__
)

497 #define 
	#PLATFORM_ID
 "Linux"

	)

499 #elif 
defined
(
__DOS__
)

500 #define 
	#PLATFORM_ID
 "DOS"

	)

502 #elif 
defined
(
__OS2__
)

503 #define 
	#PLATFORM_ID
 "OS2"

	)

505 #elif 
defined
(
__WINDOWS__
)

506 #define 
	#PLATFORM_ID
 "Windows3x"

	)

508 #elif 
defined
(
__VXWORKS__
)

509 #define 
	#PLATFORM_ID
 "VxWorks"

	)

512 #define 
	#PLATFORM_ID


	)

515 #elif 
defined
(
__INTEGRITY
)

516 #if 
defined
(
INT_178B
)

517 #define 
	#PLATFORM_ID
 "Integrity178"

	)

520 #define 
	#PLATFORM_ID
 "Integrity"

	)

524 #define 
	#PLATFORM_ID


	)

533 #if 
defined
(
_WIN32
) && defined(
_MSC_VER
)

534 #if 
defined
(
_M_IA64
)

535 #define 
	#ARCHITECTURE_ID
 "IA64"

	)

537 #elif 
defined
(
_M_ARM64EC
)

538 #define 
	#ARCHITECTURE_ID
 "ARM64EC"

	)

540 #elif 
defined
(
_M_X64
) || defined(
_M_AMD64
)

541 #define 
	#ARCHITECTURE_ID
 "x64"

	)

543 #elif 
defined
(
_M_IX86
)

544 #define 
	#ARCHITECTURE_ID
 "X86"

	)

546 #elif 
defined
(
_M_ARM64
)

547 #define 
	#ARCHITECTURE_ID
 "ARM64"

	)

549 #elif 
defined
(
_M_ARM
)

550 #if 
_M_ARM
 == 4

551 #define 
	#ARCHITECTURE_ID
 "ARMV4I"

	)

552 #elif 
_M_ARM
 == 5

553 #define 
	#ARCHITECTURE_ID
 "ARMV5I"

	)

555 #define 
	#ARCHITECTURE_ID
 "ARMV" 
	`STRINGIFY
(
_M_ARM
)

	)

558 #elif 
defined
(
_M_MIPS
)

559 #define 
	#ARCHITECTURE_ID
 "MIPS"

	)

561 #elif 
defined
(
_M_SH
)

562 #define 
	#ARCHITECTURE_ID
 "SHx"

	)

565 #define 
	#ARCHITECTURE_ID
 ""

	)

568 #elif 
defined
(
__WATCOMC__
)

569 #if 
defined
(
_M_I86
)

570 #define 
	#ARCHITECTURE_ID
 "I86"

	)

572 #elif 
defined
(
_M_IX86
)

573 #define 
	#ARCHITECTURE_ID
 "X86"

	)

576 #define 
	#ARCHITECTURE_ID
 ""

	)

579 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

580 #if 
defined
(
__ICCARM__
)

581 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

583 #elif 
defined
(
__ICCRX__
)

584 #define 
	#ARCHITECTURE_ID
 "RX"

	)

586 #elif 
defined
(
__ICCRH850__
)

587 #define 
	#ARCHITECTURE_ID
 "RH850"

	)

589 #elif 
defined
(
__ICCRL78__
)

590 #define 
	#ARCHITECTURE_ID
 "RL78"

	)

592 #elif 
defined
(
__ICCRISCV__
)

593 #define 
	#ARCHITECTURE_ID
 "RISCV"

	)

595 #elif 
defined
(
__ICCAVR__
)

596 #define 
	#ARCHITECTURE_ID
 "AVR"

	)

598 #elif 
defined
(
__ICC430__
)

599 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

601 #elif 
defined
(
__ICCV850__
)

602 #define 
	#ARCHITECTURE_ID
 "V850"

	)

604 #elif 
defined
(
__ICC8051__
)

605 #define 
	#ARCHITECTURE_ID
 "8051"

	)

607 #elif 
defined
(
__ICCSTM8__
)

608 #define 
	#ARCHITECTURE_ID
 "STM8"

	)

611 #define 
	#ARCHITECTURE_ID
 ""

	)

614 #elif 
defined
(
__ghs__
)

615 #if 
defined
(
__PPC64__
)

616 #define 
	#ARCHITECTURE_ID
 "PPC64"

	)

618 #elif 
defined
(
__ppc__
)

619 #define 
	#ARCHITECTURE_ID
 "PPC"

	)

621 #elif 
defined
(
__ARM__
)

622 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

624 #elif 
defined
(
__x86_64__
)

625 #define 
	#ARCHITECTURE_ID
 "x64"

	)

627 #elif 
defined
(
__i386__
)

628 #define 
	#ARCHITECTURE_ID
 "X86"

	)

631 #define 
	#ARCHITECTURE_ID
 ""

	)

634 #elif 
defined
(
__TI_COMPILER_VERSION__
)

635 #if 
defined
(
__TI_ARM__
)

636 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

638 #elif 
defined
(
__MSP430__
)

639 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

641 #elif 
defined
(
__TMS320C28XX__
)

642 #define 
	#ARCHITECTURE_ID
 "TMS320C28x"

	)

644 #elif 
defined
(
__TMS320C6X__
) || defined(
_TMS320C6X
)

645 #define 
	#ARCHITECTURE_ID
 "TMS320C6x"

	)

648 #define 
	#ARCHITECTURE_ID
 ""

	)

652 #define 
	#ARCHITECTURE_ID


	)

656 #define 
	#DEC
(
n
) \

657 ('0' + (((
n
) / 10000000)%10)), \

658 ('0' + (((
n
) / 1000000)%10)), \

659 ('0' + (((
n
) / 100000)%10)), \

660 ('0' + (((
n
) / 10000)%10)), \

661 ('0' + (((
n
) / 1000)%10)), \

662 ('0' + (((
n
) / 100)%10)), \

663 ('0' + (((
n
) / 10)%10)), \

664 ('0' + ((
n
) % 10))

	)

667 #define 
	#HEX
(
n
) \

668 ('0' + ((
n
)>>28 & 0xF)), \

669 ('0' + ((
n
)>>24 & 0xF)), \

670 ('0' + ((
n
)>>20 & 0xF)), \

671 ('0' + ((
n
)>>16 & 0xF)), \

672 ('0' + ((
n
)>>12 & 0xF)), \

673 ('0' + ((
n
)>>8 & 0xF)), \

674 ('0' + ((
n
)>>4 & 0xF)), \

675 ('0' + ((
n
) & 0xF))

	)

678 #ifdef 
COMPILER_VERSION


679 char const* 
	ginfo_version
 = "INFO" ":" "compiler_version[" 
COMPILER_VERSION
 "]";

682 #elif 
defined
(
COMPILER_VERSION_MAJOR
)

683 char const 
	ginfo_version
[] = {

686 
COMPILER_VERSION_MAJOR
,

687 #ifdef 
COMPILER_VERSION_MINOR


688 '.', 
COMPILER_VERSION_MINOR
,

689 #ifdef 
COMPILER_VERSION_PATCH


690 '.', 
COMPILER_VERSION_PATCH
,

691 #ifdef 
COMPILER_VERSION_TWEAK


692 '.', 
COMPILER_VERSION_TWEAK
,

700 #ifdef 
COMPILER_VERSION_INTERNAL


701 char const 
	ginfo_version_internal
[] = {

705 
COMPILER_VERSION_INTERNAL
,']','\0'};

706 #elif 
defined
(
COMPILER_VERSION_INTERNAL_STR
)

707 char const* 
	ginfo_version_internal
 = "INFO" ":" "compiler_version_internal[" 
COMPILER_VERSION_INTERNAL_STR
 "]";

711 #ifdef 
SIMULATE_VERSION_MAJOR


712 char const 
	ginfo_simulate_version
[] = {

715 
SIMULATE_VERSION_MAJOR
,

716 #ifdef 
SIMULATE_VERSION_MINOR


717 '.', 
SIMULATE_VERSION_MINOR
,

718 #ifdef 
SIMULATE_VERSION_PATCH


719 '.', 
SIMULATE_VERSION_PATCH
,

720 #ifdef 
SIMULATE_VERSION_TWEAK


721 '.', 
SIMULATE_VERSION_TWEAK
,

732 char const* 
	ginfo_platform
 = "INFO" ":" "platform[" 
PLATFORM_ID
 "]";

733 char const* 
	ginfo_arch
 = "INFO" ":" "arch[" 
ARCHITECTURE_ID
 "]";

737 #if !
defined
(
__STDC__
) && !defined(
__clang__
)

738 #if 
defined
(
_MSC_VER
) || defined(
__ibmxl__
) || defined(
__IBMC__
)

739 #define 
	#C_VERSION
 "90"

	)

741 #define 
	#C_VERSION


	)

743 #elif 
__STDC_VERSION__
 > 201710L

744 #define 
	#C_VERSION
 "23"

	)

745 #elif 
__STDC_VERSION__
 >= 201710L

746 #define 
	#C_VERSION
 "17"

	)

747 #elif 
__STDC_VERSION__
 >= 201000L

748 #define 
	#C_VERSION
 "11"

	)

749 #elif 
__STDC_VERSION__
 >= 199901L

750 #define 
	#C_VERSION
 "99"

	)

752 #define 
	#C_VERSION
 "90"

	)

754 const char* 
	ginfo_language_standard_default
 =

755 "INFO" ":" "standard_default[" 
C_VERSION
 "]";

757 const char* 
	ginfo_language_extensions_default
 = "INFO" ":" "extensions_default["

759 #if (
defined
(
__clang__
) || defined(
__GNUC__
) || \

760 
defined
(
__TI_COMPILER_VERSION__
)) && \

761 !
defined
(
__STRICT_ANSI__
) && !defined(
_MSC_VER
)

770 #ifdef 
ID_VOID_MAIN


771 void 
	$main
() {
	}
}

773 #if 
defined
(
__CLASSIC_C__
)

774 int 
	$main
(
argc
, 
argv
) int argc; char *argv[];

776 int 
	$main
(int 
argc
, char* 
argv
[])

779 int 
require
 = 0;

780 
require
 += 
info_compiler
[
argc
];

781 
require
 += 
info_platform
[
argc
];

782 
require
 += 
info_arch
[
argc
];

783 #ifdef 
COMPILER_VERSION_MAJOR


784 
require
 += 
info_version
[
argc
];

786 #ifdef 
COMPILER_VERSION_INTERNAL


787 
require
 += 
info_version_internal
[
argc
];

789 #ifdef 
SIMULATE_ID


790 
require
 += 
info_simulate
[
argc
];

792 #ifdef 
SIMULATE_VERSION_MAJOR


793 
require
 += 
info_simulate_version
[
argc
];

795 #if 
	`defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

796 
require
 += 
info_cray
[
argc
];

798 
require
 += 
info_language_standard_default
[
argc
];

799 
require
 += 
info_language_extensions_default
[
argc
];

800 (void)
argv
;

801 return 
require
;

802 
	}
}

	@CMakeFiles/3.22.1/CompilerIdCXX/CMakeCXXCompilerId.cpp

4 #ifndef 
__cplusplus


8 #if !
defined
(
__has_include
)

11 #define 
	#__has_include
(
x
) 0

	)

18 #if 
defined
(
__COMO__
)

19 #define 
	#COMPILER_ID
 "Comeau"

	)

21 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__COMO_VERSION__
 / 100)

	)

22 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__COMO_VERSION__
 % 100)

	)

24 #elif 
defined
(
__INTEL_COMPILER
) || defined(
__ICC
)

25 #define 
	#COMPILER_ID
 "Intel"

	)

26 #if 
defined
(
_MSC_VER
)

27 #define 
	#SIMULATE_ID
 "MSVC"

	)

29 #if 
defined
(
__GNUC__
)

30 #define 
	#SIMULATE_ID
 "GNU"

	)

34 #if 
__INTEL_COMPILER
 < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111

35 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
/100)

	)

36 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER
/10 % 10)

	)

37 #if 
defined
(
__INTEL_COMPILER_UPDATE
)

38 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

40 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_COMPILER
 % 10)

	)

43 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_COMPILER
)

	)

44 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_COMPILER_UPDATE
)

	)

47 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(0)

	)

49 #if 
defined
(
__INTEL_COMPILER_BUILD_DATE
)

51 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__INTEL_COMPILER_BUILD_DATE
)

	)

53 #if 
defined
(
_MSC_VER
)

55 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

56 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

58 #if 
defined
(
__GNUC__
)

59 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

60 #elif 
defined
(
__GNUG__
)

61 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

63 #if 
defined
(
__GNUC_MINOR__
)

64 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

66 #if 
defined
(
__GNUC_PATCHLEVEL__
)

67 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

70 #elif (
defined
(
__clang__
) && defined(
__INTEL_CLANG_COMPILER
)) || defined(
__INTEL_LLVM_COMPILER
)

71 #define 
	#COMPILER_ID
 "IntelLLVM"

	)

72 #if 
defined
(
_MSC_VER
)

73 #define 
	#SIMULATE_ID
 "MSVC"

	)

75 #if 
defined
(
__GNUC__
)

76 #define 
	#SIMULATE_ID
 "GNU"

	)

82 #if 
__INTEL_LLVM_COMPILER
 < 1000000L

83 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100)

	)

84 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10 % 10)

	)

85 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 10)

	)

87 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/10000)

	)

88 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__INTEL_LLVM_COMPILER
/100 % 100)

	)

89 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__INTEL_LLVM_COMPILER
 % 100)

	)

91 #if 
defined
(
_MSC_VER
)

93 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

94 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

96 #if 
defined
(
__GNUC__
)

97 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

98 #elif 
defined
(
__GNUG__
)

99 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

101 #if 
defined
(
__GNUC_MINOR__
)

102 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

104 #if 
defined
(
__GNUC_PATCHLEVEL__
)

105 #define 
	#SIMULATE_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

108 #elif 
defined
(
__PATHCC__
)

109 #define 
	#COMPILER_ID
 "PathScale"

	)

110 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PATHCC__
)

	)

111 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PATHCC_MINOR__
)

	)

112 #if 
defined
(
__PATHCC_PATCHLEVEL__
)

113 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PATHCC_PATCHLEVEL__
)

	)

116 #elif 
defined
(
__BORLANDC__
) && defined(
__CODEGEARC_VERSION__
)

117 #define 
	#COMPILER_ID
 "Embarcadero"

	)

118 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>24 & 0x00FF)

	)

119 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__CODEGEARC_VERSION__
>>16 & 0x00FF)

	)

120 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__CODEGEARC_VERSION__
 & 0xFFFF)

	)

122 #elif 
defined
(
__BORLANDC__
)

123 #define 
	#COMPILER_ID
 "Borland"

	)

125 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__BORLANDC__
>>8)

	)

126 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__BORLANDC__
 & 0xFF)

	)

128 #elif 
defined
(
__WATCOMC__
) && __WATCOMC__ < 1200

129 #define 
	#COMPILER_ID
 "Watcom"

	)

131 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__WATCOMC__
 / 100)

	)

132 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

133 #if (
__WATCOMC__
 % 10) > 0

134 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

137 #elif 
defined
(
__WATCOMC__
)

138 #define 
	#COMPILER_ID
 "OpenWatcom"

	)

140 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__WATCOMC__
 - 1100) / 100)

	)

141 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__WATCOMC__
 / 10) % 10)

	)

142 #if (
__WATCOMC__
 % 10) > 0

143 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__WATCOMC__
 % 10)

	)

146 #elif 
defined
(
__SUNPRO_CC
)

147 #define 
	#COMPILER_ID
 "SunPro"

	)

148 #if 
__SUNPRO_CC
 >= 0x5100

150 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_CC
>>12)

	)

151 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_CC
>>4 & 0xFF)

	)

152 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_CC
 & 0xF)

	)

155 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__SUNPRO_CC
>>8)

	)

156 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__SUNPRO_CC
>>4 & 0xF)

	)

157 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__SUNPRO_CC
 & 0xF)

	)

160 #elif 
defined
(
__HP_aCC
)

161 #define 
	#COMPILER_ID
 "HP"

	)

163 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__HP_aCC
/10000)

	)

164 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__HP_aCC
/100 % 100)

	)

165 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__HP_aCC
 % 100)

	)

167 #elif 
defined
(
__DECCXX
)

168 #define 
	#COMPILER_ID
 "Compaq"

	)

170 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__DECCXX_VER
/10000000)

	)

171 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__DECCXX_VER
/100000 % 100)

	)

172 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__DECCXX_VER
 % 10000)

	)

174 #elif 
defined
(
__IBMCPP__
) && defined(
__COMPILER_VER__
)

175 #define 
	#COMPILER_ID
 "zOS"

	)

177 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

178 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

179 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

181 #elif 
defined
(
__ibmxl__
) && defined(
__clang__
)

182 #define 
	#COMPILER_ID
 "XLClang"

	)

183 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ibmxl_version__
)

	)

184 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ibmxl_release__
)

	)

185 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ibmxl_modification__
)

	)

186 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__ibmxl_ptf_fix_level__
)

	)

189 #elif 
defined
(
__IBMCPP__
) && !defined(
__COMPILER_VER__
) && __IBMCPP__ >= 800

190 #define 
	#COMPILER_ID
 "XL"

	)

192 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

193 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

194 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

196 #elif 
defined
(
__IBMCPP__
) && !defined(
__COMPILER_VER__
) && __IBMCPP__ < 800

197 #define 
	#COMPILER_ID
 "VisualAge"

	)

199 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__IBMCPP__
/100)

	)

200 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__IBMCPP__
/10 % 10)

	)

201 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__IBMCPP__
 % 10)

	)

203 #elif 
defined
(
__NVCOMPILER
)

204 #define 
	#COMPILER_ID
 "NVHPC"

	)

205 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__NVCOMPILER_MAJOR__
)

	)

206 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__NVCOMPILER_MINOR__
)

	)

207 #if 
defined
(
__NVCOMPILER_PATCHLEVEL__
)

208 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__NVCOMPILER_PATCHLEVEL__
)

	)

211 #elif 
defined
(
__PGI
)

212 #define 
	#COMPILER_ID
 "PGI"

	)

213 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__PGIC__
)

	)

214 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__PGIC_MINOR__
)

	)

215 #if 
defined
(
__PGIC_PATCHLEVEL__
)

216 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__PGIC_PATCHLEVEL__
)

	)

219 #elif 
defined
(
_CRAYC
)

220 #define 
	#COMPILER_ID
 "Cray"

	)

221 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_RELEASE_MAJOR
)

	)

222 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_RELEASE_MINOR
)

	)

224 #elif 
defined
(
__TI_COMPILER_VERSION__
)

225 #define 
	#COMPILER_ID
 "TI"

	)

227 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000000)

	)

228 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__TI_COMPILER_VERSION__
/1000 % 1000)

	)

229 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__TI_COMPILER_VERSION__
 % 1000)

	)

231 #elif 
defined
(
__CLANG_FUJITSU
)

232 #define 
	#COMPILER_ID
 "FujitsuClang"

	)

233 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

234 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

235 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

236 #define 
	#COMPILER_VERSION_INTERNAL_STR
 
__clang_version__


	)

239 #elif 
defined
(
__FUJITSU
)

240 #define 
	#COMPILER_ID
 "Fujitsu"

	)

241 #if 
defined
(
__FCC_version__
)

242 #define 
	#COMPILER_VERSION
 
__FCC_version__


	)

243 #elif 
defined
(
__FCC_major__
)

244 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__FCC_major__
)

	)

245 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__FCC_minor__
)

	)

246 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__FCC_patchlevel__
)

	)

248 #if 
defined
(
__fcc_version
)

249 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__fcc_version
)

	)

250 #elif 
defined
(
__FCC_VERSION
)

251 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__FCC_VERSION
)

	)

255 #elif 
defined
(
__ghs__
)

256 #define 
	#COMPILER_ID
 "GHS"

	)

258 #ifdef 
__GHS_VERSION_NUMBER


259 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 100)

	)

260 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GHS_VERSION_NUMBER
 / 10 % 10)

	)

261 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GHS_VERSION_NUMBER
 % 10)

	)

264 #elif 
defined
(
__SCO_VERSION__
)

265 #define 
	#COMPILER_ID
 "SCO"

	)

267 #elif 
defined
(
__ARMCC_VERSION
) && !defined(
__clang__
)

268 #define 
	#COMPILER_ID
 "ARMCC"

	)

269 #if 
__ARMCC_VERSION
 >= 1000000

271 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/1000000)

	)

272 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 100)

	)

273 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

276 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCC_VERSION
/100000)

	)

277 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCC_VERSION
/10000 % 10)

	)

278 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCC_VERSION
 % 10000)

	)

282 #elif 
defined
(
__clang__
) && defined(
__apple_build_version__
)

283 #define 
	#COMPILER_ID
 "AppleClang"

	)

284 #if 
defined
(
_MSC_VER
)

285 #define 
	#SIMULATE_ID
 "MSVC"

	)

287 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

288 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

289 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

290 #if 
defined
(
_MSC_VER
)

292 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

293 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

295 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
__apple_build_version__
)

	)

297 #elif 
defined
(
__clang__
) && defined(
__ARMCOMPILER_VERSION
)

298 #define 
	#COMPILER_ID
 "ARMClang"

	)

299 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/1000000)

	)

300 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__ARMCOMPILER_VERSION
/10000 % 100)

	)

301 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__ARMCOMPILER_VERSION
 % 10000)

	)

302 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__ARMCOMPILER_VERSION
)

	)

304 #elif 
defined
(
__clang__
)

305 #define 
	#COMPILER_ID
 "Clang"

	)

306 #if 
defined
(
_MSC_VER
)

307 #define 
	#SIMULATE_ID
 "MSVC"

	)

309 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__clang_major__
)

	)

310 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__clang_minor__
)

	)

311 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__clang_patchlevel__
)

	)

312 #if 
defined
(
_MSC_VER
)

314 #define 
	#SIMULATE_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

315 #define 
	#SIMULATE_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

318 #elif 
defined
(
__GNUC__
) || defined(
__GNUG__
)

319 #define 
	#COMPILER_ID
 "GNU"

	)

320 #if 
defined
(
__GNUC__
)

321 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUC__
)

	)

323 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
__GNUG__
)

	)

325 #if 
defined
(
__GNUC_MINOR__
)

326 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
__GNUC_MINOR__
)

	)

328 #if 
defined
(
__GNUC_PATCHLEVEL__
)

329 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__GNUC_PATCHLEVEL__
)

	)

332 #elif 
defined
(
_MSC_VER
)

333 #define 
	#COMPILER_ID
 "MSVC"

	)

335 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
(
_MSC_VER
 / 100)

	)

336 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(
_MSC_VER
 % 100)

	)

337 #if 
defined
(
_MSC_FULL_VER
)

338 #if 
_MSC_VER
 >= 1400

340 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 100000)

	)

343 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
_MSC_FULL_VER
 % 10000)

	)

346 #if 
defined
(
_MSC_BUILD
)

347 #define 
	#COMPILER_VERSION_TWEAK
 
	`DEC
(
_MSC_BUILD
)

	)

350 #elif 
defined
(
__VISUALDSPVERSION__
) || defined(
__ADSPBLACKFIN__
) || defined(
__ADSPTS__
) || defined(
__ADSP21000__
)

351 #define 
	#COMPILER_ID
 "ADSP"

	)

352 #if 
defined
(
__VISUALDSPVERSION__
)

354 #define 
	#COMPILER_VERSION_MAJOR
 
	`HEX
(
__VISUALDSPVERSION__
>>24)

	)

355 #define 
	#COMPILER_VERSION_MINOR
 
	`HEX
(
__VISUALDSPVERSION__
>>16 & 0xFF)

	)

356 #define 
	#COMPILER_VERSION_PATCH
 
	`HEX
(
__VISUALDSPVERSION__
>>8 & 0xFF)

	)

359 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

360 #define 
	#COMPILER_ID
 "IAR"

	)

361 #if 
defined
(
__VER__
) && defined(
__ICCARM__
)

362 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 1000000)

	)

363 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
(((
__VER__
) / 1000) % 1000)

	)

364 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
((
__VER__
) % 1000)

	)

365 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

366 #elif 
defined
(
__VER__
) && (defined(
__ICCAVR__
) || defined(
__ICCRX__
) || defined(
__ICCRH850__
) || defined(
__ICCRL78__
) || defined(
__ICC430__
) || defined(
__ICCRISCV__
) || defined(
__ICCV850__
) || defined(
__ICC8051__
) || defined(
__ICCSTM8__
))

367 #define 
	#COMPILER_VERSION_MAJOR
 
	`DEC
((
__VER__
) / 100)

	)

368 #define 
	#COMPILER_VERSION_MINOR
 
	`DEC
((
__VER__
) - (((__VER__) / 100)*100))

	)

369 #define 
	#COMPILER_VERSION_PATCH
 
	`DEC
(
__SUBVERSION__
)

	)

370 #define 
	#COMPILER_VERSION_INTERNAL
 
	`DEC
(
__IAR_SYSTEMS_ICC__
)

	)

377 #elif 
defined
(
__hpux
) || defined(
__hpua
)

378 #define 
	#COMPILER_ID
 "HP"

	)

381 #define 
	#COMPILER_ID
 ""

	)

388 char const* 
	ginfo_compiler
 = "INFO" ":" "compiler[" 
COMPILER_ID
 "]";

389 #ifdef 
SIMULATE_ID


390 char const* 
	ginfo_simulate
 = "INFO" ":" "simulate[" 
SIMULATE_ID
 "]";

393 #ifdef 
__QNXNTO__


394 char const* 
	gqnxnto
 = "INFO" ":" "qnxnto[]";

397 #if 
defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

398 char const *
	ginfo_cray
 = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";

401 #define 
	#STRINGIFY_HELPER
(
X
) #X

	)

402 #define 
	#STRINGIFY
(
X
) 
	`STRINGIFY_HELPER
(X)

	)

405 #if 
defined
(
__linux
) || defined(
__linux__
) || defined(
linux
)

406 #define 
	#PLATFORM_ID
 "Linux"

	)

408 #elif 
defined
(
__MSYS__
)

409 #define 
	#PLATFORM_ID
 "MSYS"

	)

411 #elif 
defined
(
__CYGWIN__
)

412 #define 
	#PLATFORM_ID
 "Cygwin"

	)

414 #elif 
defined
(
__MINGW32__
)

415 #define 
	#PLATFORM_ID
 "MinGW"

	)

417 #elif 
defined
(
__APPLE__
)

418 #define 
	#PLATFORM_ID
 "Darwin"

	)

420 #elif 
defined
(
_WIN32
) || defined(
__WIN32__
) || defined(
WIN32
)

421 #define 
	#PLATFORM_ID
 "Windows"

	)

423 #elif 
defined
(
__FreeBSD__
) || defined(
__FreeBSD
)

424 #define 
	#PLATFORM_ID
 "FreeBSD"

	)

426 #elif 
defined
(
__NetBSD__
) || defined(
__NetBSD
)

427 #define 
	#PLATFORM_ID
 "NetBSD"

	)

429 #elif 
defined
(
__OpenBSD__
) || defined(
__OPENBSD
)

430 #define 
	#PLATFORM_ID
 "OpenBSD"

	)

432 #elif 
defined
(
__sun
) || defined(
sun
)

433 #define 
	#PLATFORM_ID
 "SunOS"

	)

435 #elif 
defined
(
_AIX
) || defined(
__AIX
) || defined(
__AIX__
) || defined(
__aix
) || defined(
__aix__
)

436 #define 
	#PLATFORM_ID
 "AIX"

	)

438 #elif 
defined
(
__hpux
) || defined(
__hpux__
)

439 #define 
	#PLATFORM_ID
 "HP-UX"

	)

441 #elif 
defined
(
__HAIKU__
)

442 #define 
	#PLATFORM_ID
 "Haiku"

	)

444 #elif 
defined
(
__BeOS
) || defined(
__BEOS__
) || defined(
_BEOS
)

445 #define 
	#PLATFORM_ID
 "BeOS"

	)

447 #elif 
defined
(
__QNX__
) || defined(
__QNXNTO__
)

448 #define 
	#PLATFORM_ID
 "QNX"

	)

450 #elif 
defined
(
__tru64
) || defined(
_tru64
) || defined(
__TRU64__
)

451 #define 
	#PLATFORM_ID
 "Tru64"

	)

453 #elif 
defined
(
__riscos
) || defined(
__riscos__
)

454 #define 
	#PLATFORM_ID
 "RISCos"

	)

456 #elif 
defined
(
__sinix
) || defined(
__sinix__
) || defined(
__SINIX__
)

457 #define 
	#PLATFORM_ID
 "SINIX"

	)

459 #elif 
defined
(
__UNIX_SV__
)

460 #define 
	#PLATFORM_ID
 "UNIX_SV"

	)

462 #elif 
defined
(
__bsdos__
)

463 #define 
	#PLATFORM_ID
 "BSDOS"

	)

465 #elif 
defined
(
_MPRAS
) || defined(
MPRAS
)

466 #define 
	#PLATFORM_ID
 "MP-RAS"

	)

468 #elif 
defined
(
__osf
) || defined(
__osf__
)

469 #define 
	#PLATFORM_ID
 "OSF1"

	)

471 #elif 
defined
(
_SCO_SV
) || defined(
SCO_SV
) || defined(
sco_sv
)

472 #define 
	#PLATFORM_ID
 "SCO_SV"

	)

474 #elif 
defined
(
__ultrix
) || defined(
__ultrix__
) || defined(
_ULTRIX
)

475 #define 
	#PLATFORM_ID
 "ULTRIX"

	)

477 #elif 
defined
(
__XENIX__
) || defined(
_XENIX
) || defined(
XENIX
)

478 #define 
	#PLATFORM_ID
 "Xenix"

	)

480 #elif 
defined
(
__WATCOMC__
)

481 #if 
defined
(
__LINUX__
)

482 #define 
	#PLATFORM_ID
 "Linux"

	)

484 #elif 
defined
(
__DOS__
)

485 #define 
	#PLATFORM_ID
 "DOS"

	)

487 #elif 
defined
(
__OS2__
)

488 #define 
	#PLATFORM_ID
 "OS2"

	)

490 #elif 
defined
(
__WINDOWS__
)

491 #define 
	#PLATFORM_ID
 "Windows3x"

	)

493 #elif 
defined
(
__VXWORKS__
)

494 #define 
	#PLATFORM_ID
 "VxWorks"

	)

497 #define 
	#PLATFORM_ID


	)

500 #elif 
defined
(
__INTEGRITY
)

501 #if 
defined
(
INT_178B
)

502 #define 
	#PLATFORM_ID
 "Integrity178"

	)

505 #define 
	#PLATFORM_ID
 "Integrity"

	)

509 #define 
	#PLATFORM_ID


	)

518 #if 
defined
(
_WIN32
) && defined(
_MSC_VER
)

519 #if 
defined
(
_M_IA64
)

520 #define 
	#ARCHITECTURE_ID
 "IA64"

	)

522 #elif 
defined
(
_M_ARM64EC
)

523 #define 
	#ARCHITECTURE_ID
 "ARM64EC"

	)

525 #elif 
defined
(
_M_X64
) || defined(
_M_AMD64
)

526 #define 
	#ARCHITECTURE_ID
 "x64"

	)

528 #elif 
defined
(
_M_IX86
)

529 #define 
	#ARCHITECTURE_ID
 "X86"

	)

531 #elif 
defined
(
_M_ARM64
)

532 #define 
	#ARCHITECTURE_ID
 "ARM64"

	)

534 #elif 
defined
(
_M_ARM
)

535 #if 
_M_ARM
 == 4

536 #define 
	#ARCHITECTURE_ID
 "ARMV4I"

	)

537 #elif 
_M_ARM
 == 5

538 #define 
	#ARCHITECTURE_ID
 "ARMV5I"

	)

540 #define 
	#ARCHITECTURE_ID
 "ARMV" 
	`STRINGIFY
(
_M_ARM
)

	)

543 #elif 
defined
(
_M_MIPS
)

544 #define 
	#ARCHITECTURE_ID
 "MIPS"

	)

546 #elif 
defined
(
_M_SH
)

547 #define 
	#ARCHITECTURE_ID
 "SHx"

	)

550 #define 
	#ARCHITECTURE_ID
 ""

	)

553 #elif 
defined
(
__WATCOMC__
)

554 #if 
defined
(
_M_I86
)

555 #define 
	#ARCHITECTURE_ID
 "I86"

	)

557 #elif 
defined
(
_M_IX86
)

558 #define 
	#ARCHITECTURE_ID
 "X86"

	)

561 #define 
	#ARCHITECTURE_ID
 ""

	)

564 #elif 
defined
(
__IAR_SYSTEMS_ICC__
) || defined(
__IAR_SYSTEMS_ICC
)

565 #if 
defined
(
__ICCARM__
)

566 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

568 #elif 
defined
(
__ICCRX__
)

569 #define 
	#ARCHITECTURE_ID
 "RX"

	)

571 #elif 
defined
(
__ICCRH850__
)

572 #define 
	#ARCHITECTURE_ID
 "RH850"

	)

574 #elif 
defined
(
__ICCRL78__
)

575 #define 
	#ARCHITECTURE_ID
 "RL78"

	)

577 #elif 
defined
(
__ICCRISCV__
)

578 #define 
	#ARCHITECTURE_ID
 "RISCV"

	)

580 #elif 
defined
(
__ICCAVR__
)

581 #define 
	#ARCHITECTURE_ID
 "AVR"

	)

583 #elif 
defined
(
__ICC430__
)

584 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

586 #elif 
defined
(
__ICCV850__
)

587 #define 
	#ARCHITECTURE_ID
 "V850"

	)

589 #elif 
defined
(
__ICC8051__
)

590 #define 
	#ARCHITECTURE_ID
 "8051"

	)

592 #elif 
defined
(
__ICCSTM8__
)

593 #define 
	#ARCHITECTURE_ID
 "STM8"

	)

596 #define 
	#ARCHITECTURE_ID
 ""

	)

599 #elif 
defined
(
__ghs__
)

600 #if 
defined
(
__PPC64__
)

601 #define 
	#ARCHITECTURE_ID
 "PPC64"

	)

603 #elif 
defined
(
__ppc__
)

604 #define 
	#ARCHITECTURE_ID
 "PPC"

	)

606 #elif 
defined
(
__ARM__
)

607 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

609 #elif 
defined
(
__x86_64__
)

610 #define 
	#ARCHITECTURE_ID
 "x64"

	)

612 #elif 
defined
(
__i386__
)

613 #define 
	#ARCHITECTURE_ID
 "X86"

	)

616 #define 
	#ARCHITECTURE_ID
 ""

	)

619 #elif 
defined
(
__TI_COMPILER_VERSION__
)

620 #if 
defined
(
__TI_ARM__
)

621 #define 
	#ARCHITECTURE_ID
 "ARM"

	)

623 #elif 
defined
(
__MSP430__
)

624 #define 
	#ARCHITECTURE_ID
 "MSP430"

	)

626 #elif 
defined
(
__TMS320C28XX__
)

627 #define 
	#ARCHITECTURE_ID
 "TMS320C28x"

	)

629 #elif 
defined
(
__TMS320C6X__
) || defined(
_TMS320C6X
)

630 #define 
	#ARCHITECTURE_ID
 "TMS320C6x"

	)

633 #define 
	#ARCHITECTURE_ID
 ""

	)

637 #define 
	#ARCHITECTURE_ID


	)

641 #define 
	#DEC
(
n
) \

642 ('0' + (((
n
) / 10000000)%10)), \

643 ('0' + (((
n
) / 1000000)%10)), \

644 ('0' + (((
n
) / 100000)%10)), \

645 ('0' + (((
n
) / 10000)%10)), \

646 ('0' + (((
n
) / 1000)%10)), \

647 ('0' + (((
n
) / 100)%10)), \

648 ('0' + (((
n
) / 10)%10)), \

649 ('0' + ((
n
) % 10))

	)

652 #define 
	#HEX
(
n
) \

653 ('0' + ((
n
)>>28 & 0xF)), \

654 ('0' + ((
n
)>>24 & 0xF)), \

655 ('0' + ((
n
)>>20 & 0xF)), \

656 ('0' + ((
n
)>>16 & 0xF)), \

657 ('0' + ((
n
)>>12 & 0xF)), \

658 ('0' + ((
n
)>>8 & 0xF)), \

659 ('0' + ((
n
)>>4 & 0xF)), \

660 ('0' + ((
n
) & 0xF))

	)

663 #ifdef 
COMPILER_VERSION


664 char const* 
	ginfo_version
 = "INFO" ":" "compiler_version[" 
COMPILER_VERSION
 "]";

667 #elif 
defined
(
COMPILER_VERSION_MAJOR
)

668 char const 
	ginfo_version
[] = {

671 
COMPILER_VERSION_MAJOR
,

672 #ifdef 
COMPILER_VERSION_MINOR


673 '.', 
COMPILER_VERSION_MINOR
,

674 #ifdef 
COMPILER_VERSION_PATCH


675 '.', 
COMPILER_VERSION_PATCH
,

676 #ifdef 
COMPILER_VERSION_TWEAK


677 '.', 
COMPILER_VERSION_TWEAK
,

685 #ifdef 
COMPILER_VERSION_INTERNAL


686 char const 
	ginfo_version_internal
[] = {

690 
COMPILER_VERSION_INTERNAL
,']','\0'};

691 #elif 
defined
(
COMPILER_VERSION_INTERNAL_STR
)

692 char const* 
	ginfo_version_internal
 = "INFO" ":" "compiler_version_internal[" 
COMPILER_VERSION_INTERNAL_STR
 "]";

696 #ifdef 
SIMULATE_VERSION_MAJOR


697 char const 
	ginfo_simulate_version
[] = {

700 
SIMULATE_VERSION_MAJOR
,

701 #ifdef 
SIMULATE_VERSION_MINOR


702 '.', 
SIMULATE_VERSION_MINOR
,

703 #ifdef 
SIMULATE_VERSION_PATCH


704 '.', 
SIMULATE_VERSION_PATCH
,

705 #ifdef 
SIMULATE_VERSION_TWEAK


706 '.', 
SIMULATE_VERSION_TWEAK
,

717 char const* 
	ginfo_platform
 = "INFO" ":" "platform[" 
PLATFORM_ID
 "]";

718 char const* 
	ginfo_arch
 = "INFO" ":" "arch[" 
ARCHITECTURE_ID
 "]";

722 #if 
defined
(
__INTEL_COMPILER
) && defined(
_MSVC_LANG
) && _MSVC_LANG < 201403L

723 #if 
defined
(
__INTEL_CXX11_MODE__
)

724 #if 
defined
(
__cpp_aggregate_nsdmi
)

725 #define 
	#CXX_STD
 201402L

	)

727 #define 
	#CXX_STD
 201103L

	)

730 #define 
	#CXX_STD
 199711L

	)

732 #elif 
defined
(
_MSC_VER
) && defined(
_MSVC_LANG
)

733 #define 
	#CXX_STD
 
_MSVC_LANG


	)

735 #define 
	#CXX_STD
 
__cplusplus


	)

738 const char* 
	ginfo_language_standard_default
 = "INFO" ":" "standard_default["

739 #if 
CXX_STD
 > 202002L

741 #elif 
CXX_STD
 > 201703L

743 #elif 
CXX_STD
 >= 201703L

745 #elif 
CXX_STD
 >= 201402L

747 #elif 
CXX_STD
 >= 201103L

754 const char* 
	ginfo_language_extensions_default
 = "INFO" ":" "extensions_default["

756 #if (
defined
(
__clang__
) || defined(
__GNUC__
) || \

757 
defined
(
__TI_COMPILER_VERSION__
)) && \

758 !
defined
(
__STRICT_ANSI__
) && !defined(
_MSC_VER
)

767 int 
	$main
(int 
argc
, char* 
argv
[])

769 int 
require
 = 0;

770 
require
 += 
info_compiler
[
argc
];

771 
require
 += 
info_platform
[
argc
];

772 #ifdef 
COMPILER_VERSION_MAJOR


773 
require
 += 
info_version
[
argc
];

775 #ifdef 
COMPILER_VERSION_INTERNAL


776 
require
 += 
info_version_internal
[
argc
];

778 #ifdef 
SIMULATE_ID


779 
require
 += 
info_simulate
[
argc
];

781 #ifdef 
SIMULATE_VERSION_MAJOR


782 
require
 += 
info_simulate_version
[
argc
];

784 #if 
	`defined
(
__CRAYXT_COMPUTE_LINUX_TARGET
)

785 
require
 += 
info_cray
[
argc
];

787 
require
 += 
info_language_standard_default
[
argc
];

788 
require
 += 
info_language_extensions_default
[
argc
];

789 (void)
argv
;

790 return 
require
;

791 
	}
}

	@deps/klib/bgzf.c

25 #include 
	~<stdio.h
>

26 #include 
	~<stdlib.h
>

27 #include 
	~<string.h
>

28 #include 
	~<unistd.h
>

29 #include 
	~<assert.h
>

30 #include 
	~<sys/types.h
>

31 #include 
	~"bgzf.h
"

33 #ifdef 
_USE_KNETFILE


34 #include 
	~"knetfile.h
"

35 typedef 
knetFile
 *
	t_bgzf_file_t
;

36 #define 
	#_bgzf_open
(
fn
, 
mode
) 
	`knet_open
(fn, mode)

	)

37 #define 
	#_bgzf_dopen
(
fp
, 
mode
) 
	`knet_dopen
(fp, mode)

	)

38 #define 
	#_bgzf_close
(
fp
) 
	`knet_close
(fp)

	)

39 #define 
	#_bgzf_fileno
(
fp
) ((fp)->
fd
)

	)

40 #define 
	#_bgzf_tell
(
fp
) 
	`knet_tell
(fp)

	)

41 #define 
	#_bgzf_seek
(
fp
, 
offset
, 
whence
) 
	`knet_seek
(fp, offset, whence)

	)

42 #define 
	#_bgzf_read
(
fp
, 
buf
, 
len
) 
	`knet_read
(fp, buf, len)

	)

43 #define 
	#_bgzf_write
(
fp
, 
buf
, 
len
) 
	`knet_write
(fp, buf, len)

	)

45 #if 
defined
(
_WIN32
) || defined(
_MSC_VER
)

46 #define 
	#ftello
(
fp
) 
	`ftell
(fp)

	)

47 #define 
	#fseeko
(
fp
, 
offset
, 
whence
) 
	`fseek
(fp, offset, whence)

	)

49 extern 
off_t
 
ftello
(
FILE
 *
stream
);

50 extern int 
fseeko
(
FILE
 *
stream
, 
off_t
 
offset
, int 
whence
);

52 typedef 
FILE
 *
	t_bgzf_file_t
;

53 #define 
	#_bgzf_open
(
fn
, 
mode
) 
	`fopen
(fn, mode)

	)

54 #define 
	#_bgzf_dopen
(
fp
, 
mode
) 
	`fdopen
(fp, mode)

	)

55 #define 
	#_bgzf_close
(
fp
) 
	`fclose
(fp)

	)

56 #define 
	#_bgzf_fileno
(
fp
) 
	`fileno
(fp)

	)

57 #define 
	#_bgzf_tell
(
fp
) 
	`ftello
(fp)

	)

58 #define 
	#_bgzf_seek
(
fp
, 
offset
, 
whence
) 
	`fseeko
(fp, offset, whence)

	)

59 #define 
	#_bgzf_read
(
fp
, 
buf
, 
len
) 
	`fread
(buf, 1, len, fp)

	)

60 #define 
	#_bgzf_write
(
fp
, 
buf
, 
len
) 
	`fwrite
(buf, 1, len, fp)

	)

63 #define 
	#BLOCK_HEADER_LENGTH
 18

	)

64 #define 
	#BLOCK_FOOTER_LENGTH
 8

	)

71 static const 
uint8_t
 
	gg_magic
[19] = "\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\0\0";

73 #ifdef 
BGZF_CACHE


75 int 
	msize
;

76 
uint8_t
 *
	mblock
;

77 
int64_t
 
	mend_offset
;

78 } 
	tcache_t
;

79 #include 
	~"khash.h
"

80 
	$KHASH_MAP_INIT_INT64
(
cache
, 
cache_t
)

83 static 
inline
 void 
	$packInt16
(
uint8_t
 *
buffer
, 
uint16_t
 
value
)

85 
buffer
[0] = 
value
;

86 
buffer
[1] = 
value
 >> 8;

87 
	}
}

89 static 
inline
 int 
	$unpackInt16
(const 
uint8_t
 *
buffer
)

91 return 
buffer
[0] | buffer[1] << 8;

92 
	}
}

94 static 
inline
 void 
	$packInt32
(
uint8_t
 *
buffer
, 
uint32_t
 
value
)

96 
buffer
[0] = 
value
;

97 
buffer
[1] = 
value
 >> 8;

98 
buffer
[2] = 
value
 >> 16;

99 
buffer
[3] = 
value
 >> 24;

100 
	}
}

102 static 
BGZF
 *
	$bgzf_read_init
()

104 
BGZF
 *
fp
;

105 
fp
 = 
	`calloc
(1, sizeof(
BGZF
));

106 
fp
->
open_mode
 = 'r';

107 
fp
->
uncompressed_block
 = 
	`malloc
(
BGZF_MAX_BLOCK_SIZE
);

108 
fp
->
compressed_block
 = 
	`malloc
(
BGZF_MAX_BLOCK_SIZE
);

109 #ifdef 
BGZF_CACHE


110 
fp
->
cache
 = 
	`kh_init
(cache);

112 return 
fp
;

113 
	}
}

115 static 
BGZF
 *
	$bgzf_write_init
(int 
compress_level
)

117 
BGZF
 *
fp
;

118 
fp
 = 
	`calloc
(1, sizeof(
BGZF
));

119 
fp
->
open_mode
 = 'w';

120 
fp
->
uncompressed_block
 = 
	`malloc
(
BGZF_MAX_BLOCK_SIZE
);

121 
fp
->
compressed_block
 = 
	`malloc
(
BGZF_MAX_BLOCK_SIZE
);

122 
fp
->
compress_level
 = compress_level < 0? 
Z_DEFAULT_COMPRESSION
 : compress_level;

123 if (
fp
->
compress_level
 > 9) fp->compress_level = 
Z_DEFAULT_COMPRESSION
;

124 return 
fp
;

125 
	}
}

127 static int 
	$mode2level
(const char *
__restrict
 
mode
)

129 int 
i
, 
compress_level
 = -1;

130 for (
i
 = 0; 
mode
[i]; ++i)

131 if (
mode
[
i
] >= '0' && mode[i] <= '9') break;

132 if (
mode
[
i
]) 
compress_level
 = (int)mode[i] - '0';

133 if (
	`strchr
(
mode
, 'u')) 
compress_level
 = 0;

134 return 
compress_level
;

135 
	}
}

137 
BGZF
 *
	$bgzf_open
(const char *
path
, const char *
mode
)

139 
BGZF
 *
fp
 = 0;

140 if (
	`strchr
(
mode
, 'r') || strchr(mode, 'R')) {

141 
_bgzf_file_t
 
fpr
;

142 if ((
fpr
 = 
	`_bgzf_open
(
path
, "r")) == 0) return 0;

143 
fp
 = 
	`bgzf_read_init
();

144 
fp
->fp = 
fpr
;

145 } else if (
	`strchr
(
mode
, 'w') || strchr(mode, 'W')) {

146 
FILE
 *
fpw
;

147 if ((
fpw
 = 
	`fopen
(
path
, "w")) == 0) return 0;

148 
fp
 = 
	`bgzf_write_init
(
	`mode2level
(
mode
));

149 
fp
->fp = 
fpw
;

151 return 
fp
;

152 
	}
}

154 
BGZF
 *
	$bgzf_dopen
(int 
fd
, const char *
mode
)

156 
BGZF
 *
fp
 = 0;

157 if (
	`strchr
(
mode
, 'r') || strchr(mode, 'R')) {

158 
_bgzf_file_t
 
fpr
;

159 if ((
fpr
 = 
	`_bgzf_dopen
(
fd
, "r")) == 0) return 0;

160 
fp
 = 
	`bgzf_read_init
();

161 
fp
->fp = 
fpr
;

162 } else if (
	`strchr
(
mode
, 'w') || strchr(mode, 'W')) {

163 
FILE
 *
fpw
;

164 if ((
fpw
 = 
	`fdopen
(
fd
, "w")) == 0) return 0;

165 
fp
 = 
	`bgzf_write_init
(
	`mode2level
(
mode
));

166 
fp
->fp = 
fpw
;

168 return 
fp
;

169 
	}
}

172 static int 
	$deflate_block
(
BGZF
 *
fp
, int 
block_length
)

174 
uint8_t
 *
buffer
 = 
fp
->
compressed_block
;

175 int 
buffer_size
 = 
BGZF_BLOCK_SIZE
;

176 int 
input_length
 = 
block_length
;

177 int 
compressed_length
 = 0;

178 int 
remaining
;

179 
uint32_t
 
crc
;

181 
	`assert
(
block_length
 <= 
BGZF_BLOCK_SIZE
);

182 
	`memcpy
(
buffer
, 
g_magic
, 
BLOCK_HEADER_LENGTH
);

184 int 
status
;

185 
z_stream
 
zs
;

186 
zs
.
zalloc
 = 
NULL
;

187 
zs
.
zfree
 = 
NULL
;

188 
zs
.
next_in
 = 
fp
->
uncompressed_block
;

189 
zs
.
avail_in
 = 
input_length
;

190 
zs
.
next_out
 = (void*)&
buffer
[
BLOCK_HEADER_LENGTH
];

191 
zs
.
avail_out
 = 
buffer_size
 - 
BLOCK_HEADER_LENGTH
 - 
BLOCK_FOOTER_LENGTH
;

192 
status
 = 
	`deflateInit2
(&
zs
, 
fp
->
compress_level
, 
Z_DEFLATED
, -15, 8, 
Z_DEFAULT_STRATEGY
);

193 if (
status
 != 
Z_OK
) {

194 
fp
->
errcode
 |= 
BGZF_ERR_ZLIB
;

197 
status
 = 
	`deflate
(&
zs
, 
Z_FINISH
);

198 if (
status
 != 
Z_STREAM_END
) {

199 
	`deflateEnd
(&
zs
);

200 if (
status
 == 
Z_OK
) {

201 
input_length
 -= 1024;

202 
	`assert
(
input_length
 > 0);

205 
fp
->
errcode
 |= 
BGZF_ERR_ZLIB
;

208 if (
	`deflateEnd
(&
zs
) != 
Z_OK
) {

209 
fp
->
errcode
 |= 
BGZF_ERR_ZLIB
;

212 
compressed_length
 = 
zs
.
total_out
;

213 
compressed_length
 += 
BLOCK_HEADER_LENGTH
 + 
BLOCK_FOOTER_LENGTH
;

214 
	`assert
(
compressed_length
 <= 
BGZF_BLOCK_SIZE
);

218 
	`assert
(
compressed_length
 > 0);

219 
	`packInt16
((
uint8_t
*)&
buffer
[16], 
compressed_length
 - 1);

220 
crc
 = 
	`crc32
(0L, 
NULL
, 0L);

221 
crc
 = 
	`crc32
(crc, 
fp
->
uncompressed_block
, 
input_length
);

222 
	`packInt32
((
uint8_t
*)&
buffer
[
compressed_length
-8], 
crc
);

223 
	`packInt32
((
uint8_t
*)&
buffer
[
compressed_length
-4], 
input_length
);

225 
remaining
 = 
block_length
 - 
input_length
;

226 if (
remaining
 > 0) {

227 
	`assert
(
remaining
 <= 
input_length
);

228 
	`memcpy
(
fp
->
uncompressed_block
, fp->uncompressed_block + 
input_length
, 
remaining
);

230 
fp
->
block_offset
 = 
remaining
;

231 return 
compressed_length
;

232 
	}
}

235 static int 
	$inflate_block
(
BGZF
* 
fp
, int 
block_length
)

237 
z_stream
 
zs
;

238 
zs
.
zalloc
 = 
NULL
;

239 
zs
.
zfree
 = 
NULL
;

240 
zs
.
next_in
 = 
fp
->
compressed_block
 + 18;

241 
zs
.
avail_in
 = 
block_length
 - 16;

242 
zs
.
next_out
 = 
fp
->
uncompressed_block
;

243 
zs
.
avail_out
 = 
BGZF_BLOCK_SIZE
;

245 if (
	`inflateInit2
(&
zs
, -15) != 
Z_OK
) {

246 
fp
->
errcode
 |= 
BGZF_ERR_ZLIB
;

249 if (
	`inflate
(&
zs
, 
Z_FINISH
) != 
Z_STREAM_END
) {

250 
	`inflateEnd
(&
zs
);

251 
fp
->
errcode
 |= 
BGZF_ERR_ZLIB
;

254 if (
	`inflateEnd
(&
zs
) != 
Z_OK
) {

255 
fp
->
errcode
 |= 
BGZF_ERR_ZLIB
;

258 return 
zs
.
total_out
;

259 
	}
}

261 static int 
	$check_header
(const 
uint8_t
 *
header
)

263 return (
header
[0] == 31 && header[1] == 139 && header[2] == 8 && (header[3] & 4) != 0

264 && 
	`unpackInt16
((
uint8_t
*)&
header
[10]) == 6

265 && 
header
[12] == 'B' && header[13] == 'C'

266 && 
	`unpackInt16
((
uint8_t
*)&
header
[14]) == 2);

267 
	}
}

269 #ifdef 
BGZF_CACHE


270 static void 
	$free_cache
(
BGZF
 *
fp
)

272 
khint_t
 
k
;

273 
	`khash_t
(
cache
) *
h
 = (khash_t(cache)*)
fp
->cache;

274 if (
fp
->
open_mode
 != 'r') return;

275 for (
k
 = 
	`kh_begin
(
h
); k < 
	`kh_end
(h); ++k)

276 if (
	`kh_exist
(
h
, 
k
)) 
	`free
(
	`kh_val
(h, k).
block
);

277 
	`kh_destroy
(
cache
, 
h
);

278 
	}
}

280 static int 
	$load_block_from_cache
(
BGZF
 *
fp
, 
int64_t
 
block_address
)

282 
khint_t
 
k
;

283 
cache_t
 *
p
;

284 
	`khash_t
(
cache
) *
h
 = (khash_t(cache)*)
fp
->cache;

285 
k
 = 
	`kh_get
(
cache
, 
h
, 
block_address
);

286 if (
k
 == 
	`kh_end
(
h
)) return 0;

287 
p
 = &
	`kh_val
(
h
, 
k
);

288 if (
fp
->
block_length
 != 0) fp->
block_offset
 = 0;

289 
fp
->
block_address
 = block_address;

290 
fp
->
block_length
 = 
p
->
size
;

291 
	`memcpy
(
fp
->
uncompressed_block
, 
p
->
block
, 
BGZF_BLOCK_SIZE
);

292 
	`_bgzf_seek
((
_bgzf_file_t
)
fp
->fp, 
p
->
end_offset
, 
SEEK_SET
);

293 return 
p
->
size
;

294 
	}
}

296 static void 
	$cache_block
(
BGZF
 *
fp
, int 
size
)

298 int 
ret
;

299 
khint_t
 
k
;

300 
cache_t
 *
p
;

301 
	`khash_t
(
cache
) *
h
 = (khash_t(cache)*)
fp
->cache;

302 if (
BGZF_BLOCK_SIZE
 >= 
fp
->
cache_size
) return;

303 if ((
	`kh_size
(
h
) + 1) * 
BGZF_BLOCK_SIZE
 > 
fp
->
cache_size
) {

307 for (
k
 = 
	`kh_begin
(
h
); k < 
	`kh_end
(h); ++k)

308 if (
	`kh_exist
(
h
, 
k
)) break;

309 if (
k
 < 
	`kh_end
(
h
)) {

310 
	`free
(
	`kh_val
(
h
, 
k
).
block
);

311 
	`kh_del
(
cache
, 
h
, 
k
);

314 
k
 = 
	`kh_put
(
cache
, 
h
, 
fp
->
block_address
, &
ret
);

315 if (
ret
 == 0) return;

316 
p
 = &
	`kh_val
(
h
, 
k
);

317 
p
->
size
 = 
fp
->
block_length
;

318 
p
->
end_offset
 = 
fp
->
block_address
 + 
size
;

319 
p
->
block
 = 
	`malloc
(
BGZF_BLOCK_SIZE
);

320 
	`memcpy
(
	`kh_val
(
h
, 
k
).
block
, 
fp
->
uncompressed_block
, 
BGZF_BLOCK_SIZE
);

321 
	}
}

323 static void 
	$free_cache
(
BGZF
 *
fp
) {
	}
}

324 static int 
	$load_block_from_cache
(
BGZF
 *
fp
, 
int64_t
 
block_address
) {return 0;
	}
}

325 static void 
	$cache_block
(
BGZF
 *
fp
, int 
size
) {
	}
}

328 int 
	$bgzf_read_block
(
BGZF
 *
fp
)

330 
uint8_t
 
header
[
BLOCK_HEADER_LENGTH
], *
compressed_block
;

331 int 
count
, 
size
 = 0, 
block_length
, 
remaining
;

332 
int64_t
 
block_address
;

333 
block_address
 = 
	`_bgzf_tell
((
_bgzf_file_t
)
fp
->fp);

334 if (
	`load_block_from_cache
(
fp
, 
block_address
)) return 0;

335 
count
 = 
	`_bgzf_read
(
fp
->fp, 
header
, sizeof(header));

336 if (
count
 == 0) {

337 
fp
->
block_length
 = 0;

340 if (
count
 != sizeof(
header
) || !
	`check_header
(header)) {

341 
fp
->
errcode
 |= 
BGZF_ERR_HEADER
;

344 
size
 = 
count
;

345 
block_length
 = 
	`unpackInt16
((
uint8_t
*)&
header
[16]) + 1;

346 
compressed_block
 = (
uint8_t
*)
fp
->compressed_block;

347 
	`memcpy
(
compressed_block
, 
header
, 
BLOCK_HEADER_LENGTH
);

348 
remaining
 = 
block_length
 - 
BLOCK_HEADER_LENGTH
;

349 
count
 = 
	`_bgzf_read
(
fp
->fp, &
compressed_block
[
BLOCK_HEADER_LENGTH
], 
remaining
);

350 if (
count
 != 
remaining
) {

351 
fp
->
errcode
 |= 
BGZF_ERR_IO
;

354 
size
 += 
count
;

355 if ((
count
 = 
	`inflate_block
(
fp
, 
block_length
)) < 0) return -1;

356 if (
fp
->
block_length
 != 0) fp->
block_offset
 = 0;

357 
fp
->
block_address
 = block_address;

358 
fp
->
block_length
 = 
count
;

359 
	`cache_block
(
fp
, 
size
);

361 
	}
}

363 
ssize_t
 
	$bgzf_read
(
BGZF
 *
fp
, void *
data
, 
ssize_t
 
length
)

365 
ssize_t
 
bytes_read
 = 0;

366 
uint8_t
 *
output
 = 
data
;

367 if (
length
 <= 0) return 0;

368 
	`assert
(
fp
->
open_mode
 == 'r');

369 while (
bytes_read
 < 
length
) {

370 int 
copy_length
, 
available
 = 
fp
->
block_length
 - fp->
block_offset
;

371 
uint8_t
 *
buffer
;

372 if (
available
 <= 0) {

373 if (
	`bgzf_read_block
(
fp
) != 0) return -1;

374 
available
 = 
fp
->
block_length
 - fp->
block_offset
;

375 if (
available
 <= 0) break;

377 
copy_length
 = 
length
 - 
bytes_read
 < 
available
? length - bytes_read : available;

378 
buffer
 = 
fp
->
uncompressed_block
;

379 
	`memcpy
(
output
, 
buffer
 + 
fp
->
block_offset
, 
copy_length
);

380 
fp
->
block_offset
 += 
copy_length
;

381 
output
 += 
copy_length
;

382 
bytes_read
 += 
copy_length
;

384 if (
fp
->
block_offset
 == fp->
block_length
) {

385 
fp
->
block_address
 = 
	`_bgzf_tell
((
_bgzf_file_t
)fp->fp);

386 
fp
->
block_offset
 = fp->
block_length
 = 0;

388 return 
bytes_read
;

389 
	}
}

391 int 
	$bgzf_flush
(
BGZF
 *
fp
)

393 
	`assert
(
fp
->
open_mode
 == 'w');

394 while (
fp
->
block_offset
 > 0) {

395 int 
block_length
;

396 
block_length
 = 
	`deflate_block
(
fp
, fp->
block_offset
);

397 if (
block_length
 < 0) return -1;

398 if (
	`fwrite
(
fp
->
compressed_block
, 1, 
block_length
, fp->fp) != block_length) {

399 
fp
->
errcode
 |= 
BGZF_ERR_IO
;

402 
fp
->
block_address
 += 
block_length
;

405 
	}
}

407 int 
	$bgzf_flush_try
(
BGZF
 *
fp
, 
ssize_t
 
size
)

409 if (
fp
->
block_offset
 + 
size
 > 
BGZF_BLOCK_SIZE
)

410 return 
	`bgzf_flush
(
fp
);

412 
	}
}

414 
ssize_t
 
	$bgzf_write
(
BGZF
 *
fp
, const void *
data
, 
ssize_t
 
length
)

416 const 
uint8_t
 *
input
 = 
data
;

417 int 
block_length
 = 
BGZF_BLOCK_SIZE
, 
bytes_written
;

418 
	`assert
(
fp
->
open_mode
 == 'w');

419 
input
 = 
data
;

420 
bytes_written
 = 0;

421 while (
bytes_written
 < 
length
) {

422 
uint8_t
* 
buffer
 = 
fp
->
uncompressed_block
;

423 int 
copy_length
 = 
block_length
 - 
fp
->
block_offset
 < 
length
 - 
bytes_written
? block_length - fp->block_offset : length - bytes_written;

424 
	`memcpy
(
buffer
 + 
fp
->
block_offset
, 
input
, 
copy_length
);

425 
fp
->
block_offset
 += 
copy_length
;

426 
input
 += 
copy_length
;

427 
bytes_written
 += 
copy_length
;

428 if (
fp
->
block_offset
 == 
block_length
 && 
	`bgzf_flush
(fp)) break;

430 return 
bytes_written
;

431 
	}
}

433 int 
	$bgzf_close
(
BGZF
* 
fp
)

435 int 
ret
, 
count
, 
block_length
;

436 if (
fp
 == 0) return -1;

437 if (
fp
->
open_mode
 == 'w') {

438 if (
	`bgzf_flush
(
fp
) != 0) return -1;

439 
block_length
 = 
	`deflate_block
(
fp
, 0);

440 
count
 = 
	`fwrite
(
fp
->
compressed_block
, 1, 
block_length
, fp->fp);

441 if (
	`fflush
(
fp
->fp) != 0) {

442 
fp
->
errcode
 |= 
BGZF_ERR_IO
;

446 
ret
 = 
fp
->
open_mode
 == 'w'? 
	`fclose
(fp->fp) : 
	`_bgzf_close
(fp->fp);

447 if (
ret
 != 0) return -1;

448 
	`free
(
fp
->
uncompressed_block
);

449 
	`free
(
fp
->
compressed_block
);

450 
	`free_cache
(
fp
);

451 
	`free
(
fp
);

453 
	}
}

455 void 
	$bgzf_set_cache_size
(
BGZF
 *
fp
, int 
cache_size
)

457 if (
fp
) fp->
cache_size
 = cache_size;

458 
	}
}

460 int 
	$bgzf_check_EOF
(
BGZF
 *
fp
)

462 static 
uint8_t
 
magic
[28] = "\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\033\0\3\0\0\0\0\0\0\0\0\0";

463 
uint8_t
 
buf
[28];

464 
off_t
 
offset
;

465 
offset
 = 
	`_bgzf_tell
((
_bgzf_file_t
)
fp
->fp);

466 if (
	`_bgzf_seek
(
fp
->fp, -28, 
SEEK_END
) < 0) return 0;

467 
	`_bgzf_read
(
fp
->fp, 
buf
, 28);

468 
	`_bgzf_seek
(
fp
->fp, 
offset
, 
SEEK_SET
);

469 return (
	`memcmp
(
magic
, 
buf
, 28) == 0)? 1 : 0;

470 
	}
}

472 
int64_t
 
	$bgzf_seek
(
BGZF
* 
fp
, 
int64_t
 
pos
, int 
where
)

474 int 
block_offset
;

475 
int64_t
 
block_address
;

477 if (
fp
->
open_mode
 != 'r' || 
where
 != 
SEEK_SET
) {

478 
fp
->
errcode
 |= 
BGZF_ERR_MISUSE
;

481 
block_offset
 = 
pos
 & 0xFFFF;

482 
block_address
 = 
pos
 >> 16;

483 if (
	`_bgzf_seek
(
fp
->fp, 
block_address
, 
SEEK_SET
) < 0) {

484 
fp
->
errcode
 |= 
BGZF_ERR_IO
;

487 
fp
->
block_length
 = 0;

488 
fp
->
block_address
 = block_address;

489 
fp
->
block_offset
 = block_offset;

491 
	}
}

493 int 
	$bgzf_is_bgzf
(const char *
fn
)

495 
uint8_t
 
buf
[16];

496 int 
n
;

497 
_bgzf_file_t
 
fp
;

498 if ((
fp
 = 
	`_bgzf_open
(
fn
, "r")) == 0) return 0;

499 
n
 = 
	`_bgzf_read
(
fp
, 
buf
, 16);

500 
	`_bgzf_close
(
fp
);

501 if (
n
 != 16) return 0;

502 return 
	`memcmp
(
g_magic
, 
buf
, 16) == 0? 1 : 0;

503 
	}
}

505 int 
	$bgzf_getc
(
BGZF
 *
fp
)

507 int 
c
;

508 if (
fp
->
block_offset
 >= fp->
block_length
) {

509 if (
	`bgzf_read_block
(
fp
) != 0) return -2;

510 if (
fp
->
block_length
 == 0) return -1;

512 
c
 = ((unsigned char*)
fp
->
uncompressed_block
)[fp->
block_offset
++];

513 if (
fp
->
block_offset
 == fp->
block_length
) {

514 
fp
->
block_address
 = 
	`_bgzf_tell
((
_bgzf_file_t
)fp->fp);

515 
fp
->
block_offset
 = 0;

516 
fp
->
block_length
 = 0;

518 return 
c
;

519 
	}
}

521 #ifndef 
kroundup32


522 #define 
	#kroundup32
(
x
) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

	)

525 int 
	$bgzf_getline
(
BGZF
 *
fp
, int 
delim
, 
kstring_t
 *
str
)

527 int 
l
, 
state
 = 0;

528 unsigned char *
buf
 = (unsigned char*)
fp
->
uncompressed_block
;

529 
str
->
l
 = 0;

531 if (
fp
->
block_offset
 >= fp->
block_length
) {

532 if (
	`bgzf_read_block
(
fp
) != 0) { 
state
 = -2; break; }

533 if (
fp
->
block_length
 == 0) { 
state
 = -1; break; }

535 for (
l
 = 
fp
->
block_offset
; l < fp->
block_length
 && 
buf
[l] != 
delim
; ++l);

536 if (
l
 < 
fp
->
block_length
) 
state
 = 1;

537 
l
 -= 
fp
->
block_offset
;

538 if (
str
->
l
 + l + 1 >= str->
m
) {

539 
str
->
m
 = str->
l
 + l + 2;

540 
	`kroundup32
(
str
->
m
);

541 
str
->
s
 = (char*)
	`realloc
(str->s, str->
m
);

543 
	`memcpy
(
str
->
s
 + str->
l
, 
buf
 + 
fp
->
block_offset
, l);

544 
str
->
l
 += l;

545 
fp
->
block_offset
 += 
l
 + 1;

546 if (
fp
->
block_offset
 >= fp->
block_length
) {

547 
fp
->
block_address
 = 
	`_bgzf_tell
((
_bgzf_file_t
)fp->fp);

548 
fp
->
block_offset
 = 0;

549 
fp
->
block_length
 = 0;

551 } while (
state
 == 0);

552 if (
str
->
l
 == 0 && 
state
 < 0) return state;

553 
str
->
s
[str->
l
] = 0;

554 return 
str
->
l
;

555 
	}
}

	@deps/klib/bgzf.h

28 #ifndef 
__BGZF_H


29 #define 
	#__BGZF_H


	)

31 #include 
	~<stdint.h
>

32 #include 
	~<stdio.h
>

33 #include 
	~<zlib.h
>

35 #define 
	#BGZF_BLOCK_SIZE
 0x10000

	)

36 #define 
	#BGZF_MAX_BLOCK_SIZE
 0x10000

	)

38 #define 
	#BGZF_ERR_ZLIB
 1

	)

39 #define 
	#BGZF_ERR_HEADER
 2

	)

40 #define 
	#BGZF_ERR_IO
 4

	)

41 #define 
	#BGZF_ERR_MISUSE
 8

	)

44 int 
	mopen_mode
:8, 
	mcompress_level
:8, 
	merrcode
:16;

45 int 
	mcache_size
;

46 int 
	mblock_length
, 
	mblock_offset
;

47 
int64_t
 
	mblock_address
;

48 void *
	muncompressed_block
, *
	mcompressed_block
;

49 void *
	mcache
;

50 void *
	mfp
;

51 } 
	tBGZF
;

53 #ifndef 
KSTRING_T


54 #define 
	#KSTRING_T
 
kstring_t


	)

55 typedef struct 
	s__kstring_t
 {

56 
size_t
 
	ml
, 
	mm
;

57 char *
	ms
;

58 } 
	tkstring_t
;

61 #ifdef 
__cplusplus


77 
BGZF
* 
bgzf_dopen
(int 
fd
, const char *
mode
);

79 #define 
	#bgzf_fdopen
(
fd
, 
mode
) 
	`bgzf_dopen
((fd), (mode))

80 

	)

84 
BGZF
* 
bgzf_open
(const char* 
path
, const char *
mode
);

92 int 
bgzf_close
(
BGZF
 *
fp
);

102 
ssize_t
 
bgzf_read
(
BGZF
 *
fp
, void *
data
, ssize_t 
length
);

112 
ssize_t
 
bgzf_write
(
BGZF
 *
fp
, const void *
data
, ssize_t 
length
);

117 int 
bgzf_flush
(
BGZF
 *
fp
);

125 #define 
	#bgzf_tell
(
fp
) ((fp->
block_address
 << 16) | (fp->
block_offset
 & 0xFFFF))

	)

135 
int64_t
 
bgzf_seek
(
BGZF
 *
fp
, int64_t 
pos
, int 
whence
);

143 int 
bgzf_check_EOF
(
BGZF
 *
fp
);

151 int 
bgzf_is_bgzf
(const char *
fn
);

163 void 
bgzf_set_cache_size
(
BGZF
 *
fp
, int 
size
);

168 int 
bgzf_flush_try
(
BGZF
 *
fp
, 
ssize_t
 
size
);

175 int 
bgzf_getc
(
BGZF
 *
fp
);

185 int 
bgzf_getline
(
BGZF
 *
fp
, int 
delim
, 
kstring_t
 *
str
);

190 int 
bgzf_read_block
(
BGZF
 *
fp
);

192 #ifdef 
__cplusplus


	@deps/klib/kbit.h

1 #ifndef 
KBIT_H


2 #define 
	#KBIT_H


	)

4 #include 
	~<stdint.h
>

6 static 
inline
 
uint64_t
 
	$kbi_popcount64
(
uint64_t
 
y
)

8 
y
 -= ((y >> 1) & 0x5555555555555555ull);

9 
y
 = (y & 0x3333333333333333ull) + (y >> 2 & 0x3333333333333333ull);

10 return ((
y
 + (y >> 4)) & 0xf0f0f0f0f0f0f0full) * 0x101010101010101ull >> 56;

11 
	}
}

13 static 
inline
 
uint64_t
 
	$kbi_DNAcount64
(
uint64_t
 
y
, int 
c
)

16 
y
 = ((
c
&2)? y : ~y) >> 1 & ((c&1)? y : ~y) & 0x5555555555555555ull;

18 
y
 = (y & 0x3333333333333333ull) + (y >> 2 & 0x3333333333333333ull);

19 return ((
y
 + (y >> 4)) & 0xf0f0f0f0f0f0f0full) * 0x101010101010101ull >> 56;

20 
	}
}

22 #ifndef 
kroundup32


23 #define 
	#kroundup32
(
x
) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

	)

26 #ifndef 
kbi_swap


27 #define 
	#kbi_swap
(
a
, 
b
) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))

29 

	)

	@deps/klib/kbtree.h

28 #ifndef 
__AC_KBTREE_H


29 #define 
	#__AC_KBTREE_H


	)

31 #include 
	~<stdlib.h
>

32 #include 
	~<string.h
>

33 #include 
	~<stdint.h
>

35 #define 
	#KB_MAX_DEPTH
 64

	)

38 
int32_t
 
	mis_internal
:1, 
	mn
:31;

39 } 
	tkbnode_t
;

42 
kbnode_t
 *
	mx
;

43 int 
	mi
;

44 } 
	tkbpos_t
;

47 
kbpos_t
 
	mstack
[
KB_MAX_DEPTH
], *
	mp
;

48 } 
	tkbitr_t
;

50 #define 
	#__KB_KEY
(
type
, 
x
) ((type*)((char*)x + 4))

	)

51 #define 
	#__KB_PTR
(
btr
, 
x
) ((
kbnode_t
**)((char*)x + btr->
off_ptr
))

	)

53 #define 
	#__KB_TREE_T
(
name
) \

55 
kbnode_t
 *
root
; \

56 int 
off_key
, 
off_ptr
, 
ilen
, 
elen
; \

57 int 
n
, 
t
; \

58 int 
n_keys
, 
n_nodes
; \

59 } 
	tkbtree_
##
	tname
##
	t_t
;

	)

61 #define 
	#__KB_INIT
(
name
, 
key_t
) \

62 
kbtree_
##
name
##
_t
 *
kb_init_
##
	`name
(int 
size
) \

64 
kbtree_
##
name
##
_t
 *
b
; \

65 
b
 = (
kbtree_
##
name
##
_t
*)
	`calloc
(1, sizeof(kbtree_##name##_t)); \

66 
b
->
t
 = ((
size
 - 4 - sizeof(void*)) / (sizeof(void*) + sizeof(
key_t
)) + 1) >> 1; \

67 if (
b
->
t
 < 2) { \

68 
	`free
(
b
); return 0; \

70 
b
->
n
 = 2 * b->
t
 - 1; \

71 
b
->
off_ptr
 = 4 + b->
n
 * sizeof(
key_t
); \

72 
b
->
ilen
 = (4 + sizeof(void*) + b->
n
 * (sizeof(void*) + sizeof(
key_t
)) + 3) >> 2 << 2; \

73 
b
->
elen
 = (b->
off_ptr
 + 3) >> 2 << 2; \

74 
b
->
root
 = (
kbnode_t
*)
	`calloc
(1, b->
ilen
); \

75 ++
b
->
n_nodes
; \

76 return 
b
; \

77 }

	)

79 #define 
	#__kb_destroy
(
b
) do { \

80 int 
i
, 
max
 = 8; \

81 
kbnode_t
 *
x
, **
top
, **
stack
 = 0; \

82 if (
b
) { \

83 
top
 = 
stack
 = (
kbnode_t
**)
	`calloc
(
max
, sizeof(kbnode_t*)); \

84 *
top
++ = (
b
)->
root
; \

85 while (
top
 != 
stack
) { \

86 
x
 = *--
top
; \

87 if (
x
->
is_internal
 == 0) { 
	`free
(x); continue; } \

88 for (
i
 = 0; i <= 
x
->
n
; ++i) \

89 if (
	`__KB_PTR
(
b
, 
x
)[
i
]) { \

90 if (
top
 - 
stack
 == 
max
) { \

91 
max
 <<= 1; \

92 
stack
 = (
kbnode_t
**)
	`realloc
(stack, 
max
 * sizeof(kbnode_t*)); \

93 
top
 = 
stack
 + (
max
>>1); \

95 *
top
++ = 
	`__KB_PTR
(
b
, 
x
)[
i
]; \

97 
	`free
(
x
); \

100 
	`free
(
b
); free(
stack
); \

101 } while (0)

	)

103 #define 
	#__KB_GET_AUX1
(
name
, 
key_t
, 
__cmp
) \

104 static 
inline
 int 
__kb_getp_aux_
##
	`name
(const 
kbnode_t
 * 
__restrict
 
x
, const 
key_t
 * __restrict 
k
, int *
r
) \

106 int 
tr
, *
rr
, 
begin
 = 0, 
end
 = 
x
->
n
; \

107 if (
x
->
n
 == 0) return -1; \

108 
rr
 = 
r
? r : &
tr
; \

109 while (
begin
 < 
end
) { \

110 int 
mid
 = (
begin
 + 
end
) >> 1; \

111 if (
	`__cmp
(
	`__KB_KEY
(
key_t
, 
x
)[
mid
], *
k
) < 0) 
begin
 = mid + 1; \

112 else 
end
 = 
mid
; \

114 if (
begin
 == 
x
->
n
) { *
rr
 = 1; return x->n - 1; } \

115 if ((*
rr
 = 
	`__cmp
(*
k
, 
	`__KB_KEY
(
key_t
, 
x
)[
begin
])) < 0) --begin; \

116 return 
begin
; \

117 }

	)

119 #define 
	#__KB_GET
(
name
, 
key_t
) \

120 static 
key_t
 *
kb_getp_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, const key_t * 
__restrict
 
k
) \

122 int 
i
, 
r
 = 0; \

123 
kbnode_t
 *
x
 = 
b
->
root
; \

124 while (
x
) { \

125 
i
 = 
__kb_getp_aux_
##
	`name
(
x
, 
k
, &
r
); \

126 if (
i
 >= 0 && 
r
 == 0) return &
	`__KB_KEY
(
key_t
, 
x
)[i]; \

127 if (
x
->
is_internal
 == 0) return 0; \

128 
x
 = 
	`__KB_PTR
(
b
, x)[
i
 + 1]; \

132 static 
inline
 
key_t
 *
kb_get_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, const key_t 
k
) \

134 return 
kb_getp_
##
	`name
(
b
, &
k
); \

135 }

	)

137 #define 
	#__KB_INTERVAL
(
name
, 
key_t
) \

138 static void 
kb_intervalp_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, const 
key_t
 * 
__restrict
 
k
, key_t **
lower
, key_t **
upper
) \

140 int 
i
, 
r
 = 0; \

141 
kbnode_t
 *
x
 = 
b
->
root
; \

142 *
lower
 = *
upper
 = 0; \

143 while (
x
) { \

144 
i
 = 
__kb_getp_aux_
##
	`name
(
x
, 
k
, &
r
); \

145 if (
i
 >= 0 && 
r
 == 0) { \

146 *
lower
 = *
upper
 = &
	`__KB_KEY
(
key_t
, 
x
)[
i
]; \

149 if (
i
 >= 0) *
lower
 = &
	`__KB_KEY
(
key_t
, 
x
)[i]; \

150 if (
i
 < 
x
->
n
 - 1) *
upper
 = &
	`__KB_KEY
(
key_t
, x)[i + 1]; \

151 if (
x
->
is_internal
 == 0) return; \

152 
x
 = 
	`__KB_PTR
(
b
, x)[
i
 + 1]; \

155 static 
inline
 void 
kb_interval_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, const 
key_t
 
k
, key_t **
lower
, key_t **
upper
) \

157 
kb_intervalp_
##
	`name
(
b
, &
k
, 
lower
, 
upper
); \

158 }

	)

160 #define 
	#__KB_PUT
(
name
, 
key_t
, 
__cmp
) \

162 static void 
__kb_split_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, 
kbnode_t
 *
x
, int 
i
, kbnode_t *
y
) \

164 
kbnode_t
 *
z
; \

165 
z
 = (
kbnode_t
*)
	`calloc
(1, 
y
->
is_internal
? 
b
->
ilen
 : b->
elen
); \

166 ++
b
->
n_nodes
; \

167 
z
->
is_internal
 = 
y
->is_internal; \

168 
z
->
n
 = 
b
->
t
 - 1; \

169 
	`memcpy
(
	`__KB_KEY
(
key_t
, 
z
), __KB_KEY(key_t, 
y
) + 
b
->
t
, sizeof(key_t) * (b->t - 1)); \

170 if (
y
->
is_internal
) 
	`memcpy
(
	`__KB_PTR
(
b
, 
z
), __KB_PTR(b, y) + b->
t
, sizeof(void*) * b->t); \

171 
y
->
n
 = 
b
->
t
 - 1; \

172 
	`memmove
(
	`__KB_PTR
(
b
, 
x
) + 
i
 + 2, __KB_PTR(b, x) + i + 1, sizeof(void*) * (x->
n
 - i)); \

173 
	`__KB_PTR
(
b
, 
x
)[
i
 + 1] = 
z
; \

174 
	`memmove
(
	`__KB_KEY
(
key_t
, 
x
) + 
i
 + 1, __KB_KEY(key_t, x) + i, sizeof(key_t) * (x->
n
 - i)); \

175 
	`__KB_KEY
(
key_t
, 
x
)[
i
] = __KB_KEY(key_t, 
y
)[
b
->
t
 - 1]; \

176 ++
x
->
n
; \

178 static 
key_t
 *
__kb_putp_aux_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, 
kbnode_t
 *
x
, const key_t * 
__restrict
 
k
) \

180 int 
i
 = 
x
->
n
 - 1; \

181 
key_t
 *
ret
; \

182 if (
x
->
is_internal
 == 0) { \

183 
i
 = 
__kb_getp_aux_
##
	`name
(
x
, 
k
, 0); \

184 if (
i
 != 
x
->
n
 - 1) \

185 
	`memmove
(
	`__KB_KEY
(
key_t
, 
x
) + 
i
 + 2, __KB_KEY(key_t, x) + i + 1, (x->
n
 - i - 1) * sizeof(key_t)); \

186 
ret
 = &
	`__KB_KEY
(
key_t
, 
x
)[
i
 + 1]; \

187 *
ret
 = *
k
; \

188 ++
x
->
n
; \

190 
i
 = 
__kb_getp_aux_
##
	`name
(
x
, 
k
, 0) + 1; \

191 if (
	`__KB_PTR
(
b
, 
x
)[
i
]->
n
 == 2 * b->
t
 - 1) { \

192 
__kb_split_
##
	`name
(
b
, 
x
, 
i
, 
	`__KB_PTR
(b, x)[i]); \

193 if (
	`__cmp
(*
k
, 
	`__KB_KEY
(
key_t
, 
x
)[
i
]) > 0) ++i; \

195 
ret
 = 
__kb_putp_aux_
##
	`name
(
b
, 
	`__KB_PTR
(b, 
x
)[
i
], 
k
); \

197 return 
ret
; \

199 static 
key_t
 *
kb_putp_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, const key_t * 
__restrict
 
k
) \

201 
kbnode_t
 *
r
, *
s
; \

202 ++
b
->
n_keys
; \

203 
r
 = 
b
->
root
; \

204 if (
r
->
n
 == 2 * 
b
->
t
 - 1) { \

205 ++
b
->
n_nodes
; \

206 
s
 = (
kbnode_t
*)
	`calloc
(1, 
b
->
ilen
); \

207 
b
->
root
 = 
s
; s->
is_internal
 = 1; s->
n
 = 0; \

208 
	`__KB_PTR
(
b
, 
s
)[0] = 
r
; \

209 
__kb_split_
##
	`name
(
b
, 
s
, 0, 
r
); \

210 
r
 = 
s
; \

212 return 
__kb_putp_aux_
##
	`name
(
b
, 
r
, 
k
); \

214 static 
inline
 void 
kb_put_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, const 
key_t
 
k
) \

216 
kb_putp_
##
	`name
(
b
, &
k
); \

217 }

	)

220 #define 
	#__KB_DEL
(
name
, 
key_t
) \

221 static 
key_t
 
__kb_delp_aux_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, 
kbnode_t
 *
x
, const key_t * 
__restrict
 
k
, int 
s
) \

223 int 
yn
, 
zn
, 
i
, 
r
 = 0; \

224 
kbnode_t
 *
xp
, *
y
, *
z
; \

225 
key_t
 
kp
; \

226 if (
x
 == 0) return *
k
; \

227 if (
s
) { \

228 
r
 = 
x
->
is_internal
 == 0? 0 : 
s
 == 1? 1 : -1; \

229 
i
 = 
s
 == 1? 
x
->
n
 - 1 : -1; \

230 } else 
i
 = 
__kb_getp_aux_
##
	`name
(
x
, 
k
, &
r
); \

231 if (
x
->
is_internal
 == 0) { \

232 if (
s
 == 2) ++
i
; \

233 
kp
 = 
	`__KB_KEY
(
key_t
, 
x
)[
i
]; \

234 
	`memmove
(
	`__KB_KEY
(
key_t
, 
x
) + 
i
, __KB_KEY(key_t, x) + i + 1, (x->
n
 - i - 1) * sizeof(key_t)); \

235 --
x
->
n
; \

236 return 
kp
; \

238 if (
r
 == 0) { \

239 if ((
yn
 = 
	`__KB_PTR
(
b
, 
x
)[
i
]->
n
) >= b->
t
) { \

240 
xp
 = 
	`__KB_PTR
(
b
, 
x
)[
i
]; \

241 
kp
 = 
	`__KB_KEY
(
key_t
, 
x
)[
i
]; \

242 
	`__KB_KEY
(
key_t
, 
x
)[
i
] = 
__kb_delp_aux_
##
	`name
(
b
, 
xp
, 0, 1); \

243 return 
kp
; \

244 } else if ((
zn
 = 
	`__KB_PTR
(
b
, 
x
)[
i
 + 1]->
n
) >= b->
t
) { \

245 
xp
 = 
	`__KB_PTR
(
b
, 
x
)[
i
 + 1]; \

246 
kp
 = 
	`__KB_KEY
(
key_t
, 
x
)[
i
]; \

247 
	`__KB_KEY
(
key_t
, 
x
)[
i
] = 
__kb_delp_aux_
##
	`name
(
b
, 
xp
, 0, 2); \

248 return 
kp
; \

249 } else if (
yn
 == 
b
->
t
 - 1 && 
zn
 == b->t - 1) { \

250 
y
 = 
	`__KB_PTR
(
b
, 
x
)[
i
]; 
z
 = __KB_PTR(b, x)[i + 1]; \

251 
	`__KB_KEY
(
key_t
, 
y
)[y->
n
++] = *
k
; \

252 
	`memmove
(
	`__KB_KEY
(
key_t
, 
y
) + y->
n
, __KB_KEY(key_t, 
z
), z->n * sizeof(key_t)); \

253 if (
y
->
is_internal
) 
	`memmove
(
	`__KB_PTR
(
b
, y) + y->
n
, __KB_PTR(b, 
z
), (z->n + 1) * sizeof(void*)); \

254 
y
->
n
 += 
z
->n; \

255 
	`memmove
(
	`__KB_KEY
(
key_t
, 
x
) + 
i
, __KB_KEY(key_t, x) + i + 1, (x->
n
 - i - 1) * sizeof(key_t)); \

256 
	`memmove
(
	`__KB_PTR
(
b
, 
x
) + 
i
 + 1, __KB_PTR(b, x) + i + 2, (x->
n
 - i - 1) * sizeof(void*)); \

257 --
x
->
n
; \

258 
	`free
(
z
); \

259 return 
__kb_delp_aux_
##
	`name
(
b
, 
y
, 
k
, 
s
); \

262 ++
i
; \

263 if ((
xp
 = 
	`__KB_PTR
(
b
, 
x
)[
i
])->
n
 == b->
t
 - 1) { \

264 if (
i
 > 0 && (
y
 = 
	`__KB_PTR
(
b
, 
x
)[i - 1])->
n
 >= b->
t
) { \

265 
	`memmove
(
	`__KB_KEY
(
key_t
, 
xp
) + 1, __KB_KEY(key_t, xp), xp->
n
 * sizeof(key_t)); \

266 if (
xp
->
is_internal
) 
	`memmove
(
	`__KB_PTR
(
b
, xp) + 1, __KB_PTR(b, xp), (xp->
n
 + 1) * sizeof(void*)); \

267 
	`__KB_KEY
(
key_t
, 
xp
)[0] = __KB_KEY(key_t, 
x
)[
i
 - 1]; \

268 
	`__KB_KEY
(
key_t
, 
x
)[
i
 - 1] = __KB_KEY(key_t, 
y
)[y->
n
 - 1]; \

269 if (
xp
->
is_internal
) 
	`__KB_PTR
(
b
, xp)[0] = __KB_PTR(b, 
y
)[y->
n
]; \

270 --
y
->
n
; ++
xp
->n; \

271 } else if (
i
 < 
x
->
n
 && (
y
 = 
	`__KB_PTR
(
b
, x)[i + 1])->n >= b->
t
) { \

272 
	`__KB_KEY
(
key_t
, 
xp
)[xp->
n
++] = __KB_KEY(key_t, 
x
)[
i
]; \

273 
	`__KB_KEY
(
key_t
, 
x
)[
i
] = __KB_KEY(key_t, 
y
)[0]; \

274 if (
xp
->
is_internal
) 
	`__KB_PTR
(
b
, xp)[xp->
n
] = __KB_PTR(b, 
y
)[0]; \

275 --
y
->
n
; \

276 
	`memmove
(
	`__KB_KEY
(
key_t
, 
y
), __KB_KEY(key_t, y) + 1, y->
n
 * sizeof(key_t)); \

277 if (
y
->
is_internal
) 
	`memmove
(
	`__KB_PTR
(
b
, y), __KB_PTR(b, y) + 1, (y->
n
 + 1) * sizeof(void*)); \

278 } else if (
i
 > 0 && (
y
 = 
	`__KB_PTR
(
b
, 
x
)[i - 1])->
n
 == b->
t
 - 1) { \

279 
	`__KB_KEY
(
key_t
, 
y
)[y->
n
++] = __KB_KEY(key_t, 
x
)[
i
 - 1]; \

280 
	`memmove
(
	`__KB_KEY
(
key_t
, 
y
) + y->
n
, __KB_KEY(key_t, 
xp
), xp->n * sizeof(key_t)); \

281 if (
y
->
is_internal
) 
	`memmove
(
	`__KB_PTR
(
b
, y) + y->
n
, __KB_PTR(b, 
xp
), (xp->n + 1) * sizeof(void*)); \

282 
y
->
n
 += 
xp
->n; \

283 
	`memmove
(
	`__KB_KEY
(
key_t
, 
x
) + 
i
 - 1, __KB_KEY(key_t, x) + i, (x->
n
 - i) * sizeof(key_t)); \

284 
	`memmove
(
	`__KB_PTR
(
b
, 
x
) + 
i
, __KB_PTR(b, x) + i + 1, (x->
n
 - i) * sizeof(void*)); \

285 --
x
->
n
; \

286 
	`free
(
xp
); \

287 
xp
 = 
y
; \

288 } else if (
i
 < 
x
->
n
 && (
y
 = 
	`__KB_PTR
(
b
, x)[i + 1])->n == b->
t
 - 1) { \

289 
	`__KB_KEY
(
key_t
, 
xp
)[xp->
n
++] = __KB_KEY(key_t, 
x
)[
i
]; \

290 
	`memmove
(
	`__KB_KEY
(
key_t
, 
xp
) + xp->
n
, __KB_KEY(key_t, 
y
), y->n * sizeof(key_t)); \

291 if (
xp
->
is_internal
) 
	`memmove
(
	`__KB_PTR
(
b
, xp) + xp->
n
, __KB_PTR(b, 
y
), (y->n + 1) * sizeof(void*)); \

292 
xp
->
n
 += 
y
->n; \

293 
	`memmove
(
	`__KB_KEY
(
key_t
, 
x
) + 
i
, __KB_KEY(key_t, x) + i + 1, (x->
n
 - i - 1) * sizeof(key_t)); \

294 
	`memmove
(
	`__KB_PTR
(
b
, 
x
) + 
i
 + 1, __KB_PTR(b, x) + i + 2, (x->
n
 - i - 1) * sizeof(void*)); \

295 --
x
->
n
; \

296 
	`free
(
y
); \

299 return 
__kb_delp_aux_
##
	`name
(
b
, 
xp
, 
k
, 
s
); \

301 static 
key_t
 
kb_delp_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, const key_t * 
__restrict
 
k
) \

303 
kbnode_t
 *
x
; \

304 
key_t
 
ret
; \

305 
ret
 = 
__kb_delp_aux_
##
	`name
(
b
, b->
root
, 
k
, 0); \

306 --
b
->
n_keys
; \

307 if (
b
->
root
->
n
 == 0 && b->root->
is_internal
) { \

308 --
b
->
n_nodes
; \

309 
x
 = 
b
->
root
; \

310 
b
->
root
 = 
	`__KB_PTR
(b, 
x
)[0]; \

311 
	`free
(
x
); \

313 return 
ret
; \

315 static 
inline
 
key_t
 
kb_del_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, const key_t 
k
) \

317 return 
kb_delp_
##
	`name
(
b
, &
k
); \

318 }

	)

320 #define 
	#__KB_ITR
(
name
, 
key_t
) \

321 static 
inline
 void 
kb_itr_first_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, 
kbitr_t
 *
itr
) \

323 
itr
->
p
 = 0; \

324 if (
b
->
n_keys
 == 0) return; \

325 
itr
->
p
 = itr->
stack
; \

326 
itr
->
p
->
x
 = 
b
->
root
; itr->p->
i
 = 0; \

327 while (
itr
->
p
->
x
->
is_internal
 && 
	`__KB_PTR
(
b
, itr->p->x)[0] != 0) { \

328 
kbnode_t
 *
x
 = 
itr
->
p
->x; \

329 ++
itr
->
p
; \

330 
itr
->
p
->
x
 = 
	`__KB_PTR
(
b
, x)[0]; itr->p->
i
 = 0; \

333 static int 
kb_itr_get_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, const 
key_t
 * 
__restrict
 
k
, 
kbitr_t
 *
itr
) \

335 int 
i
, 
r
 = 0; \

336 
itr
->
p
 = itr->
stack
; \

337 
itr
->
p
->
x
 = 
b
->
root
; itr->p->
i
 = 0; \

338 while (
itr
->
p
->
x
) { \

339 
i
 = 
__kb_getp_aux_
##
	`name
(
itr
->
p
->
x
, 
k
, &
r
); \

340 if (
i
 >= 0 && 
r
 == 0) return 0; \

341 if (
itr
->
p
->
x
->
is_internal
 == 0) return -1; \

342 
itr
->
p
[1].
x
 = 
	`__KB_PTR
(
b
, itr->p->x)[
i
 + 1]; \

343 
itr
->
p
[1].
i
 = i; \

344 ++
itr
->
p
; \

348 static 
inline
 int 
kb_itr_next_
##
	`name
(
kbtree_
##
name
##
_t
 *
b
, 
kbitr_t
 *
itr
) \

350 if (
itr
->
p
 < itr->
stack
) return 0; \

352 ++
itr
->
p
->
i
; \

353 while (
itr
->
p
->
x
 && itr->p->
i
 <= itr->p->x->
n
) { \

354 
itr
->
p
[1].
i
 = 0; \

355 
itr
->
p
[1].
x
 = itr->p->x->
is_internal
? 
	`__KB_PTR
(
b
, itr->p->x)[itr->p->
i
] : 0; \

356 ++
itr
->
p
; \

358 --
itr
->
p
; \

359 if (
itr
->
p
 < itr->
stack
) return 0; \

360 if (
itr
->
p
->
x
 && itr->p->
i
 < itr->p->x->
n
) return 1; \

362 }

	)

364 #define 
	#KBTREE_INIT
(
name
, 
key_t
, 
__cmp
) \

365 
	`__KB_TREE_T
(
name
) \

366 
	`__KB_INIT
(
name
, 
key_t
) \

367 
	`__KB_GET_AUX1
(
name
, 
key_t
, 
__cmp
) \

368 
	`__KB_GET
(
name
, 
key_t
) \

369 
	`__KB_INTERVAL
(
name
, 
key_t
) \

370 
	`__KB_PUT
(
name
, 
key_t
, 
__cmp
) \

371 
	`__KB_DEL
(
name
, 
key_t
) \

372 
	`__KB_ITR
(
name
, 
key_t
)

	)

374 #define 
	#KB_DEFAULT_SIZE
 512

	)

376 #define 
	#kbtree_t
(
name
) 
kbtree_
##name##
_t


	)

377 #define 
	#kb_init
(
name
, 
s
) 
kb_init_
##
	`name
(s)

	)

378 #define 
	#kb_destroy
(
name
, 
b
) 
	`__kb_destroy
(b)

	)

379 #define 
	#kb_get
(
name
, 
b
, 
k
) 
kb_get_
##
	`name
(b, k)

	)

380 #define 
	#kb_put
(
name
, 
b
, 
k
) 
kb_put_
##
	`name
(b, k)

	)

381 #define 
	#kb_del
(
name
, 
b
, 
k
) 
kb_del_
##
	`name
(b, k)

	)

382 #define 
	#kb_interval
(
name
, 
b
, 
k
, 
l
, 
u
) 
kb_interval_
##
	`name
(b, k, l, u)

	)

383 #define 
	#kb_getp
(
name
, 
b
, 
k
) 
kb_getp_
##
	`name
(b, k)

	)

384 #define 
	#kb_putp
(
name
, 
b
, 
k
) 
kb_putp_
##
	`name
(b, k)

	)

385 #define 
	#kb_delp
(
name
, 
b
, 
k
) 
kb_delp_
##
	`name
(b, k)

	)

386 #define 
	#kb_intervalp
(
name
, 
b
, 
k
, 
l
, 
u
) 
kb_intervalp_
##
	`name
(b, k, l, u)

	)

388 #define 
	#kb_itr_first
(
name
, 
b
, 
i
) 
kb_itr_first_
##
	`name
(b, i)

	)

389 #define 
	#kb_itr_get
(
name
, 
b
, 
k
, 
i
) 
kb_itr_get_
##
	`name
(b, k, i)

	)

390 #define 
	#kb_itr_next
(
name
, 
b
, 
i
) 
kb_itr_next_
##
	`name
(b, i)

	)

391 #define 
	#kb_itr_key
(
type
, 
itr
) 
	`__KB_KEY
(type, (itr)->
p
->
x
)[(itr)->p->
i
]

	)

392 #define 
	#kb_itr_valid
(
itr
) ((itr)->
p
 >= (itr)->
stack
)

	)

394 #define 
	#kb_size
(
b
) ((b)->
n_keys
)

	)

396 #define 
	#kb_generic_cmp
(
a
, 
b
) (((b) < (a)) - ((a) < (b)))

	)

397 #define 
	#kb_str_cmp
(
a
, 
b
) 
	`strcmp
(a, b)

	)

402 
kbnode_t
 *
	mx
;

403 int 
	mi
;

404 } 
	t__kbstack_t
;

406 #define 
	#__kb_traverse
(
key_t
, 
b
, 
__func
) do { \

407 int 
__kmax
 = 8; \

408 
__kbstack_t
 *
__kstack
, *
__kp
; \

409 
__kp
 = 
__kstack
 = (
__kbstack_t
*)
	`calloc
(
__kmax
, sizeof(__kbstack_t)); \

410 
__kp
->
x
 = (
b
)->
root
; __kp->
i
 = 0; \

412 while (
__kp
->
x
 && __kp->
i
 <= __kp->x->
n
) { \

413 if (
__kp
 - 
__kstack
 == 
__kmax
 - 1) { \

414 
__kmax
 <<= 1; \

415 
__kstack
 = (
__kbstack_t
*)
	`realloc
(__kstack, 
__kmax
 * sizeof(__kbstack_t)); \

416 
__kp
 = 
__kstack
 + (
__kmax
>>1) - 1; \

418 (
__kp
+1)->
i
 = 0; (__kp+1)->
x
 = __kp->x->
is_internal
? 
	`__KB_PTR
(
b
, __kp->x)[__kp->i] : 0; \

419 ++
__kp
; \

421 --
__kp
; \

422 if (
__kp
 >= 
__kstack
) { \

423 if (
__kp
->
x
 && __kp->
i
 < __kp->x->
n
) 
	`__func
(&
	`__KB_KEY
(
key_t
, __kp->x)[__kp->i]); \

424 ++
__kp
->
i
; \

427 
	`free
(
__kstack
); \

428 } while (0)

	)

430 #define 
	#__kb_get_first
(
key_t
, 
b
, 
ret
) do { \

431 
kbnode_t
 *
__x
 = (
b
)->
root
; \

432 while (
	`__KB_PTR
(
b
, 
__x
)[0] != 0) \

433 
__x
 = 
	`__KB_PTR
(
b
, __x)[0]; \

434 (
ret
) = 
	`__KB_KEY
(
key_t
, 
__x
)[0]; \

435 } while (0)

	)

	@deps/klib/kdq.h

1 #ifndef 
__AC_KDQ_H


2 #define 
	#__AC_KDQ_H


	)

4 #include 
	~<stdlib.h
>

5 #include 
	~<string.h
>

7 #define 
	#__KDQ_TYPE
(
type
) \

9 
size_t
 
front
:58, 
bits
:6, 
count
, 
mask
; \

10 
type
 *
a
; \

11 } 
	tkdq_
##
	ttype
##
	t_t
;

	)

13 #define 
	#kdq_t
(
type
) 
kdq_
##type##
_t


	)

14 #define 
	#kdq_size
(
q
) ((q)->
count
)

	)

15 #define 
	#kdq_first
(
q
) ((q)->
a
[(q)->
front
])

	)

16 #define 
	#kdq_last
(
q
) ((q)->
a
[((q)->
front
 + (q)->
count
 - 1) & (q)->
mask
])

	)

17 #define 
	#kdq_at
(
q
, 
i
) ((q)->
a
[((q)->
front
 + (i)) & (q)->
mask
])

	)

19 #define 
	#__KDQ_IMPL
(
type
, 
SCOPE
) \

20 
SCOPE
 
kdq_
##
type
##
_t
 *
kdq_init_
##
	`type
() \

22 
kdq_
##
type
##
_t
 *
q
; \

23 
q
 = (
kdq_
##
type
##
_t
*)
	`calloc
(1, sizeof(kdq_##type##_t)); \

24 
q
->
bits
 = 2, q->
mask
 = (1ULL<<q->bits) - 1; \

25 
q
->
a
 = (
type
*)
	`malloc
((1<<q->
bits
) * sizeof(type)); \

26 return 
q
; \

28 
SCOPE
 void 
kdq_destroy_
##
	`type
(
kdq_
##
type
##
_t
 *
q
) \

30 if (
q
 == 0) return; \

31 
	`free
(
q
->
a
); free(q); \

33 
SCOPE
 int 
kdq_resize_
##
	`type
(
kdq_
##
type
##
_t
 *
q
, int 
new_bits
) \

35 
size_t
 
new_size
 = 1ULL<<
new_bits
, 
old_size
 = 1ULL<<
q
->
bits
; \

36 if (
new_size
 < 
q
->
count
) { \

37 int 
i
; \

38 for (
i
 = 0; i < 64; ++i) \

39 if (1ULL<<
i
 > 
q
->
count
) break; \

40 
new_bits
 = 
i
, 
new_size
 = 1ULL<<new_bits; \

42 if (
new_bits
 == 
q
->
bits
) return q->bits; \

43 if (
new_bits
 > 
q
->
bits
) q->
a
 = (
type
*)
	`realloc
(q->a, (1ULL<<new_bits) * sizeof(type)); \

44 if (
q
->
front
 + q->
count
 <= 
old_size
) { \

45 if (
q
->
front
 + q->
count
 > 
new_size
) \

46 
	`memmove
(
q
->
a
, q->a + 
new_size
, (q->
front
 + q->
count
 - new_size) * sizeof(
type
)); \

48 
	`memmove
(
q
->
a
 + (
new_size
 - (
old_size
 - q->
front
)), q->a + q->front, (old_size - q->front) * sizeof(
type
)); \

49 
q
->
front
 = 
new_size
 - (
old_size
 - q->front); \

51 
q
->
bits
 = 
new_bits
, q->
mask
 = (1ULL<<q->bits) - 1; \

52 if (
new_bits
 < 
q
->
bits
) q->
a
 = (
type
*)
	`realloc
(q->a, (1ULL<<new_bits) * sizeof(type)); \

53 return 
q
->
bits
; \

55 
SCOPE
 
type
 *
kdq_pushp_
##
	`type
(
kdq_
##type##
_t
 *
q
) \

57 if (
q
->
count
 == 1ULL<<q->
bits
) 
kdq_resize_
##
	`type
(q, q->bits + 1); \

58 return &
q
->
a
[((q->
count
++) + q->
front
) & (q)->
mask
]; \

60 
SCOPE
 void 
kdq_push_
##
	`type
(
kdq_
##
type
##
_t
 *
q
, type 
v
) \

62 if (
q
->
count
 == 1ULL<<q->
bits
) 
kdq_resize_
##
	`type
(q, q->bits + 1); \

63 
q
->
a
[((q->
count
++) + q->
front
) & (q)->
mask
] = 
v
; \

65 
SCOPE
 
type
 *
kdq_unshiftp_
##
	`type
(
kdq_
##type##
_t
 *
q
) \

67 if (
q
->
count
 == 1ULL<<q->
bits
) 
kdq_resize_
##
	`type
(q, q->bits + 1); \

68 ++
q
->
count
; \

69 
q
->
front
 = q->front? q->front - 1 : (1ULL<<q->
bits
) - 1; \

70 return &
q
->
a
[q->
front
]; \

72 
SCOPE
 void 
kdq_unshift_
##
	`type
(
kdq_
##
type
##
_t
 *
q
, type 
v
) \

74 
type
 *
p
; \

75 
p
 = 
kdq_unshiftp_
##
	`type
(
q
); \

76 *
p
 = 
v
; \

78 
SCOPE
 
type
 *
kdq_pop_
##
	`type
(
kdq_
##type##
_t
 *
q
) \

80 return 
q
->
count
? &q->
a
[((--q->count) + q->
front
) & q->
mask
] : 0; \

82 
SCOPE
 
type
 *
kdq_shift_
##
	`type
(
kdq_
##type##
_t
 *
q
) \

84 
type
 *
d
 = 0; \

85 if (
q
->
count
 == 0) return 0; \

86 
d
 = &
q
->
a
[q->
front
++]; \

87 
q
->
front
 &= q->
mask
; \

88 --
q
->
count
; \

89 return 
d
; \

90 }

	)

92 #define 
	#KDQ_INIT2
(
type
, 
SCOPE
) \

93 
	`__KDQ_TYPE
(
type
) \

94 
	`__KDQ_IMPL
(
type
, 
SCOPE
)

	)

96 #ifndef 
klib_unused


97 #if (
defined
 
__clang__
 && 
__clang_major__
 >= 3) || (defined 
__GNUC__
 && __GNUC__ >= 3)

98 #define 
	#klib_unused
 
	`__attribute__
 ((
__unused__
))

	)

100 #define 
	#klib_unused


	)

104 #define 
	#KDQ_INIT
(
type
) 
	`KDQ_INIT2
(type, static 
inline
 
klib_unused
)

	)

106 #define 
	#KDQ_DECLARE
(
type
) \

107 
	`__KDQ_TYPE
(
type
) \

108 
kdq_
##
type
##
_t
 *
kdq_init_
##
	`type
(); \

109 void 
kdq_destroy_
##
	`type
(
kdq_
##
type
##
_t
 *
q
); \

110 int 
kdq_resize_
##
	`type
(
kdq_
##
type
##
_t
 *
q
, int 
new_bits
); \

111 
type
 *
kdq_pushp_
##
	`type
(
kdq_
##type##
_t
 *
q
); \

112 void 
kdq_push_
##
	`type
(
kdq_
##
type
##
_t
 *
q
, type 
v
); \

113 
type
 *
kdq_unshiftp_
##
	`type
(
kdq_
##type##
_t
 *
q
); \

114 void 
kdq_unshift_
##
	`type
(
kdq_
##
type
##
_t
 *
q
, type 
v
); \

115 
type
 *
kdq_pop_
##
	`type
(
kdq_
##type##
_t
 *
q
); \

116 
type
 *
kdq_shift_
##
	`type
(
kdq_
##type##
_t
 *
q
);

	)

118 #define 
	#kdq_init
(
type
) 
kdq_init_
##
	`type
()

	)

119 #define 
	#kdq_destroy
(
type
, 
q
) 
kdq_destroy_
##
	`type
(q)

	)

120 #define 
	#kdq_resize
(
type
, 
q
, 
new_bits
) 
kdq_resize_
##
	`type
(q, new_bits)

	)

121 #define 
	#kdq_pushp
(
type
, 
q
) 
kdq_pushp_
##
	`type
(q)

	)

122 #define 
	#kdq_push
(
type
, 
q
, 
v
) 
kdq_push_
##
	`type
(q, v)

	)

123 #define 
	#kdq_pop
(
type
, 
q
) 
kdq_pop_
##
	`type
(q)

	)

124 #define 
	#kdq_unshiftp
(
type
, 
q
) 
kdq_unshiftp_
##
	`type
(q)

	)

125 #define 
	#kdq_unshift
(
type
, 
q
, 
v
) 
kdq_unshift_
##
	`type
(q, v)

	)

126 #define 
	#kdq_shift
(
type
, 
q
) 
kdq_shift_
##
	`type
(q)

	)

	@deps/klib/kexpr.c

1 #include 
	~<string.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<stdint.h
>

4 #include 
	~<assert.h
>

5 #include 
	~<stdio.h
>

6 #include 
	~<ctype.h
>

7 #include 
	~<math.h
>

8 #include 
	~"kexpr.h
"

14 #define 
	#KEO_NULL
 0

	)

15 #define 
	#KEO_POS
 1

	)

16 #define 
	#KEO_NEG
 2

	)

17 #define 
	#KEO_BNOT
 3

	)

18 #define 
	#KEO_LNOT
 4

	)

19 #define 
	#KEO_POW
 5

	)

20 #define 
	#KEO_MUL
 6

	)

21 #define 
	#KEO_DIV
 7

	)

22 #define 
	#KEO_IDIV
 8

	)

23 #define 
	#KEO_MOD
 9

	)

24 #define 
	#KEO_ADD
 10

	)

25 #define 
	#KEO_SUB
 11

	)

26 #define 
	#KEO_LSH
 12

	)

27 #define 
	#KEO_RSH
 13

	)

28 #define 
	#KEO_LT
 14

	)

29 #define 
	#KEO_LE
 15

	)

30 #define 
	#KEO_GT
 16

	)

31 #define 
	#KEO_GE
 17

	)

32 #define 
	#KEO_EQ
 18

	)

33 #define 
	#KEO_NE
 19

	)

34 #define 
	#KEO_BAND
 20

	)

35 #define 
	#KEO_BXOR
 21

	)

36 #define 
	#KEO_BOR
 22

	)

37 #define 
	#KEO_LAND
 23

	)

38 #define 
	#KEO_LOR
 24

	)

40 #define 
	#KET_NULL
 0

	)

41 #define 
	#KET_VAL
 1

	)

42 #define 
	#KET_OP
 2

	)

43 #define 
	#KET_FUNC
 3

	)

45 #define 
	#KEF_NULL
 0

	)

46 #define 
	#KEF_REAL
 1

	)

48 struct 
	gke1_s
;

50 typedef struct 
	ske1_s
 {

51 
uint32_t
 
	mttype
:16, 
	mvtype
:10, 
	massigned
:1, 
	muser_func
:5;

52 
int32_t
 
	mop
:8, 
	mn_args
:24;

53 char *
	mname
;

55 void (*
	mbuiltin
)(struct 
ke1_s
 *
	ma
, struct ke1_s *
	mb
);

56 double (*
	mreal_func1
)(double);

57 double (*
	mreal_func2
)(double, double);

58 } 
	mf
;

59 double 
	mr
;

60 
int64_t
 
	mi
;

61 char *
	ms
;

62 } 
	tke1_t
;

64 static int 
	gke_op
[25] = {

80 static const char *
	gke_opstr
[] = {

96 struct 
	skexpr_s
 {

97 int 
	mn
;

98 
ke1_t
 *
	me
;

105 #define 
	#KE_GEN_CMP
(
_type
, 
_op
) \

106 static void 
ke_op_
##
	`_type
(
ke1_t
 *
p
, ke1_t *
q
) { \

107 if (
p
->
vtype
 == 
KEV_STR
 && 
q
->vtype == KEV_STR) p->
i
 = (
	`strcmp
(p->
s
, q->s) 
_op
 0); \

108 else 
p
->
i
 = p->
vtype
 == 
KEV_REAL
 || 
q
->vtype == KEV_REAL? (p->
r
 
_op
 q->r) : (p->i _op q->i); \

109 
p
->
r
 = (double)p->
i
; \

110 
p
->
vtype
 = 
KEV_INT
; \

111 }

	)

113 
KE_GEN_CMP
(
KEO_LT
, <)

114 
KE_GEN_CMP
(
KEO_LE
, <=)

115 
KE_GEN_CMP
(
KEO_GT
, >)

116 
KE_GEN_CMP
(
KEO_GE
, >=)

117 
	$KE_GEN_CMP
(
KEO_EQ
, ==)

118 
	`KE_GEN_CMP
(
KEO_NE
, !=)

120 #define 
	#KE_GEN_BIN_INT
(
_type
, 
_op
) \

121 static void 
ke_op_
##
	`_type
(
ke1_t
 *
p
, ke1_t *
q
) { \

122 
p
->
i
 
_op
 
q
->i; p->
r
 = (double)p->i; \

123 
p
->
vtype
 = 
KEV_INT
; \

124 
	}

	)
}

126 
	$KE_GEN_BIN_INT
(
KEO_BAND
, &=)

127 
	`KE_GEN_BIN_INT
(
KEO_BOR
, |=)

128 
	`KE_GEN_BIN_INT
(
KEO_BXOR
, ^=)

129 
	`KE_GEN_BIN_INT
(
KEO_LSH
, <<=)

130 
	`KE_GEN_BIN_INT
(
KEO_RSH
, >>=)

131 
	`KE_GEN_BIN_INT
(
KEO_MOD
, %=)

132 
	`KE_GEN_BIN_INT
(
KEO_IDIV
, /=)

134 #define 
	#KE_GEN_BIN_BOTH
(
_type
, 
_op
) \

135 static void 
ke_op_
##
	`_type
(
ke1_t
 *
p
, ke1_t *
q
) { \

136 
p
->
i
 
_op
 
q
->i; p->
r
 _op q->r; \

137 
p
->
vtype
 = p->vtype == 
KEV_REAL
 || 
q
->vtype == KEV_REAL? KEV_REAL : 
KEV_INT
; \

138 
	}

	)
}

140 
KE_GEN_BIN_BOTH
(
KEO_ADD
, +=)

141 
KE_GEN_BIN_BOTH
(
KEO_SUB
, -=)

142 
	$KE_GEN_BIN_BOTH
(
KEO_MUL
, *=)

144 static void 
	$ke_op_KEO_DIV
(
ke1_t
 *
p
, ke1_t *
q
) { p->
r
 /= q->r, p->
i
 = (
int64_t
)(p->r + .5); p->
vtype
 = 
KEV_REAL
; 
	}
}

145 static void 
	$ke_op_KEO_LAND
(
ke1_t
 *
p
, ke1_t *
q
) { p->
i
 = (p->i && q->i); p->
r
 = p->i; p->
vtype
 = 
KEV_INT
; 
	}
}

146 static void 
	$ke_op_KEO_LOR
(
ke1_t
 *
p
, ke1_t *
q
) { p->
i
 = (p->i || q->i); p->
r
 = p->i; p->
vtype
 = 
KEV_INT
; 
	}
}

147 static void 
	$ke_op_KEO_POW
(
ke1_t
 *
p
, ke1_t *
q
) { p->
r
 = 
	`pow
(p->r, q->r), p->
i
 = (
int64_t
)(p->r + .5); p->
vtype
 = p->vtype == 
KEV_REAL
 || q->vtype == KEV_REAL? KEV_REAL : 
KEV_INT
; 
	}
}

148 static void 
	$ke_op_KEO_BNOT
(
ke1_t
 *
p
, ke1_t *
q
) { p->
i
 = ~p->i; p->
r
 = (double)p->i; p->
vtype
 = 
KEV_INT
; 
	}
}

149 static void 
	$ke_op_KEO_LNOT
(
ke1_t
 *
p
, ke1_t *
q
) { p->
i
 = !p->i; p->
r
 = (double)p->i; p->
vtype
 = 
KEV_INT
; 
	}
}

150 static void 
	$ke_op_KEO_POS
(
ke1_t
 *
p
, ke1_t *
q
) { 
	}
}

151 static void 
	$ke_op_KEO_NEG
(
ke1_t
 *
p
, ke1_t *
q
) { p->
i
 = -p->i, p->
r
 = -p->r; 
	}
}

153 static void 
	$ke_func1_abs
(
ke1_t
 *
p
, ke1_t *
q
) { if (p->
vtype
 == 
KEV_INT
) p->
i
 = 
	`abs
(p->i), p->
r
 = (double)p->i; else p->r = 
	`fabs
(p->r), p->i = (
int64_t
)(p->r + .5); 
	}
}

159 static 
inline
 char *
	$mystrndup
(const char *
src
, int 
n
)

161 char *
dst
;

162 
dst
 = (char*)
	`calloc
(
n
 + 1, 1);

163 
	`strncpy
(
dst
, 
src
, 
n
);

164 return 
dst
;

165 
	}
}

168 static 
ke1_t
 
	$ke_read_token
(char *
p
, char **
r
, int *
err
, int 
last_is_val
)

170 char *
q
 = 
p
;

171 
ke1_t
 
e
;

172 
	`memset
(&
e
, 0, sizeof(
ke1_t
));

173 if (
	`isalpha
(*
p
) || *p == '_') {

174 for (; *
p
 && (*p == '_' || 
	`isalnum
(*p)); ++p);

175 if (*
p
 == '(') 
e
.
ttype
 = 
KET_FUNC
, e.
n_args
 = 1;

176 else 
e
.
ttype
 = 
KET_VAL
, e.
vtype
 = 
KEV_REAL
;

177 
e
.
name
 = 
	`mystrndup
(
q
, 
p
 - q);

178 
e
.
i
 = 0, e.
r
 = 0.;

179 *
r
 = 
p
;

180 } else if (
	`isdigit
(*
p
) || *p == '.') {

181 long 
x
;

182 double 
y
;

183 char *
pp
;

184 
e
.
ttype
 = 
KET_VAL
;

185 
y
 = 
	`strtod
(
q
, &
p
);

186 
x
 = 
	`strtol
(
q
, &
pp
, 0);

187 if (
q
 == 
p
 && q == 
pp
) {

188 *
err
 |= 
KEE_NUM
;

189 } else if (
p
 > 
pp
) {

190 
e
.
vtype
 = 
KEV_REAL
;

191 
e
.
i
 = (
int64_t
)(
y
 + .5), e.
r
 = y;

192 *
r
 = 
p
;

194 
e
.
vtype
 = 
KEV_INT
;

195 
e
.
i
 = 
x
, e.
r
 = 
y
;

196 *
r
 = 
pp
;

198 } else if (*
p
 == '"' || *p == '\'') {

199 int 
c
 = *
p
;

200 for (++
p
; *p && *p != 
c
; ++p)

201 if (*
p
 == '\\') ++p;

202 if (*
p
 == 
c
) {

203 
e
.
ttype
 = 
KET_VAL
, e.
vtype
 = 
KEV_STR
;

204 
e
.
s
 = 
	`mystrndup
(
q
 + 1, 
p
 - q - 1);

205 *
r
 = 
p
 + 1;

206 } else *
err
 |= 
KEE_UNQU
, *
r
 = 
p
;

208 
e
.
ttype
 = 
KET_OP
;

209 if (*
p
 == '*' && p[1] == '*') 
e
.
op
 = 
KEO_POW
, e.
f
.
builtin
 = 
ke_op_KEO_POW
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

210 else if (*
p
 == '*') 
e
.
op
 = 
KEO_MUL
, e.
f
.
builtin
 = 
ke_op_KEO_MUL
, e.
n_args
 = 2, *
r
 = 
q
 + 1;

211 else if (*
p
 == '/' && p[1] == '/') 
e
.
op
 = 
KEO_IDIV
, e.
f
.
builtin
 = 
ke_op_KEO_IDIV
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

212 else if (*
p
 == '/') 
e
.
op
 = 
KEO_DIV
, e.
f
.
builtin
 = 
ke_op_KEO_DIV
, e.
n_args
 = 2, *
r
 = 
q
 + 1;

213 else if (*
p
 == '%') 
e
.
op
 = 
KEO_MOD
, e.
f
.
builtin
 = 
ke_op_KEO_MOD
, e.
n_args
 = 2, *
r
 = 
q
 + 1;

214 else if (*
p
 == '+') {

215 if (
last_is_val
) 
e
.
op
 = 
KEO_ADD
, e.
f
.
builtin
 = 
ke_op_KEO_ADD
, e.
n_args
 = 2;

216 else 
e
.
op
 = 
KEO_POS
, e.
f
.
builtin
 = 
ke_op_KEO_POS
, e.
n_args
 = 1;

217 *
r
 = 
q
 + 1;

218 } else if (*
p
 == '-') {

219 if (
last_is_val
) 
e
.
op
 = 
KEO_SUB
, e.
f
.
builtin
 = 
ke_op_KEO_SUB
, e.
n_args
 = 2;

220 else 
e
.
op
 = 
KEO_NEG
, e.
f
.
builtin
 = 
ke_op_KEO_NEG
, e.
n_args
 = 1;

221 *
r
 = 
q
 + 1;

222 } else if (*
p
 == '=' && p[1] == '=') 
e
.
op
 = 
KEO_EQ
, e.
f
.
builtin
 = 
ke_op_KEO_EQ
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

223 else if (*
p
 == '!' && p[1] == '=') 
e
.
op
 = 
KEO_NE
, e.
f
.
builtin
 = 
ke_op_KEO_NE
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

224 else if (*
p
 == '<' && p[1] == '>') 
e
.
op
 = 
KEO_NE
, e.
f
.
builtin
 = 
ke_op_KEO_NE
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

225 else if (*
p
 == '>' && p[1] == '=') 
e
.
op
 = 
KEO_GE
, e.
f
.
builtin
 = 
ke_op_KEO_GE
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

226 else if (*
p
 == '<' && p[1] == '=') 
e
.
op
 = 
KEO_LE
, e.
f
.
builtin
 = 
ke_op_KEO_LE
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

227 else if (*
p
 == '>' && p[1] == '>') 
e
.
op
 = 
KEO_RSH
, e.
f
.
builtin
 = 
ke_op_KEO_RSH
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

228 else if (*
p
 == '<' && p[1] == '<') 
e
.
op
 = 
KEO_LSH
, e.
f
.
builtin
 = 
ke_op_KEO_LSH
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

229 else if (*
p
 == '>') 
e
.
op
 = 
KEO_GT
, e.
f
.
builtin
 = 
ke_op_KEO_GT
, e.
n_args
 = 2, *
r
 = 
q
 + 1;

230 else if (*
p
 == '<') 
e
.
op
 = 
KEO_LT
, e.
f
.
builtin
 = 
ke_op_KEO_LT
, e.
n_args
 = 2, *
r
 = 
q
 + 1;

231 else if (*
p
 == '|' && p[1] == '|') 
e
.
op
 = 
KEO_LOR
, e.
f
.
builtin
 = 
ke_op_KEO_LOR
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

232 else if (*
p
 == '&' && p[1] == '&') 
e
.
op
 = 
KEO_LAND
, e.
f
.
builtin
 = 
ke_op_KEO_LAND
, e.
n_args
 = 2, *
r
 = 
q
 + 2;

233 else if (*
p
 == '|') 
e
.
op
 = 
KEO_BOR
, e.
f
.
builtin
 = 
ke_op_KEO_BOR
, e.
n_args
 = 2, *
r
 = 
q
 + 1;

234 else if (*
p
 == '&') 
e
.
op
 = 
KEO_BAND
, e.
f
.
builtin
 = 
ke_op_KEO_BAND
, e.
n_args
 = 2, *
r
 = 
q
 + 1;

235 else if (*
p
 == '^') 
e
.
op
 = 
KEO_BXOR
, e.
f
.
builtin
 = 
ke_op_KEO_BXOR
, e.
n_args
 = 2, *
r
 = 
q
 + 1;

236 else if (*
p
 == '~') 
e
.
op
 = 
KEO_BNOT
, e.
f
.
builtin
 = 
ke_op_KEO_BNOT
, e.
n_args
 = 1, *
r
 = 
q
 + 1;

237 else if (*
p
 == '!') 
e
.
op
 = 
KEO_LNOT
, e.
f
.
builtin
 = 
ke_op_KEO_LNOT
, e.
n_args
 = 1, *
r
 = 
q
 + 1;

238 else 
e
.
ttype
 = 
KET_NULL
, *
err
 |= 
KEE_UNOP
;

240 return 
e
;

241 
	}
}

243 static 
inline
 
ke1_t
 *
	$push_back
(
ke1_t
 **
a
, int *
n
, int *
m
)

245 if (*
n
 == *
m
) {

246 int 
old_m
 = *
m
;

247 *
m
 = *m? *m<<1 : 8;

248 *
a
 = (
ke1_t
*)
	`realloc
(*a, *
m
 * sizeof(ke1_t));

249 
	`memset
(*
a
 + 
old_m
, 0, (*
m
 - old_m) * sizeof(
ke1_t
));

251 return &(*
a
)[(*
n
)++];

252 
	}
}

254 static 
ke1_t
 *
	$ke_parse_core
(const char *
_s
, int *
_n
, int *
err
)

256 char *
s
, *
p
, *
q
;

257 int 
n_out
, 
m_out
, 
n_op
, 
m_op
, 
last_is_val
 = 0;

258 
ke1_t
 *
out
, *
op
, *
t
, *
u
;

260 *
err
 = 0; *
_n
 = 0;

261 
s
 = 
	`strdup
(
_s
);

262 for (
p
 = 
q
 = 
s
; *p; ++p)

263 if (!
	`isspace
(*
p
)) *
q
++ = *p;

264 *
q
++ = 0;

266 
out
 = 
op
 = 0;

267 
n_out
 = 
m_out
 = 
n_op
 = 
m_op
 = 0;

268 
p
 = 
s
;

269 while (*
p
) {

270 if (*
p
 == '(') {

271 
t
 = 
	`push_back
(&
op
, &
n_op
, &
m_op
);

272 
t
->
op
 = -1, t->
ttype
 = 
KET_NULL
;

273 ++
p
;

274 } else if (*
p
 == ')') {

275 while (
n_op
 > 0 && 
op
[n_op-1].op >= 0) {

276 
u
 = 
	`push_back
(&
out
, &
n_out
, &
m_out
);

277 *
u
 = 
op
[--
n_op
];

279 if (
n_op
 == 0) {

280 *
err
 |= 
KEE_UNRP
;

282 } else --
n_op
;

283 if (
n_op
 > 0 && 
op
[n_op-1].
ttype
 == 
KET_FUNC
) {

284 
u
 = 
	`push_back
(&
out
, &
n_out
, &
m_out
);

285 *
u
 = 
op
[--
n_op
];

286 if (
u
->
n_args
 == 1 && 
	`strcmp
(u->
name
, "abs") == 0) u->
f
.
builtin
 = 
ke_func1_abs
;

288 ++
p
;

289 } else if (*
p
 == ',') {

290 while (
n_op
 > 0 && 
op
[n_op-1].op >= 0) {

291 
u
 = 
	`push_back
(&
out
, &
n_out
, &
m_out
);

292 *
u
 = 
op
[--
n_op
];

294 if (
n_op
 < 2 || 
op
[n_op-2].
ttype
 != 
KET_FUNC
) {

295 *
err
 |= 
KEE_FUNC
;

298 ++
op
[
n_op
-2].
n_args
;

299 ++
p
;

301 
ke1_t
 
v
;

302 
v
 = 
	`ke_read_token
(
p
, &p, 
err
, 
last_is_val
);

303 if (*
err
) break;

304 if (
v
.
ttype
 == 
KET_VAL
) {

305 
u
 = 
	`push_back
(&
out
, &
n_out
, &
m_out
);

306 *
u
 = 
v
;

307 
last_is_val
 = 1;

308 } else if (
v
.
ttype
 == 
KET_FUNC
) {

309 
t
 = 
	`push_back
(&
op
, &
n_op
, &
m_op
);

310 *
t
 = 
v
;

311 
last_is_val
 = 0;

312 } else if (
v
.
ttype
 == 
KET_OP
) {

313 int 
oi
 = 
ke_op
[
v
.
op
];

314 while (
n_op
 > 0 && 
op
[n_op-1].
ttype
 == 
KET_OP
) {

315 int 
pre
 = 
ke_op
[
op
[
n_op
-1].op]>>1;

316 if (((
oi
&1) && oi>>1 <= 
pre
) || (!(oi&1) && oi>>1 < pre)) break;

317 
u
 = 
	`push_back
(&
out
, &
n_out
, &
m_out
);

318 *
u
 = 
op
[--
n_op
];

320 
t
 = 
	`push_back
(&
op
, &
n_op
, &
m_op
);

321 *
t
 = 
v
;

322 
last_is_val
 = 0;

327 if (*
err
 == 0) {

328 while (
n_op
 > 0 && 
op
[n_op-1].op >= 0) {

329 
u
 = 
	`push_back
(&
out
, &
n_out
, &
m_out
);

330 *
u
 = 
op
[--
n_op
];

332 if (
n_op
 > 0) *
err
 |= 
KEE_UNLP
;

335 if (*
err
 == 0) {

336 int 
i
, 
n
;

337 for (
i
 = 
n
 = 0; i < 
n_out
; ++i) {

338 
ke1_t
 *
e
 = &
out
[
i
];

339 if (
e
->
ttype
 == 
KET_VAL
) ++
n
;

340 else 
n
 -= 
e
->
n_args
 - 1;

342 if (
n
 != 1) *
err
 |= 
KEE_ARG
;

345 
	`free
(
op
); free(
s
);

346 if (*
err
) {

347 
	`free
(
out
);

350 *
_n
 = 
n_out
;

351 return 
out
;

352 
	}
}

354 
kexpr_t
 *
	$ke_parse
(const char *
_s
, int *
err
)

356 int 
n
;

357 
ke1_t
 *
e
;

358 
kexpr_t
 *
ke
;

359 
e
 = 
	`ke_parse_core
(
_s
, &
n
, 
err
);

360 if (*
err
) return 0;

361 
ke
 = (
kexpr_t
*)
	`calloc
(1, sizeof(kexpr_t));

362 
ke
->
n
 = n, ke->
e
 = e;

363 return 
ke
;

364 
	}
}

366 int 
	$ke_eval
(const 
kexpr_t
 *
ke
, 
int64_t
 *
_i
, double *
_r
, const char **
_p
, int *
ret_type
)

368 
ke1_t
 *
stack
, *
p
, *
q
;

369 int 
i
, 
top
 = 0, 
err
 = 0;

370 *
_i
 = 0, *
_r
 = 0., *
ret_type
 = 0;

371 for (
i
 = 0; i < 
ke
->
n
; ++i) {

372 
ke1_t
 *
e
 = &
ke
->e[
i
];

373 if ((
e
->
ttype
 == 
KET_OP
 || e->ttype == 
KET_FUNC
) && e->
f
.
builtin
 == 0) 
err
 |= 
KEE_UNFUNC
;

374 else if (
e
->
ttype
 == 
KET_VAL
 && e->
name
 && e->
assigned
 == 0) 
err
 |= 
KEE_UNVAR
;

376 
stack
 = (
ke1_t
*)
	`malloc
(
ke
->
n
 * sizeof(ke1_t));

377 for (
i
 = 0; i < 
ke
->
n
; ++i) {

378 
ke1_t
 *
e
 = &
ke
->e[
i
];

379 if (
e
->
ttype
 == 
KET_OP
 || e->ttype == 
KET_FUNC
) {

380 if (
e
->
n_args
 == 2 && e->
f
.
builtin
) {

381 
q
 = &
stack
[--
top
], 
p
 = &stack[top-1];

382 if (
e
->
user_func
) {

383 if (
e
->
user_func
 == 
KEF_REAL
)

384 
p
->
r
 = 
e
->
f
.
	`real_func2
(p->r, 
q
->r), p->
i
 = (
int64_t
)(p->r + .5), p->
vtype
 = 
KEV_REAL
;

385 } else 
e
->
f
.
	`builtin
(
p
, 
q
);

386 } else if (
e
->
n_args
 == 1 && e->
f
.
builtin
) {

387 
p
 = &
stack
[
top
-1];

388 if (
e
->
user_func
) {

389 if (
e
->
user_func
 == 
KEF_REAL
)

390 
p
->
r
 = 
e
->
f
.
	`real_func1
(p->r), p->
i
 = (
int64_t
)(p->r + .5), p->
vtype
 = 
KEV_REAL
;

391 } else 
e
->
f
.
	`builtin
(&
stack
[
top
-1], 0);

392 } else 
top
 -= 
e
->
n_args
 - 1;

393 } else 
stack
[
top
++] = *
e
;

395 *
ret_type
 = 
stack
->
vtype
;

396 *
_i
 = 
stack
->
i
, *
_r
 = stack->
r
, *
_p
 = stack->
s
;

397 
	`free
(
stack
);

398 return 
err
;

399 
	}
}

401 
int64_t
 
	$ke_eval_int
(const 
kexpr_t
 *
ke
, int *
err
)

403 int 
int_ret
;

404 
int64_t
 
i
;

405 double 
r
;

406 const char *
s
;

407 *
err
 = 
	`ke_eval
(
ke
, &
i
, &
r
, &
s
, &
int_ret
);

408 return 
i
;

409 
	}
}

411 double 
	$ke_eval_real
(const 
kexpr_t
 *
ke
, int *
err
)

413 int 
int_ret
;

414 
int64_t
 
i
;

415 double 
r
;

416 const char *
s
;

417 *
err
 = 
	`ke_eval
(
ke
, &
i
, &
r
, &
s
, &
int_ret
);

418 return 
r
;

419 
	}
}

421 void 
	$ke_destroy
(
kexpr_t
 *
ke
)

423 int 
i
;

424 if (
ke
 == 0) return;

425 for (
i
 = 0; i < 
ke
->
n
; ++i) {

426 
	`free
(
ke
->
e
[
i
].
name
);

427 
	`free
(
ke
->
e
[
i
].
s
);

429 
	`free
(
ke
->
e
); free(ke);

430 
	}
}

432 int 
	$ke_set_int
(
kexpr_t
 *
ke
, const char *
var
, 
int64_t
 
y
)

434 int 
i
, 
n
 = 0;

435 double 
yy
 = (double)
y
;

436 for (
i
 = 0; i < 
ke
->
n
; ++i) {

437 
ke1_t
 *
e
 = &
ke
->e[
i
];

438 if (
e
->
ttype
 == 
KET_VAL
 && e->
name
 && 
	`strcmp
(e->name, 
var
) == 0)

439 
e
->
i
 = 
y
, e->
r
 = 
yy
, e->
vtype
 = 
KEV_INT
, e->
assigned
 = 1, ++
n
;

441 return 
n
;

442 
	}
}

444 int 
	$ke_set_real
(
kexpr_t
 *
ke
, const char *
var
, double 
x
)

446 int 
i
, 
n
 = 0;

447 
int64_t
 
xx
 = (int64_t)(
x
 + .5);

448 for (
i
 = 0; i < 
ke
->
n
; ++i) {

449 
ke1_t
 *
e
 = &
ke
->e[
i
];

450 if (
e
->
ttype
 == 
KET_VAL
 && e->
name
 && 
	`strcmp
(e->name, 
var
) == 0)

451 
e
->
r
 = 
x
, e->
i
 = 
xx
, e->
vtype
 = 
KEV_REAL
, e->
assigned
 = 1, ++
n
;

453 return 
n
;

454 
	}
}

456 int 
	$ke_set_str
(
kexpr_t
 *
ke
, const char *
var
, const char *
x
)

458 int 
i
, 
n
 = 0;

459 for (
i
 = 0; i < 
ke
->
n
; ++i) {

460 
ke1_t
 *
e
 = &
ke
->e[
i
];

461 if (
e
->
ttype
 == 
KET_VAL
 && e->
name
 && 
	`strcmp
(e->name, 
var
) == 0) {

462 if (
e
->
vtype
 == 
KEV_STR
) 
	`free
(e->
s
);

463 
e
->
s
 = 
	`strdup
(
x
);

464 
e
->
i
 = 0, e->
r
 = 0., e->
assigned
 = 1;

465 
e
->
vtype
 = 
KEV_STR
;

466 ++
n
;

469 return 
n
;

470 
	}
}

472 int 
	$ke_set_real_func1
(
kexpr_t
 *
ke
, const char *
name
, double (*
func
)(double))

474 int 
i
, 
n
 = 0;

475 for (
i
 = 0; i < 
ke
->
n
; ++i) {

476 
ke1_t
 *
e
 = &
ke
->e[
i
];

477 if (
e
->
ttype
 == 
KET_FUNC
 && e->
n_args
 == 1 && 
	`strcmp
(e->
name
, name) == 0)

478 
e
->
f
.
real_func1
 = 
func
, e->
user_func
 = 
KEF_REAL
, ++
n
;

480 return 
n
;

481 
	}
}

483 int 
	$ke_set_real_func2
(
kexpr_t
 *
ke
, const char *
name
, double (*
func
)(double, double))

485 int 
i
, 
n
 = 0;

486 for (
i
 = 0; i < 
ke
->
n
; ++i) {

487 
ke1_t
 *
e
 = &
ke
->e[
i
];

488 if (
e
->
ttype
 == 
KET_FUNC
 && e->
n_args
 == 2 && 
	`strcmp
(e->
name
, name) == 0)

489 
e
->
f
.
real_func2
 = 
func
, e->
user_func
 = 
KEF_REAL
, ++
n
;

491 return 
n
;

492 
	}
}

494 int 
	$ke_set_default_func
(
kexpr_t
 *
ke
)

496 int 
n
 = 0;

497 
n
 += 
	`ke_set_real_func1
(
ke
, "exp", 
exp
);

498 
n
 += 
	`ke_set_real_func1
(
ke
, "log", 
log
);

499 
n
 += 
	`ke_set_real_func1
(
ke
, "log10", 
log10
);

500 
n
 += 
	`ke_set_real_func1
(
ke
, "sqrt", 
sqrt
);

501 
n
 += 
	`ke_set_real_func1
(
ke
, "sin", 
sin
);

502 
n
 += 
	`ke_set_real_func1
(
ke
, "cos", 
cos
);

503 
n
 += 
	`ke_set_real_func1
(
ke
, "tan", 
tan
);

504 
n
 += 
	`ke_set_real_func2
(
ke
, "pow", 
pow
);

505 return 
n
;

506 
	}
}

508 void 
	$ke_unset
(
kexpr_t
 *
ke
)

510 int 
i
;

511 for (
i
 = 0; i < 
ke
->
n
; ++i) {

512 
ke1_t
 *
e
 = &
ke
->e[
i
];

513 if (
e
->
ttype
 == 
KET_VAL
 && e->
name
) e->
assigned
 = 0;

515 
	}
}

517 void 
	$ke_print
(const 
kexpr_t
 *
ke
)

519 int 
i
;

520 if (
ke
 == 0) return;

521 for (
i
 = 0; i < 
ke
->
n
; ++i) {

522 const 
ke1_t
 *
u
 = &
ke
->
e
[
i
];

523 if (
i
) 
	`putchar
(' ');

524 if (
u
->
ttype
 == 
KET_VAL
) {

525 if (
u
->
name
) 
	`printf
("%s", u->name);

526 else if (
u
->
vtype
 == 
KEV_REAL
) 
	`printf
("%g", u->
r
);

527 else if (
u
->
vtype
 == 
KEV_INT
) 
	`printf
("%lld", (long long)u->
i
);

528 else if (
u
->
vtype
 == 
KEV_STR
) 
	`printf
("\"%s\"", u->
s
);

529 } else if (
u
->
ttype
 == 
KET_OP
) {

530 
	`printf
("%s", 
ke_opstr
[
u
->
op
]);

531 } else if (
u
->
ttype
 == 
KET_FUNC
) {

532 
	`printf
("%s(%d)", 
u
->
name
, u->
n_args
);

535 
	`putchar
('\n');

536 
	}
}

539 #ifdef 
KE_MAIN


540 #include 
	~<unistd.h
>

542 int 
	$main
(int 
argc
, char *
argv
[])

544 int 
c
, 
err
, 
to_print
 = 0, 
is_int
 = 0;

545 
kexpr_t
 *
ke
;

547 while ((
c
 = 
	`getopt
(
argc
, 
argv
, "pi")) >= 0) {

548 if (
c
 == 'p') 
to_print
 = 1;

549 else if (
c
 == 'i') 
is_int
 = 1;

551 if (
optind
 == 
argc
) {

552 
	`fprintf
(
stderr
, "Usage: %s [-pi] <expr>\n", 
argv
[0]);

555 
ke
 = 
	`ke_parse
(
argv
[
optind
], &
err
);

556 
	`ke_set_default_func
(
ke
);

557 if (
err
) {

558 
	`fprintf
(
stderr
, "Parse error: 0x%x\n", 
err
);

561 if (!
to_print
) {

562 
int64_t
 
vi
;

563 double 
vr
;

564 const char *
vs
;

565 int 
i
, 
ret_type
;

566 if (
argc
 - 
optind
 > 1) {

567 for (
i
 = 
optind
 + 1; i < 
argc
; ++i) {

568 char *
p
, *
s
 = 
argv
[
i
];

569 for (
p
 = 
s
; *p && *p != '='; ++p);

570 if (*
p
 == 0) continue;

571 *
p
 = 0;

572 
	`ke_set_real
(
ke
, 
s
, 
	`strtod
(
p
+1, &p));

575 
err
 |= 
	`ke_eval
(
ke
, &
vi
, &
vr
, &
vs
, &
ret_type
);

576 if (
err
 & 
KEE_UNFUNC
)

577 
	`fprintf
(
stderr
, "Evaluation warning: an undefined function returns the first function argument.\n");

578 if (
err
 & 
KEE_UNVAR
) 
	`fprintf
(
stderr
, "Evaluation warning: unassigned variables are set to 0.\n");

579 if (
ret_type
 == 
KEV_INT
) 
	`printf
("%lld\n", (long long)
vi
);

580 else if (
ret_type
 == 
KEV_REAL
) 
	`printf
("%g\n", 
vr
);

581 else 
	`printf
("%s\n", 
vs
);

582 } else 
	`ke_print
(
ke
);

583 
	`ke_destroy
(
ke
);

585 
	}
}

	@deps/klib/kexpr.h

1 #ifndef 
KEXPR_H


2 #define 
	#KEXPR_H


	)

4 #include 
	~<stdint.h
>

6 struct 
	gkexpr_s
;

7 typedef struct 
kexpr_s
 
	tkexpr_t
;

10 #define 
	#KEE_UNQU
 0x01

11 #define 
	#KEE_UNLP
 0x02

12 #define 
	#KEE_UNRP
 0x04

13 #define 
	#KEE_UNOP
 0x08

14 #define 
	#KEE_FUNC
 0x10

15 #define 
	#KEE_ARG
 0x20

	)

16 #define 
	#KEE_NUM
 0x40

17 

	)

19 #define 
	#KEE_UNFUNC
 0x40

20 #define 
	#KEE_UNVAR
 0x80

21 

	)

23 #define 
	#KEV_REAL
 1

	)

24 #define 
	#KEV_INT
 2

	)

25 #define 
	#KEV_STR
 3

	)

27 #ifdef 
__cplusplus


32 
kexpr_t
 *
ke_parse
(const char *
_s
, int *
err
);

35 void 
ke_destroy
(
kexpr_t
 *
ke
);

38 int 
ke_set_int
(
kexpr_t
 *
ke
, const char *
var
, 
int64_t
 
x
);

41 int 
ke_set_real
(
kexpr_t
 *
ke
, const char *
var
, double 
x
);

44 int 
ke_set_str
(
kexpr_t
 *
ke
, const char *
var
, const char *
x
);

47 int 
ke_set_real_func1
(
kexpr_t
 *
ke
, const char *
name
, double (*
func
)(double));

48 int 
ke_set_real_func2
(
kexpr_t
 *
ke
, const char *
name
, double (*
func
)(double, double));

51 int 
ke_set_default_func
(
kexpr_t
 *
ke
);

54 void 
ke_unset
(
kexpr_t
 *
e
);

57 int 
ke_eval
(const 
kexpr_t
 *
ke
, 
int64_t
 *
_i
, double *
_r
, const char **
_s
, int *
ret_type
);

58 
int64_t
 
ke_eval_int
(const 
kexpr_t
 *
ke
, int *
err
);

59 double 
ke_eval_real
(const 
kexpr_t
 *
ke
, int *
err
);

62 void 
ke_print
(const 
kexpr_t
 *
ke
);

64 #ifdef 
__cplusplus


	@deps/klib/kgraph.h

1 #ifndef 
AC_KGRAPH_H


2 #define 
	#AC_KGRAPH_H


	)

4 #include 
	~<stdint.h
>

5 #include 
	~<stdlib.h
>

6 #include 
	~"khash.h
"

7 #include 
	~"kbtree.h
"

9 typedef unsigned 
	tkgint_t
;

11 #define 
	#kgraph_t
(
name
) 
kh_
##name##
_t


	)

13 #define 
	#__KG_BASIC
(
name
, 
SCOPE
, 
vertex_t
, 
arc_t
, 
ehn
) \

14 
SCOPE
 
	`kgraph_t
(
name
) *
kg_init_
##
	`name
(void) { return 
	`kh_init
(name); } \

15 
SCOPE
 void 
kg_destroy_
##
	`name
(
	`kgraph_t
(
name
) *
g
) { \

16 
khint_t
 
k
; \

17 if (
g
 == 0) return; \

18 for (
k
 = 
	`kh_begin
(
g
); k != 
	`kh_end
(g); ++k) \

19 if (
	`kh_exist
(
g
, 
k
)) 
	`kh_destroy
(
ehn
, 
	`kh_val
(g, k).
_arc
); \

20 
	`kh_destroy
(
name
, 
g
); \

22 
SCOPE
 
vertex_t
 *
kg_get_v_
##
	`name
(
	`kgraph_t
(
name
) *
g
, 
kgint_t
 
v
) { \

23 
khint_t
 
k
 = 
	`kh_get
(
name
, 
g
, 
v
); \

24 return 
k
 == 
	`kh_end
(
g
)? 0 : &
	`kh_val
(g, k); \

26 
SCOPE
 
vertex_t
 *
kg_put_v_
##
	`name
(
	`kgraph_t
(
name
) *
g
, 
kgint_t
 
v
, int *
absent
) { \

27 
khint_t
 
k
; \

28 
k
 = 
	`kh_put
(
name
, 
g
, 
v
, 
absent
); \

29 if (*
absent
) 
	`kh_val
(
g
, 
k
).
_arc
 = 
	`kh_init
(
ehn
); \

30 return &
	`kh_val
(
g
, 
k
); \

32 
SCOPE
 void 
kg_put_a_
##
	`name
(
	`kgraph_t
(
name
) *
g
, 
kgint_t
 
vbeg
, kgint_t 
vend
, int 
dir
, 
arc_t
 **
pb
, arc_t **
pe
) { \

33 
vertex_t
 *
p
; \

34 
khint_t
 
k
; \

35 int 
absent
; \

36 
p
 = 
kg_put_v_
##
	`name
(
g
, 
vbeg
, &
absent
); \

37 
k
 = 
	`kh_put
(
ehn
, 
p
->
_arc
, 
vend
<<2|
dir
, &
absent
); \

38 *
pb
 = &
	`kh_val
(
p
->
_arc
, 
k
); \

39 
p
 = 
kg_put_v_
##
	`name
(
g
, 
vend
, &
absent
); \

40 
k
 = 
	`kh_put
(
ehn
, 
p
->
_arc
, 
vbeg
<<2|(~
dir
&3), &
absent
); \

41 *
pe
 = &
	`kh_val
(
p
->
_arc
, 
k
); \

43 
SCOPE
 
vertex_t
 *
kg_del_v_
##
	`name
(
	`kgraph_t
(
name
) *
g
, 
kgint_t
 
v
) { \

44 
khint_t
 
k
, 
k0
, 
k2
, 
k3
; \

45 
	`khash_t
(
ehn
) *
h
; \

46 
k0
 = 
k
 = 
	`kh_get
(
name
, 
g
, 
v
); \

47 if (
k
 == 
	`kh_end
(
g
)) return 0; \

48 
h
 = 
	`kh_val
(
g
, 
k
).
_arc
; \

49 for (
k
 = 
	`kh_begin
(
h
); k != 
	`kh_end
(h); ++k) \

50 if (
	`kh_exist
(
h
, 
k
)) { \

51 
k2
 = 
	`kh_get
(
name
, 
g
, 
	`kh_key
(
h
, 
k
)>>2); \

53 
k3
 = 
	`kh_get
(
ehn
, 
	`kh_val
(
g
, 
k2
).
_arc
, 
v
<<2|(~
	`kh_key
(
h
, 
k
)&3)); \

55 
	`kh_del
(
ehn
, 
	`kh_val
(
g
, 
k2
).
_arc
, 
k3
); \

57 
	`kh_destroy
(
ehn
, 
h
); \

58 
	`kh_del
(
name
, 
g
, 
k0
); \

59 return &
	`kh_val
(
g
, 
k0
); \

60 }

	)

62 #define 
	#KGRAPH_PRINT
(
name
, 
SCOPE
) \

63 
SCOPE
 void 
kg_print_
##
	`name
(
	`kgraph_t
(
name
) *
g
) { \

64 
khint_t
 
k
, 
k2
; \

65 for (
k
 = 
	`kh_begin
(
g
); k != 
	`kh_end
(g); ++k) \

66 if (
	`kh_exist
(
g
, 
k
)) { \

67 
	`printf
("v %u\n", 
	`kh_key
(
g
, 
k
)); \

68 for (
k2
 = 
	`kh_begin
(
	`kh_val
(
g
, 
k
).
_arc
); k2 != 
	`kh_end
(kh_val(g, k)._arc); ++k2) \

69 if (
	`kh_exist
(
	`kh_val
(
g
, 
k
).
_arc
, 
k2
) && 
	`kh_key
(g, k) < kh_key(kh_val(g, k)._arc, k2)>>2) \

70 
	`printf
("a %u%c%c%u\n", 
	`kh_key
(
g
, 
k
), "><"[kh_key(
	`kh_val
(g, k).
_arc
, 
k2
)>>1&1], \

71 "><"[
	`kh_key
(
	`kh_val
(
g
, 
k
).
_arc
, 
k2
)&1], kh_key(kh_val(g, k)._arc, k2)>>2); \

73 }

	)

75 #define 
	#KGRAPH_INIT
(
name
, 
SCOPE
, 
vertex_t
, 
arc_t
, 
ehn
) \

76 
	`KHASH_INIT2
(
name
, 
SCOPE
, 
kgint_t
, 
vertex_t
, 1, 
kh_int_hash_func
, 
kh_int_hash_equal
) \

77 
	`__KG_BASIC
(
name
, 
SCOPE
, 
vertex_t
, 
arc_t
, 
ehn
)

	)

	@deps/klib/khash.h

117 #ifndef 
__AC_KHASH_H


118 #define 
	#__AC_KHASH_H


	)

126 #define 
	#AC_VERSION_KHASH_H
 "0.2.8"

	)

128 #include 
	~<stdlib.h
>

129 #include 
	~<string.h
>

130 #include 
	~<limits.h
>

134 #if 
UINT_MAX
 == 0xffffffffu

135 typedef unsigned int 
	tkhint32_t
;

136 #elif 
ULONG_MAX
 == 0xffffffffu

137 typedef unsigned long 
	tkhint32_t
;

140 #if 
ULONG_MAX
 == 
ULLONG_MAX


141 typedef unsigned long 
	tkhint64_t
;

143 typedef unsigned long long 
	tkhint64_t
;

146 #ifndef 
kh_inline


147 #ifdef 
_MSC_VER


148 #define 
	#kh_inline
 
__inline


	)

150 #define 
	#kh_inline
 
inline


	)

154 #ifndef 
klib_unused


155 #if (
defined
 
__clang__
 && 
__clang_major__
 >= 3) || (defined 
__GNUC__
 && __GNUC__ >= 3)

156 #define 
	#klib_unused
 
	`__attribute__
 ((
__unused__
))

	)

158 #define 
	#klib_unused


	)

162 typedef 
khint32_t
 
	tkhint_t
;

163 typedef 
khint_t
 
	tkhiter_t
;

165 #define 
	#__ac_isempty
(
flag
, 
i
) ((flag[i>>4]>>((i&0xfU)<<1))&2)

	)

166 #define 
	#__ac_isdel
(
flag
, 
i
) ((flag[i>>4]>>((i&0xfU)<<1))&1)

	)

167 #define 
	#__ac_iseither
(
flag
, 
i
) ((flag[i>>4]>>((i&0xfU)<<1))&3)

	)

168 #define 
	#__ac_set_isdel_false
(
flag
, 
i
) (flag[i>>4]&=~(1ul<<((i&0xfU)<<1)))

	)

169 #define 
	#__ac_set_isempty_false
(
flag
, 
i
) (flag[i>>4]&=~(2ul<<((i&0xfU)<<1)))

	)

170 #define 
	#__ac_set_isboth_false
(
flag
, 
i
) (flag[i>>4]&=~(3ul<<((i&0xfU)<<1)))

	)

171 #define 
	#__ac_set_isdel_true
(
flag
, 
i
) (flag[i>>4]|=1ul<<((i&0xfU)<<1))

	)

173 #define 
	#__ac_fsize
(
m
) ((m) < 16? 1 : (m)>>4)

	)

175 #ifndef 
kroundup32


176 #define 
	#kroundup32
(
x
) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

	)

179 #ifndef 
kcalloc


180 #define 
	#kcalloc
(
N
,
Z
) 
	`calloc
(N,Z)

	)

182 #ifndef 
kmalloc


183 #define 
	#kmalloc
(
Z
) 
	`malloc
(Z)

	)

185 #ifndef 
krealloc


186 #define 
	#krealloc
(
P
,
Z
) 
	`realloc
(P,Z)

	)

188 #ifndef 
kfree


189 #define 
	#kfree
(
P
) 
	`free
(P)

	)

192 static const double 
	g__ac_HASH_UPPER
 = 0.77;

194 #define 
	#__KHASH_TYPE
(
name
, 
khkey_t
, 
khval_t
) \

195 typedef struct 
kh_
##
	tname
##
	t_s
 { \

196 
khint_t
 
n_buckets
, 
size
, 
n_occupied
, 
upper_bound
; \

197 
khint32_t
 *
flags
; \

198 
khkey_t
 *
keys
; \

199 
khval_t
 *
vals
; \

200 } 
	tkh_
##
	tname
##
	t_t
;

	)

202 #define 
	#__KHASH_PROTOTYPES
(
name
, 
khkey_t
, 
khval_t
) \

203 extern 
kh_
##
name
##
_t
 *
kh_init_
##
	`name
(void); \

204 extern void 
kh_destroy_
##
	`name
(
kh_
##
name
##
_t
 *
h
); \

205 extern void 
kh_clear_
##
	`name
(
kh_
##
name
##
_t
 *
h
); \

206 extern 
khint_t
 
kh_get_
##
	`name
(const 
kh_
##
name
##
_t
 *
h
, 
khkey_t
 
key
); \

207 extern int 
kh_resize_
##
	`name
(
kh_
##
name
##
_t
 *
h
, 
khint_t
 
new_n_buckets
); \

208 extern 
khint_t
 
kh_put_
##
	`name
(
kh_
##
name
##
_t
 *
h
, 
khkey_t
 
key
, int *
ret
); \

209 extern void 
kh_del_
##
	`name
(
kh_
##
name
##
_t
 *
h
, 
khint_t
 
x
);

	)

211 #define 
	#__KHASH_IMPL
(
name
, 
SCOPE
, 
khkey_t
, 
khval_t
, 
kh_is_map
, 
__hash_func
, 
__hash_equal
) \

212 
SCOPE
 
kh_
##
name
##
_t
 *
kh_init_
##
	`name
(void) { \

213 return (
kh_
##
name
##
_t
*)
	`kcalloc
(1, sizeof(kh_##name##_t)); \

215 
SCOPE
 void 
kh_destroy_
##
	`name
(
kh_
##
name
##
_t
 *
h
) \

217 if (
h
) { \

218 
	`kfree
((void *)
h
->
keys
); kfree(h->
flags
); \

219 
	`kfree
((void *)
h
->
vals
); \

220 
	`kfree
(
h
); \

223 
SCOPE
 void 
kh_clear_
##
	`name
(
kh_
##
name
##
_t
 *
h
) \

225 if (
h
 && h->
flags
) { \

226 
	`memset
(
h
->
flags
, 0xaa, 
	`__ac_fsize
(h->
n_buckets
) * sizeof(
khint32_t
)); \

227 
h
->
size
 = h->
n_occupied
 = 0; \

230 
SCOPE
 
khint_t
 
kh_get_
##
	`name
(const 
kh_
##
name
##
_t
 *
h
, 
khkey_t
 
key
) \

232 if (
h
->
n_buckets
) { \

233 
khint_t
 
k
, 
i
, 
last
, 
mask
, 
step
 = 0; \

234 
mask
 = 
h
->
n_buckets
 - 1; \

235 
k
 = 
	`__hash_func
(
key
); 
i
 = k & 
mask
; \

236 
last
 = 
i
; \

237 while (!
	`__ac_isempty
(
h
->
flags
, 
i
) && (
	`__ac_isdel
(h->flags, i) || !
	`__hash_equal
(h->
keys
[i], 
key
))) { \

238 
i
 = (i + (++
step
)) & 
mask
; \

239 if (
i
 == 
last
) return 
h
->
n_buckets
; \

241 return 
	`__ac_iseither
(
h
->
flags
, 
i
)? h->
n_buckets
 : i; \

244 
SCOPE
 int 
kh_resize_
##
	`name
(
kh_
##
name
##
_t
 *
h
, 
khint_t
 
new_n_buckets
) \

246 
khint32_t
 *
new_flags
 = 0; \

247 
khint_t
 
j
 = 1; \

249 
	`kroundup32
(
new_n_buckets
); \

250 if (
new_n_buckets
 < 4) new_n_buckets = 4; \

251 if (
h
->
size
 >= (
khint_t
)(
new_n_buckets
 * 
__ac_HASH_UPPER
 + 0.5)) 
j
 = 0; \

253 
new_flags
 = (
khint32_t
*)
	`kmalloc
(
	`__ac_fsize
(
new_n_buckets
) * sizeof(khint32_t)); \

254 if (!
new_flags
) return -1; \

255 
	`memset
(
new_flags
, 0xaa, 
	`__ac_fsize
(
new_n_buckets
) * sizeof(
khint32_t
)); \

256 if (
h
->
n_buckets
 < 
new_n_buckets
) { \

257 
khkey_t
 *
new_keys
 = (khkey_t*)
	`krealloc
((void *)
h
->
keys
, 
new_n_buckets
 * sizeof(khkey_t)); \

258 if (!
new_keys
) { 
	`kfree
(
new_flags
); return -1; } \

259 
h
->
keys
 = 
new_keys
; \

260 if (
kh_is_map
) { \

261 
khval_t
 *
new_vals
 = (khval_t*)
	`krealloc
((void *)
h
->
vals
, 
new_n_buckets
 * sizeof(khval_t)); \

262 if (!
new_vals
) { 
	`kfree
(
new_flags
); return -1; } \

263 
h
->
vals
 = 
new_vals
; \

268 if (
j
) { \

269 for (
j
 = 0; j != 
h
->
n_buckets
; ++j) { \

270 if (
	`__ac_iseither
(
h
->
flags
, 
j
) == 0) { \

271 
khkey_t
 
key
 = 
h
->
keys
[
j
]; \

272 
khval_t
 
val
; \

273 
khint_t
 
new_mask
; \

274 
new_mask
 = 
new_n_buckets
 - 1; \

275 if (
kh_is_map
) 
val
 = 
h
->
vals
[
j
]; \

276 
	`__ac_set_isdel_true
(
h
->
flags
, 
j
); \

278 
khint_t
 
k
, 
i
, 
step
 = 0; \

279 
k
 = 
	`__hash_func
(
key
); \

280 
i
 = 
k
 & 
new_mask
; \

281 while (!
	`__ac_isempty
(
new_flags
, 
i
)) i = (i + (++
step
)) & 
new_mask
; \

282 
	`__ac_set_isempty_false
(
new_flags
, 
i
); \

283 if (
i
 < 
h
->
n_buckets
 && 
	`__ac_iseither
(h->
flags
, i) == 0) { \

284 { 
khkey_t
 
tmp
 = 
h
->
keys
[
i
]; h->keys[i] = 
key
; key = tmp; } \

285 if (
kh_is_map
) { 
khval_t
 
tmp
 = 
h
->
vals
[
i
]; h->vals[i] = 
val
; val = tmp; } \

286 
	`__ac_set_isdel_true
(
h
->
flags
, 
i
); \

288 
h
->
keys
[
i
] = 
key
; \

289 if (
kh_is_map
) 
h
->
vals
[
i
] = 
val
; \

295 if (
h
->
n_buckets
 > 
new_n_buckets
) { \

296 
h
->
keys
 = (
khkey_t
*)
	`krealloc
((void *)h->keys, 
new_n_buckets
 * sizeof(khkey_t)); \

297 if (
kh_is_map
) 
h
->
vals
 = (
khval_t
*)
	`krealloc
((void *)h->vals, 
new_n_buckets
 * sizeof(khval_t)); \

299 
	`kfree
(
h
->
flags
); \

300 
h
->
flags
 = 
new_flags
; \

301 
h
->
n_buckets
 = 
new_n_buckets
; \

302 
h
->
n_occupied
 = h->
size
; \

303 
h
->
upper_bound
 = (
khint_t
)(h->
n_buckets
 * 
__ac_HASH_UPPER
 + 0.5); \

307 
SCOPE
 
khint_t
 
kh_put_
##
	`name
(
kh_
##
name
##
_t
 *
h
, 
khkey_t
 
key
, int *
ret
) \

309 
khint_t
 
x
; \

310 if (
h
->
n_occupied
 >= h->
upper_bound
) { \

311 if (
h
->
n_buckets
 > (h->
size
<<1)) { \

312 if (
kh_resize_
##
	`name
(
h
, h->
n_buckets
 - 1) < 0) { \

313 *
ret
 = -1; return 
h
->
n_buckets
; \

315 } else if (
kh_resize_
##
	`name
(
h
, h->
n_buckets
 + 1) < 0) { \

316 *
ret
 = -1; return 
h
->
n_buckets
; \

320 
khint_t
 
k
, 
i
, 
site
, 
last
, 
mask
 = 
h
->
n_buckets
 - 1, 
step
 = 0; \

321 
x
 = 
site
 = 
h
->
n_buckets
; 
k
 = 
	`__hash_func
(
key
); 
i
 = k & 
mask
; \

322 if (
	`__ac_isempty
(
h
->
flags
, 
i
)) 
x
 = i; \

324 
last
 = 
i
; \

325 while (!
	`__ac_isempty
(
h
->
flags
, 
i
) && (
	`__ac_isdel
(h->flags, i) || !
	`__hash_equal
(h->
keys
[i], 
key
))) { \

326 if (
	`__ac_isdel
(
h
->
flags
, 
i
)) 
site
 = i; \

327 
i
 = (i + (++
step
)) & 
mask
; \

328 if (
i
 == 
last
) { 
x
 = 
site
; break; } \

330 if (
x
 == 
h
->
n_buckets
) { \

331 if (
	`__ac_isempty
(
h
->
flags
, 
i
) && 
site
 != h->
n_buckets
) 
x
 = site; \

332 else 
x
 = 
i
; \

336 if (
	`__ac_isempty
(
h
->
flags
, 
x
)) { \

337 
h
->
keys
[
x
] = 
key
; \

338 
	`__ac_set_isboth_false
(
h
->
flags
, 
x
); \

339 ++
h
->
size
; ++h->
n_occupied
; \

340 *
ret
 = 1; \

341 } else if (
	`__ac_isdel
(
h
->
flags
, 
x
)) { \

342 
h
->
keys
[
x
] = 
key
; \

343 
	`__ac_set_isboth_false
(
h
->
flags
, 
x
); \

344 ++
h
->
size
; \

345 *
ret
 = 2; \

346 } else *
ret
 = 0; \

347 return 
x
; \

349 
SCOPE
 void 
kh_del_
##
	`name
(
kh_
##
name
##
_t
 *
h
, 
khint_t
 
x
) \

351 if (
x
 != 
h
->
n_buckets
 && !
	`__ac_iseither
(h->
flags
, x)) { \

352 
	`__ac_set_isdel_true
(
h
->
flags
, 
x
); \

353 --
h
->
size
; \

355 }

	)

357 #define 
	#KHASH_DECLARE
(
name
, 
khkey_t
, 
khval_t
) \

358 
	`__KHASH_TYPE
(
name
, 
khkey_t
, 
khval_t
) \

359 
	`__KHASH_PROTOTYPES
(
name
, 
khkey_t
, 
khval_t
)

	)

361 #define 
	#KHASH_INIT2
(
name
, 
SCOPE
, 
khkey_t
, 
khval_t
, 
kh_is_map
, 
__hash_func
, 
__hash_equal
) \

362 
	`__KHASH_TYPE
(
name
, 
khkey_t
, 
khval_t
) \

363 
	`__KHASH_IMPL
(
name
, 
SCOPE
, 
khkey_t
, 
khval_t
, 
kh_is_map
, 
__hash_func
, 
__hash_equal
)

	)

365 #define 
	#KHASH_INIT
(
name
, 
khkey_t
, 
khval_t
, 
kh_is_map
, 
__hash_func
, 
__hash_equal
) \

366 
	`KHASH_INIT2
(
name
, static 
kh_inline
 
klib_unused
, 
khkey_t
, 
khval_t
, 
kh_is_map
, 
__hash_func
, 
__hash_equal
)

	)

375 #define 
	#kh_int_hash_func
(
key
) (
khint32_t
)(key)

	)

379 #define 
	#kh_int_hash_equal
(
a
, 
b
) ((a) == (b))

	)

385 #define 
	#kh_int64_hash_func
(
key
) (
khint32_t
)((key)>>33^(key)^(key)<<11)

	)

389 #define 
	#kh_int64_hash_equal
(
a
, 
b
) ((a) == (b))

	)

395 static 
kh_inline
 
khint_t
 
	$__ac_X31_hash_string
(const char *
s
)

397 
khint_t
 
h
 = (khint_t)*
s
;

398 if (
h
) for (++
s
 ; *s; ++s) h = (h << 5) - h + (
khint_t
)*s;

399 return 
h
;

400 
	}
}

406 #define 
	#kh_str_hash_func
(
key
) 
	`__ac_X31_hash_string
(key)

	)

410 #define 
	#kh_str_hash_equal
(
a
, 
b
) (
	`strcmp
(a, b) == 0)

	)

412 static 
kh_inline
 
khint_t
 
	$__ac_Wang_hash
(
khint_t
 
key
)

414 
key
 += ~(key << 15);

415 
key
 ^= (key >> 10);

416 
key
 += (key << 3);

417 
key
 ^= (key >> 6);

418 
key
 += ~(key << 11);

419 
key
 ^= (key >> 16);

420 return 
key
;

421 
	}
}

422 #define 
	#kh_int_hash_func2
(
key
) 
	`__ac_Wang_hash
((
khint_t
)key)

	)

432 #define 
	#khash_t
(
name
) 
kh_
##name##
_t


	)

439 #define 
	#kh_init
(
name
) 
kh_init_
##
	`name
()

	)

446 #define 
	#kh_destroy
(
name
, 
h
) 
kh_destroy_
##
	`name
(h)

	)

453 #define 
	#kh_clear
(
name
, 
h
) 
kh_clear_
##
	`name
(h)

	)

461 #define 
	#kh_resize
(
name
, 
h
, 
s
) 
kh_resize_
##
	`name
(h, s)

	)

474 #define 
	#kh_put
(
name
, 
h
, 
k
, 
r
) 
kh_put_
##
	`name
(h, k, r)

	)

483 #define 
	#kh_get
(
name
, 
h
, 
k
) 
kh_get_
##
	`name
(h, k)

	)

491 #define 
	#kh_del
(
name
, 
h
, 
k
) 
kh_del_
##
	`name
(h, k)

	)

499 #define 
	#kh_exist
(
h
, 
x
) (!
	`__ac_iseither
((h)->
flags
, (x)))

	)

507 #define 
	#kh_key
(
h
, 
x
) ((h)->
keys
[x])

	)

516 #define 
	#kh_val
(
h
, 
x
) ((h)->
vals
[x])

	)

521 #define 
	#kh_value
(
h
, 
x
) ((h)->
vals
[x])

	)

528 #define 
	#kh_begin
(
h
) (
khint_t
)(0)

	)

535 #define 
	#kh_end
(
h
) ((h)->
n_buckets
)

	)

542 #define 
	#kh_size
(
h
) ((h)->
size
)

	)

549 #define 
	#kh_n_buckets
(
h
) ((h)->
n_buckets
)

	)

558 #define 
	#kh_foreach
(
h
, 
kvar
, 
vvar
, 
code
) { 
khint_t
 
__i
; \

559 for (
__i
 = 
	`kh_begin
(
h
); __i != 
	`kh_end
(h); ++__i) { \

560 if (!
	`kh_exist
(
h
,
__i
)) continue; \

561 (
kvar
) = 
	`kh_key
(
h
,
__i
); \

562 (
vvar
) = 
	`kh_val
(
h
,
__i
); \

563 
code
; \

564 } }

	)

572 #define 
	#kh_foreach_value
(
h
, 
vvar
, 
code
) { 
khint_t
 
__i
; \

573 for (
__i
 = 
	`kh_begin
(
h
); __i != 
	`kh_end
(h); ++__i) { \

574 if (!
	`kh_exist
(
h
,
__i
)) continue; \

575 (
vvar
) = 
	`kh_val
(
h
,
__i
); \

576 
code
; \

577 } }

	)

585 #define 
	#KHASH_SET_INIT_INT
(
name
) \

586 
	`KHASH_INIT
(
name
, 
khint32_t
, char, 0, 
kh_int_hash_func
, 
kh_int_hash_equal
)

	)

593 #define 
	#KHASH_MAP_INIT_INT
(
name
, 
khval_t
) \

594 
	`KHASH_INIT
(
name
, 
khint32_t
, 
khval_t
, 1, 
kh_int_hash_func
, 
kh_int_hash_equal
)

	)

600 #define 
	#KHASH_SET_INIT_INT64
(
name
) \

601 
	`KHASH_INIT
(
name
, 
khint64_t
, char, 0, 
kh_int64_hash_func
, 
kh_int64_hash_equal
)

	)

608 #define 
	#KHASH_MAP_INIT_INT64
(
name
, 
khval_t
) \

609 
	`KHASH_INIT
(
name
, 
khint64_t
, 
khval_t
, 1, 
kh_int64_hash_func
, 
kh_int64_hash_equal
)

	)

611 typedef const char *
	tkh_cstr_t
;

616 #define 
	#KHASH_SET_INIT_STR
(
name
) \

617 
	`KHASH_INIT
(
name
, 
kh_cstr_t
, char, 0, 
kh_str_hash_func
, 
kh_str_hash_equal
)

	)

624 #define 
	#KHASH_MAP_INIT_STR
(
name
, 
khval_t
) \

625 
	`KHASH_INIT
(
name
, 
kh_cstr_t
, 
khval_t
, 1, 
kh_str_hash_func
, 
kh_str_hash_equal
)

	)

	@deps/klib/khmm.c

1 #include 
	~<math.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<assert.h
>

4 #include 
	~<string.h
>

5 #include 
	~<stdlib.h
>

6 #include 
	~"khmm.h
"

10 
hmm_par_t
 *
	$hmm_new_par
(int 
m
, int 
n
)

12 
hmm_par_t
 *
hp
;

13 int 
i
;

14 
	`assert
(
m
 > 0 && 
n
 > 0);

15 
hp
 = (
hmm_par_t
*)
	`calloc
(1, sizeof(hmm_par_t));

16 
hp
->
m
 = m; hp->
n
 = n;

17 
hp
->
a0
 = (
FLOAT
*)
	`calloc
(
n
, sizeof(FLOAT));

18 
hp
->
a
 = (
FLOAT
**)
	`calloc2
(
n
, n, sizeof(FLOAT));

19 
hp
->
e
 = (
FLOAT
**)
	`calloc2
(
m
 + 1, 
n
, sizeof(FLOAT));

20 
hp
->
ae
 = (
FLOAT
**)
	`calloc2
((
m
 + 1) * 
n
, n, sizeof(FLOAT));

21 for (
i
 = 0; i != 
n
; ++i) 
hp
->
e
[
m
][i] = 1.0;

22 return 
hp
;

23 
	}
}

24 void 
	$hmm_delete_par
(
hmm_par_t
 *
hp
)

26 int 
i
;

27 if (
hp
 == 0) return;

28 for (
i
 = 0; i != 
hp
->
n
; ++i) 
	`free
(hp->
a
[i]);

29 for (
i
 = 0; i <= 
hp
->
m
; ++i) 
	`free
(hp->
e
[i]);

30 for (
i
 = 0; i < (
hp
->
m
 + 1) * hp->
n
; ++i) 
	`free
(hp->
ae
[i]);

31 
	`free
(
hp
->
a
); free(hp->
e
); free(hp->
a0
); free(hp->
ae
);

32 
	`free
(
hp
);

33 
	}
}

37 
hmm_data_t
 *
	$hmm_new_data
(int 
L
, const char *
seq
, const 
hmm_par_t
 *
hp
)

39 
hmm_data_t
 *
hd
;

40 
hd
 = (
hmm_data_t
*)
	`calloc
(1, sizeof(hmm_data_t));

41 
hd
->
L
 = L;

42 
hd
->
seq
 = (char*)
	`malloc
(
L
 + 1);

43 
	`memcpy
(
hd
->
seq
 + 1, seq, 
L
);

44 return 
hd
;

45 
	}
}

46 void 
	$hmm_delete_data
(
hmm_data_t
 *
hd
)

48 int 
i
;

49 if (
hd
 == 0) return;

50 for (
i
 = 0; i <= 
hd
->
L
; ++i) {

51 if (
hd
->
f
) 
	`free
(hd->f[
i
]);

52 if (
hd
->
b
) 
	`free
(hd->b[
i
]);

54 
	`free
(
hd
->
f
); free(hd->
b
); free(hd->
s
); free(hd->
v
); free(hd->
p
); free(hd->
seq
);

55 
	`free
(
hd
);

56 
	}
}

60 
hmm_exp_t
 *
	$hmm_new_exp
(const 
hmm_par_t
 *
hp
)

62 
hmm_exp_t
 *
he
;

63 
	`assert
(
hp
);

64 
he
 = (
hmm_exp_t
*)
	`calloc
(1, sizeof(hmm_exp_t));

65 
he
->
m
 = 
hp
->m; he->
n
 = hp->n;

66 
he
->
A0
 = (
FLOAT
*)
	`calloc
(
hp
->
n
, sizeof(FLOAT));

67 
he
->
A
 = (
FLOAT
**)
	`calloc2
(
hp
->
n
, hp->n, sizeof(FLOAT));

68 
he
->
E
 = (
FLOAT
**)
	`calloc2
(
hp
->
m
 + 1, hp->
n
, sizeof(FLOAT));

69 return 
he
;

70 
	}
}

71 void 
	$hmm_delete_exp
(
hmm_exp_t
 *
he
)

73 int 
i
;

74 if (
he
 == 0) return;

75 for (
i
 = 0; i != 
he
->
n
; ++i) 
	`free
(he->
A
[i]);

76 for (
i
 = 0; i <= 
he
->
m
; ++i) 
	`free
(he->
E
[i]);

77 
	`free
(
he
->
A
); free(he->
E
); free(he->
A0
);

78 
	`free
(
he
);

79 
	}
}

83 
FLOAT
 
	$hmm_Viterbi
(const 
hmm_par_t
 *
hp
, 
hmm_data_t
 *
hd
)

85 
FLOAT
 **
la
, **
le
, *
preV
, *
curV
, 
max
;

86 int **
Vmax
, 
max_l
;

87 int 
k
, 
l
, 
b
, 
u
;

89 if (
hd
->
v
) 
	`free
(hd->v);

90 
hd
->
v
 = (int*)
	`calloc
(hd->
L
+1, sizeof(int));

91 
la
 = (
FLOAT
**)
	`calloc2
(
hp
->
n
, hp->n, sizeof(FLOAT));

92 
le
 = (
FLOAT
**)
	`calloc2
(
hp
->
m
 + 1, hp->
n
, sizeof(FLOAT));

93 
Vmax
 = (int**)
	`calloc2
(
hd
->
L
+1, 
hp
->
n
, sizeof(int));

94 
preV
 = (
FLOAT
*)
	`malloc
(sizeof(FLOAT) * 
hp
->
n
);

95 
curV
 = (
FLOAT
*)
	`malloc
(sizeof(FLOAT) * 
hp
->
n
);

96 for (
k
 = 0; k != 
hp
->
n
; ++k)

97 for (
l
 = 0; l != 
hp
->
n
; ++l)

98 
la
[
k
][
l
] = 
	`log
(
hp
->
a
[l][k]);

99 for (
b
 = 0; b != 
hp
->
m
; ++b)

100 for (
k
 = 0; k != 
hp
->
n
; ++k)

101 
le
[
b
][
k
] = 
	`log
(
hp
->
e
[b][k]);

102 for (
k
 = 0; k != 
hp
->
n
; ++k) 
le
[hp->
m
][k] = 0.0;

104 for (
k
 = 0; k != 
hp
->
n
; ++k) {

105 
preV
[
k
] = 
le
[(int)
hd
->
seq
[1]][k] + 
	`log
(
hp
->
a0
[k]);

106 
Vmax
[1][
k
] = 0;

109 for (
u
 = 2; u <= 
hd
->
L
; ++u) {

110 
FLOAT
 *
tmp
, *
leu
 = 
le
[(int)
hd
->
seq
[
u
]];

111 for (
k
 = 0; k != 
hp
->
n
; ++k) {

112 
FLOAT
 *
laa
 = 
la
[
k
];

113 for (
l
 = 0, 
max
 = -
HMM_INF
, 
max_l
 = -1; l != 
hp
->
n
; ++l) {

114 if (
max
 < 
preV
[
l
] + 
laa
[l]) {

115 
max
 = 
preV
[
l
] + 
laa
[l];

116 
max_l
 = 
l
;

119 
	`assert
(
max_l
 >= 0);

120 
curV
[
k
] = 
leu
[k] + 
max
;

121 
Vmax
[
u
][
k
] = 
max_l
;

123 
tmp
 = 
curV
; curV = 
preV
; preV = tmp;

126 for (
k
 = 0, 
max_l
 = -1, 
max
 = -
HMM_INF
; k != 
hp
->
n
; ++k) {

127 if (
max
 < 
preV
[
k
]) {

128 
max
 = 
preV
[
k
]; 
max_l
 = k;

131 
	`assert
(
max_l
 >= 0);

132 
hd
->
v
[hd->
L
] = 
max_l
;

133 for (
u
 = 
hd
->
L
; u >= 1; --u)

134 
hd
->
v
[
u
-1] = 
Vmax
[u][hd->v[u]];

135 for (
k
 = 0; k != 
hp
->
n
; ++k) 
	`free
(
la
[k]);

136 for (
b
 = 0; b < 
hp
->
m
; ++b) 
	`free
(
le
[b]);

137 for (
u
 = 0; u <= 
hd
->
L
; ++u) 
	`free
(
Vmax
[u]);

138 
	`free
(
la
); free(
le
); free(
Vmax
); free(
preV
); free(
curV
);

139 
hd
->
status
 |= 
HMM_VITERBI
;

140 return 
max
;

141 
	}
}

145 void 
	$hmm_forward
(const 
hmm_par_t
 *
hp
, 
hmm_data_t
 *
hd
)

147 
FLOAT
 
sum
, 
tmp
, **
at
;

148 int 
u
, 
k
, 
l
;

149 int 
n
, 
m
, 
L
;

150 
	`assert
(
hp
 && 
hd
);

152 
n
 = 
hp
->n; 
m
 = hp->m; 
L
 = 
hd
->L;

153 if (
hd
->
s
) 
	`free
(hd->s);

154 if (
hd
->
f
) {

155 for (
k
 = 0; k <= 
hd
->
L
; ++k) 
	`free
(hd->
f
[k]);

156 
	`free
(
hd
->
f
);

158 
hd
->
f
 = (
FLOAT
**)
	`calloc2
(hd->
L
+1, 
hp
->
n
, sizeof(FLOAT));

159 
hd
->
s
 = (
FLOAT
*)
	`calloc
(hd->
L
+1, sizeof(FLOAT));

160 
hd
->
status
 &= ~(unsigned)
HMM_FORWARD
;

162 
at
 = (
FLOAT
**)
	`calloc2
(
n
, n, sizeof(FLOAT));

164 for (
k
 = 0; k != 
n
; ++k)

165 for (
l
 = 0; l != 
n
; ++l)

166 
at
[
k
][
l
] = 
hp
->
a
[l][k];

168 
hd
->
s
[0] = 1.0;

169 for (
k
 = 0; k != 
n
; ++k) 
hd
->
f
[0][k] = 0.0;

171 for (
k
 = 0, 
sum
 = 0.0; k != 
n
; ++k)

172 
sum
 += (
hd
->
f
[1][
k
] = 
hp
->
a0
[k] * hp->
e
[(int)hd->
seq
[1]][k]);

173 for (
k
 = 0; k != 
n
; ++k) 
hd
->
f
[1][k] /= 
sum
;

174 
hd
->
s
[1] = 
sum
;

176 for (
u
 = 2; u <= 
L
; ++u) {

177 
FLOAT
 *
fu
 = 
hd
->
f
[
u
], *
fu1
 = hd->f[u-1], *
eu
 = 
hp
->
e
[(int)hd->
seq
[u]];

178 for (
k
 = 0, 
sum
 = 0.0; k != 
n
; ++k) {

179 
FLOAT
 *
aa
 = 
at
[
k
];

180 for (
l
 = 0, 
tmp
 = 0.0; l != 
n
; ++l) tmp += 
fu1
[l] * 
aa
[l];

181 
sum
 += (
fu
[
k
] = 
eu
[k] * 
tmp
);

183 for (
k
 = 0; k != 
n
; ++k) 
fu
[k] /= 
sum
;

184 
hd
->
s
[
u
] = 
sum
;

187 for (
k
 = 0; k != 
hp
->
n
; ++k) 
	`free
(
at
[k]);

188 
	`free
(
at
);

189 
hd
->
status
 |= 
HMM_FORWARD
;

190 
	}
}

194 void 
	$hmm_pre_backward
(
hmm_par_t
 *
hp
)

196 int 
m
, 
n
, 
b
, 
k
, 
l
;

197 
	`assert
(
hp
);

198 
m
 = 
hp
->m; 
n
 = hp->n;

199 for (
b
 = 0; b <= 
m
; ++b) {

200 for (
k
 = 0; k != 
n
; ++k) {

201 
FLOAT
 *
p
 = 
hp
->
ae
[
b
 * hp->
n
 + 
k
];

202 for (
l
 = 0; l != 
n
; ++l)

203 
p
[
l
] = 
hp
->
e
[
b
][l] * hp->
a
[
k
][l];

206 
	}
}

210 void 
	$hmm_backward
(const 
hmm_par_t
 *
hp
, 
hmm_data_t
 *
hd
)

212 
FLOAT
 
tmp
;

213 int 
k
, 
l
, 
u
;

214 int 
m
, 
n
, 
L
;

215 
	`assert
(
hp
 && 
hd
);

216 
	`assert
(
hd
->
status
 & 
HMM_FORWARD
);

218 
m
 = 
hp
->m; 
n
 = hp->n; 
L
 = 
hd
->L;

219 if (
hd
->
b
) {

220 for (
k
 = 0; k <= 
hd
->
L
; ++k) 
	`free
(hd->
b
[k]);

221 
	`free
(
hd
->
b
);

223 
hd
->
status
 &= ~(unsigned)
HMM_BACKWARD
;

224 
hd
->
b
 = (
FLOAT
**)
	`calloc2
(
L
+1, 
hp
->
n
, sizeof(FLOAT));

226 for (
k
 = 0; k != 
hp
->
n
; ++k) 
hd
->
b
[
L
][k] = 1.0 / hd->
s
[L];

228 for (
u
 = 
L
-1; u >= 1; --u) {

229 
FLOAT
 *
bu1
 = 
hd
->
b
[
u
+1], **
p
 = 
hp
->
ae
 + (int)hd->
seq
[u+1] * 
n
;

230 for (
k
 = 0; k != 
n
; ++k) {

231 
FLOAT
 *
q
 = 
p
[
k
];

232 for (
l
 = 0, 
tmp
 = 0.0; l != 
n
; ++l) tmp += 
q
[l] * 
bu1
[l];

233 
hd
->
b
[
u
][
k
] = 
tmp
 / hd->
s
[u];

236 
hd
->
status
 |= 
HMM_BACKWARD
;

237 for (
l
 = 0, 
tmp
 = 0.0; l != 
n
; ++l)

238 
tmp
 += 
hp
->
a0
[
l
] * 
hd
->
b
[1][l] * hp->
e
[(int)hd->
seq
[1]][l];

239 if (
tmp
 > 1.0 + 1e-6 || tmp < 1.0 - 1e-6)

240 
	`fprintf
(
stderr
, "++ Underflow may have happened (%lg).\n", 
tmp
);

241 
	}
}

245 
FLOAT
 
	$hmm_lk
(const 
hmm_data_t
 *
hd
)

247 
FLOAT
 
sum
 = 0.0, 
prod
 = 1.0;

248 int 
u
, 
L
;

249 
L
 = 
hd
->L;

250 
	`assert
(
hd
->
status
 & 
HMM_FORWARD
);

251 for (
u
 = 1; u <= 
L
; ++u) {

252 
prod
 *= 
hd
->
s
[
u
];

253 if (
prod
 < 
HMM_TINY
 || prod >= 1.0/HMM_TINY) {

254 
sum
 += 
	`log
(
prod
);

255 
prod
 = 1.0;

258 
sum
 += 
	`log
(
prod
);

259 return 
sum
;

260 
	}
}

264 void 
	$hmm_post_decode
(const 
hmm_par_t
 *
hp
, 
hmm_data_t
 *
hd
)

266 int 
u
, 
k
;

267 
	`assert
(
hd
->
status
 && 
HMM_BACKWARD
);

268 if (
hd
->
p
) 
	`free
(hd->p);

269 
hd
->
p
 = (int*)
	`calloc
(hd->
L
 + 1, sizeof(int));

270 for (
u
 = 1; u <= 
hd
->
L
; ++u) {

271 
FLOAT
 
prob
, 
max
, *
fu
 = 
hd
->
f
[
u
], *
bu
 = hd->
b
[u], 
su
 = hd->
s
[u];

272 int 
max_k
;

273 for (
k
 = 0, 
max
 = -1.0, 
max_k
 = -1; k != 
hp
->
n
; ++k) {

274 if (
max
 < (
prob
 = 
fu
[
k
] * 
bu
[k] * 
su
)) {

275 
max
 = 
prob
; 
max_k
 = 
k
;

278 
	`assert
(
max_k
 >= 0);

279 
hd
->
p
[
u
] = 
max_k
;

281 
hd
->
status
 |= 
HMM_POSTDEC
;

282 
	}
}

286 
FLOAT
 
	$hmm_post_state
(const 
hmm_par_t
 *
hp
, const 
hmm_data_t
 *
hd
, int 
u
, 
FLOAT
 *
prob
)

288 
FLOAT
 
sum
 = 0.0, 
ss
 = 
hd
->
s
[
u
], *
fu
 = hd->
f
[u], *
bu
 = hd->
b
[u];

289 int 
k
;

290 for (
k
 = 0; k != 
hp
->
n
; ++k)

291 
sum
 += (
prob
[
k
] = 
fu
[k] * 
bu
[k] * 
ss
);

292 return 
sum
;

293 
	}
}

297 
hmm_exp_t
 *
	$hmm_expect
(const 
hmm_par_t
 *
hp
, const 
hmm_data_t
 *
hd
)

299 int 
k
, 
l
, 
u
, 
b
, 
m
, 
n
;

300 
hmm_exp_t
 *
he
;

301 
	`assert
(
hd
->
status
 & 
HMM_BACKWARD
);

302 
he
 = 
	`hmm_new_exp
(
hp
);

304 
m
 = 
hp
->m; 
n
 = hp->n;

305 for (
k
 = 0; k != 
n
; ++k)

306 for (
l
 = 0; l != 
n
; ++l) 
he
->
A
[
k
][l] = 
HMM_TINY
;

307 for (
b
 = 0; b <= 
m
; ++b)

308 for (
l
 = 0; l != 
n
; ++l) 
he
->
E
[
b
][l] = 
HMM_TINY
;

310 for (
u
 = 1; u < 
hd
->
L
; ++u) {

311 
FLOAT
 *
fu
 = 
hd
->
f
[
u
], *
bu
 = hd->
b
[u], *
bu1
 = hd->b[u+1], 
ss
 = hd->
s
[u];

312 
FLOAT
 *
Ec
 = 
he
->
E
[(int)
hd
->
seq
[
u
]], **
p
 = 
hp
->
ae
 + (int)hd->seq[u+1] * 
n
;

313 for (
k
 = 0; k != 
n
; ++k) {

314 
FLOAT
 *
q
 = 
p
[
k
], *
AA
 = 
he
->
A
[k], 
fuk
 = 
fu
[k];

315 for (
l
 = 0; l != 
n
; ++l)

316 
AA
[
l
] += 
fuk
 * 
q
[l] * 
bu1
[l];

317 
Ec
[
k
] += 
fuk
 * 
bu
[k] * 
ss
;

321 for (
l
 = 0; l != 
n
; ++l)

322 
he
->
A0
[
l
] += 
hp
->
a0
[l] * hp->
e
[(int)
hd
->
seq
[1]][l] * hd->
b
[1][l];

323 return 
he
;

324 
	}
}

326 
FLOAT
 
	$hmm_Q0
(const 
hmm_par_t
 *
hp
, 
hmm_exp_t
 *
he
)

328 int 
k
, 
l
, 
b
;

329 
FLOAT
 
sum
 = 0.0;

330 for (
k
 = 0; k != 
hp
->
n
; ++k) {

331 
FLOAT
 
tmp
;

332 for (
b
 = 0, 
tmp
 = 0.0; b != 
hp
->
m
; ++b) tmp += 
he
->
E
[b][
k
];

333 for (
b
 = 0; b != 
hp
->
m
; ++b)

334 
sum
 += 
he
->
E
[
b
][
k
] * 
	`log
(he->E[b][k] / 
tmp
);

336 for (
k
 = 0; k != 
hp
->
n
; ++k) {

337 
FLOAT
 
tmp
, *
A
 = 
he
->A[
k
];

338 for (
l
 = 0, 
tmp
 = 0.0; l != 
hp
->
n
; ++l) tmp += 
A
[l];

339 for (
l
 = 0; l != 
hp
->
n
; ++l) 
sum
 += 
A
[l] * 
	`log
(A[l] / 
tmp
);

341 return (
he
->
Q0
 = 
sum
);

342 
	}
}

346 void 
	$hmm_add_expect
(const 
hmm_exp_t
 *
he0
, hmm_exp_t *
he1
)

348 int 
b
, 
k
, 
l
;

349 
	`assert
(
he0
->
m
 == 
he1
->m && he0->
n
 == he1->n);

350 for (
k
 = 0; k != 
he1
->
n
; ++k) {

351 
he1
->
A0
[
k
] += 
he0
->A0[k];

352 for (
l
 = 0; l != 
he1
->
n
; ++l)

353 
he1
->
A
[
k
][
l
] += 
he0
->A[k][l];

355 for (
b
 = 0; b != 
he1
->
m
; ++b) {

356 for (
l
 = 0; l != 
he1
->
n
; ++l)

357 
he1
->
E
[
b
][
l
] += 
he0
->E[b][l];

359 
	}
}

363 
FLOAT
 
	$hmm_Q
(const 
hmm_par_t
 *
hp
, const 
hmm_exp_t
 *
he
)

365 
FLOAT
 
sum
 = 0.0;

366 int 
bb
, 
k
, 
l
;

367 for (
bb
 = 0; bb != 
he
->
m
; ++bb) {

368 
FLOAT
 *
eb
 = 
hp
->
e
[
bb
], *
Eb
 = 
he
->
E
[bb];

369 for (
k
 = 0; k != 
hp
->
n
; ++k) {

370 if (
eb
[
k
] <= 0.0) return -
HMM_INF
;

371 
sum
 += 
Eb
[
k
] * 
	`log
(
eb
[k]);

374 for (
k
 = 0; k != 
he
->
n
; ++k) {

375 
FLOAT
 *
Ak
 = 
he
->
A
[
k
], *
ak
 = 
hp
->
a
[k];

376 for (
l
 = 0; l != 
he
->
n
; ++l) {

377 if (
ak
[
l
] <= 0.0) return -
HMM_INF
;

378 
sum
 += 
Ak
[
l
] * 
	`log
(
ak
[l]);

381 return (
sum
 -= 
he
->
Q0
);

382 
	}
}

386 char *
	$hmm_simulate
(const 
hmm_par_t
 *
hp
, int 
L
)

388 int 
i
, 
k
, 
l
, 
b
;

389 
FLOAT
 
x
, 
y
, **
et
;

390 char *
seq
;

391 
seq
 = (char*)
	`calloc
(
L
+1, 1);

393 
et
 = (
FLOAT
**)
	`calloc2
(
hp
->
n
, hp->
m
, sizeof(FLOAT));

394 for (
k
 = 0; k != 
hp
->
n
; ++k)

395 for (
b
 = 0; b != 
hp
->
m
; ++b)

396 
et
[
k
][
b
] = 
hp
->
e
[b][k];

398 
x
 = 
	`drand48
();

399 for (
k
 = 0, 
y
 = 0.0; k != 
hp
->
n
; ++k) {

400 
y
 += 
hp
->
a0
[
k
];

401 if (
y
 >= 
x
) break;

404 for (
i
 = 0; i != 
L
; ++i) {

405 
FLOAT
 *
el
, *
ak
 = 
hp
->
a
[
k
];

406 
x
 = 
	`drand48
();

407 for (
l
 = 0, 
y
 = 0.0; l != 
hp
->
n
; ++l) {

408 
y
 += 
ak
[
l
];

409 if (
y
 >= 
x
) break;

411 
el
 = 
et
[
l
];

412 
x
 = 
	`drand48
();

413 for (
b
 = 0, 
y
 = 0.0; b != 
hp
->
m
; ++b) {

414 
y
 += 
el
[
b
];

415 if (
y
 >= 
x
) break;

417 
seq
[
i
] = 
b
;

418 
k
 = 
l
;

420 for (
k
 = 0; k != 
hp
->
n
; ++k) 
	`free
(
et
[k]);

421 
	`free
(
et
);

422 return 
seq
;

423 
	}
}

	@deps/klib/khmm.h

1 #ifndef 
AC_SCHMM_H_


2 #define 
	#AC_SCHMM_H_


	)

16 #include 
	~<stdlib.h
>

18 #define 
	#HMM_VERSION
 "0.1.0-7"

	)

20 #define 
	#HMM_FORWARD
 0x02

	)

21 #define 
	#HMM_BACKWARD
 0x04

	)

22 #define 
	#HMM_VITERBI
 0x40

	)

23 #define 
	#HMM_POSTDEC
 0x80

	)

25 #ifndef 
FLOAT


26 #define 
	#FLOAT
 double

	)

28 #define 
	#HMM_TINY
 1e-25

	)

29 #define 
	#HMM_INF
 1e300

	)

33 int 
	mm
, 
	mn
;

34 
FLOAT
 **
	ma
, **
	me
;

35 
FLOAT
 **
	mae
;

36 
FLOAT
 *
	ma0
;

37 } 
	thmm_par_t
;

41 int 
	mL
;

42 unsigned 
	mstatus
;

43 char *
	mseq
;

44 
FLOAT
 **
	mf
, **
	mb
, *
	ms
;

45 int *
	mv
;

46 int *
	mp
;

47 } 
	thmm_data_t
;

51 int 
	mm
, 
	mn
;

52 
FLOAT
 
	mQ0
, **
	mA
, **
	mE
, *
	mA0
;

53 } 
	thmm_exp_t
;

57 int 
	ml
, *
	mobs
;

58 
FLOAT
 *
	mthr
;

59 } 
	thmm_gof_t
;

61 #ifdef 
__cplusplus


65 
hmm_par_t
 *
hmm_new_par
(int 
m
, int 
n
);

66 void 
hmm_delete_par
(
hmm_par_t
 *
hp
);

68 
hmm_data_t
 *
hmm_new_data
(int 
L
, const char *
seq
, const 
hmm_par_t
 *
hp
);

69 void 
hmm_delete_data
(
hmm_data_t
 *
hd
);

71 
hmm_exp_t
 *
hmm_new_exp
(const 
hmm_par_t
 *
hp
);

72 void 
hmm_delete_exp
(
hmm_exp_t
 *
he
);

74 
FLOAT
 
hmm_Viterbi
(const 
hmm_par_t
 *
hp
, 
hmm_data_t
 *
hd
);

75 void 
hmm_pre_backward
(
hmm_par_t
 *
hp
);

76 void 
hmm_forward
(const 
hmm_par_t
 *
hp
, 
hmm_data_t
 *
hd
);

77 void 
hmm_backward
(const 
hmm_par_t
 *
hp
, 
hmm_data_t
 *
hd
);

79 
FLOAT
 
hmm_lk
(const 
hmm_data_t
 *
hd
);

81 
FLOAT
 
hmm_post_state
(const 
hmm_par_t
 *
hp
, const 
hmm_data_t
 *
hd
, int 
u
, FLOAT *
prob
);

83 void 
hmm_post_decode
(const 
hmm_par_t
 *
hp
, 
hmm_data_t
 *
hd
);

85 
hmm_exp_t
 *
hmm_expect
(const 
hmm_par_t
 *
hp
, const 
hmm_data_t
 *
hd
);

87 void 
hmm_add_expect
(const 
hmm_exp_t
 *
he0
, hmm_exp_t *
he1
);

89 
FLOAT
 
hmm_Q
(const 
hmm_par_t
 *
hp
, const 
hmm_exp_t
 *
he
);

90 
FLOAT
 
hmm_Q0
(const 
hmm_par_t
 *
hp
, 
hmm_exp_t
 *
he
);

92 char *
hmm_simulate
(const 
hmm_par_t
 *
hp
, int 
L
);

93 #ifdef 
__cplusplus


97 static 
inline
 void **
	$calloc2
(int 
n_row
, int 
n_col
, int 
size
)

99 char **
p
;

100 int 
k
;

101 
p
 = (char**)
	`malloc
(sizeof(char*) * 
n_row
);

102 for (
k
 = 0; k != 
n_row
; ++k)

103 
p
[
k
] = (char*)
	`calloc
(
n_col
, 
size
);

104 return (void**)
p
;

105 
	}
}

	@deps/klib/klist.h

26 #ifndef 
_AC_KLIST_H


27 #define 
	#_AC_KLIST_H


	)

29 #include 
	~<stdlib.h
>

31 #ifndef 
klib_unused


32 #if (
defined
 
__clang__
 && 
__clang_major__
 >= 3) || (defined 
__GNUC__
 && __GNUC__ >= 3)

33 #define 
	#klib_unused
 
	`__attribute__
 ((
__unused__
))

	)

35 #define 
	#klib_unused


	)

39 #define 
	#KMEMPOOL_INIT2
(
SCOPE
, 
name
, 
kmptype_t
, 
kmpfree_f
) \

41 
size_t
 
cnt
, 
n
, 
max
; \

42 
kmptype_t
 **
buf
; \

43 } 
	tkmp_
##
	tname
##
	t_t
; \

44 
SCOPE
 
kmp_
##
name
##
_t
 *
kmp_init_
##
	`name
(void) { \

45 return 
	`calloc
(1, sizeof(
kmp_
##
name
##
_t
)); \

47 
SCOPE
 void 
kmp_destroy_
##
	`name
(
kmp_
##
name
##
_t
 *
mp
) { \

48 
size_t
 
k
; \

49 for (
k
 = 0; k < 
mp
->
n
; ++k) { \

50 
	`kmpfree_f
(
mp
->
buf
[
k
]); 
	`free
(mp->buf[k]); \

52 
	`free
(
mp
->
buf
); free(mp); \

54 
SCOPE
 
kmptype_t
 *
kmp_alloc_
##
	`name
(
kmp_
##
name
##
_t
 *
mp
) { \

55 ++
mp
->
cnt
; \

56 if (
mp
->
n
 == 0) return 
	`calloc
(1, sizeof(
kmptype_t
)); \

57 return 
mp
->
buf
[--mp->
n
]; \

59 
SCOPE
 void 
kmp_free_
##
	`name
(
kmp_
##
name
##
_t
 *
mp
, 
kmptype_t
 *
p
) { \

60 --
mp
->
cnt
; \

61 if (
mp
->
n
 == mp->
max
) { \

62 
mp
->
max
 = mp->max? mp->max<<1 : 16; \

63 
mp
->
buf
 = 
	`realloc
(mp->buf, sizeof(
kmptype_t
 *) * mp->
max
); \

65 
mp
->
buf
[mp->
n
++] = 
p
; \

66 }

	)

68 #define 
	#KMEMPOOL_INIT
(
name
, 
kmptype_t
, 
kmpfree_f
) \

69 
	`KMEMPOOL_INIT2
(static 
inline
 
klib_unused
, 
name
, 
kmptype_t
, 
kmpfree_f
)

	)

71 #define 
	#kmempool_t
(
name
) 
kmp_
##name##
_t


	)

72 #define 
	#kmp_init
(
name
) 
kmp_init_
##
	`name
()

	)

73 #define 
	#kmp_destroy
(
name
, 
mp
) 
kmp_destroy_
##
	`name
(mp)

	)

74 #define 
	#kmp_alloc
(
name
, 
mp
) 
kmp_alloc_
##
	`name
(mp)

	)

75 #define 
	#kmp_free
(
name
, 
mp
, 
p
) 
kmp_free_
##
	`name
(mp, p)

	)

77 #define 
	#KLIST_INIT2
(
SCOPE
, 
name
, 
kltype_t
, 
kmpfree_t
) \

78 struct 
__kl1_
##
name
 { \

79 
kltype_t
 
data
; \

80 struct 
__kl1_
##
name
 *
next
; \

82 typedef struct 
__kl1_
##
	tname
 
	tkl1_
##name; \

83 
	`KMEMPOOL_INIT2
(
SCOPE
, 
name
, 
kl1_
##name, 
kmpfree_t
) \

85 
kl1_
##
name
 *
head
, *
tail
; \

86 
kmp_
##
name
##
_t
 *
mp
; \

87 
size_t
 
size
; \

88 } 
	tkl_
##
	tname
##
	t_t
; \

89 
SCOPE
 
kl_
##
name
##
_t
 *
kl_init_
##
	`name
(void) { \

90 
kl_
##
name
##
_t
 *
kl
 = 
	`calloc
(1, sizeof(kl_##name##_t)); \

91 
kl
->
mp
 = 
	`kmp_init
(
name
); \

92 
kl
->
head
 = kl->
tail
 = 
	`kmp_alloc
(
name
, kl->
mp
); \

93 
kl
->
head
->
next
 = 0; \

94 return 
kl
; \

96 
SCOPE
 void 
kl_destroy_
##
	`name
(
kl_
##
name
##
_t
 *
kl
) { \

97 
kl1_
##
name
 *
p
; \

98 for (
p
 = 
kl
->
head
; p != kl->
tail
; p = p->
next
) \

99 
	`kmp_free
(
name
, 
kl
->
mp
, 
p
); \

100 
	`kmp_free
(
name
, 
kl
->
mp
, 
p
); \

101 
	`kmp_destroy
(
name
, 
kl
->
mp
); \

102 
	`free
(
kl
); \

104 
SCOPE
 
kltype_t
 *
kl_pushp_
##
	`name
(
kl_
##
name
##
_t
 *
kl
) { \

105 
kl1_
##
name
 *
q
, *
p
 = 
	`kmp_alloc
(name, 
kl
->
mp
); \

106 
q
 = 
kl
->
tail
; 
p
->
next
 = 0; kl->tail->next = p; kl->tail = p; \

107 ++
kl
->
size
; \

108 return &
q
->
data
; \

110 
SCOPE
 int 
kl_shift_
##
	`name
(
kl_
##
name
##
_t
 *
kl
, 
kltype_t
 *
d
) { \

111 
kl1_
##
name
 *
p
; \

112 if (
kl
->
head
->
next
 == 0) return -1; \

113 --
kl
->
size
; \

114 
p
 = 
kl
->
head
; kl->head = kl->head->
next
; \

115 if (
d
) *d = 
p
->
data
; \

116 
	`kmp_free
(
name
, 
kl
->
mp
, 
p
); \

118 }

	)

120 #define 
	#KLIST_INIT
(
name
, 
kltype_t
, 
kmpfree_t
) \

121 
	`KLIST_INIT2
(static 
inline
 
klib_unused
, 
name
, 
kltype_t
, 
kmpfree_t
)

	)

123 #define 
	#kliter_t
(
name
) 
kl1_
##
	)
name

124 #define 
	#klist_t
(
name
) 
kl_
##name##
_t


	)

125 #define 
	#kl_val
(
iter
) ((iter)->
data
)

	)

126 #define 
	#kl_next
(
iter
) ((iter)->
next
)

	)

127 #define 
	#kl_begin
(
kl
) ((kl)->
head
)

	)

128 #define 
	#kl_end
(
kl
) ((kl)->
tail
)

	)

130 #define 
	#kl_init
(
name
) 
kl_init_
##
	`name
()

	)

131 #define 
	#kl_destroy
(
name
, 
kl
) 
kl_destroy_
##
	`name
(kl)

	)

132 #define 
	#kl_pushp
(
name
, 
kl
) 
kl_pushp_
##
	`name
(kl)

	)

133 #define 
	#kl_shift
(
name
, 
kl
, 
d
) 
kl_shift_
##
	`name
(kl, d)

	)

	@deps/klib/kmath.c

1 #include 
	~<stdlib.h
>

2 #include 
	~<string.h
>

3 #include 
	~<math.h
>

4 #include 
	~"kmath.h
"

19 #define 
	#KR_NN
 312

	)

20 #define 
	#KR_MM
 156

	)

21 #define 
	#KR_UM
 0xFFFFFFFF80000000ULL

	)

22 #define 
	#KR_LM
 0x7FFFFFFFULL

	)

24 struct 
	s_krand_t
 {

25 int 
	mmti
, 
	mn_iset
;

26 double 
	mn_gset
;

27 
krint64_t
 
	mmt
[
KR_NN
];

30 static void 
	$kr_srand0
(
krint64_t
 
seed
, 
krand_t
 *
kr
)

32 
kr
->
mt
[0] = 
seed
;

33 for (
kr
->
mti
 = 1; kr->mti < 
KR_NN
; ++kr->mti)

34 
kr
->
mt
[kr->
mti
] = 6364136223846793005ULL * (kr->mt[kr->mti - 1] ^ (kr->mt[kr->mti - 1] >> 62)) + kr->mti;

35 
	}
}

37 
krand_t
 *
	$kr_srand
(
krint64_t
 
seed
)

39 
krand_t
 *
kr
;

40 
kr
 = (
krand_t
*)
	`calloc
(1, sizeof(krand_t));

41 
	`kr_srand0
(
seed
, 
kr
);

42 return 
kr
;

43 
	}
}

45 
krint64_t
 
	$kr_rand
(
krand_t
 *
kr
)

47 
krint64_t
 
x
;

48 static const 
krint64_t
 
mag01
[2] = { 0, 0xB5026F5AA96619E9ULL };

49 if (
kr
->
mti
 >= 
KR_NN
) {

50 int 
i
;

51 if (
kr
->
mti
 == 
KR_NN
 + 1) 
	`kr_srand0
(5489ULL, kr);

52 for (
i
 = 0; i < 
KR_NN
 - 
KR_MM
; ++i) {

53 
x
 = (
kr
->
mt
[
i
] & 
KR_UM
) | (kr->mt[i+1] & 
KR_LM
);

54 
kr
->
mt
[
i
] = kr->mt[i + 
KR_MM
] ^ (
x
>>1) ^ 
mag01
[(int)(x&1)];

56 for (; 
i
 < 
KR_NN
 - 1; ++i) {

57 
x
 = (
kr
->
mt
[
i
] & 
KR_UM
) | (kr->mt[i+1] & 
KR_LM
);

58 
kr
->
mt
[
i
] = kr->mt[i + (
KR_MM
 - 
KR_NN
)] ^ (
x
>>1) ^ 
mag01
[(int)(x&1)];

60 
x
 = (
kr
->
mt
[
KR_NN
 - 1] & 
KR_UM
) | (kr->mt[0] & 
KR_LM
);

61 
kr
->
mt
[
KR_NN
 - 1] = kr->mt[
KR_MM
 - 1] ^ (
x
>>1) ^ 
mag01
[(int)(x&1)];

62 
kr
->
mti
 = 0;

64 
x
 = 
kr
->
mt
[kr->
mti
++];

65 
x
 ^= (x >> 29) & 0x5555555555555555ULL;

66 
x
 ^= (x << 17) & 0x71D67FFFEDA60000ULL;

67 
x
 ^= (x << 37) & 0xFFF7EEE000000000ULL;

68 
x
 ^= (x >> 43);

69 return 
x
;

70 
	}
}

72 double 
	$kr_normal
(
krand_t
 *
kr
)

74 if (
kr
->
n_iset
 == 0) {

75 double 
fac
, 
rsq
, 
v1
, 
v2
;

77 
v1
 = 2.0 * 
	`kr_drand
(
kr
) - 1.0;

78 
v2
 = 2.0 * 
	`kr_drand
(
kr
) - 1.0;

79 
rsq
 = 
v1
 * v1 + 
v2
 * v2;

80 } while (
rsq
 >= 1.0 || rsq == 0.0);

81 
fac
 = 
	`sqrt
(-2.0 * 
	`log
(
rsq
) / rsq);

82 
kr
->
n_gset
 = 
v1
 * 
fac
;

83 
kr
->
n_iset
 = 1;

84 return 
v2
 * 
fac
;

86 
kr
->
n_iset
 = 0;

87 return 
kr
->
n_gset
;

89 
	}
}

91 #ifdef 
_KR_MAIN


92 int 
	$main
(int 
argc
, char *
argv
[])

94 long 
i
, 
N
 = 200000000;

95 
krand_t
 *
kr
;

96 if (
argc
 > 1) 
N
 = 
	`atol
(
argv
[1]);

97 
kr
 = 
	`kr_srand
(11);

98 for (
i
 = 0; i < 
N
; ++i) 
	`kr_rand
(
kr
);

100 
	`free
(
kr
);

102 
	}
}

125 static double 
	$__kmin_hj_aux
(
kmin_f
 
func
, int 
n
, double *
x1
, void *
data
, double 
fx1
, double *
dx
, int *
n_calls
)

127 int 
k
, 
j
 = *
n_calls
;

128 double 
ftmp
;

129 for (
k
 = 0; k != 
n
; ++k) {

130 
x1
[
k
] += 
dx
[k];

131 
ftmp
 = 
	`func
(
n
, 
x1
, 
data
); ++
j
;

132 if (
ftmp
 < 
fx1
) fx1 = ftmp;

134 
dx
[
k
] = 0.0 - dx[k];

135 
x1
[
k
] += 
dx
[k] + dx[k];

136 
ftmp
 = 
	`func
(
n
, 
x1
, 
data
); ++
j
;

137 if (
ftmp
 < 
fx1
) fx1 = ftmp;

138 else 
x1
[
k
] -= 
dx
[k];

141 *
n_calls
 = 
j
;

142 return 
fx1
;

143 
	}
}

145 double 
	$kmin_hj
(
kmin_f
 
func
, int 
n
, double *
x
, void *
data
, double 
r
, double 
eps
, int 
max_calls
)

147 double 
fx
, 
fx1
, *
x1
, *
dx
, 
radius
;

148 int 
k
, 
n_calls
 = 0;

149 
x1
 = (double*)
	`calloc
(
n
, sizeof(double));

150 
dx
 = (double*)
	`calloc
(
n
, sizeof(double));

151 for (
k
 = 0; k != 
n
; ++k) {

152 
dx
[
k
] = 
	`fabs
(
x
[k]) * 
r
;

153 if (
dx
[
k
] == 0) dx[k] = 
r
;

155 
radius
 = 
r
;

156 
fx1
 = 
fx
 = 
	`func
(
n
, 
x
, 
data
); ++
n_calls
;

158 
	`memcpy
(
x1
, 
x
, 
n
 * sizeof(double));

159 
fx1
 = 
	`__kmin_hj_aux
(
func
, 
n
, 
x1
, 
data
, 
fx
, 
dx
, &
n_calls
);

160 while (
fx1
 < 
fx
) {

161 for (
k
 = 0; k != 
n
; ++k) {

162 double 
t
 = 
x
[
k
];

163 
dx
[
k
] = 
x1
[k] > 
x
[k]? 
	`fabs
(dx[k]) : 0.0 - fabs(dx[k]);

164 
x
[
k
] = 
x1
[k];

165 
x1
[
k
] = x1[k] + x1[k] - 
t
;

167 
fx
 = 
fx1
;

168 if (
n_calls
 >= 
max_calls
) break;

169 
fx1
 = 
	`func
(
n
, 
x1
, 
data
); ++
n_calls
;

170 
fx1
 = 
	`__kmin_hj_aux
(
func
, 
n
, 
x1
, 
data
, fx1, 
dx
, &
n_calls
);

171 if (
fx1
 >= 
fx
) break;

172 for (
k
 = 0; k != 
n
; ++k)

173 if (
	`fabs
(
x1
[
k
] - 
x
[k]) > .5 * fabs(
dx
[k])) break;

174 if (
k
 == 
n
) break;

176 if (
radius
 >= 
eps
) {

177 if (
n_calls
 >= 
max_calls
) break;

178 
radius
 *= 
r
;

179 for (
k
 = 0; k != 
n
; ++k) 
dx
[k] *= 
r
;

182 
	`free
(
x1
); free(
dx
);

183 return 
fx1
;

184 
	}
}

187 double 
	$kmin_brent
(
kmin1_f
 
func
, double 
a
, double 
b
, void *
data
, double 
tol
, double *
xmin
)

189 double 
bound
, 
u
, 
r
, 
q
, 
fu
, 
tmp
, 
fa
, 
fb
, 
fc
, 
c
;

190 const double 
gold1
 = 1.6180339887;

191 const double 
gold2
 = 0.3819660113;

192 const double 
tiny
 = 1e-20;

193 const int 
max_iter
 = 100;

195 double 
e
, 
d
, 
w
, 
v
, 
mid
, 
tol1
, 
tol2
, 
p
, 
eold
, 
fv
, 
fw
;

196 int 
iter
;

198 
fa
 = 
	`func
(
a
, 
data
); 
fb
 = func(
b
, data);

199 if (
fb
 > 
fa
) {

200 
tmp
 = 
a
; a = 
b
; b = tmp;

201 
tmp
 = 
fa
; fa = 
fb
; fb = tmp;

203 
c
 = 
b
 + 
gold1
 * (b - 
a
), 
fc
 = 
	`func
(c, 
data
);

204 while (
fb
 > 
fc
) {

205 
bound
 = 
b
 + 100.0 * (
c
 - b);

206 
r
 = (
b
 - 
a
) * (
fb
 - 
fc
);

207 
q
 = (
b
 - 
c
) * (
fb
 - 
fa
);

208 if (
	`fabs
(
q
 - 
r
) < 
tiny
) {

209 
tmp
 = 
q
 > 
r
? 
tiny
 : 0.0 - tiny;

210 } else 
tmp
 = 
q
 - 
r
;

211 
u
 = 
b
 - ((b - 
c
) * 
q
 - (b - 
a
) * 
r
) / (2.0 * 
tmp
);

212 if ((
b
 > 
u
 && u > 
c
) || (b < u && u < c)) {

213 
fu
 = 
	`func
(
u
, 
data
);

214 if (
fu
 < 
fc
) {

215 
a
 = 
b
; b = 
u
; 
fa
 = 
fb
; fb = 
fu
;

217 } else if (
fu
 > 
fb
) {

218 
c
 = 
u
; 
fc
 = 
fu
;

221 
u
 = 
c
 + 
gold1
 * (c - 
b
); 
fu
 = 
	`func
(u, 
data
);

222 } else if ((
c
 > 
u
 && u > 
bound
) || (c < u && u < bound)) {

223 
fu
 = 
	`func
(
u
, 
data
);

224 if (
fu
 < 
fc
) {

225 
b
 = 
c
; c = 
u
; u = c + 
gold1
 * (c - b);

226 
fb
 = 
fc
; fc = 
fu
; fu = 
	`func
(
u
, 
data
);

228 
a
 = 
b
; b = 
c
; c = 
u
;

229 
fa
 = 
fb
; fb = 
fc
; fc = 
fu
;

232 } else if ((
u
 > 
bound
 && bound > 
c
) || (u < bound && bound < c)) {

233 
u
 = 
bound
; 
fu
 = 
	`func
(u, 
data
);

235 
u
 = 
c
 + 
gold1
 * (c - 
b
); 
fu
 = 
	`func
(u, 
data
);

237 
a
 = 
b
; b = 
c
; c = 
u
;

238 
fa
 = 
fb
; fb = 
fc
; fc = 
fu
;

240 if (
a
 > 
c
) 
u
 = a, a = c, c = u;

243 
e
 = 
d
 = 0.0;

244 
w
 = 
v
 = 
b
; 
fv
 = 
fw
 = 
fb
;

245 for (
iter
 = 0; iter != 
max_iter
; ++iter) {

246 
mid
 = 0.5 * (
a
 + 
c
);

247 
tol2
 = 2.0 * (
tol1
 = 
tol
 * 
	`fabs
(
b
) + 
tiny
);

248 if (
	`fabs
(
b
 - 
mid
) <= (
tol2
 - 0.5 * (
c
 - 
a
))) {

249 *
xmin
 = 
b
; return 
fb
;

251 if (
	`fabs
(
e
) > 
tol1
) {

253 
r
 = (
b
 - 
w
) * (
fb
 - 
fv
);

254 
q
 = (
b
 - 
v
) * (
fb
 - 
fw
);

255 
p
 = (
b
 - 
v
) * 
q
 - (b - 
w
) * 
r
;

256 
q
 = 2.0 * (q - 
r
);

257 if (
q
 > 0.0) 
p
 = 0.0 - p;

258 else 
q
 = 0.0 - q;

259 
eold
 = 
e
; e = 
d
;

260 if (
	`fabs
(
p
) >= fabs(0.5 * 
q
 * 
eold
) || p <= q * (
a
 - 
b
) || p >= q * (
c
 - b)) {

261 
d
 = 
gold2
 * (
e
 = (
b
 >= 
mid
 ? 
a
 - b : 
c
 - b));

263 
d
 = 
p
 / 
q
; 
u
 = 
b
 + d;

264 if (
u
 - 
a
 < 
tol2
 || 
c
 - u < tol2)

265 
d
 = (
mid
 > 
b
)? 
tol1
 : 0.0 - tol1;

267 } else 
d
 = 
gold2
 * (
e
 = (
b
 >= 
mid
 ? 
a
 - b : 
c
 - b));

268 
u
 = 
	`fabs
(
d
) >= 
tol1
 ? 
b
 + d : b + (d > 0.0? tol1 : -tol1);

269 
fu
 = 
	`func
(
u
, 
data
);

270 if (
fu
 <= 
fb
) {

271 if (
u
 >= 
b
) 
a
 = b;

272 else 
c
 = 
b
;

273 
v
 = 
w
; w = 
b
; b = 
u
; 
fv
 = 
fw
; fw = 
fb
; fb = 
fu
;

275 if (
u
 < 
b
) 
a
 = u;

276 else 
c
 = 
u
;

277 if (
fu
 <= 
fw
 || 
w
 == 
b
) {

278 
v
 = 
w
; w = 
u
;

279 
fv
 = 
fw
; fw = 
fu
;

280 } else if (
fu
 <= 
fv
 || 
v
 == 
b
 || v == 
w
) {

281 
v
 = 
u
; 
fv
 = 
fu
;

285 *
xmin
 = 
b
;

286 return 
fb
;

287 
	}
}

297 double 
	$kf_lgamma
(double 
z
)

299 double 
x
 = 0;

300 
x
 += 0.1659470187408462e-06 / (
z
+7);

301 
x
 += 0.9934937113930748e-05 / (
z
+6);

302 
x
 -= 0.1385710331296526 / (
z
+5);

303 
x
 += 12.50734324009056 / (
z
+4);

304 
x
 -= 176.6150291498386 / (
z
+3);

305 
x
 += 771.3234287757674 / (
z
+2);

306 
x
 -= 1259.139216722289 / (
z
+1);

307 
x
 += 676.5203681218835 / 
z
;

308 
x
 += 0.9999999999995183;

309 return 
	`log
(
x
) - 5.58106146679532777 - 
z
 + (z-0.5) * log(z+6.5);

310 
	}
}

316 double 
	$kf_erfc
(double 
x
)

318 const double 
p0
 = 220.2068679123761;

319 const double 
p1
 = 221.2135961699311;

320 const double 
p2
 = 112.0792914978709;

321 const double 
p3
 = 33.912866078383;

322 const double 
p4
 = 6.37396220353165;

323 const double 
p5
 = .7003830644436881;

324 const double 
p6
 = .03526249659989109;

325 const double 
q0
 = 440.4137358247522;

326 const double 
q1
 = 793.8265125199484;

327 const double 
q2
 = 637.3336333788311;

328 const double 
q3
 = 296.5642487796737;

329 const double 
q4
 = 86.78073220294608;

330 const double 
q5
 = 16.06417757920695;

331 const double 
q6
 = 1.755667163182642;

332 const double 
q7
 = .08838834764831844;

333 double 
expntl
, 
z
, 
p
;

334 
z
 = 
	`fabs
(
x
) * 
M_SQRT2
;

335 if (
z
 > 37.) return 
x
 > 0.? 0. : 2.;

336 
expntl
 = 
	`exp
(
z
 * z * - .5);

337 if (
z
 < 10. / 
M_SQRT2
)

338 
p
 = 
expntl
 * ((((((
p6
 * 
z
 + 
p5
) * z + 
p4
) * z + 
p3
) * z + 
p2
) * z + 
p1
) * z + 
p0
)

339 / (((((((
q7
 * 
z
 + 
q6
) * z + 
q5
) * z + 
q4
) * z + 
q3
) * z + 
q2
) * z + 
q1
) * z + 
q0
);

340 else 
p
 = 
expntl
 / 2.506628274631001 / (
z
 + 1. / (z + 2. / (z + 3. / (z + 4. / (z + .65)))));

341 return 
x
 > 0.? 2. * 
p
 : 2. * (1. - p);

342 
	}
}

357 #define 
	#KF_GAMMA_EPS
 1e-14

	)

358 #define 
	#KF_TINY
 1e-290

	)

361 static double 
	$_kf_gammap
(double 
s
, double 
z
)

363 double 
sum
, 
x
;

364 int 
k
;

365 for (
k
 = 1, 
sum
 = 
x
 = 1.; k < 100; ++k) {

366 
sum
 += (
x
 *= 
z
 / (
s
 + 
k
));

367 if (
x
 / 
sum
 < 
KF_GAMMA_EPS
) break;

369 return 
	`exp
(
s
 * 
	`log
(
z
) - z - 
	`kf_lgamma
(s + 1.) + log(
sum
));

370 
	}
}

372 static double 
	$_kf_gammaq
(double 
s
, double 
z
)

374 int 
j
;

375 double 
C
, 
D
, 
f
;

376 
f
 = 1. + 
z
 - 
s
; 
C
 = f; 
D
 = 0.;

379 for (
j
 = 1; j < 100; ++j) {

380 double 
a
 = 
j
 * (
s
 - j), 
b
 = (j<<1) + 1 + 
z
 - s, 
d
;

381 
D
 = 
b
 + 
a
 * D;

382 if (
D
 < 
KF_TINY
) D = KF_TINY;

383 
C
 = 
b
 + 
a
 / C;

384 if (
C
 < 
KF_TINY
) C = KF_TINY;

385 
D
 = 1. / D;

386 
d
 = 
C
 * 
D
;

387 
f
 *= 
d
;

388 if (
	`fabs
(
d
 - 1.) < 
KF_GAMMA_EPS
) break;

390 return 
	`exp
(
s
 * 
	`log
(
z
) - z - 
	`kf_lgamma
(s) - log(
f
));

391 
	}
}

393 double 
	$kf_gammap
(double 
s
, double 
z
)

395 return 
z
 <= 1. || z < 
s
? 
	`_kf_gammap
(s, z) : 1. - 
	`_kf_gammaq
(s, z);

396 
	}
}

398 double 
	$kf_gammaq
(double 
s
, double 
z
)

400 return 
z
 <= 1. || z < 
s
? 1. - 
	`_kf_gammap
(s, z) : 
	`_kf_gammaq
(s, z);

401 
	}
}

410 static double 
	$kf_betai_aux
(double 
a
, double 
b
, double 
x
)

412 double 
C
, 
D
, 
f
;

413 int 
j
;

414 if (
x
 == 0.) return 0.;

415 if (
x
 == 1.) return 1.;

416 
f
 = 1.; 
C
 = f; 
D
 = 0.;

418 for (
j
 = 1; j < 200; ++j) {

419 double 
aa
, 
d
;

420 int 
m
 = 
j
>>1;

421 
aa
 = (
j
&1)? -(
a
 + 
m
) * (a + 
b
 + m) * 
x
 / ((a + 2*m) * (a + 2*m + 1))

422 : 
m
 * (
b
 - m) * 
x
 / ((
a
 + 2*m - 1) * (a + 2*m));

423 
D
 = 1. + 
aa
 * D;

424 if (
D
 < 
KF_TINY
) D = KF_TINY;

425 
C
 = 1. + 
aa
 / C;

426 if (
C
 < 
KF_TINY
) C = KF_TINY;

427 
D
 = 1. / D;

428 
d
 = 
C
 * 
D
;

429 
f
 *= 
d
;

430 if (
	`fabs
(
d
 - 1.) < 
KF_GAMMA_EPS
) break;

432 return 
	`exp
(
	`kf_lgamma
(
a
+
b
) - kf_lgamma(a) - kf_lgamma(b) + a * 
	`log
(
x
) + b * log(1.-x)) / a / 
f
;

433 
	}
}

434 double 
	$kf_betai
(double 
a
, double 
b
, double 
x
)

436 return 
x
 < (
a
 + 1.) / (a + 
b
 + 2.)? 
	`kf_betai_aux
(a, b, x) : 1. - kf_betai_aux(b, a, 1. - x);

437 
	}
}

443 double 
	$km_ks_dist
(int 
na
, const double 
a
[], int 
nb
, const double 
b
[])

445 int 
ia
 = 0, 
ib
 = 0;

446 double 
fa
 = 0, 
fb
 = 0, 
sup
 = 0, 
na1
 = 1. / 
na
, 
nb1
 = 1. / 
nb
;

447 while (
ia
 < 
na
 || 
ib
 < 
nb
) {

448 if (
ia
 == 
na
) 
fb
 += 
nb1
, ++
ib
;

449 else if (
ib
 == 
nb
) 
fa
 += 
na1
, ++
ia
;

450 else if (
a
[
ia
] < 
b
[
ib
]) 
fa
 += 
na1
, ++ia;

451 else if (
a
[
ia
] > 
b
[
ib
]) 
fb
 += 
nb1
, ++ib;

452 else 
fa
 += 
na1
, 
fb
 += 
nb1
, ++
ia
, ++
ib
;

453 if (
sup
 < 
	`fabs
(
fa
 - 
fb
)) sup = fabs(fa - fb);

455 return 
sup
;

456 
	}
}

458 #ifdef 
KF_MAIN


459 #include 
	~<stdio.h
>

460 #include 
	~"ksort.h
"

461 
	$KSORT_INIT_GENERIC
(double)

462 int 
	$main
(int 
argc
, char *
argv
[])

464 double 
x
 = 5.5, 
y
 = 3;

465 double 
a
, 
b
;

466 double 
xx
[] = {0.22, -0.87, -2.39, -1.79, 0.37, -1.54, 1.28, -0.31, -0.74, 1.72, 0.38, -0.17, -0.62, -1.10, 0.30, 0.15, 2.30, 0.19, -0.50, -0.09};

467 double 
yy
[] = {-5.13, -2.19, -2.43, -3.83, 0.50, -3.25, 4.32, 1.63, 5.18, -0.43, 7.11, 4.87, -3.10, -5.81, 3.76, 6.31, 2.58, 0.07, 5.76, 3.50};

468 
	`ks_introsort
(double, 20, 
xx
); ks_introsort(double, 20, 
yy
);

469 
	`printf
("K-S distance: %f\n", 
	`km_ks_dist
(20, 
xx
, 20, 
yy
));

470 
	`printf
("erfc(%lg): %lg, %lg\n", 
x
, 
	`erfc
(x), 
	`kf_erfc
(x));

471 
	`printf
("upper-gamma(%lg,%lg): %lg\n", 
x
, 
y
, 
	`kf_gammaq
(y, x)*
	`tgamma
(y));

472 
a
 = 2; 
b
 = 2; 
x
 = 0.5;

473 
	`printf
("incomplete-beta(%lg,%lg,%lg): %lg\n", 
a
, 
b
, 
x
, 
	`kf_betai
(a, b, x) / 
	`exp
(
	`kf_lgamma
(a+b) - kf_lgamma(a) - kf_lgamma(b)));

475 
	}
}

	@deps/klib/kmath.h

1 #ifndef 
AC_KMATH_H


2 #define 
	#AC_KMATH_H


	)

4 #include 
	~<stdint.h
>

6 #ifdef 
__cplusplus


14 typedef 
uint64_t
 
	tkrint64_t
;

16 struct 
_krand_t
;

17 typedef struct 
_krand_t
 
	tkrand_t
;

19 #define 
	#kr_drand
(
_kr
) ((
	`kr_rand
(_kr) >> 11) * (1.0/9007199254740992.0))

	)

20 #define 
	#kr_sample
(
_kr
, 
_k
, 
_cnt
) ((*(_cnt))++ < (_k)? *(_cnt) - 1 : 
	`kr_rand
(_kr) % *(_cnt))

	)

22 
krand_t
 *
kr_srand
(
krint64_t
 
seed
);

23 
krint64_t
 
kr_rand
(
krand_t
 *
kr
);

24 double 
kr_normal
(
krand_t
 *
kr
);

30 #define 
	#KMIN_RADIUS
 0.5

	)

31 #define 
	#KMIN_EPS
 1e-7

	)

32 #define 
	#KMIN_MAXCALL
 50000

	)

34 typedef double (*
kmin_f
)(int, double*, void*);

35 typedef double (*
kmin1_f
)(double, void*);

37 double 
kmin_hj
(
kmin_f
 
func
, int 
n
, double *
x
, void *
data
, double 
r
, double 
eps
, int 
max_calls
);

38 double 
kmin_brent
(
kmin1_f
 
func
, double 
a
, double 
b
, void *
data
, double 
tol
, double *
xmin
);

44 double 
kf_lgamma
(double 
z
);

45 double 
kf_erfc
(double 
x
);

46 double 
kf_gammap
(double 
s
, double 
z
);

47 double 
kf_gammaq
(double 
s
, double 
z
);

48 double 
kf_betai
(double 
a
, double 
b
, double 
x
);

50 #ifdef 
__cplusplus


	@deps/klib/knetfile.c

31 #include 
	~<time.h
>

32 #include 
	~<stdio.h
>

33 #include 
	~<ctype.h
>

34 #include 
	~<stdlib.h
>

35 #include 
	~<string.h
>

36 #include 
	~<errno.h
>

37 #include 
	~<unistd.h
>

38 #include 
	~<sys/types.h
>

40 #ifndef 
_WIN32


41 #include 
	~<netdb.h
>

42 #include 
	~<arpa/inet.h
>

43 #include 
	~<sys/socket.h
>

46 #include 
	~"knetfile.h
"

60 static int 
	$socket_wait
(int 
fd
, int 
is_read
)

62 
fd_set
 
fds
, *
fdr
 = 0, *
fdw
 = 0;

63 struct 
timeval
 
tv
;

64 int 
ret
;

65 
tv
.
tv_sec
 = 5; tv.
tv_usec
 = 0;

66 
	`FD_ZERO
(&
fds
);

67 
	`FD_SET
(
fd
, &
fds
);

68 if (
is_read
) 
fdr
 = &
fds
;

69 else 
fdw
 = &
fds
;

70 
ret
 = 
	`select
(
fd
+1, 
fdr
, 
fdw
, 0, &
tv
);

71 #ifndef 
_WIN32


72 if (
ret
 == -1) 
	`perror
("select");

74 if (
ret
 == 0)

75 
	`fprintf
(
stderr
, "select time-out\n");

76 else if (
ret
 == 
SOCKET_ERROR
)

77 
	`fprintf
(
stderr
, "select: %d\n", 
	`WSAGetLastError
());

79 return 
ret
;

80 
	}
}

82 #ifndef 
_WIN32


86 static int 
	$socket_connect
(const char *
host
, const char *
port
)

88 #define 
	#__err_connect
(
func
) do { 
	`perror
(func); 
	`freeaddrinfo
(
res
); return -1; } while (0)

	)

90 int 
ai_err
, 
on
 = 1, 
fd
;

91 struct 
linger
 
lng
 = { 0, 0 };

92 struct 
addrinfo
 
hints
, *
res
 = 0;

93 
	`memset
(&
hints
, 0, sizeof(struct 
addrinfo
));

94 
hints
.
ai_family
 = 
AF_UNSPEC
;

95 
hints
.
ai_socktype
 = 
SOCK_STREAM
;

98 if ((
ai_err
 = 
	`getaddrinfo
(
host
, 
port
, &
hints
, &
res
)) != 0) { 
	`fprintf
(
stderr
, "can't resolve %s:%s: %s\n", host, port, 
	`gai_strerror
(ai_err)); return -1; }

99 if ((
fd
 = 
	`socket
(
res
->
ai_family
, res->
ai_socktype
, res->
ai_protocol
)) == -1) 
	`__err_connect
("socket");

103 if (
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_REUSEADDR
, &
on
, sizeof(on)) == -1) 
	`__err_connect
("setsockopt");

104 if (
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_LINGER
, &
lng
, sizeof(lng)) == -1) 
	`__err_connect
("setsockopt");

105 if (
	`connect
(
fd
, 
res
->
ai_addr
, res->
ai_addrlen
) != 0) 
	`__err_connect
("connect");

106 
	`freeaddrinfo
(
res
);

107 return 
fd
;

108 
	}
}

111 char *
	$int64tostr
(char *
buf
, 
int64_t
 
x
)

113 int 
cnt
;

114 int 
i
 = 0;

116 
buf
[
i
++] = '0' + 
x
 % 10;

117 
x
 /= 10;

118 } while (
x
);

119 
buf
[
i
] = 0;

120 for (
cnt
 = 
i
, i = 0; i < cnt/2; ++i) {

121 int 
c
 = 
buf
[
i
]; buf[i] = buf[
cnt
-i-1]; buf[cnt-i-1] = c;

123 return 
buf
;

124 
	}
}

126 
int64_t
 
	$strtoint64
(const char *
buf
)

128 
int64_t
 
x
;

129 for (
x
 = 0; *
buf
 != '\0'; ++buf)

130 
x
 = x * 10 + ((
int64_t
) *
buf
 - 48);

131 return 
x
;

132 
	}
}

134 int 
	$knet_win32_init
()

136 
WSADATA
 
wsaData
;

137 return 
	`WSAStartup
(
	`MAKEWORD
(2, 2), &
wsaData
);

138 
	}
}

139 void 
	$knet_win32_destroy
()

141 
	`WSACleanup
();

142 
	}
}

147 static 
SOCKET
 
	$socket_connect
(const char *
host
, const char *
port
)

149 #define 
	#__err_connect
(
func
) \

151 
	`fprintf
(
stderr
, "%s: %d\n", 
func
, 
	`WSAGetLastError
()); \

153 } while (0)

	)

155 int 
on
 = 1;

156 
SOCKET
 
fd
;

157 struct 
linger
 
lng
 = { 0, 0 };

158 struct 
sockaddr_in
 
server
;

159 struct 
hostent
 *
hp
 = 0;

161 if ((
fd
 = 
	`socket
(
AF_INET
, 
SOCK_STREAM
, 
IPPROTO_TCP
)) == 
INVALID_SOCKET
) 
	`__err_connect
("socket");

162 if (
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_REUSEADDR
, (char*)&
on
, sizeof(on)) == -1) 
	`__err_connect
("setsockopt");

163 if (
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_LINGER
, (char*)&
lng
, sizeof(lng)) == -1) 
	`__err_connect
("setsockopt");

165 if (
	`isalpha
(
host
[0])) 
hp
 = 
	`gethostbyname
(host);

167 struct 
in_addr
 
addr
;

168 
addr
.
s_addr
 = 
	`inet_addr
(
host
);

169 
hp
 = 
	`gethostbyaddr
((char*)&
addr
, 4, 
AF_INET
);

171 if (
hp
 == 0) 
	`__err_connect
("gethost");

173 
server
.
sin_addr
.
s_addr
 = *((unsigned long*)
hp
->
h_addr
);

174 
server
.
sin_family
= 
AF_INET
;

175 
server
.
sin_port
 = 
	`htons
(
	`atoi
(
port
));

176 if (
	`connect
(
fd
, (struct 
sockaddr
*)&
server
, sizeof(server)) != 0) 
	`__err_connect
("connect");

178 return 
fd
;

179 
	}
}

182 static 
off_t
 
	$my_netread
(int 
fd
, void *
buf
, 
off_t
 
len
)

184 
off_t
 
rest
 = 
len
, 
curr
, 
l
 = 0;

187 while (
rest
) {

188 if (
	`socket_wait
(
fd
, 1) <= 0) break;

189 
curr
 = 
	`netread
(
fd
, 
buf
 + 
l
, 
rest
);

194 if (
curr
 == 0) break;

195 
l
 += 
curr
; 
rest
 -= curr;

197 return 
l
;

198 
	}
}

204 static int 
	$kftp_get_response
(
knetFile
 *
ftp
)

206 #ifndef 
_WIN32


207 unsigned char 
c
;

209 char 
c
;

211 int 
n
 = 0;

212 char *
p
;

213 if (
	`socket_wait
(
ftp
->
ctrl_fd
, 1) <= 0) return 0;

214 while (
	`netread
(
ftp
->
ctrl_fd
, &
c
, 1)) {

216 if (
n
 >= 
ftp
->
max_response
) {

217 
ftp
->
max_response
 = ftp->max_response? ftp->max_response<<1 : 256;

218 
ftp
->
response
 = (char*)
	`realloc
(ftp->response, ftp->
max_response
);

220 
ftp
->
response
[
n
++] = 
c
;

221 if (
c
 == '\n') {

222 if (
n
 >= 4 && 
	`isdigit
(
ftp
->
response
[0]) && isdigit(ftp->response[1]) && isdigit(ftp->response[2])

223 && 
ftp
->
response
[3] != '-') break;

224 
n
 = 0;

228 if (
n
 < 2) return -1;

229 
ftp
->
response
[
n
-2] = 0;

230 return 
	`strtol
(
ftp
->
response
, &
p
, 0);

231 
	}
}

233 static int 
	$kftp_send_cmd
(
knetFile
 *
ftp
, const char *
cmd
, int 
is_get
)

235 if (
	`socket_wait
(
ftp
->
ctrl_fd
, 0) <= 0) return -1;

236 
	`netwrite
(
ftp
->
ctrl_fd
, 
cmd
, 
	`strlen
(cmd));

237 return 
is_get
? 
	`kftp_get_response
(
ftp
) : 0;

238 
	}
}

240 static int 
	$kftp_pasv_prep
(
knetFile
 *
ftp
)

242 char *
p
;

243 int 
v
[6];

244 
	`kftp_send_cmd
(
ftp
, "PASV\r\n", 1);

245 for (
p
 = 
ftp
->
response
; *p && *p != '('; ++p);

246 if (*
p
 != '(') return -1;

247 ++
p
;

248 
	`sscanf
(
p
, "%d,%d,%d,%d,%d,%d", &
v
[0], &v[1], &v[2], &v[3], &v[4], &v[5]);

249 
	`memcpy
(
ftp
->
pasv_ip
, 
v
, 4 * sizeof(int));

250 
ftp
->
pasv_port
 = (
v
[4]<<8&0xff00) + v[5];

252 
	}
}

255 static int 
	$kftp_pasv_connect
(
knetFile
 *
ftp
)

257 char 
host
[80], 
port
[10];

258 if (
ftp
->
pasv_port
 == 0) {

259 
	`fprintf
(
stderr
, "[kftp_pasv_connect] kftp_pasv_prep() is not called before hand.\n");

262 
	`sprintf
(
host
, "%d.%d.%d.%d", 
ftp
->
pasv_ip
[0], ftp->pasv_ip[1], ftp->pasv_ip[2], ftp->pasv_ip[3]);

263 
	`sprintf
(
port
, "%d", 
ftp
->
pasv_port
);

264 
ftp
->
fd
 = 
	`socket_connect
(
host
, 
port
);

265 if (
ftp
->
fd
 == -1) return -1;

267 
	}
}

269 int 
	$kftp_connect
(
knetFile
 *
ftp
)

271 
ftp
->
ctrl_fd
 = 
	`socket_connect
(ftp->
host
, ftp->
port
);

272 if (
ftp
->
ctrl_fd
 == -1) return -1;

273 
	`kftp_get_response
(
ftp
);

274 
	`kftp_send_cmd
(
ftp
, "USER anonymous\r\n", 1);

275 
	`kftp_send_cmd
(
ftp
, "PASS kftp@\r\n", 1);

276 
	`kftp_send_cmd
(
ftp
, "TYPE I\r\n", 1);

278 
	}
}

280 int 
	$kftp_reconnect
(
knetFile
 *
ftp
)

282 if (
ftp
->
ctrl_fd
 != -1) {

283 
	`netclose
(
ftp
->
ctrl_fd
);

284 
ftp
->
ctrl_fd
 = -1;

286 
	`netclose
(
ftp
->
fd
);

287 
ftp
->
fd
 = -1;

288 return 
	`kftp_connect
(
ftp
);

289 
	}
}

292 
knetFile
 *
	$kftp_parse_url
(const char *
fn
, const char *
mode
)

294 
knetFile
 *
fp
;

295 char *
p
;

296 int 
l
;

297 if (
	`strstr
(
fn
, "ftp://") != fn) return 0;

298 for (
p
 = (char*)
fn
 + 6; *p && *p != '/'; ++p);

299 if (*
p
 != '/') return 0;

300 
l
 = 
p
 - 
fn
 - 6;

301 
fp
 = (
knetFile
*)
	`calloc
(1, sizeof(knetFile));

302 
fp
->
type
 = 
KNF_TYPE_FTP
;

303 
fp
->
fd
 = -1;

306 
fp
->
port
 = 
	`strdup
("21");

307 
fp
->
host
 = (char*)
	`calloc
(
l
 + 1, 1);

308 if (
	`strchr
(
mode
, 'c')) 
fp
->
no_reconnect
 = 1;

309 
	`strncpy
(
fp
->
host
, 
fn
 + 6, 
l
);

310 
fp
->
retr
 = (char*)
	`calloc
(
	`strlen
(
p
) + 8, 1);

311 
	`sprintf
(
fp
->
retr
, "RETR %s\r\n", 
p
);

312 
fp
->
size_cmd
 = (char*)
	`calloc
(
	`strlen
(
p
) + 8, 1);

313 
	`sprintf
(
fp
->
size_cmd
, "SIZE %s\r\n", 
p
);

314 
fp
->
seek_offset
 = 0;

315 return 
fp
;

316 
	}
}

318 int 
	$kftp_connect_file
(
knetFile
 *
fp
)

320 int 
ret
;

321 long long 
file_size
;

322 if (
fp
->
fd
 != -1) {

323 
	`netclose
(
fp
->
fd
);

324 if (
fp
->
no_reconnect
) 
	`kftp_get_response
(fp);

326 
	`kftp_pasv_prep
(
fp
);

327 
	`kftp_send_cmd
(
fp
, fp->
size_cmd
, 1);

328 #ifndef 
_WIN32


329 if ( 
	`sscanf
(
fp
->
response
,"%*d %lld", &
file_size
) != 1 )

331 
	`fprintf
(
stderr
,"[kftp_connect_file] %s\n", 
fp
->
response
);

335 const char *
p
 = 
fp
->
response
;

336 while (*
p
 != ' ') ++p;

337 while (*
p
 < '0' || *p > '9') ++p;

338 
file_size
 = 
	`strtoint64
(
p
);

340 
fp
->
file_size
 = file_size;

341 if (
fp
->
offset
>=0) {

342 char 
tmp
[32];

343 #ifndef 
_WIN32


344 
	`sprintf
(
tmp
, "REST %lld\r\n", (long long)
fp
->
offset
);

346 
	`strcpy
(
tmp
, "REST ");

347 
	`int64tostr
(
tmp
 + 5, 
fp
->
offset
);

348 
	`strcat
(
tmp
, "\r\n");

350 
	`kftp_send_cmd
(
fp
, 
tmp
, 1);

352 
	`kftp_send_cmd
(
fp
, fp->
retr
, 0);

353 
	`kftp_pasv_connect
(
fp
);

354 
ret
 = 
	`kftp_get_response
(
fp
);

355 if (
ret
 != 150) {

356 
	`fprintf
(
stderr
, "[kftp_connect_file] %s\n", 
fp
->
response
);

357 
	`netclose
(
fp
->
fd
);

358 
fp
->
fd
 = -1;

361 
fp
->
is_ready
 = 1;

363 
	}
}

370 
knetFile
 *
	$khttp_parse_url
(const char *
fn
, const char *
mode
)

372 
knetFile
 *
fp
;

373 char *
p
, *
proxy
, *
q
;

374 int 
l
;

375 if (
	`strstr
(
fn
, "http://") != fn) return 0;

377 for (
p
 = (char*)
fn
 + 7; *p && *p != '/'; ++p);

378 
l
 = 
p
 - 
fn
 - 7;

379 
fp
 = (
knetFile
*)
	`calloc
(1, sizeof(knetFile));

380 
fp
->
http_host
 = (char*)
	`calloc
(
l
 + 1, 1);

381 
	`strncpy
(
fp
->
http_host
, 
fn
 + 7, 
l
);

382 
fp
->
http_host
[
l
] = 0;

383 for (
q
 = 
fp
->
http_host
; *q && *q != ':'; ++q);

384 if (*
q
 == ':') *q++ = 0;

386 
proxy
 = 
	`getenv
("http_proxy");

388 if (
proxy
 == 0) {

389 
fp
->
host
 = 
	`strdup
(fp->
http_host
);

390 
fp
->
port
 = 
	`strdup
(*
q
? q : "80");

391 
fp
->
path
 = 
	`strdup
(*
p
? p : "/");

393 
fp
->
host
 = (
	`strstr
(
proxy
, "http://") == proxy)? 
	`strdup
(proxy + 7) : strdup(proxy);

394 for (
q
 = 
fp
->
host
; *q && *q != ':'; ++q);

395 if (*
q
 == ':') *q++ = 0;

396 
fp
->
port
 = 
	`strdup
(*
q
? q : "80");

397 
fp
->
path
 = 
	`strdup
(
fn
);

399 
fp
->
type
 = 
KNF_TYPE_HTTP
;

400 
fp
->
ctrl_fd
 = fp->
fd
 = -1;

401 
fp
->
seek_offset
 = 0;

402 return 
fp
;

403 
	}
}

405 int 
	$khttp_connect_file
(
knetFile
 *
fp
)

407 int 
ret
, 
l
 = 0;

408 char *
buf
, *
p
;

409 if (
fp
->
fd
 != -1) 
	`netclose
(fp->fd);

410 
fp
->
fd
 = 
	`socket_connect
(fp->
host
, fp->
port
);

411 
buf
 = (char*)
	`calloc
(0x10000, 1);

412 
l
 += 
	`sprintf
(
buf
 + l, "GET %s HTTP/1.0\r\nHost: %s\r\n", 
fp
->
path
, fp->
http_host
);

413 
l
 += 
	`sprintf
(
buf
 + l, "Range: bytes=%lld-\r\n", (long long)
fp
->
offset
);

414 
l
 += 
	`sprintf
(
buf
 + l, "\r\n");

415 
	`netwrite
(
fp
->
fd
, 
buf
, 
l
);

416 
l
 = 0;

417 while (
	`netread
(
fp
->
fd
, 
buf
 + 
l
, 1)) {

418 if (
buf
[
l
] == '\n' && l >= 3)

419 if (
	`strncmp
(
buf
 + 
l
 - 3, "\r\n\r\n", 4) == 0) break;

420 ++
l
;

422 
buf
[
l
] = 0;

423 if (
l
 < 14) {

424 
	`netclose
(
fp
->
fd
);

425 
fp
->
fd
 = -1;

428 
ret
 = 
	`strtol
(
buf
 + 8, &
p
, 0);

429 if (
ret
 == 200 && 
fp
->
offset
>0) {

430 
off_t
 
rest
 = 
fp
->
offset
;

431 while (
rest
) {

432 
off_t
 
l
 = 
rest
 < 0x10000? rest : 0x10000;

433 
rest
 -= 
	`my_netread
(
fp
->
fd
, 
buf
, 
l
);

435 } else if (
ret
 != 206 && ret != 200) {

436 
	`free
(
buf
);

437 
	`fprintf
(
stderr
, "[khttp_connect_file] fail to open file (HTTP code: %d).\n", 
ret
);

438 
	`netclose
(
fp
->
fd
);

439 
fp
->
fd
 = -1;

442 
	`free
(
buf
);

443 
fp
->
is_ready
 = 1;

445 
	}
}

451 
knetFile
 *
	$knet_open
(const char *
fn
, const char *
mode
)

453 
knetFile
 *
fp
 = 0;

454 if (
mode
[0] != 'r') {

455 
	`fprintf
(
stderr
, "[kftp_open] only mode \"r\" is supported.\n");

458 if (
	`strstr
(
fn
, "ftp://") == fn) {

459 
fp
 = 
	`kftp_parse_url
(
fn
, 
mode
);

460 if (
fp
 == 0) return 0;

461 if (
	`kftp_connect
(
fp
) == -1) {

462 
	`knet_close
(
fp
);

465 
	`kftp_connect_file
(
fp
);

466 } else if (
	`strstr
(
fn
, "http://") == fn) {

467 
fp
 = 
	`khttp_parse_url
(
fn
, 
mode
);

468 if (
fp
 == 0) return 0;

469 
	`khttp_connect_file
(
fp
);

471 #ifdef 
_WIN32


475 int 
fd
 = 
	`open
(
fn
, 
O_RDONLY
 | 
O_BINARY
);

477 int 
fd
 = 
	`open
(
fn
, 
O_RDONLY
);

479 if (
fd
 == -1) {

480 
	`perror
("open");

483 
fp
 = (
knetFile
*)
	`calloc
(1, sizeof(knetFile));

484 
fp
->
type
 = 
KNF_TYPE_LOCAL
;

485 
fp
->
fd
 = fd;

486 
fp
->
ctrl_fd
 = -1;

488 if (
fp
 && fp->
fd
 == -1) {

489 
	`knet_close
(
fp
);

492 return 
fp
;

493 
	}
}

495 
knetFile
 *
	$knet_dopen
(int 
fd
, const char *
mode
)

497 
knetFile
 *
fp
 = (knetFile*)
	`calloc
(1, sizeof(knetFile));

498 
fp
->
type
 = 
KNF_TYPE_LOCAL
;

499 
fp
->
fd
 = fd;

500 return 
fp
;

501 
	}
}

503 
off_t
 
	$knet_read
(
knetFile
 *
fp
, void *
buf
, 
off_t
 
len
)

505 
off_t
 
l
 = 0;

506 if (
fp
->
fd
 == -1) return 0;

507 if (
fp
->
type
 == 
KNF_TYPE_FTP
) {

508 if (
fp
->
is_ready
 == 0) {

509 if (!
fp
->
no_reconnect
) 
	`kftp_reconnect
(fp);

510 
	`kftp_connect_file
(
fp
);

512 } else if (
fp
->
type
 == 
KNF_TYPE_HTTP
) {

513 if (
fp
->
is_ready
 == 0)

514 
	`khttp_connect_file
(
fp
);

516 if (
fp
->
type
 == 
KNF_TYPE_LOCAL
) {

517 
off_t
 
rest
 = 
len
, 
curr
;

518 while (
rest
) {

520 
curr
 = 
	`read
(
fp
->
fd
, 
buf
 + 
l
, 
rest
);

521 } while (
curr
 < 0 && 
EINTR
 == 
errno
);

522 if (
curr
 < 0) return -1;

523 if (
curr
 == 0) break;

524 
l
 += 
curr
; 
rest
 -= curr;

526 } else 
l
 = 
	`my_netread
(
fp
->
fd
, 
buf
, 
len
);

527 
fp
->
offset
 += 
l
;

528 return 
l
;

529 
	}
}

531 
off_t
 
	$knet_seek
(
knetFile
 *
fp
, 
int64_t
 
off
, int 
whence
)

533 if (
whence
 == 
SEEK_SET
 && 
off
 == 
fp
->
offset
) return 0;

534 if (
fp
->
type
 == 
KNF_TYPE_LOCAL
) {

537 
off_t
 
offset
 = 
	`lseek
(
fp
->
fd
, 
off
, 
whence
);

538 if (
offset
 == -1) {

543 
fp
->
offset
 = offset;

544 return 
off
;

545 } else if (
fp
->
type
 == 
KNF_TYPE_FTP
) {

546 if (
whence
==
SEEK_CUR
)

547 
fp
->
offset
 += 
off
;

548 else if (
whence
==
SEEK_SET
)

549 
fp
->
offset
 = 
off
;

550 else if ( 
whence
==
SEEK_END
)

551 
fp
->
offset
 = fp->
file_size
+
off
;

552 
fp
->
is_ready
 = 0;

553 return 
off
;

554 } else if (
fp
->
type
 == 
KNF_TYPE_HTTP
) {

555 if (
whence
 == 
SEEK_END
) {

556 
	`fprintf
(
stderr
, "[knet_seek] SEEK_END is not supported for HTTP. Offset is unchanged.\n");

557 
errno
 = 
ESPIPE
;

560 if (
whence
==
SEEK_CUR
)

561 
fp
->
offset
 += 
off
;

562 else if (
whence
==
SEEK_SET
)

563 
fp
->
offset
 = 
off
;

564 
fp
->
is_ready
 = 0;

565 return 
off
;

567 
errno
 = 
EINVAL
;

568 
	`fprintf
(
stderr
,"[knet_seek] %s\n", 
	`strerror
(
errno
));

570 
	}
}

572 int 
	$knet_close
(
knetFile
 *
fp
)

574 if (
fp
 == 0) return 0;

575 if (
fp
->
ctrl_fd
 != -1) 
	`netclose
(fp->ctrl_fd);

576 if (
fp
->
fd
 != -1) {

579 if (
fp
->
type
 == 
KNF_TYPE_LOCAL
) 
	`close
(fp->
fd
);

580 else 
	`netclose
(
fp
->
fd
);

582 
	`free
(
fp
->
host
); free(fp->
port
);

583 
	`free
(
fp
->
response
); free(fp->
retr
);

584 
	`free
(
fp
->
path
); free(fp->
http_host
);

585 
	`free
(
fp
);

587 
	}
}

589 #ifdef 
KNETFILE_MAIN


590 int 
	$main
(void)

592 char *
buf
;

593 
knetFile
 *
fp
;

594 int 
type
 = 4, 
l
;

595 #ifdef 
_WIN32


596 
	`knet_win32_init
();

598 
buf
 = 
	`calloc
(0x100000, 1);

599 if (
type
 == 0) {

600 
fp
 = 
	`knet_open
("knetfile.c", "r");

601 
	`knet_seek
(
fp
, 1000, 
SEEK_SET
);

602 } else if (
type
 == 1) {

603 
fp
 = 
	`knet_open
("ftp://ftp.ncbi.nih.gov/1000genomes/ftp/data/NA12878/alignment/NA12878.chrom6.SLX.SRP000032.2009_06.bam", "r");

604 
	`knet_seek
(
fp
, 2500000000ll, 
SEEK_SET
);

605 
l
 = 
	`knet_read
(
fp
, 
buf
, 255);

606 } else if (
type
 == 2) {

607 
fp
 = 
	`knet_open
("ftp://ftp.sanger.ac.uk/pub4/treefam/tmp/index.shtml", "r");

608 
	`knet_seek
(
fp
, 1000, 
SEEK_SET
);

609 } else if (
type
 == 3) {

610 
fp
 = 
	`knet_open
("http://www.sanger.ac.uk/Users/lh3/index.shtml", "r");

611 
	`knet_seek
(
fp
, 1000, 
SEEK_SET
);

612 } else if (
type
 == 4) {

613 
fp
 = 
	`knet_open
("http://www.sanger.ac.uk/Users/lh3/ex1.bam", "r");

614 
	`knet_read
(
fp
, 
buf
, 10000);

615 
	`knet_seek
(
fp
, 20000, 
SEEK_SET
);

616 
	`knet_seek
(
fp
, 10000, 
SEEK_SET
);

617 
l
 = 
	`knet_read
(
fp
, 
buf
+10000, 10000000) + 10000;

619 if (
type
 != 4 && type != 1) {

620 
	`knet_read
(
fp
, 
buf
, 255);

621 
buf
[255] = 0;

622 
	`printf
("%s\n", 
buf
);

623 } else 
	`write
(
	`fileno
(
stdout
), 
buf
, 
l
);

624 
	`knet_close
(
fp
);

625 
	`free
(
buf
);

627 
	}
}

	@deps/klib/knetfile.h

1 #ifndef 
KNETFILE_H


2 #define 
	#KNETFILE_H


	)

4 #include 
	~<stdint.h
>

5 #include 
	~<fcntl.h
>

7 #ifndef 
_WIN32


8 #define 
	#netread
(
fd
, 
ptr
, 
len
) 
	`read
(fd, ptr, len)

	)

9 #define 
	#netwrite
(
fd
, 
ptr
, 
len
) 
	`write
(fd, ptr, len)

	)

10 #define 
	#netclose
(
fd
) 
	`close
(fd)

	)

12 #include 
	~<winsock2.h
>

13 #define 
	#netread
(
fd
, 
ptr
, 
len
) 
	`recv
(fd, ptr, len, 0)

	)

14 #define 
	#netwrite
(
fd
, 
ptr
, 
len
) 
	`send
(fd, ptr, len, 0)

	)

15 #define 
	#netclose
(
fd
) 
	`closesocket
(fd)

	)

20 #define 
	#KNF_TYPE_LOCAL
 1

	)

21 #define 
	#KNF_TYPE_FTP
 2

	)

22 #define 
	#KNF_TYPE_HTTP
 3

	)

24 typedef struct 
	sknetFile_s
 {

25 int 
	mtype
, 
	mfd
;

26 
int64_t
 
	moffset
;

27 char *
	mhost
, *
	mport
;

30 int 
	mctrl_fd
, 
	mpasv_ip
[4], 
	mpasv_port
, 
	mmax_response
, 
	mno_reconnect
, 
	mis_ready
;

31 char *
	mresponse
, *
	mretr
, *
	msize_cmd
;

32 
int64_t
 
	mseek_offset
;

33 
int64_t
 
	mfile_size
;

36 char *
	mpath
, *
	mhttp_host
;

37 } 
	tknetFile
;

39 #define 
	#knet_tell
(
fp
) ((fp)->
offset
)

	)

40 #define 
	#knet_fileno
(
fp
) ((fp)->
fd
)

	)

42 #ifdef 
__cplusplus


46 #ifdef 
_WIN32


47 int 
knet_win32_init
();

48 void 
knet_win32_destroy
();

51 
knetFile
 *
knet_open
(const char *
fn
, const char *
mode
);

56 
knetFile
 *
knet_dopen
(int 
fd
, const char *
mode
);

62 
off_t
 
knet_read
(
knetFile
 *
fp
, void *
buf
, off_t 
len
);

68 
off_t
 
knet_seek
(
knetFile
 *
fp
, 
int64_t
 
off
, int 
whence
);

69 int 
knet_close
(
knetFile
 *
fp
);

71 #ifdef 
__cplusplus


	@deps/klib/knhx.c

1 #include 
	~<ctype.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<string.h
>

5 #include 
	~"knhx.h
"

8 int 
	merror
, 
	mn
, 
	mmax
;

9 
knhx1_t
 *
	mnode
;

10 } 
	tknaux_t
;

12 static 
inline
 char *
	$add_node
(const char *
s
, 
knaux_t
 *
aux
, int 
x
)

14 char *
p
, *
nbeg
, *
nend
 = 0;

15 
knhx1_t
 *
r
;

16 if (
aux
->
n
 == aux->
max
) {

17 
aux
->
max
 = aux->max? aux->max<<1 : 8;

18 
aux
->
node
 = (
knhx1_t
*)
	`realloc
(aux->node, sizeof(knhx1_t) * aux->
max
);

20 
r
 = 
aux
->
node
 + (aux->
n
++);

21 
r
->
n
 = 
x
; r->
parent
 = -1;

22 for (
p
 = (char*)
s
, 
nbeg
 = p, 
r
->
d
 = -1.0; *p && *p != ',' && *p != ')'; ++p) {

23 if (*
p
 == '[') {

24 if (
nend
 == 0) nend = 
p
;

25 do ++
p
; while (*p && *p != ']');

26 if (*
p
 == 0) {

27 
aux
->
error
 |= 
KNERR_BRACKET
;

30 } else if (*
p
 == ':') {

31 if (
nend
 == 0) nend = 
p
;

32 
r
->
d
 = 
	`strtod
(
p
 + 1, &p);

33 --
p
;

34 } else if (!
	`isgraph
(*
p
)) if (
nend
 == 0) nend = p;

36 if (
nend
 == 0) nend = 
p
;

37 if (
nend
 != 
nbeg
) {

38 
r
->
name
 = (char*)
	`calloc
(
nend
 - 
nbeg
 + 1, 1);

39 
	`strncpy
(
r
->
name
, 
nbeg
, 
nend
 - nbeg);

40 } else 
r
->
name
 = 
	`strdup
("");

41 return 
p
;

42 
	}
}

44 
knhx1_t
 *
	$kn_parse
(const char *
nhx
, int *
_n
, int *
_error
)

46 char *
p
;

47 int *
stack
, 
top
, 
max
;

48 
knaux_t
 *
aux
;

49 
knhx1_t
 *
ret
;

51 #define 
	#__push_back
(
y
) do { \

52 if (
top
 == 
max
) { \

53 
max
 = max? max<<1 : 16; \

54 
stack
 = (int*)
	`realloc
(stack, sizeof(int) * 
max
); \

56 
stack
[
top
++] = (
y
); \

58 

	)

59 
stack
 = 0; 
top
 = 
max
 = 0;

60 
p
 = (char*)
nhx
;

61 
aux
 = (
knaux_t
*)
	`calloc
(1, sizeof(knaux_t));

62 while (*
p
) {

63 while (*
p
 && !
	`isgraph
(*p)) ++p;

64 if (*
p
 == 0) break;

65 if (*
p
 == ',') ++p;

66 else if (*
p
 == '(') {

67 
	`__push_back
(-1);

68 ++
p
;

69 } else if (*
p
 == ')') {

70 int 
x
 = 
aux
->
n
, 
m
, 
i
;

71 for (
i
 = 
top
 - 1; i >= 0; --i)

72 if (
stack
[
i
] < 0) break;

73 
m
 = 
top
 - 1 - 
i
;

74 
p
 = 
	`add_node
(p + 1, 
aux
, 
m
);

75 
aux
->
node
[
x
].
child
 = (int*)
	`calloc
(
m
, sizeof(int));

76 for (
i
 = 
top
 - 1, 
m
 = m - 1; m >= 0; --m, --i) {

77 
aux
->
node
[
x
].
child
[
m
] = 
stack
[
i
];

78 
aux
->
node
[
stack
[
i
]].
parent
 = 
x
;

80 
top
 = 
i
;

81 
	`__push_back
(
x
);

83 
	`__push_back
(
aux
->
n
);

84 
p
 = 
	`add_node
(p, 
aux
, 0);

87 *
_n
 = 
aux
->
n
;

88 *
_error
 = 
aux
->
error
;

89 
ret
 = 
aux
->
node
;

90 
	`free
(
aux
); free(
stack
);

91 return 
ret
;

92 
	}
}

94 #ifndef 
kroundup32


95 #define 
	#kroundup32
(
x
) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

	)

98 static 
inline
 int 
	$kputsn
(const char *
p
, int 
l
, 
kstring_t
 *
s
)

100 if (
s
->
l
 + l + 1 >= s->
m
) {

101 
s
->
m
 = s->
l
 + l + 2;

102 
	`kroundup32
(
s
->
m
);

103 
s
->s = (char*)
	`realloc
(s->s, s->
m
);

105 
	`memcpy
(
s
->s + s->
l
, 
p
, l);

106 
s
->
l
 += l; s->s[s->l] = 0;

107 return 
l
;

108 
	}
}

110 static 
inline
 int 
	$kputc
(int 
c
, 
kstring_t
 *
s
)

112 if (
s
->
l
 + 1 >= s->
m
) {

113 
s
->
m
 = s->
l
 + 2;

114 
	`kroundup32
(
s
->
m
);

115 
s
->s = (char*)
	`realloc
(s->s, s->
m
);

117 
s
->s[s->
l
++] = 
c
; s->s[s->l] = 0;

118 return 
c
;

119 
	}
}

121 static void 
	$format_node_recur
(const 
knhx1_t
 *
node
, const knhx1_t *
p
, 
kstring_t
 *
s
, char *
numbuf
)

123 if (
p
->
n
) {

124 int 
i
;

125 
	`kputc
('(', 
s
);

126 for (
i
 = 0; i < 
p
->
n
; ++i) {

127 if (
i
) 
	`kputc
(',', 
s
);

128 
	`format_node_recur
(
node
, &node[
p
->
child
[
i
]], 
s
, 
numbuf
);

130 
	`kputc
(')', 
s
);

131 if (
p
->
name
) 
	`kputsn
(p->name, 
	`strlen
(p->name), 
s
);

132 if (
p
->
d
 >= 0) {

133 
	`sprintf
(
numbuf
, ":%g", 
p
->
d
);

134 
	`kputsn
(
numbuf
, 
	`strlen
(numbuf), 
s
);

137 
	`kputsn
(
p
->
name
, 
	`strlen
(p->name), 
s
);

138 if (
p
->
d
 >= 0) {

139 
	`sprintf
(
numbuf
, ":%g", 
p
->
d
);

140 
	`kputsn
(
numbuf
, 
	`strlen
(numbuf), 
s
);

143 
	}
}

145 void 
	$kn_format
(const 
knhx1_t
 *
node
, int 
root
, 
kstring_t
 *
s
)

147 char 
numbuf
[128];

148 
	`format_node_recur
(
node
, &node[
root
], 
s
, 
numbuf
);

149 
	}
}

151 #ifdef 
KNHX_MAIN


152 int 
	$main
(int 
argc
, char *
argv
[])

154 char *
s
 = "((a[abc],d1)x:0.5,((b[&&NHX:S=MOUSE],h2)[&&NHX:S=HUMAN:B=99][blabla][&&NHX:K=foo],c))";

155 
knhx1_t
 *
node
;

156 int 
i
, 
j
, 
n
, 
error
;

157 
kstring_t
 
str
;

158 
node
 = 
	`kn_parse
(
s
, &
n
, &
error
);

159 for (
i
 = 0; i < 
n
; ++i) {

160 
knhx1_t
 *
p
 = 
node
 + 
i
;

161 
	`printf
("[%d] %s\t%d\t%d\t%g", 
i
, 
p
->
name
, p->
parent
, p->
n
, p->
d
);

162 for (
j
 = 0; j < 
p
->
n
; ++j)

163 
	`printf
("\t%d", 
p
->
child
[
j
]);

164 
	`putchar
('\n');

166 
str
.
l
 = str.
m
 = 0; str.
s
 = 0;

167 
	`kn_format
(
node
, 
n
-1, &
str
);

168 
	`puts
(
str
.
s
);

169 
	`free
(
str
.
s
);

171 
	}
}

	@deps/klib/knhx.h

1 #ifndef 
KNHX_H_


2 #define 
	#KNHX_H_


	)

4 #define 
	#KNERR_MISSING_LEFT
 0x01

	)

5 #define 
	#KNERR_MISSING_RGHT
 0x02

	)

6 #define 
	#KNERR_BRACKET
 0x04

	)

7 #define 
	#KNERR_COLON
 0x08

	)

10 int 
	mparent
, 
	mn
;

11 int *
	mchild
;

12 char *
	mname
;

13 double 
	md
;

14 } 
	tknhx1_t
;

16 #ifndef 
KSTRING_T


17 #define 
	#KSTRING_T
 
kstring_t


	)

18 typedef struct 
	s__kstring_t
 {

19 
size_t
 
	ml
, 
	mm
;

20 char *
	ms
;

21 } 
	tkstring_t
;

24 #ifdef 
__cplusplus


28 
knhx1_t
 *
kn_parse
(const char *
nhx
, int *
_n
, int *
_error
);

29 void 
kn_format
(const 
knhx1_t
 *
node
, int 
root
, 
kstring_t
 *
s
);

31 #ifdef 
__cplusplus


	@deps/klib/kopen.c

1 #include 
	~<stdio.h
>

2 #include 
	~<fcntl.h
>

3 #include 
	~<errno.h
>

4 #include 
	~<ctype.h
>

5 #include 
	~<unistd.h
>

6 #include 
	~<string.h
>

7 #include 
	~<stdlib.h
>

8 #include 
	~<signal.h
>

9 #include 
	~<sys/types.h
>

10 #ifndef 
_WIN32


11 #include 
	~<netdb.h
>

12 #include 
	~<arpa/inet.h
>

13 #include 
	~<sys/socket.h
>

16 #ifdef 
_WIN32


17 #define 
	#_KO_NO_NET


	)

20 #ifndef 
_KO_NO_NET


21 static int 
	$socket_wait
(int 
fd
, int 
is_read
)

23 
fd_set
 
fds
, *
fdr
 = 0, *
fdw
 = 0;

24 struct 
timeval
 
tv
;

25 int 
ret
;

26 
tv
.
tv_sec
 = 5; tv.
tv_usec
 = 0;

27 
	`FD_ZERO
(&
fds
);

28 
	`FD_SET
(
fd
, &
fds
);

29 if (
is_read
) 
fdr
 = &
fds
;

30 else 
fdw
 = &
fds
;

31 
ret
 = 
	`select
(
fd
+1, 
fdr
, 
fdw
, 0, &
tv
);

32 if (
ret
 == -1) 
	`perror
("select");

33 return 
ret
;

34 
	}
}

36 static int 
	$socket_connect
(const char *
host
, const char *
port
)

38 #define 
	#__err_connect
(
func
) do { 
	`perror
(func); 
	`freeaddrinfo
(
res
); return -1; } while (0)

	)

40 int 
ai_err
, 
on
 = 1, 
fd
;

41 struct 
linger
 
lng
 = { 0, 0 };

42 struct 
addrinfo
 
hints
, *
res
 = 0;

43 
	`memset
(&
hints
, 0, sizeof(struct 
addrinfo
));

44 
hints
.
ai_family
 = 
AF_UNSPEC
;

45 
hints
.
ai_socktype
 = 
SOCK_STREAM
;

46 if ((
ai_err
 = 
	`getaddrinfo
(
host
, 
port
, &
hints
, &
res
)) != 0) { 
	`fprintf
(
stderr
, "can't resolve %s:%s: %s\n", host, port, 
	`gai_strerror
(ai_err)); return -1; }

47 if ((
fd
 = 
	`socket
(
res
->
ai_family
, res->
ai_socktype
, res->
ai_protocol
)) == -1) 
	`__err_connect
("socket");

48 if (
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_REUSEADDR
, &
on
, sizeof(on)) == -1) 
	`__err_connect
("setsockopt");

49 if (
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_LINGER
, &
lng
, sizeof(lng)) == -1) 
	`__err_connect
("setsockopt");

50 if (
	`connect
(
fd
, 
res
->
ai_addr
, res->
ai_addrlen
) != 0) 
	`__err_connect
("connect");

51 
	`freeaddrinfo
(
res
);

52 return 
fd
;

53 #undef 
__err_connect


54 
	}
}

56 static int 
	$http_open
(const char *
fn
)

58 char *
p
, *
proxy
, *
q
, *
http_host
, *
host
, *
port
, *
path
, *
buf
;

59 int 
fd
, 
ret
, 
l
;

62 if (
	`strstr
(
fn
, "http://") != fn) return 0;

64 for (
p
 = (char*)
fn
 + 7; *p && *p != '/'; ++p);

65 
l
 = 
p
 - 
fn
 - 7;

66 
http_host
 = 
	`calloc
(
l
 + 1, 1);

67 
	`strncpy
(
http_host
, 
fn
 + 7, 
l
);

68 
http_host
[
l
] = 0;

69 for (
q
 = 
http_host
; *q && *q != ':'; ++q);

70 if (*
q
 == ':') *q++ = 0;

72 
proxy
 = 
	`getenv
("http_proxy");

74 if (
proxy
 == 0) {

75 
host
 = 
	`strdup
(
http_host
);

76 
port
 = 
	`strdup
(*
q
? q : "80");

77 
path
 = 
	`strdup
(*
p
? p : "/");

79 
host
 = (
	`strstr
(
proxy
, "http://") == proxy)? 
	`strdup
(proxy + 7) : strdup(proxy);

80 for (
q
 = 
host
; *q && *q != ':'; ++q);

81 if (*
q
 == ':') *q++ = 0;

82 
port
 = 
	`strdup
(*
q
? q : "80");

83 
path
 = 
	`strdup
(
fn
);

87 
l
 = 0;

88 
fd
 = 
	`socket_connect
(
host
, 
port
);

89 
buf
 = 
	`calloc
(0x10000, 1);

90 
l
 += 
	`sprintf
(
buf
 + l, "GET %s HTTP/1.0\r\nHost: %s\r\n", 
path
, 
http_host
);

91 
l
 += 
	`sprintf
(
buf
 + l, "\r\n");

92 
	`write
(
fd
, 
buf
, 
l
);

93 
l
 = 0;

94 while (
	`read
(
fd
, 
buf
 + 
l
, 1)) {

95 if (
buf
[
l
] == '\n' && l >= 3)

96 if (
	`strncmp
(
buf
 + 
l
 - 3, "\r\n\r\n", 4) == 0) break;

97 ++
l
;

99 
buf
[
l
] = 0;

100 if (
l
 < 14) {

101 
	`close
(
fd
);

102 
fd
 = -1;

104 
ret
 = 
	`strtol
(
buf
 + 8, &
p
, 0);

105 if (
ret
 != 200) {

106 
	`close
(
fd
);

107 
fd
 = -1;

109 
	`free
(
buf
); free(
http_host
); free(
host
); free(
port
); free(
path
);

110 return 
fd
;

111 
	}
}

114 int 
	mmax_response
, 
	mctrl_fd
;

115 char *
	mresponse
;

116 } 
	tftpaux_t
;

118 static int 
	$kftp_get_response
(
ftpaux_t
 *
aux
)

120 unsigned char 
c
;

121 int 
n
 = 0;

122 char *
p
;

123 if (
	`socket_wait
(
aux
->
ctrl_fd
, 1) <= 0) return 0;

124 while (
	`read
(
aux
->
ctrl_fd
, &
c
, 1)) {

125 if (
n
 >= 
aux
->
max_response
) {

126 
aux
->
max_response
 = aux->max_response? aux->max_response<<1 : 256;

127 
aux
->
response
 = 
	`realloc
(aux->response, aux->
max_response
);

129 
aux
->
response
[
n
++] = 
c
;

130 if (
c
 == '\n') {

131 if (
n
 >= 4 && 
	`isdigit
(
aux
->
response
[0]) && isdigit(aux->response[1]) && isdigit(aux->response[2])

132 && 
aux
->
response
[3] != '-') break;

133 
n
 = 0;

137 if (
n
 < 2) return -1;

138 
aux
->
response
[
n
-2] = 0;

139 return 
	`strtol
(
aux
->
response
, &
p
, 0);

140 
	}
}

142 static int 
	$kftp_send_cmd
(
ftpaux_t
 *
aux
, const char *
cmd
, int 
is_get
)

144 if (
	`socket_wait
(
aux
->
ctrl_fd
, 0) <= 0) return -1;

145 
	`write
(
aux
->
ctrl_fd
, 
cmd
, 
	`strlen
(cmd));

146 return 
is_get
? 
	`kftp_get_response
(
aux
) : 0;

147 
	}
}

149 static int 
	$ftp_open
(const char *
fn
)

151 char *
p
, *
host
 = 0, *
port
 = 0, *
retr
 = 0;

152 char 
host2
[80], 
port2
[10];

153 int 
v
[6], 
l
, 
fd
 = -1, 
ret
, 
pasv_port
, 
pasv_ip
[4];

154 
ftpaux_t
 
aux
;

157 if (
	`strstr
(
fn
, "ftp://") != fn) return 0;

158 for (
p
 = (char*)
fn
 + 6; *p && *p != '/'; ++p);

159 if (*
p
 != '/') return 0;

160 
l
 = 
p
 - 
fn
 - 6;

161 
port
 = 
	`strdup
("21");

162 
host
 = 
	`calloc
(
l
 + 1, 1);

163 
	`strncpy
(
host
, 
fn
 + 6, 
l
);

164 
retr
 = 
	`calloc
(
	`strlen
(
p
) + 8, 1);

165 
	`sprintf
(
retr
, "RETR %s\r\n", 
p
);

168 
	`memset
(&
aux
, 0, sizeof(
ftpaux_t
));

169 
aux
.
ctrl_fd
 = 
	`socket_connect
(
host
, 
port
);

170 if (
aux
.
ctrl_fd
 == -1) goto 
ftp_open_end
;

173 
	`kftp_get_response
(&
aux
);

174 
	`kftp_send_cmd
(&
aux
, "USER anonymous\r\n", 1);

175 
	`kftp_send_cmd
(&
aux
, "PASS kopen@\r\n", 1);

176 
	`kftp_send_cmd
(&
aux
, "TYPE I\r\n", 1);

177 
	`kftp_send_cmd
(&
aux
, "PASV\r\n", 1);

178 for (
p
 = 
aux
.
response
; *p && *p != '('; ++p);

179 if (*
p
 != '(') goto 
ftp_open_end
;

180 ++
p
;

181 
	`sscanf
(
p
, "%d,%d,%d,%d,%d,%d", &
v
[0], &v[1], &v[2], &v[3], &v[4], &v[5]);

182 
	`memcpy
(
pasv_ip
, 
v
, 4 * sizeof(int));

183 
pasv_port
 = (
v
[4]<<8&0xff00) + v[5];

184 
	`kftp_send_cmd
(&
aux
, 
retr
, 0);

185 
	`sprintf
(
host2
, "%d.%d.%d.%d", 
pasv_ip
[0], pasv_ip[1], pasv_ip[2], pasv_ip[3]);

186 
	`sprintf
(
port2
, "%d", 
pasv_port
);

187 
fd
 = 
	`socket_connect
(
host2
, 
port2
);

188 if (
fd
 == -1) goto 
ftp_open_end
;

189 
ret
 = 
	`kftp_get_response
(&
aux
);

190 if (
ret
 != 150) {

191 
	`close
(
fd
);

192 
fd
 = -1;

194 
	`close
(
aux
.
ctrl_fd
);

196 
ftp_open_end
:

197 
	`free
(
host
); free(
port
); free(
retr
); free(
aux
.
response
);

198 return 
fd
;

199 
	}
}

202 static char **
	$cmd2argv
(const char *
cmd
)

204 int 
i
, 
beg
, 
end
, 
argc
;

205 char **
argv
, *
p
, *
q
, *
str
;

206 
end
 = 
	`strlen
(
cmd
);

207 for (
i
 = 
end
 - 1; i >= 0; --i)

208 if (!
	`isspace
(
cmd
[
i
])) break;

209 
end
 = 
i
 + 1;

210 for (
beg
 = 0; beg < 
end
; ++beg)

211 if (!
	`isspace
(
cmd
[
beg
])) break;

212 if (
beg
 == 
end
) return 0;

213 for (
i
 = 
beg
 + 1, 
argc
 = 0; i < 
end
; ++i)

214 if (
	`isspace
(
cmd
[
i
]) && !isspace(cmd[i-1]))

215 ++
argc
;

216 
argv
 = (char**)
	`calloc
(
argc
 + 2, sizeof(void*));

217 
argv
[0] = 
str
 = (char*)
	`calloc
(
end
 - 
beg
 + 1, 1);

218 
	`strncpy
(
argv
[0], 
cmd
 + 
beg
, 
end
 - beg);

219 for (
i
 = 
argc
 = 1, 
q
 = 
p
 = 
str
; i < 
end
 - 
beg
; ++i)

220 if (
	`isspace
(
str
[
i
])) str[i] = 0;

221 else if (
str
[
i
] && str[i-1] == 0) 
argv
[
argc
++] = &str[i];

222 return 
argv
;

223 
	}
}

225 #define 
	#KO_STDIN
 1

	)

226 #define 
	#KO_FILE
 2

	)

227 #define 
	#KO_PIPE
 3

	)

228 #define 
	#KO_HTTP
 4

	)

229 #define 
	#KO_FTP
 5

	)

232 int 
	mtype
, 
	mfd
;

233 
pid_t
 
	mpid
;

234 } 
	tkoaux_t
;

236 void *
	$kopen
(const char *
fn
, int *
_fd
)

238 
koaux_t
 *
aux
 = 0;

239 *
_fd
 = -1;

240 if (
	`strstr
(
fn
, "http://") == fn) {

241 
aux
 = 
	`calloc
(1, sizeof(
koaux_t
));

242 
aux
->
type
 = 
KO_HTTP
;

243 
aux
->
fd
 = 
	`http_open
(
fn
);

244 } else if (
	`strstr
(
fn
, "ftp://") == fn) {

245 
aux
 = 
	`calloc
(1, sizeof(
koaux_t
));

246 
aux
->
type
 = 
KO_FTP
;

247 
aux
->
fd
 = 
	`ftp_open
(
fn
);

248 } else if (
	`strcmp
(
fn
, "-") == 0) {

249 
aux
 = 
	`calloc
(1, sizeof(
koaux_t
));

250 
aux
->
type
 = 
KO_STDIN
;

251 
aux
->
fd
 = 
STDIN_FILENO
;

253 const char *
p
, *
q
;

254 for (
p
 = 
fn
; *p; ++p)

255 if (!
	`isspace
(*
p
)) break;

256 if (*
p
 == '<') {

257 int 
need_shell
, 
pfd
[2];

258 
pid_t
 
pid
;

260 for (
q
 = 
p
 + 1; *q; ++q)

261 if (
	`ispunct
(*
q
) && *q != '.' && *q != '_' && *q != '-' && *q != ':')

263 
need_shell
 = (*
q
 != 0);

264 
	`pipe
(
pfd
);

265 
pid
 = 
	`vfork
();

266 if (
pid
 == -1) {

267 
	`close
(
pfd
[0]); close(pfd[1]);

270 if (
pid
 == 0) {

271 char **
argv
;

272 
	`close
(
pfd
[0]);

273 
	`dup2
(
pfd
[1], 
STDOUT_FILENO
);

274 
	`close
(
pfd
[1]);

275 if (!
need_shell
) {

276 
argv
 = 
	`cmd2argv
(
p
 + 1);

277 
	`execvp
(
argv
[0], argv);

278 
	`free
(
argv
[0]); free(argv);

279 } else 
	`execl
("/bin/sh", "sh", "-c", 
p
 + 1, 
NULL
);

280 
	`exit
(1);

282 
	`close
(
pfd
[1]);

283 
aux
 = 
	`calloc
(1, sizeof(
koaux_t
));

284 
aux
->
type
 = 
KO_PIPE
;

285 
aux
->
fd
 = 
pfd
[0];

286 
aux
->
pid
 = pid;

289 #ifdef 
_WIN32


290 *
_fd
 = 
	`open
(
fn
, 
O_RDONLY
 | 
O_BINARY
);

292 *
_fd
 = 
	`open
(
fn
, 
O_RDONLY
);

294 if (*
_fd
) {

295 
aux
 = 
	`calloc
(1, sizeof(
koaux_t
));

296 
aux
->
type
 = 
KO_FILE
;

297 
aux
->
fd
 = *
_fd
;

301 *
_fd
 = 
aux
->
fd
;

302 return 
aux
;

303 
	}
}

305 int 
	$kclose
(void *
a
)

307 
koaux_t
 *
aux
 = (koaux_t*)
a
;

308 if (
aux
->
type
 == 
KO_PIPE
) {

309 int 
status
;

310 
pid_t
 
pid
;

311 
pid
 = 
	`waitpid
(
aux
->pid, &
status
, 
WNOHANG
);

312 if (
pid
 != 
aux
->pid) 
	`kill
(aux->pid, 15);

315 
	}
}

317 #ifdef 
_KO_MAIN


318 #define 
	#BUF_SIZE
 0x10000

	)

319 int 
	$main
(int 
argc
, char *
argv
[])

321 void *
x
;

322 int 
l
, 
fd
;

323 unsigned char 
buf
[
BUF_SIZE
];

324 
FILE
 *
fp
;

325 if (
argc
 == 1) {

326 
	`fprintf
(
stderr
, "Usage: kopen <file>\n");

329 
x
 = 
	`kopen
(
argv
[1], &
fd
);

330 
fp
 = 
	`fdopen
(
fd
, "r");

331 if (
fp
 == 0) {

332 
	`fprintf
(
stderr
, "ERROR: fail to open the input\n");

336 if ((
l
 = 
	`fread
(
buf
, 1, 
BUF_SIZE
, 
fp
)) != 0)

337 
	`fwrite
(
buf
, 1, 
l
, 
stdout
);

338 } while (
l
 == 
BUF_SIZE
);

339 
	`fclose
(
fp
);

340 
	`kclose
(
x
);

342 
	}
}

	@deps/klib/ksa.c

35 #include 
	~<stdlib.h
>

37 #ifdef 
_KSA64


38 #include 
	~<stdint.h
>

39 typedef 
int64_t
 
	tsaint_t
;

40 #define 
	#SAINT_MAX
 
INT64_MAX


	)

41 #define 
	#SAIS_CORE
 
ksa_core64


	)

42 #define 
	#SAIS_BWT
 
ksa_bwt64


	)

43 #define 
	#SAIS_MAIN
 
ksa_sa64


	)

45 #include 
	~<limits.h
>

46 typedef int 
	tsaint_t
;

47 #define 
	#SAINT_MAX
 
INT_MAX


	)

48 #define 
	#SAIS_CORE
 
ksa_core


	)

49 #define 
	#SAIS_BWT
 
ksa_bwt


	)

50 #define 
	#SAIS_MAIN
 
ksa_sa


	)

54 #define 
	#chr
(
i
) (
cs
 == sizeof(
saint_t
) ? ((const saint_t *)
T
)[i] : (T[i]? (saint_t)T[i] : i - 
SAINT_MAX
))

	)

57 static void 
	$getCounts
(const unsigned char *
T
, 
saint_t
 *
C
, saint_t 
n
, saint_t 
k
, int 
cs
)

59 
saint_t
 
i
;

60 for (
i
 = 0; i < 
k
; ++i) 
C
[i] = 0;

61 for (
i
 = 0; i < 
n
; ++i) {

62 
saint_t
 
c
 = 
	`chr
(
i
);

63 ++
C
[
c
 > 0? c : 0];

65 
	}
}

75 static 
inline
 void 
	$getBuckets
(const 
saint_t
 *
C
, saint_t *
B
, saint_t 
k
, saint_t 
end
)

77 
saint_t
 
i
, 
sum
 = 0;

78 if (
end
) for (
i
 = 0; i < 
k
; ++i) 
sum
 += 
C
[i], 
B
[i] = sum;

79 else for (
i
 = 0; i < 
k
; ++i) 
sum
 += 
C
[i], 
B
[i] = sum - C[i];

80 
	}
}

83 static void 
	$induceSA
(const unsigned char *
T
, 
saint_t
 *
SA
, saint_t *
C
, saint_t *
B
, saint_t 
n
, saint_t 
k
, saint_t 
cs
)

85 
saint_t
 *
b
, 
i
, 
j
;

86 
saint_t
 
c0
, 
c1
;

88 if (
C
 == 
B
) 
	`getCounts
(
T
, C, 
n
, 
k
, 
cs
);

89 
	`getBuckets
(
C
, 
B
, 
k
, 0);

90 for (
i
 = 0, 
b
 = 0, 
c1
 = -1; i < 
n
; ++i) {

91 
j
 = 
SA
[
i
], SA[i] = ~j;

92 if (0 < 
j
) {

93 --
j
;

94 if ((
c0
 = 
	`chr
(
j
)) != 
c1
) {

95 
B
[
c1
 > 0? c1 : 0] = 
b
 - 
SA
;

96 
c1
 = 
c0
;

97 
b
 = 
SA
 + 
B
[
c1
 > 0? c1 : 0];

99 *
b
++ = (0 < 
j
 && 
	`chr
(j - 1) < 
c1
) ? ~j : j;

103 if (
C
 == 
B
) 
	`getCounts
(
T
, C, 
n
, 
k
, 
cs
);

104 
	`getBuckets
(
C
, 
B
, 
k
, 1);

105 for (
i
 = 
n
 - 1, 
b
 = 0, 
c1
 = -1; 0 <= i; --i) {

106 if (0 < (
j
 = 
SA
[
i
])) {

107 --
j
;

108 if ((
c0
 = 
	`chr
(
j
)) != 
c1
) {

109 
B
[
c1
 > 0? c1 : 0] = 
b
 - 
SA
;

110 
c1
 = 
c0
;

111 
b
 = 
SA
 + 
B
[
c1
 > 0? c1 : 0];

113 if (
c0
 > 0) *--
b
 = (
j
 == 0 || 
	`chr
(j - 1) > 
c1
) ? ~j : j;

114 } else 
SA
[
i
] = ~
j
;

116 
	}
}

131 int 
	$SAIS_CORE
(const unsigned char *
T
, 
saint_t
 *
SA
, saint_t 
fs
, saint_t 
n
, saint_t 
k
, int 
cs
)

133 
saint_t
 *
C
, *
B
;

134 
saint_t
 
i
, 
j
, 
c
, 
m
, 
q
, 
qlen
, 
name
;

135 
saint_t
 
c0
, 
c1
;

138 if (
k
 <= 
fs
) 
C
 = 
SA
 + 
n
, 
B
 = (k <= fs - k) ? C + k : C;

140 if ((
C
 = (
saint_t
*)
	`malloc
(
k
 * (1 + (
cs
 == 1)) * sizeof(saint_t))) == 
NULL
) return -2;

141 
B
 = 
cs
 == 1? 
C
 + 
k
 : C;

143 
	`getCounts
(
T
, 
C
, 
n
, 
k
, 
cs
);

144 
	`getBuckets
(
C
, 
B
, 
k
, 1);

145 for (
i
 = 0; i < 
n
; ++i) 
SA
[i] = 0;

147 for (
i
 = 
n
 - 2, 
c
 = 1, 
c1
 = 
	`chr
(n - 1); 0 <= i; --i, c1 = 
c0
) {

148 if ((
c0
 = 
	`chr
(
i
)) < 
c1
 + 
c
) c = 1;

149 else if (
c
) 
SA
[--
B
[
c1
 > 0? c1 : 0]] = 
i
 + 1, c = 0;

151 
	`induceSA
(
T
, 
SA
, 
C
, 
B
, 
n
, 
k
, 
cs
);

152 if (
fs
 < 
k
) 
	`free
(
C
);

155 for (
i
 = 0, 
m
 = 0; i < 
n
; ++i) {

156 
saint_t
 
p
 = 
SA
[
i
];

157 if (
p
 == 
n
 - 1) 
SA
[
m
++] = p;

158 else if (0 < 
p
 && 
	`chr
(p - 1) > (
c0
 = chr(p))) {

159 for (
j
 = 
p
 + 1; j < 
n
 && 
c0
 == (
c1
 = 
	`chr
(j)); ++j);

160 if (
j
 < 
n
 && 
c0
 < 
c1
) 
SA
[
m
++] = 
p
;

163 for (
i
 = 
m
; i < 
n
; ++i) 
SA
[i] = 0;

165 for (
i
 = 
n
 - 2, 
j
 = n, 
c
 = 1, 
c1
 = 
	`chr
(n - 1); 0 <= i; --i, c1 = 
c0
) {

166 if ((
c0
 = 
	`chr
(
i
)) < 
c1
 + 
c
) c = 1;

167 else if (
c
) 
SA
[
m
 + ((
i
 + 1) >> 1)] = 
j
 - i - 1, j = i + 1, c = 0;

170 for (
i
 = 0, 
name
 = 0, 
q
 = 
n
, 
qlen
 = 0; i < 
m
; ++i) {

171 
saint_t
 
p
 = 
SA
[
i
], 
plen
 = SA[
m
 + (p >> 1)], 
diff
 = 1;

172 if (
plen
 == 
qlen
) {

173 for (
j
 = 0; j < 
plen
 && 
	`chr
(
p
 + j) == chr(
q
 + j); j++);

174 if (
j
 == 
plen
) 
diff
 = 0;

176 if (
diff
) ++
name
, 
q
 = 
p
, 
qlen
 = 
plen
;

177 
SA
[
m
 + (
p
 >> 1)] = 
name
;

181 if (
name
 < 
m
) {

182 
saint_t
 *
RA
 = 
SA
 + 
n
 + 
fs
 - 
m
 - 1;

183 for (
i
 = 
n
 - 1, 
j
 = 
m
 - 1; m <= i; --i)

184 if (
SA
[
i
] != 0) 
RA
[
j
--] = SA[i];

185 
RA
[
m
] = 0;

186 if (
	`SAIS_CORE
((unsigned char *)
RA
, 
SA
, 
fs
 + 
n
 - 
m
 * 2 - 2, m + 1, 
name
 + 1, sizeof(
saint_t
)) != 0) return -2;

187 for (
i
 = 
n
 - 2, 
j
 = 
m
 - 1, 
c
 = 1, 
c1
 = 
	`chr
(n - 1); 0 <= i; --i, c1 = 
c0
) {

188 if ((
c0
 = 
	`chr
(
i
)) < 
c1
 + 
c
) c = 1;

189 else if (
c
) 
RA
[
j
--] = 
i
 + 1, c = 0;

191 for (
i
 = 0; i < 
m
; ++i) 
SA
[i] = 
RA
[SA[i+1]];

195 if (
k
 <= 
fs
) 
C
 = 
SA
 + 
n
, 
B
 = (k <= fs - k) ? C + k : C;

197 if ((
C
 = (
saint_t
*)
	`malloc
(
k
 * (1 + (
cs
 == 1)) * sizeof(saint_t))) == 
NULL
) return -2;

198 
B
 = 
cs
 == 1? 
C
 + 
k
 : C;

201 
	`getCounts
(
T
, 
C
, 
n
, 
k
, 
cs
);

202 
	`getBuckets
(
C
, 
B
, 
k
, 1);

203 for (
i
 = 
m
; i < 
n
; ++i) 
SA
[i] = 0;

204 for (
i
 = 
m
 - 1; 0 <= i; --i) {

205 
j
 = 
SA
[
i
], SA[i] = 0;

206 
c
 = 
	`chr
(
j
);

207 
SA
[--
B
[
c
 > 0? c : 0]] = 
j
;

209 
	`induceSA
(
T
, 
SA
, 
C
, 
B
, 
n
, 
k
, 
cs
);

210 if (
fs
 < 
k
) 
	`free
(
C
);

212 
	}
}

224 int 
	$SAIS_MAIN
(const unsigned char *
T
, 
saint_t
 *
SA
, saint_t 
n
, int 
k
)

226 if (
T
 == 
NULL
 || 
SA
 == NULL || T[
n
 - 1] != '\0' || n <= 0) return -1;

227 if (
k
 < 0 || k > 256) k = 256;

228 return 
	`SAIS_CORE
(
T
, 
SA
, 0, 
n
, (
saint_t
)
k
, 1);

229 
	}
}

231 int 
	$SAIS_BWT
(unsigned char *
T
, 
saint_t
 
n
, int 
k
)

233 
saint_t
 *
SA
, 
i
;

234 int 
ret
;

235 if ((
SA
 = 
	`malloc
(
n
 * sizeof(
saint_t
))) == 0) return -1;

236 if ((
ret
 = 
	`SAIS_MAIN
(
T
, 
SA
, 
n
, 
k
)) != 0) return ret;

237 for (
i
 = 0; i < 
n
; ++i)

238 if (
SA
[
i
]) SA[i] = 
T
[SA[i] - 1];

239 for (
i
 = 0; i < 
n
; ++i) 
T
[i] = 
SA
[i];

240 
	`free
(
SA
);

242 
	}
}

	@deps/klib/kseq.h

28 #ifndef 
AC_KSEQ_H


29 #define 
	#AC_KSEQ_H


	)

31 #include 
	~<ctype.h
>

32 #include 
	~<string.h
>

33 #include 
	~<stdlib.h
>

35 #define 
	#KS_SEP_SPACE
 0

36 #define 
	#KS_SEP_TAB
 1

37 #define 
	#KS_SEP_LINE
 2

38 #define 
	#KS_SEP_MAX
 2

	)

40 #define 
	#__KS_TYPE
(
type_t
) \

41 typedef struct 
	s__kstream_t
 { \

42 unsigned char *
buf
; \

43 int 
begin
, 
end
, 
is_eof
; \

44 
type_t
 
f
; \

45 } 
	tkstream_t
;

	)

47 #define 
	#ks_err
(
ks
) ((ks)->
end
 == -1)

	)

48 #define 
	#ks_eof
(
ks
) ((ks)->
is_eof
 && (ks)->
begin
 >= (ks)->
end
)

	)

49 #define 
	#ks_rewind
(
ks
) ((ks)->
is_eof
 = (ks)->
begin
 = (ks)->
end
 = 0)

	)

51 #define 
	#__KS_BASIC
(
type_t
, 
__bufsize
) \

52 static 
inline
 
kstream_t
 *
	`ks_init
(
type_t
 
f
) \

54 
kstream_t
 *
ks
 = (kstream_t*)
	`calloc
(1, sizeof(kstream_t)); \

55 
ks
->
f
 = f; \

56 
ks
->
buf
 = (unsigned char*)
	`malloc
(
__bufsize
); \

57 return 
ks
; \

59 static 
inline
 void 
	`ks_destroy
(
kstream_t
 *
ks
) \

61 if (
ks
) { \

62 
	`free
(
ks
->
buf
); \

63 
	`free
(
ks
); \

65 }

	)

67 #define 
	#__KS_GETC
(
__read
, 
__bufsize
) \

68 static 
inline
 int 
	`ks_getc
(
kstream_t
 *
ks
) \

70 if (
	`ks_err
(
ks
)) return -3; \

71 if (
ks
->
is_eof
 && ks->
begin
 >= ks->
end
) return -1; \

72 if (
ks
->
begin
 >= ks->
end
) { \

73 
ks
->
begin
 = 0; \

74 
ks
->
end
 = 
	`__read
(ks->
f
, ks->
buf
, 
__bufsize
); \

75 if (
ks
->
end
 == 0) { ks->
is_eof
 = 1; return -1;} \

76 if (
ks
->
end
 == -1) { ks->
is_eof
 = 1; return -3;}\

78 return (int)
ks
->
buf
[ks->
begin
++]; \

79 }

	)

81 #ifndef 
KSTRING_T


82 #define 
	#KSTRING_T
 
kstring_t


	)

83 typedef struct 
	s__kstring_t
 {

84 
size_t
 
	ml
, 
	mm
;

85 char *
	ms
;

86 } 
	tkstring_t
;

89 #ifndef 
kroundup32


90 #define 
	#kroundup32
(
x
) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

	)

93 #define 
	#__KS_GETUNTIL
(
__read
, 
__bufsize
) \

94 static int 
	`ks_getuntil2
(
kstream_t
 *
ks
, int 
delimiter
, 
kstring_t
 *
str
, int *
dret
, int 
append
) \

96 int 
gotany
 = 0; \

97 if (
dret
) *dret = 0; \

98 
str
->
l
 = 
append
? str->l : 0; \

100 int 
i
; \

101 if (
	`ks_err
(
ks
)) return -3; \

102 if (
ks
->
begin
 >= ks->
end
) { \

103 if (!
ks
->
is_eof
) { \

104 
ks
->
begin
 = 0; \

105 
ks
->
end
 = 
	`__read
(ks->
f
, ks->
buf
, 
__bufsize
); \

106 if (
ks
->
end
 == 0) { ks->
is_eof
 = 1; break; } \

107 if (
ks
->
end
 == -1) { ks->
is_eof
 = 1; return -3; } \

110 if (
delimiter
 == 
KS_SEP_LINE
) { \

111 for (
i
 = 
ks
->
begin
; i < ks->
end
; ++i) \

112 if (
ks
->
buf
[
i
] == '\n') break; \

113 } else if (
delimiter
 > 
KS_SEP_MAX
) { \

114 for (
i
 = 
ks
->
begin
; i < ks->
end
; ++i) \

115 if (
ks
->
buf
[
i
] == 
delimiter
) break; \

116 } else if (
delimiter
 == 
KS_SEP_SPACE
) { \

117 for (
i
 = 
ks
->
begin
; i < ks->
end
; ++i) \

118 if (
	`isspace
(
ks
->
buf
[
i
])) break; \

119 } else if (
delimiter
 == 
KS_SEP_TAB
) { \

120 for (
i
 = 
ks
->
begin
; i < ks->
end
; ++i) \

121 if (
	`isspace
(
ks
->
buf
[
i
]) && ks->buf[i] != ' ') break; \

122 } else 
i
 = 0; \

123 if (
str
->
m
 - str->
l
 < (
size_t
)(
i
 - 
ks
->
begin
 + 1)) { \

124 
str
->
m
 = str->
l
 + (
i
 - 
ks
->
begin
) + 1; \

125 
	`kroundup32
(
str
->
m
); \

126 
str
->
s
 = (char*)
	`realloc
(str->s, str->
m
); \

128 
gotany
 = 1; \

129 
	`memcpy
(
str
->
s
 + str->
l
, 
ks
->
buf
 + ks->
begin
, 
i
 - ks->begin); \

130 
str
->
l
 = str->l + (
i
 - 
ks
->
begin
); \

131 
ks
->
begin
 = 
i
 + 1; \

132 if (
i
 < 
ks
->
end
) { \

133 if (
dret
) *dret = 
ks
->
buf
[
i
]; \

137 if (!
gotany
 && 
	`ks_eof
(
ks
)) return -1; \

138 if (
str
->
s
 == 0) { \

139 
str
->
m
 = 1; \

140 
str
->
s
 = (char*)
	`calloc
(1, 1); \

141 } else if (
delimiter
 == 
KS_SEP_LINE
 && 
str
->
l
 > 1 && str->
s
[str->l-1] == '\r') --str->l; \

142 
str
->
s
[str->
l
] = '\0'; \

143 return 
str
->
l
; \

145 static 
inline
 int 
	`ks_getuntil
(
kstream_t
 *
ks
, int 
delimiter
, 
kstring_t
 *
str
, int *
dret
) \

146 { return 
	`ks_getuntil2
(
ks
, 
delimiter
, 
str
, 
dret
, 0); }

	)

148 #define 
	#KSTREAM_INIT
(
type_t
, 
__read
, 
__bufsize
) \

149 
	`__KS_TYPE
(
type_t
) \

150 
	`__KS_BASIC
(
type_t
, 
__bufsize
) \

151 
	`__KS_GETC
(
__read
, 
__bufsize
) \

152 
	`__KS_GETUNTIL
(
__read
, 
__bufsize
)

	)

154 #define 
	#kseq_rewind
(
ks
) ((ks)->
last_char
 = (ks)->
f
->
is_eof
 = (ks)->f->
begin
 = (ks)->f->
end
 = 0)

	)

156 #define 
	#__KSEQ_BASIC
(
SCOPE
, 
type_t
) \

157 
SCOPE
 
kseq_t
 *
	`kseq_init
(
type_t
 
fd
) \

159 
kseq_t
 *
s
 = (kseq_t*)
	`calloc
(1, sizeof(kseq_t)); \

160 
s
->
f
 = 
	`ks_init
(
fd
); \

161 return 
s
; \

163 
SCOPE
 void 
	`kseq_destroy
(
kseq_t
 *
ks
) \

165 if (!
ks
) return; \

166 
	`free
(
ks
->
name
.
s
); free(ks->
comment
.s); free(ks->
seq
.s); free(ks->
qual
.s); \

167 
	`ks_destroy
(
ks
->
f
); \

168 
	`free
(
ks
); \

169 }

	)

177 #define 
	#__KSEQ_READ
(
SCOPE
) \

178 
SCOPE
 int 
	`kseq_read
(
kseq_t
 *
seq
) \

180 int 
c
,
r
; \

181 
kstream_t
 *
ks
 = 
seq
->
f
; \

182 if (
seq
->
last_char
 == 0) { \

183 while ((
c
 = 
	`ks_getc
(
ks
)) >= 0 && c != '>' && c != '@'); \

184 if (
c
 < 0) return c; \

185 
seq
->
last_char
 = 
c
; \

187 
seq
->
comment
.
l
 = seq->seq.l = seq->
qual
.l = 0; \

188 if ((
r
=
	`ks_getuntil
(
ks
, 0, &
seq
->
name
, &
c
)) < 0) return r; \

189 if (
c
 != '\n') 
	`ks_getuntil
(
ks
, 
KS_SEP_LINE
, &
seq
->
comment
, 0); \

190 if (
seq
->seq.
s
 == 0) { \

191 
seq
->seq.
m
 = 256; \

192 
seq
->seq.
s
 = (char*)
	`malloc
(seq->seq.
m
); \

194 while ((
c
 = 
	`ks_getc
(
ks
)) >= 0 && c != '>' && c != '+' && c != '@') { \

195 if (
c
 == '\n') continue; \

196 
seq
->seq.
s
[seq->seq.
l
++] = 
c
; \

197 
	`ks_getuntil2
(
ks
, 
KS_SEP_LINE
, &
seq
->seq, 0, 1); \

199 if (
c
 == '>' || c == '@') 
seq
->
last_char
 = c; \

200 if (
seq
->seq.
l
 + 1 >= seq->seq.
m
) { \

201 
seq
->seq.
m
 = seq->seq.
l
 + 2; \

202 
	`kroundup32
(
seq
->seq.
m
); \

203 
seq
->seq.
s
 = (char*)
	`realloc
(seq->seq.s, seq->seq.
m
); \

205 
seq
->seq.
s
[seq->seq.
l
] = 0; \

206 if (
c
 != '+') return 
seq
->seq.
l
; \

207 if (
seq
->
qual
.
m
 < seq->seq.m) { \

208 
seq
->
qual
.
m
 = seq->seq.m; \

209 
seq
->
qual
.
s
 = (char*)
	`realloc
(seq->qual.s, seq->qual.
m
); \

211 while ((
c
 = 
	`ks_getc
(
ks
)) >= 0 && c != '\n'); \

212 if (
c
 == -1) return -2; \

213 while ((
c
 = 
	`ks_getuntil2
(
ks
, 
KS_SEP_LINE
, &
seq
->
qual
, 0, 1) >= 0 && seq->qual.
l
 < seq->seq.l)); \

214 if (
c
 == -3) return -3; \

215 
seq
->
last_char
 = 0; \

216 if (
seq
->seq.
l
 != seq->
qual
.l) return -2; \

217 return 
seq
->seq.
l
; \

218 }

	)

220 #define 
	#__KSEQ_TYPE
(
type_t
) \

222 
kstring_t
 
name
, 
comment
, 
seq
, 
qual
; \

223 int 
last_char
; \

224 
kstream_t
 *
f
; \

225 } 
	tkseq_t
;

	)

227 #define 
	#KSEQ_INIT2
(
SCOPE
, 
type_t
, 
__read
) \

228 
	`KSTREAM_INIT
(
type_t
, 
__read
, 16384) \

229 
	`__KSEQ_TYPE
(
type_t
) \

230 
	`__KSEQ_BASIC
(
SCOPE
, 
type_t
) \

231 
	`__KSEQ_READ
(
SCOPE
)

	)

233 #define 
	#KSEQ_INIT
(
type_t
, 
__read
) 
	`KSEQ_INIT2
(static, type_t, __read)

	)

235 #define 
	#KSEQ_DECLARE
(
type_t
) \

236 
	`__KS_TYPE
(
type_t
) \

237 
	`__KSEQ_TYPE
(
type_t
) \

238 extern 
kseq_t
 *
	`kseq_init
(
type_t
 
fd
); \

239 void 
	`kseq_destroy
(
kseq_t
 *
ks
); \

240 int 
	`kseq_read
(
kseq_t
 *
seq
);

	)

	@deps/klib/kson.c

1 #include 
	~<string.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<stdarg.h
>

4 #include 
	~<assert.h
>

5 #include 
	~<ctype.h
>

6 #include 
	~<stdio.h
>

7 #include 
	~"kson.h
"

13 
kson_node_t
 *
	$kson_parse_core
(const char *
json
, long *
_n
, int *
error
, long *
parsed_len
)

15 long *
stack
 = 0, 
top
 = 0, 
max
 = 0, 
n_a
 = 0, 
m_a
 = 0, 
i
, 
j
;

16 
kson_node_t
 *
a
 = 0, *
u
;

17 const char *
p
, *
q
;

18 
size_t
 *
tmp
;

20 #define 
	#__push_back
(
y
) do { \

21 if (
top
 == 
max
) { \

22 
max
 = max? max<<1 : 4; \

23 
stack
 = (long*)
	`realloc
(stack, sizeof(long) * 
max
); \

25 
stack
[
top
++] = (
y
); \

26 } while (0)

	)

28 #define 
	#__new_node
(
z
) do { \

29 if (
n_a
 == 
m_a
) { \

30 long 
old_m
 = 
m_a
; \

31 
m_a
 = m_a? m_a<<1 : 4; \

32 
a
 = (
kson_node_t
*)
	`realloc
(a, sizeof(kson_node_t) * 
m_a
); \

33 
	`memset
(
a
 + 
old_m
, 0, sizeof(
kson_node_t
) * (
m_a
 - old_m)); \

35 *(
z
) = &
a
[
n_a
++]; \

36 } while (0)

	)

38 
	`assert
(sizeof(
size_t
) == sizeof(
kson_node_t
*));

39 *
error
 = 
KSON_OK
;

40 for (
p
 = 
json
; *p; ++p) {

41 while (*
p
 && 
	`isspace
(*p)) ++p;

42 if (*
p
 == 0) break;

43 if (*
p
 == ',') {

44 } else if (*
p
 == '[' || *p == '{') {

45 int 
t
 = *
p
 == '['? -1 : -2;

46 if (
top
 < 2 || 
stack
[top-1] != -3) {

47 
	`__push_back
(
n_a
);

48 
	`__new_node
(&
u
);

49 
	`__push_back
(
t
);

50 } else 
stack
[
top
-1] = 
t
;

51 } else if (*
p
 == ']' || *p == '}') {

52 long 
i
, 
start
, 
t
 = *
p
 == ']'? -1 : -2;

53 for (
i
 = 
top
 - 1; i >= 0 && 
stack
[i] != 
t
; --i);

54 if (
i
 < 0) {

55 *
error
 = 
KSON_ERR_EXTRA_RIGHT
;

58 
start
 = 
i
;

59 
u
 = &
a
[
stack
[
start
-1]];

60 
u
->
key
 = u->
v
.
str
;

61 
u
->
n
 = 
top
 - 1 - 
start
;

62 
u
->
v
.
child
 = (
kson_node_t
**)
	`malloc
(u->
n
 * sizeof(kson_node_t*));

63 
tmp
 = (
size_t
*)
u
->
v
.
child
;

64 for (
i
 = 
start
 + 1; i < 
top
; ++i)

65 
tmp
[
i
 - 
start
 - 1] = 
stack
[i];

66 
u
->
type
 = *
p
 == ']'? 
KSON_TYPE_BRACKET
 : 
KSON_TYPE_BRACE
;

67 if ((
top
 = 
start
) == 1) break;

68 } else if (*
p
 == ':') {

69 if (
top
 == 0 || 
stack
[top-1] == -3) {

70 *
error
 = 
KSON_ERR_NO_KEY
;

73 
	`__push_back
(-3);

75 int 
c
 = *
p
;

77 if (
top
 >= 2 && 
stack
[top-1] == -3) {

78 --
top
;

79 
u
 = &
a
[
stack
[
top
-1]];

80 
u
->
key
 = u->
v
.
str
;

82 
	`__push_back
(
n_a
);

83 
	`__new_node
(&
u
);

86 if (
c
 == '\'' || c == '"') {

87 for (
q
 = ++
p
; *q && *q != 
c
; ++q)

88 if (*
q
 == '\\') ++q;

90 for (
q
 = 
p
; *q && *q != ']' && *q != '}' && *q != ',' && *q != ':' && *q != '\n'; ++q)

91 if (*
q
 == '\\') ++q;

93 
u
->
v
.
str
 = (char*)
	`malloc
(
q
 - 
p
 + 1); 
	`strncpy
(u->v.str, p, q - p); u->v.str[q-p] = 0;

94 
u
->
type
 = 
c
 == '\''? 
KSON_TYPE_SGL_QUOTE
 : c == '"'? 
KSON_TYPE_DBL_QUOTE
 : 
KSON_TYPE_NO_QUOTE
;

95 
p
 = 
c
 == '\'' || c == '"'? 
q
 : q - 1;

98 while (*
p
 && 
	`isspace
(*p)) ++p;

99 if (
parsed_len
) *parsed_len = 
p
 - 
json
;

100 if (
top
 != 1) *
error
 = 
KSON_ERR_EXTRA_LEFT
;

102 for (
i
 = 0; i < 
n_a
; ++i)

103 for (
j
 = 0, 
u
 = &
a
[
i
], 
tmp
 = (
size_t
*)u->
v
.
child
; j < (long)u->
n
; ++j)

104 
u
->
v
.
child
[
j
] = &
a
[
tmp
[j]];

106 
	`free
(
stack
);

107 *
_n
 = 
n_a
;

108 return 
a
;

109 
	}
}

111 void 
	$kson_destroy
(
kson_t
 *
kson
)

113 long 
i
;

114 if (
kson
 == 0) return;

115 for (
i
 = 0; i < 
kson
->
n_nodes
; ++i) {

116 
	`free
(
kson
->
root
[
i
].
key
); free(kson->root[i].
v
.
str
);

118 
	`free
(
kson
->
root
); free(kson);

119 
	}
}

121 
kson_t
 *
	$kson_parse
(const char *
json
)

123 
kson_t
 *
kson
;

124 int 
error
;

125 
kson
 = (
kson_t
*)
	`calloc
(1, sizeof(kson_t));

126 
kson
->
root
 = 
	`kson_parse_core
(
json
, &kson->
n_nodes
, &
error
, 0);

127 if (
error
) {

128 
	`kson_destroy
(
kson
);

131 return 
kson
;

132 
	}
}

138 const 
kson_node_t
 *
	$kson_by_path
(const 
kson_node_t
 *
p
, int 
depth
, ...)

140 
va_list
 
ap
;

141 
	`va_start
(
ap
, 
depth
);

142 while (
p
 && 
depth
 > 0) {

143 if (
p
->
type
 == 
KSON_TYPE_BRACE
) {

144 
p
 = 
	`kson_by_key
(p, 
	`va_arg
(
ap
, const char*));

145 } else if (
p
->
type
 == 
KSON_TYPE_BRACKET
) {

146 
p
 = 
	`kson_by_index
(p, 
	`va_arg
(
ap
, long));

148 --
depth
;

150 
	`va_end
(
ap
);

151 return 
p
;

152 
	}
}

158 void 
	$kson_format_recur
(const 
kson_node_t
 *
p
, int 
depth
)

160 long 
i
;

161 if (
p
->
key
) 
	`printf
("\"%s\":", p->key);

162 if (
p
->
type
 == 
KSON_TYPE_BRACKET
 || p->type == 
KSON_TYPE_BRACE
) {

163 
	`putchar
(
p
->
type
 == 
KSON_TYPE_BRACKET
? '[' : '{');

164 if (
p
->
n
) {

165 
	`putchar
('\n'); for (
i
 = 0; i <= 
depth
; ++i) 
	`fputs
(" ", 
stdout
);

166 for (
i
 = 0; i < (long)
p
->
n
; ++i) {

167 if (
i
) {

168 int 
i
;

169 
	`putchar
(',');

170 
	`putchar
('\n'); for (
i
 = 0; i <= 
depth
; ++i) 
	`fputs
(" ", 
stdout
);

172 
	`kson_format_recur
(
p
->
v
.
child
[
i
], 
depth
 + 1);

174 
	`putchar
('\n'); for (
i
 = 0; i < 
depth
; ++i) 
	`fputs
(" ", 
stdout
);

176 
	`putchar
(
p
->
type
 == 
KSON_TYPE_BRACKET
? ']' : '}');

178 if (
p
->
type
 != 
KSON_TYPE_NO_QUOTE
)

179 
	`putchar
(
p
->
type
 == 
KSON_TYPE_SGL_QUOTE
? '\'' : '"');

180 
	`fputs
(
p
->
v
.
str
, 
stdout
);

181 if (
p
->
type
 != 
KSON_TYPE_NO_QUOTE
)

182 
	`putchar
(
p
->
type
 == 
KSON_TYPE_SGL_QUOTE
? '\'' : '"');

184 
	}
}

186 void 
	$kson_format
(const 
kson_node_t
 *
root
)

188 
	`kson_format_recur
(
root
, 0);

189 
	`putchar
('\n');

190 
	}
}

196 #ifdef 
KSON_MAIN


197 #define 
	#kroundup32
(
x
) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

	)

198 int 
	$main
(int 
argc
, char *
argv
[])

200 
kson_t
 *
kson
 = 0;

201 if (
argc
 > 1) {

202 
FILE
 *
fp
;

203 int 
len
 = 0, 
max
 = 0, 
tmp
, 
i
;

204 char *
json
 = 0, 
buf
[0x10000];

205 if ((
fp
 = 
	`fopen
(
argv
[1], "rb")) != 0) {

207 while ((
tmp
 = 
	`fread
(
buf
, 1, 0x10000, 
fp
)) != 0) {

208 if (
len
 + 
tmp
 + 1 > 
max
) {

209 
max
 = 
len
 + 
tmp
 + 1;

210 
	`kroundup32
(
max
);

211 
json
 = (char*)
	`realloc
(json, 
max
);

213 
	`memcpy
(
json
 + 
len
, 
buf
, 
tmp
);

214 
len
 += 
tmp
;

216 
	`fclose
(
fp
);

218 
kson
 = 
	`kson_parse
(
json
);

219 
	`free
(
json
);

220 if (
kson
) {

221 
	`kson_format
(
kson
->
root
);

222 if (
argc
 > 2) {

224 const 
kson_node_t
 *
p
 = 
kson
->
root
;

225 for (
i
 = 2; i < 
argc
 && 
p
; ++i) {

226 if (
p
->
type
 == 
KSON_TYPE_BRACKET
)

227 
p
 = 
	`kson_by_index
(p, 
	`atoi
(
argv
[
i
]));

228 else if (
p
->
type
 == 
KSON_TYPE_BRACE
)

229 
p
 = 
	`kson_by_key
(p, 
argv
[
i
]);

230 else 
p
 = 0;

232 if (
p
) {

233 if (
	`kson_is_internal
(
p
)) 
	`printf
("Reached an internal node\n");

234 else 
	`printf
("Value: %s\n", 
p
->
v
.
str
);

235 } else 
	`printf
("Failed to find the slot\n");

237 } else 
	`printf
("Failed to parse\n");

240 
kson
 = 
	`kson_parse
("{'a' : 1,'b':[0,'isn\\'t',true],'d':[{\n\n\n}]}");

241 if (
kson
) {

242 const 
kson_node_t
 *
p
 = 
	`kson_by_path
(
kson
->
root
, 2, "b", 1);

243 if (
p
) 
	`printf
("*** %s\n", p->
v
.
str
);

244 else 
	`printf
("!!! not found\n");

245 
	`kson_format
(
kson
->
root
);

247 
	`printf
("Failed to parse\n");

250 
	`kson_destroy
(
kson
);

252 
	}
}

	@deps/klib/kson.h

1 #ifndef 
KSON_H


2 #define 
	#KSON_H


	)

4 #include 
	~<string.h
>

6 #define 
	#KSON_TYPE_NO_QUOTE
 1

	)

7 #define 
	#KSON_TYPE_SGL_QUOTE
 2

	)

8 #define 
	#KSON_TYPE_DBL_QUOTE
 3

	)

9 #define 
	#KSON_TYPE_BRACKET
 4

	)

10 #define 
	#KSON_TYPE_BRACE
 5

	)

12 #define 
	#KSON_OK
 0

	)

13 #define 
	#KSON_ERR_EXTRA_LEFT
 1

	)

14 #define 
	#KSON_ERR_EXTRA_RIGHT
 2

	)

15 #define 
	#KSON_ERR_NO_KEY
 3

	)

17 typedef struct 
	skson_node_s
 {

18 unsigned long long 
	mtype
:3, 
	mn
:61;

19 char *
	mkey
;

21 struct 
kson_node_s
 **
	mchild
;

22 char *
	mstr
;

23 } 
	mv
;

24 } 
	tkson_node_t
;

27 long 
	mn_nodes
;

28 
kson_node_t
 *
	mroot
;

29 } 
	tkson_t
;

31 #ifdef 
__cplusplus


35 
kson_t
 *
kson_parse
(const char *
json
);

36 void 
kson_destroy
(
kson_t
 *
kson
);

37 const 
kson_node_t
 *
kson_by_path
(const kson_node_t *
root
, int 
path_len
, ...);

38 void 
kson_format
(const 
kson_node_t
 *
root
);

40 #ifdef 
__cplusplus


44 #define 
	#kson_is_internal
(
p
) ((p)->
type
 == 
KSON_TYPE_BRACKET
 || (p)->type == 
KSON_TYPE_BRACE
)

	)

46 static 
inline
 const 
kson_node_t
 *
	$kson_by_key
(const 
kson_node_t
 *
p
, const char *
key
)

48 long 
i
;

49 if (!
	`kson_is_internal
(
p
)) return 0;

50 for (
i
 = 0; i < (long)
p
->
n
; ++i) {

51 const 
kson_node_t
 *
q
 = 
p
->
v
.
child
[
i
];

52 if (
q
->
key
 && 
	`strcmp
(q->key, key) == 0)

53 return 
q
;

56 
	}
}

58 static 
inline
 const 
kson_node_t
 *
	$kson_by_index
(const 
kson_node_t
 *
p
, long 
i
)

60 if (!
	`kson_is_internal
(
p
)) return 0;

61 return 0 <= 
i
 && i < (long)
p
->
n
? p->
v
.
child
[i] : 0;

62 
	}
}

	@deps/klib/ksort.h

63 #ifndef 
AC_KSORT_H


64 #define 
	#AC_KSORT_H


	)

66 #include 
	~<stdlib.h
>

67 #include 
	~<string.h
>

70 void *
	mleft
, *
	mright
;

71 int 
	mdepth
;

72 } 
	tks_isort_stack_t
;

74 #define 
	#KSORT_SWAP
(
type_t
, 
a
, 
b
) { register type_t 
t
=(a); (a)=(b); (b)=t; }

	)

76 #define 
	#KSORT_INIT
(
name
, 
type_t
, 
__sort_lt
) \

77 void 
ks_mergesort_
##
	`name
(
size_t
 
n
, 
type_t
 
array
[], type_t 
temp
[]) \

79 
type_t
 *
a2
[2], *
a
, *
b
; \

80 int 
curr
, 
shift
; \

82 
a2
[0] = 
array
; \

83 
a2
[1] = 
temp
? temp : (
type_t
*)
	`malloc
(sizeof(type_t) * 
n
); \

84 for (
curr
 = 0, 
shift
 = 0; (1ul<<shift) < 
n
; ++shift) { \

85 
a
 = 
a2
[
curr
]; 
b
 = a2[1-curr]; \

86 if (
shift
 == 0) { \

87 
type_t
 *
p
 = 
b
, *
i
, *
eb
 = 
a
 + 
n
; \

88 for (
i
 = 
a
; i < 
eb
; i += 2) { \

89 if (
i
 == 
eb
 - 1) *
p
++ = *i; \

91 if (
	`__sort_lt
(*(
i
+1), *i)) { \

92 *
p
++ = *(
i
+1); *p++ = *i; \

94 *
p
++ = *
i
; *p++ = *(i+1); \

99 
size_t
 
i
, 
step
 = 1ul<<
shift
; \

100 for (
i
 = 0; i < 
n
; i += 
step
<<1) { \

101 
type_t
 *
p
, *
j
, *
k
, *
ea
, *
eb
; \

102 if (
n
 < 
i
 + 
step
) { \

103 
ea
 = 
a
 + 
n
; 
eb
 = a; \

105 
ea
 = 
a
 + 
i
 + 
step
; \

106 
eb
 = 
a
 + (
n
 < 
i
 + (
step
<<1)? n : i + (step<<1)); \

108 
j
 = 
a
 + 
i
; 
k
 = a + i + 
step
; 
p
 = 
b
 + i; \

109 while (
j
 < 
ea
 && 
k
 < 
eb
) { \

110 if (
	`__sort_lt
(*
k
, *
j
)) *
p
++ = *k++; \

111 else *
p
++ = *
j
++; \

113 while (
j
 < 
ea
) *
p
++ = *j++; \

114 while (
k
 < 
eb
) *
p
++ = *k++; \

117 
curr
 = 1 - curr; \

119 if (
curr
 == 1) { \

120 
type_t
 *
p
 = 
a2
[0], *
i
 = a2[1], *
eb
 = 
array
 + 
n
; \

121 for (; 
p
 < 
eb
; ++
i
) *p++ = *i; \

123 if (
temp
 == 0) 
	`free
(
a2
[1]); \

125 void 
ks_heapadjust_
##
	`name
(
size_t
 
i
, size_t 
n
, 
type_t
 
l
[]) \

127 
size_t
 
k
 = 
i
; \

128 
type_t
 
tmp
 = 
l
[
i
]; \

129 while ((
k
 = (k << 1) + 1) < 
n
) { \

130 if (
k
 != 
n
 - 1 && 
	`__sort_lt
(
l
[k], l[k+1])) ++k; \

131 if (
	`__sort_lt
(
l
[
k
], 
tmp
)) break; \

132 
l
[
i
] = l[
k
]; i = k; \

134 
l
[
i
] = 
tmp
; \

136 void 
ks_heapmake_
##
	`name
(
size_t
 
lsize
, 
type_t
 
l
[]) \

138 
size_t
 
i
; \

139 for (
i
 = (
lsize
 >> 1) - 1; i != (
size_t
)(-1); --i) \

140 
ks_heapadjust_
##
	`name
(
i
, 
lsize
, 
l
); \

142 void 
ks_heapsort_
##
	`name
(
size_t
 
lsize
, 
type_t
 
l
[]) \

144 
size_t
 
i
; \

145 for (
i
 = 
lsize
 - 1; i > 0; --i) { \

146 
type_t
 
tmp
; \

147 
tmp
 = *
l
; *l = l[
i
]; l[i] = tmp; 
ks_heapadjust_
##
	`name
(0, i, l); \

150 static 
inline
 void 
__ks_insertsort_
##
	`name
(
type_t
 *
s
, type_t *
t
) \

152 
type_t
 *
i
, *
j
, 
swap_tmp
; \

153 for (
i
 = 
s
 + 1; i < 
t
; ++i) \

154 for (
j
 = 
i
; j > 
s
 && 
	`__sort_lt
(*j, *(j-1)); --j) { \

155 
swap_tmp
 = *
j
; *j = *(j-1); *(j-1) = swap_tmp; \

158 void 
ks_combsort_
##
	`name
(
size_t
 
n
, 
type_t
 
a
[]) \

160 const double 
shrink_factor
 = 1.2473309501039786540366528676643; \

161 int 
do_swap
; \

162 
size_t
 
gap
 = 
n
; \

163 
type_t
 
tmp
, *
i
, *
j
; \

165 if (
gap
 > 2) { \

166 
gap
 = (
size_t
)(gap / 
shrink_factor
); \

167 if (
gap
 == 9 || gap == 10) gap = 11; \

169 
do_swap
 = 0; \

170 for (
i
 = 
a
; i < a + 
n
 - 
gap
; ++i) { \

171 
j
 = 
i
 + 
gap
; \

172 if (
	`__sort_lt
(*
j
, *
i
)) { \

173 
tmp
 = *
i
; *i = *
j
; *j = tmp; \

174 
do_swap
 = 1; \

177 } while (
do_swap
 || 
gap
 > 2); \

178 if (
gap
 != 1) 
__ks_insertsort_
##
	`name
(
a
, a + 
n
); \

180 void 
ks_introsort_
##
	`name
(
size_t
 
n
, 
type_t
 
a
[]) \

182 int 
d
; \

183 
ks_isort_stack_t
 *
top
, *
stack
; \

184 
type_t
 
rp
, 
swap_tmp
; \

185 
type_t
 *
s
, *
t
, *
i
, *
j
, *
k
; \

187 if (
n
 < 1) return; \

188 else if (
n
 == 2) { \

189 if (
	`__sort_lt
(
a
[1], a[0])) { 
swap_tmp
 = a[0]; a[0] = a[1]; a[1] = swap_tmp; } \

192 for (
d
 = 2; 1ul<<d < 
n
; ++d); \

193 
stack
 = (
ks_isort_stack_t
*)
	`malloc
(sizeof(ks_isort_stack_t) * ((sizeof(
size_t
)*
d
)+2)); \

194 
top
 = 
stack
; 
s
 = 
a
; 
t
 = a + (
n
-1); 
d
 <<= 1; \

196 if (
s
 < 
t
) { \

197 if (--
d
 == 0) { \

198 
ks_combsort_
##
	`name
(
t
 - 
s
 + 1, s); \

199 
t
 = 
s
; \

202 
i
 = 
s
; 
j
 = 
t
; 
k
 = i + ((j-i)>>1) + 1; \

203 if (
	`__sort_lt
(*
k
, *
i
)) { \

204 if (
	`__sort_lt
(*
k
, *
j
)) k = j; \

205 } else 
k
 = 
	`__sort_lt
(*
j
, *
i
)? i : j; \

206 
rp
 = *
k
; \

207 if (
k
 != 
t
) { 
swap_tmp
 = *k; *k = *t; *t = swap_tmp; } \

209 do ++
i
; while (
	`__sort_lt
(*i, 
rp
)); \

210 do --
j
; while (
i
 <= j && 
	`__sort_lt
(
rp
, *j)); \

211 if (
j
 <= 
i
) break; \

212 
swap_tmp
 = *
i
; *i = *
j
; *j = swap_tmp; \

214 
swap_tmp
 = *
i
; *i = *
t
; *t = swap_tmp; \

215 if (
i
-
s
 > 
t
-i) { \

216 if (
i
-
s
 > 16) { 
top
->
left
 = s; top->
right
 = i-1; top->
depth
 = 
d
; ++top; } \

217 
s
 = 
t
-
i
 > 16? i+1 : t; \

219 if (
t
-
i
 > 16) { 
top
->
left
 = i+1; top->
right
 = t; top->
depth
 = 
d
; ++top; } \

220 
t
 = 
i
-
s
 > 16? i-1 : s; \

223 if (
top
 == 
stack
) { \

224 
	`free
(
stack
); \

225 
__ks_insertsort_
##
	`name
(
a
, a+
n
); \

227 } else { --
top
; 
s
 = (
type_t
*)top->
left
; 
t
 = (type_t*)top->
right
; 
d
 = top->
depth
; } \

233 
type_t
 
ks_ksmall_
##
	`name
(
size_t
 
n
, type_t 
arr
[], size_t 
kk
) \

235 
type_t
 *
low
, *
high
, *
k
, *
ll
, *
hh
, *
mid
; \

236 
low
 = 
arr
; 
high
 = arr + 
n
 - 1; 
k
 = arr + 
kk
; \

238 if (
high
 <= 
low
) return *
k
; \

239 if (
high
 == 
low
 + 1) { \

240 if (
	`__sort_lt
(*
high
, *
low
)) 
	`KSORT_SWAP
(
type_t
, *low, *high); \

241 return *
k
; \

243 
mid
 = 
low
 + (
high
 - low) / 2; \

244 if (
	`__sort_lt
(*
high
, *
mid
)) 
	`KSORT_SWAP
(
type_t
, *mid, *high); \

245 if (
	`__sort_lt
(*
high
, *
low
)) 
	`KSORT_SWAP
(
type_t
, *low, *high); \

246 if (
	`__sort_lt
(*
low
, *
mid
)) 
	`KSORT_SWAP
(
type_t
, *mid, *low); \

247 
	`KSORT_SWAP
(
type_t
, *
mid
, *(
low
+1)); \

248 
ll
 = 
low
 + 1; 
hh
 = 
high
; \

250 do ++
ll
; while (
	`__sort_lt
(*ll, *
low
)); \

251 do --
hh
; while (
	`__sort_lt
(*
low
, *hh)); \

252 if (
hh
 < 
ll
) break; \

253 
	`KSORT_SWAP
(
type_t
, *
ll
, *
hh
); \

255 
	`KSORT_SWAP
(
type_t
, *
low
, *
hh
); \

256 if (
hh
 <= 
k
) 
low
 = 
ll
; \

257 if (
hh
 >= 
k
) 
high
 = hh - 1; \

260 void 
ks_shuffle_
##
	`name
(
size_t
 
n
, 
type_t
 
a
[]) \

262 int 
i
, 
j
; \

263 for (
i
 = 
n
; i > 1; --i) { \

264 
type_t
 
tmp
; \

265 
j
 = (int)(
	`drand48
() * 
i
); \

266 
tmp
 = 
a
[
j
]; a[j] = a[
i
-1]; a[i-1] = tmp; \

269 void 
ks_sample_
##
	`name
(
size_t
 
n
, size_t 
r
, 
type_t
 
a
[]) \

271 int 
i
, 
k
, 
pop
 = 
n
; \

272 for (
i
 = (int)
r
, 
k
 = 0; i >= 0; --i) { \

273 double 
z
 = 1., 
x
 = 
	`drand48
(); \

274 
type_t
 
tmp
; \

275 while (
x
 < 
z
) z -= z * 
i
 / (
pop
--); \

276 if (
k
 != 
n
 - 
pop
 - 1) 
tmp
 = 
a
[k], a[k] = a[n-pop-1], a[n-pop-1] = tmp; \

277 ++
k
; \

279 }

	)

281 #define 
	#ks_mergesort
(
name
, 
n
, 
a
, 
t
) 
ks_mergesort_
##
	`name
(n, a, t)

	)

282 #define 
	#ks_introsort
(
name
, 
n
, 
a
) 
ks_introsort_
##
	`name
(n, a)

	)

283 #define 
	#ks_combsort
(
name
, 
n
, 
a
) 
ks_combsort_
##
	`name
(n, a)

	)

284 #define 
	#ks_heapsort
(
name
, 
n
, 
a
) 
ks_heapsort_
##
	`name
(n, a)

	)

285 #define 
	#ks_heapmake
(
name
, 
n
, 
a
) 
ks_heapmake_
##
	`name
(n, a)

	)

286 #define 
	#ks_heapadjust
(
name
, 
i
, 
n
, 
a
) 
ks_heapadjust_
##
	`name
(i, n, a)

	)

287 #define 
	#ks_ksmall
(
name
, 
n
, 
a
, 
k
) 
ks_ksmall_
##
	`name
(n, a, k)

	)

288 #define 
	#ks_shuffle
(
name
, 
n
, 
a
) 
ks_shuffle_
##
	`name
(n, a)

	)

290 #define 
	#ks_lt_generic
(
a
, 
b
) ((a) < (b))

	)

291 #define 
	#ks_lt_str
(
a
, 
b
) (
	`strcmp
((a), (b)) < 0)

	)

293 typedef const char *
	tksstr_t
;

295 #define 
	#KSORT_INIT_GENERIC
(
type_t
) 
	`KSORT_INIT
(type_t, type_t, 
ks_lt_generic
)

	)

296 #define 
	#KSORT_INIT_STR
 
	`KSORT_INIT
(
str
, 
ksstr_t
, 
ks_lt_str
)

	)

	@deps/klib/kstring.c

1 #include 
	~<stdarg.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<ctype.h
>

4 #include 
	~<string.h
>

5 #include 
	~<stdint.h
>

6 #include 
	~"kstring.h
"

8 int 
	$kvsprintf
(
kstring_t
 *
s
, const char *
fmt
, 
va_list
 
ap
)

10 
va_list
 
args
;

11 int 
l
;

12 
	`va_copy
(
args
, 
ap
);

13 
l
 = 
	`vsnprintf
(
s
->s + s->l, s->
m
 - s->l, 
fmt
, 
args
);

14 
	`va_end
(
args
);

15 if (
l
 + 1 > 
s
->
m
 - s->l) {

16 
s
->
m
 = s->
l
 + l + 2;

17 
	`kroundup32
(
s
->
m
);

18 
s
->s = (char*)
	`realloc
(s->s, s->
m
);

19 
	`va_copy
(
args
, 
ap
);

20 
l
 = 
	`vsnprintf
(
s
->s + s->l, s->
m
 - s->l, 
fmt
, 
args
);

21 
	`va_end
(
args
);

23 
s
->
l
 += l;

24 return 
l
;

25 
	}
}

27 int 
	$ksprintf
(
kstring_t
 *
s
, const char *
fmt
, ...)

29 
va_list
 
ap
;

30 int 
l
;

31 
	`va_start
(
ap
, 
fmt
);

32 
l
 = 
	`kvsprintf
(
s
, 
fmt
, 
ap
);

33 
	`va_end
(
ap
);

34 return 
l
;

35 
	}
}

37 char *
	$kstrtok
(const char *
str
, const char *
sep
, 
ks_tokaux_t
 *
aux
)

39 const char *
p
, *
start
;

40 if (
sep
) {

41 if (
str
 == 0 && (
aux
->
tab
[0]&1)) return 0;

42 
aux
->
finished
 = 0;

43 if (
sep
[1]) {

44 
aux
->
sep
 = -1;

45 
aux
->
tab
[0] = aux->tab[1] = aux->tab[2] = aux->tab[3] = 0;

46 for (
p
 = 
sep
; *p; ++p) 
aux
->
tab
[*p>>6] |= 1ull<<(*p&0x3f);

47 } else 
aux
->
sep
 = sep[0];

49 if (
aux
->
finished
) return 0;

50 else if (
str
) 
aux
->
p
 = str - 1, aux->
finished
 = 0;

51 if (
aux
->
sep
 < 0) {

52 for (
p
 = 
start
 = 
aux
->p + 1; *p; ++p)

53 if (
aux
->
tab
[*
p
>>6]>>(*p&0x3f)&1) break;

55 for (
p
 = 
start
 = 
aux
->p + 1; *p; ++p)

56 if (*
p
 == 
aux
->
sep
) break;

58 
aux
->
p
 = p;

59 if (*
p
 == 0) 
aux
->
finished
 = 1;

60 return (char*)
start
;

61 
	}
}

64 int 
	$ksplit_core
(char *
s
, int 
delimiter
, int *
_max
, int **
_offsets
)

66 int 
i
, 
n
, 
max
, 
last_char
, 
last_start
, *
offsets
, 
l
;

67 
n
 = 0; 
max
 = *
_max
; 
offsets
 = *
_offsets
;

68 
l
 = 
	`strlen
(
s
);

70 #define 
	#__ksplit_aux
 do { \

71 if (
_offsets
) { \

72 
s
[
i
] = 0; \

73 if (
n
 == 
max
) { \

74 int *
tmp
; \

75 
max
 = max? max<<1 : 2; \

76 if ((
tmp
 = (int*)
	`realloc
(
offsets
, sizeof(int) * 
max
))) { \

77 
offsets
 = 
tmp
; \

79 
	`free
(
offsets
); \

80 *
_offsets
 = 
NULL
; \

84 
offsets
[
n
++] = 
last_start
; \

85 } else ++
n
; \

86 } while (0)

	)

88 for (
i
 = 0, 
last_char
 = 
last_start
 = 0; i <= 
l
; ++i) {

89 if (
delimiter
 == 0) {

90 if (
	`isspace
(
s
[
i
]) || s[i] == 0) {

91 if (
	`isgraph
(
last_char
)) 
__ksplit_aux
;

93 if (
	`isspace
(
last_char
) || last_char == 0) 
last_start
 = 
i
;

96 if (
s
[
i
] == 
delimiter
 || s[i] == 0) {

97 if (
last_char
 != 0 && last_char != 
delimiter
) 
__ksplit_aux
;

99 if (
last_char
 == 
delimiter
 || last_char == 0) 
last_start
 = 
i
;

102 
last_char
 = 
s
[
i
];

104 *
_max
 = 
max
; *
_offsets
 = 
offsets
;

105 return 
n
;

106 
	}
}

108 int 
	$kgetline
(
kstring_t
 *
s
, 
kgets_func
 *
fgets_fn
, void *
fp
)

110 
size_t
 
l0
 = 
s
->
l
;

112 while (
s
->
l
 == 
l0
 || s->s[s->l-1] != '\n') {

113 if (
s
->
m
 - s->
l
 < 200) 
	`ks_resize
(s, s->m + 200);

114 if (
	`fgets_fn
(
s
->s + s->
l
, s->
m
 - s->l, 
fp
) == 
NULL
) break;

115 
s
->
l
 += 
	`strlen
(s->s + s->l);

118 if (
s
->
l
 == 
l0
) return 
EOF
;

120 if (
s
->
l
 > 
l0
 && s->s[s->l-1] == '\n') {

121 
s
->
l
--;

122 if (
s
->
l
 > 
l0
 && s->s[s->l-1] == '\r') s->l--;

124 
s
->s[s->
l
] = '\0';

126 
	}
}

132 typedef unsigned char 
	tubyte_t
;

135 static int *
	$ksBM_prep
(const 
ubyte_t
 *
pat
, int 
m
)

137 int 
i
, *
suff
, *
prep
, *
bmGs
, *
bmBc
;

138 
prep
 = (int*)
	`calloc
(
m
 + 256, sizeof(int));

139 
bmGs
 = 
prep
; 
bmBc
 = prep + 
m
;

141 for (
i
 = 0; i < 256; ++i) 
bmBc
[i] = 
m
;

142 for (
i
 = 0; i < 
m
 - 1; ++i) 
bmBc
[
pat
[i]] = m - i - 1;

144 
suff
 = (int*)
	`calloc
(
m
, sizeof(int));

146 int 
f
 = 0, 
g
;

147 
suff
[
m
 - 1] = m;

148 
g
 = 
m
 - 1;

149 for (
i
 = 
m
 - 2; i >= 0; --i) {

150 if (
i
 > 
g
 && 
suff
[i + 
m
 - 1 - 
f
] < i - g)

151 
suff
[
i
] = suff[i + 
m
 - 1 - 
f
];

153 if (
i
 < 
g
) g = i;

154 
f
 = 
i
;

155 while (
g
 >= 0 && 
pat
[g] == pat[g + 
m
 - 1 - 
f
]) --g;

156 
suff
[
i
] = 
f
 - 
g
;

161 int 
j
 = 0;

162 for (
i
 = 0; i < 
m
; ++i) 
bmGs
[i] = m;

163 for (
i
 = 
m
 - 1; i >= 0; --i)

164 if (
suff
[
i
] == i + 1)

165 for (; 
j
 < 
m
 - 1 - 
i
; ++j)

166 if (
bmGs
[
j
] == 
m
)

167 
bmGs
[
j
] = 
m
 - 1 - 
i
;

168 for (
i
 = 0; i <= 
m
 - 2; ++i)

169 
bmGs
[
m
 - 1 - 
suff
[
i
]] = m - 1 - i;

171 
	`free
(
suff
);

172 return 
prep
;

173 
	}
}

175 void *
	$kmemmem
(const void *
_str
, int 
n
, const void *
_pat
, int 
m
, int **
_prep
)

177 int 
i
, 
j
, *
prep
 = 0, *
bmGs
, *
bmBc
;

178 const 
ubyte_t
 *
str
, *
pat
;

179 
str
 = (const 
ubyte_t
*)
_str
; 
pat
 = (const ubyte_t*)
_pat
;

180 
prep
 = (
_prep
 == 0 || *_prep == 0)? 
	`ksBM_prep
(
pat
, 
m
) : *_prep;

181 if (
_prep
 && *_prep == 0) *_prep = 
prep
;

182 
bmGs
 = 
prep
; 
bmBc
 = prep + 
m
;

183 
j
 = 0;

184 while (
j
 <= 
n
 - 
m
) {

185 for (
i
 = 
m
 - 1; i >= 0 && 
pat
[i] == 
str
[i+
j
]; --i);

186 if (
i
 >= 0) {

187 int 
max
 = 
bmBc
[
str
[
i
+
j
]] - 
m
 + 1 + i;

188 if (
max
 < 
bmGs
[
i
]) max = bmGs[i];

189 
j
 += 
max
;

190 } else return (void*)(
str
 + 
j
);

192 if (
_prep
 == 0) 
	`free
(
prep
);

194 
	}
}

196 char *
	$kstrstr
(const char *
str
, const char *
pat
, int **
_prep
)

198 return (char*)
	`kmemmem
(
str
, 
	`strlen
(str), 
pat
, strlen(pat), 
_prep
);

199 
	}
}

201 char *
	$kstrnstr
(const char *
str
, const char *
pat
, int 
n
, int **
_prep
)

203 return (char*)
	`kmemmem
(
str
, 
n
, 
pat
, 
	`strlen
(pat), 
_prep
);

204 
	}
}

210 #ifdef 
KSTRING_MAIN


211 #include 
	~<stdio.h
>

212 int 
	$main
()

214 
kstring_t
 *
s
;

215 int *
fields
, 
n
, 
i
;

216 
ks_tokaux_t
 
aux
;

217 char *
p
;

218 
s
 = (
kstring_t
*)
	`calloc
(1, sizeof(kstring_t));

220 
	`ksprintf
(
s
, " abcdefg: %d ", 100);

221 
	`printf
("'%s'\n", 
s
->s);

223 
fields
 = 
	`ksplit
(
s
, 0, &
n
);

224 for (
i
 = 0; i < 
n
; ++i)

225 
	`printf
("field[%d] = '%s'\n", 
i
, 
s
->s + 
fields
[i]);

227 
s
->
l
 = 0;

228 for (
p
 = 
	`kstrtok
("ab:cde:fg/hij::k", ":/", &
aux
); p; p = kstrtok(0, 0, &aux)) {

229 
	`kputsn
(
p
, 
aux
.p - p, 
s
);

230 
	`kputc
('\n', 
s
);

232 
	`printf
("%s", 
s
->s);

234 
	`free
(
s
->s); free(s); free(
fields
);

237 static char *
str
 = "abcdefgcdgcagtcakcdcd";

238 static char *
pat
 = "cd";

239 char *
ret
, *
s
 = 
str
;

240 int *
prep
 = 0;

241 while ((
ret
 = 
	`kstrstr
(
s
, 
pat
, &
prep
)) != 0) {

242 
	`printf
("match: %s\n", 
ret
);

243 
s
 = 
ret
 + 
prep
[0];

245 
	`free
(
prep
);

248 
	}
}

	@deps/klib/kstring.h

26 #ifndef 
KSTRING_H


27 #define 
	#KSTRING_H


	)

29 #include 
	~<stdlib.h
>

30 #include 
	~<string.h
>

31 #include 
	~<stdarg.h
>

32 #include 
	~<stdint.h
>

33 #include 
	~<stdio.h
>

35 #ifndef 
kroundup32


36 #define 
	#kroundup32
(
x
) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

	)

39 #if 
__GNUC__
 > 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 > 4)

40 #define 
	#KS_ATTR_PRINTF
(
fmt
, 
arg
) 
	`__attribute__
((
	`__format__
 (
__printf__
, fmt, arg)))

	)

42 #define 
	#KS_ATTR_PRINTF
(
fmt
, 
arg
)

	)

54 #ifndef 
KSTRING_T


55 #define 
	#KSTRING_T
 
kstring_t


	)

56 typedef struct 
	s__kstring_t
 {

57 
size_t
 
	ml
, 
	mm
;

58 char *
	ms
;

59 } 
	tkstring_t
;

63 
uint64_t
 
	mtab
[4];

64 int 
	msep
, 
	mfinished
;

65 const char *
	mp
;

66 } 
	tks_tokaux_t
;

68 #ifdef 
__cplusplus


72 int 
kvsprintf
(
kstring_t
 *
s
, const char *
fmt
, 
va_list
 
ap
) 
KS_ATTR_PRINTF
(2,0);

73 int 
ksprintf
(
kstring_t
 *
s
, const char *
fmt
, ...) 
KS_ATTR_PRINTF
(2,3);

74 int 
ksplit_core
(char *
s
, int 
delimiter
, int *
_max
, int **
_offsets
);

75 char *
kstrstr
(const char *
str
, const char *
pat
, int **
_prep
);

76 char *
kstrnstr
(const char *
str
, const char *
pat
, int 
n
, int **
_prep
);

77 void *
kmemmem
(const void *
_str
, int 
n
, const void *
_pat
, int 
m
, int **
_prep
);

83 char *
kstrtok
(const char *
str
, const char *
sep
, 
ks_tokaux_t
 *
aux
);

89 typedef char *
	tkgets_func
(char *, int, void *);

90 int 
kgetline
(
kstring_t
 *
s
, 
kgets_func
 *
fgets
, void *
fp
);

92 #ifdef 
__cplusplus


96 static 
inline
 int 
	$ks_resize
(
kstring_t
 *
s
, 
size_t
 
size
)

98 if (
s
->
m
 < 
size
) {

99 char *
tmp
;

100 
s
->
m
 = 
size
;

101 
	`kroundup32
(
s
->
m
);

102 if ((
tmp
 = (char*)
	`realloc
(
s
->s, s->
m
)))

103 
s
->s = 
tmp
;

108 
	}
}

110 static 
inline
 char *
	$ks_str
(
kstring_t
 *
s
)

112 return 
s
->s;

113 
	}
}

115 static 
inline
 
size_t
 
	$ks_len
(
kstring_t
 *
s
)

117 return 
s
->
l
;

118 
	}
}

124 static 
inline
 char *
	$ks_release
(
kstring_t
 *
s
)

126 char *
ss
 = 
s
->s;

127 
s
->
l
 = s->
m
 = 0;

128 
s
->s = 
NULL
;

129 return 
ss
;

130 
	}
}

132 static 
inline
 int 
	$kputsn
(const char *
p
, int 
l
, 
kstring_t
 *
s
)

134 if (
s
->
l
 + l + 1 >= s->
m
) {

135 char *
tmp
;

136 
s
->
m
 = s->
l
 + l + 2;

137 
	`kroundup32
(
s
->
m
);

138 if ((
tmp
 = (char*)
	`realloc
(
s
->s, s->
m
)))

139 
s
->s = 
tmp
;

141 return 
EOF
;

143 
	`memcpy
(
s
->s + s->
l
, 
p
, l);

144 
s
->
l
 += l;

145 
s
->s[s->
l
] = 0;

146 return 
l
;

147 
	}
}

149 static 
inline
 int 
	$kputs
(const char *
p
, 
kstring_t
 *
s
)

151 return 
	`kputsn
(
p
, 
	`strlen
(p), 
s
);

152 
	}
}

154 static 
inline
 int 
	$kputc
(int 
c
, 
kstring_t
 *
s
)

156 if (
s
->
l
 + 1 >= s->
m
) {

157 char *
tmp
;

158 
s
->
m
 = s->
l
 + 2;

159 
	`kroundup32
(
s
->
m
);

160 if ((
tmp
 = (char*)
	`realloc
(
s
->s, s->
m
)))

161 
s
->s = 
tmp
;

163 return 
EOF
;

165 
s
->s[s->
l
++] = 
c
;

166 
s
->s[s->
l
] = 0;

167 return 
c
;

168 
	}
}

170 static 
inline
 int 
	$kputc_
(int 
c
, 
kstring_t
 *
s
)

172 if (
s
->
l
 + 1 > s->
m
) {

173 char *
tmp
;

174 
s
->
m
 = s->
l
 + 1;

175 
	`kroundup32
(
s
->
m
);

176 if ((
tmp
 = (char*)
	`realloc
(
s
->s, s->
m
)))

177 
s
->s = 
tmp
;

179 return 
EOF
;

181 
s
->s[s->
l
++] = 
c
;

183 
	}
}

185 static 
inline
 int 
	$kputsn_
(const void *
p
, int 
l
, 
kstring_t
 *
s
)

187 if (
s
->
l
 + l > s->
m
) {

188 char *
tmp
;

189 
s
->
m
 = s->
l
 + l;

190 
	`kroundup32
(
s
->
m
);

191 if ((
tmp
 = (char*)
	`realloc
(
s
->s, s->
m
)))

192 
s
->s = 
tmp
;

194 return 
EOF
;

196 
	`memcpy
(
s
->s + s->
l
, 
p
, l);

197 
s
->
l
 += l;

198 return 
l
;

199 
	}
}

201 static 
inline
 int 
	$kputw
(int 
c
, 
kstring_t
 *
s
)

203 char 
buf
[16];

204 int 
i
, 
l
 = 0;

205 unsigned int 
x
 = 
c
;

206 if (
c
 < 0) 
x
 = -x;

207 do { 
buf
[
l
++] = 
x
%10 + '0'; x /= 10; } while (x > 0);

208 if (
c
 < 0) 
buf
[
l
++] = '-';

209 if (
s
->
l
 + l + 1 >= s->
m
) {

210 char *
tmp
;

211 
s
->
m
 = s->
l
 + l + 2;

212 
	`kroundup32
(
s
->
m
);

213 if ((
tmp
 = (char*)
	`realloc
(
s
->s, s->
m
)))

214 
s
->s = 
tmp
;

216 return 
EOF
;

218 for (
i
 = 
l
 - 1; i >= 0; --i) 
s
->s[s->l++] = 
buf
[i];

219 
s
->s[s->
l
] = 0;

221 
	}
}

223 static 
inline
 int 
	$kputuw
(unsigned 
c
, 
kstring_t
 *
s
)

225 char 
buf
[16];

226 int 
l
, 
i
;

227 unsigned 
x
;

228 if (
c
 == 0) return 
	`kputc
('0', 
s
);

229 for (
l
 = 0, 
x
 = 
c
; x > 0; x /= 10) 
buf
[l++] = x%10 + '0';

230 if (
s
->
l
 + l + 1 >= s->
m
) {

231 char *
tmp
;

232 
s
->
m
 = s->
l
 + l + 2;

233 
	`kroundup32
(
s
->
m
);

234 if ((
tmp
 = (char*)
	`realloc
(
s
->s, s->
m
)))

235 
s
->s = 
tmp
;

237 return 
EOF
;

239 for (
i
 = 
l
 - 1; i >= 0; --i) 
s
->s[s->l++] = 
buf
[i];

240 
s
->s[s->
l
] = 0;

242 
	}
}

244 static 
inline
 int 
	$kputl
(long 
c
, 
kstring_t
 *
s
)

246 char 
buf
[32];

247 int 
i
, 
l
 = 0;

248 unsigned long 
x
 = 
c
;

249 if (
c
 < 0) 
x
 = -x;

250 do { 
buf
[
l
++] = 
x
%10 + '0'; x /= 10; } while (x > 0);

251 if (
c
 < 0) 
buf
[
l
++] = '-';

252 if (
s
->
l
 + l + 1 >= s->
m
) {

253 char *
tmp
;

254 
s
->
m
 = s->
l
 + l + 2;

255 
	`kroundup32
(
s
->
m
);

256 if ((
tmp
 = (char*)
	`realloc
(
s
->s, s->
m
)))

257 
s
->s = 
tmp
;

259 return 
EOF
;

261 for (
i
 = 
l
 - 1; i >= 0; --i) 
s
->s[s->l++] = 
buf
[i];

262 
s
->s[s->
l
] = 0;

264 
	}
}

270 static 
inline
 int *
	$ksplit
(
kstring_t
 *
s
, int 
delimiter
, int *
n
)

272 int 
max
 = 0, *
offsets
 = 0;

273 *
n
 = 
	`ksplit_core
(
s
->s, 
delimiter
, &
max
, &
offsets
);

274 return 
offsets
;

275 
	}
}

	@deps/klib/ksw.c

26 #include 
	~<stdlib.h
>

27 #include 
	~<stdint.h
>

28 #include 
	~<emmintrin.h
>

29 #include 
	~"ksw.h
"

31 #ifdef 
__GNUC__


32 #define 
	#LIKELY
(
x
) 
	`__builtin_expect
((x),1)

	)

33 #define 
	#UNLIKELY
(
x
) 
	`__builtin_expect
((x),0)

	)

35 #define 
	#LIKELY
(
x
) (x)

	)

36 #define 
	#UNLIKELY
(
x
) (x)

	)

39 const 
kswr_t
 
	gg_defr
 = { 0, -1, -1, -1, -1, -1, -1 };

41 struct 
	s_kswq_t
 {

42 int 
	mqlen
, 
	mslen
;

43 
uint8_t
 
	mshift
, 
	mmdiff
, 
	mmax
, 
	msize
;

44 
__m128i
 *
	mqp
, *
	mH0
, *
	mH1
, *
	mE
, *
	mHmax
;

58 
kswq_t
 *
	$ksw_qinit
(int 
size
, int 
qlen
, const 
uint8_t
 *
query
, int 
m
, const 
int8_t
 *
mat
)

60 
kswq_t
 *
q
;

61 int 
slen
, 
a
, 
tmp
, 
p
;

63 
size
 = size > 1? 2 : 1;

64 
p
 = 8 * (3 - 
size
);

65 
slen
 = (
qlen
 + 
p
 - 1) / p;

66 
q
 = (
kswq_t
*)
	`malloc
(sizeof(kswq_t) + 256 + 16 * 
slen
 * (
m
 + 4));

67 
q
->
qp
 = (
__m128i
*)(((
size_t
)q + sizeof(
kswq_t
) + 15) >> 4 << 4);

68 
q
->
H0
 = q->
qp
 + 
slen
 * 
m
;

69 
q
->
H1
 = q->
H0
 + 
slen
;

70 
q
->
E
 = q->
H1
 + 
slen
;

71 
q
->
Hmax
 = q->
E
 + 
slen
;

72 
q
->
slen
 = slen; q->
qlen
 = qlen; q->
size
 = size;

74 
tmp
 = 
m
 * m;

75 for (
a
 = 0, 
q
->
shift
 = 127, q->
mdiff
 = 0; a < 
tmp
; ++a) {

76 if (
mat
[
a
] < (
int8_t
)
q
->
shift
) q->shift = mat[a];

77 if (
mat
[
a
] > (
int8_t
)
q
->
mdiff
) q->mdiff = mat[a];

79 
q
->
max
 = q->
mdiff
;

80 
q
->
shift
 = 256 - q->shift;

81 
q
->
mdiff
 += q->
shift
;

84 if (
size
 == 1) {

85 
int8_t
 *
t
 = (int8_t*)
q
->
qp
;

86 for (
a
 = 0; a < 
m
; ++a) {

87 int 
i
, 
k
, 
nlen
 = 
slen
 * 
p
;

88 const 
int8_t
 *
ma
 = 
mat
 + 
a
 * 
m
;

89 for (
i
 = 0; i < 
slen
; ++i)

90 for (
k
 = 
i
; k < 
nlen
; k += 
slen
)

91 *
t
++ = (
k
 >= 
qlen
? 0 : 
ma
[
query
[k]]) + 
q
->
shift
;

94 
int16_t
 *
t
 = (int16_t*)
q
->
qp
;

95 for (
a
 = 0; a < 
m
; ++a) {

96 int 
i
, 
k
, 
nlen
 = 
slen
 * 
p
;

97 const 
int8_t
 *
ma
 = 
mat
 + 
a
 * 
m
;

98 for (
i
 = 0; i < 
slen
; ++i)

99 for (
k
 = 
i
; k < 
nlen
; k += 
slen
)

100 *
t
++ = (
k
 >= 
qlen
? 0 : 
ma
[
query
[k]]);

103 return 
q
;

104 
	}
}

106 
kswr_t
 
	$ksw_u8
(
kswq_t
 *
q
, int 
tlen
, const 
uint8_t
 *
target
, int 
_gapo
, int 
_gape
, int 
xtra
)

108 int 
slen
, 
i
, 
m_b
, 
n_b
, 
te
 = -1, 
gmax
 = 0, 
minsc
, 
endsc
;

109 
uint64_t
 *
b
;

110 
__m128i
 
zero
, 
gapoe
, 
gape
, 
shift
, *
H0
, *
H1
, *
E
, *
Hmax
;

111 
kswr_t
 
r
;

113 #define 
	#__max_16
(
ret
, 
xx
) do { \

114 (
xx
) = 
	`_mm_max_epu8
((xx), 
	`_mm_srli_si128
((xx), 8)); \

115 (
xx
) = 
	`_mm_max_epu8
((xx), 
	`_mm_srli_si128
((xx), 4)); \

116 (
xx
) = 
	`_mm_max_epu8
((xx), 
	`_mm_srli_si128
((xx), 2)); \

117 (
xx
) = 
	`_mm_max_epu8
((xx), 
	`_mm_srli_si128
((xx), 1)); \

118 (
ret
) = 
	`_mm_extract_epi16
((
xx
), 0) & 0x00ff; \

119 } while (0)

	)

122 
r
 = 
g_defr
;

123 
minsc
 = (
xtra
&
KSW_XSUBO
)? xtra&0xffff : 0x10000;

124 
endsc
 = (
xtra
&
KSW_XSTOP
)? xtra&0xffff : 0x10000;

125 
m_b
 = 
n_b
 = 0; 
b
 = 0;

126 
zero
 = 
	`_mm_set1_epi32
(0);

127 
gapoe
 = 
	`_mm_set1_epi8
(
_gapo
 + 
_gape
);

128 
gape
 = 
	`_mm_set1_epi8
(
_gape
);

129 
shift
 = 
	`_mm_set1_epi8
(
q
->shift);

130 
H0
 = 
q
->H0; 
H1
 = q->H1; 
E
 = q->E; 
Hmax
 = q->Hmax;

131 
slen
 = 
q
->slen;

132 for (
i
 = 0; i < 
slen
; ++i) {

133 
	`_mm_store_si128
(
E
 + 
i
, 
zero
);

134 
	`_mm_store_si128
(
H0
 + 
i
, 
zero
);

135 
	`_mm_store_si128
(
Hmax
 + 
i
, 
zero
);

138 for (
i
 = 0; i < 
tlen
; ++i) {

139 int 
j
, 
k
, 
cmp
, 
imax
;

140 
__m128i
 
e
, 
h
, 
f
 = 
zero
, 
max
 = zero, *
S
 = 
q
->
qp
 + 
target
[
i
] * 
slen
;

141 
h
 = 
	`_mm_load_si128
(
H0
 + 
slen
 - 1);

142 
h
 = 
	`_mm_slli_si128
(h, 1);

143 for (
j
 = 0; 
	`LIKELY
(j < 
slen
); ++j) {

150 
h
 = 
	`_mm_adds_epu8
(h, 
	`_mm_load_si128
(
S
 + 
j
));

151 
h
 = 
	`_mm_subs_epu8
(h, 
shift
);

152 
e
 = 
	`_mm_load_si128
(
E
 + 
j
);

153 
h
 = 
	`_mm_max_epu8
(h, 
e
);

154 
h
 = 
	`_mm_max_epu8
(h, 
f
);

155 
max
 = 
	`_mm_max_epu8
(max, 
h
);

156 
	`_mm_store_si128
(
H1
 + 
j
, 
h
);

158 
h
 = 
	`_mm_subs_epu8
(h, 
gapoe
);

159 
e
 = 
	`_mm_subs_epu8
(e, 
gape
);

160 
e
 = 
	`_mm_max_epu8
(e, 
h
);

161 
	`_mm_store_si128
(
E
 + 
j
, 
e
);

163 
f
 = 
	`_mm_subs_epu8
(f, 
gape
);

164 
f
 = 
	`_mm_max_epu8
(f, 
h
);

166 
h
 = 
	`_mm_load_si128
(
H0
 + 
j
);

169 for (
k
 = 0; 
	`LIKELY
(k < 16); ++k) {

170 
f
 = 
	`_mm_slli_si128
(f, 1);

171 for (
j
 = 0; 
	`LIKELY
(j < 
slen
); ++j) {

172 
h
 = 
	`_mm_load_si128
(
H1
 + 
j
);

173 
h
 = 
	`_mm_max_epu8
(h, 
f
);

174 
	`_mm_store_si128
(
H1
 + 
j
, 
h
);

175 
h
 = 
	`_mm_subs_epu8
(h, 
gapoe
);

176 
f
 = 
	`_mm_subs_epu8
(f, 
gape
);

177 
cmp
 = 
	`_mm_movemask_epi8
(
	`_mm_cmpeq_epi8
(
	`_mm_subs_epu8
(
f
, 
h
), 
zero
));

178 if (
	`UNLIKELY
(
cmp
 == 0xffff)) goto 
end_loop16
;

181 
end_loop16
:

183 
	`__max_16
(
imax
, 
max
);

184 if (
imax
 >= 
minsc
) {

185 if (
n_b
 == 0 || (
int32_t
)
b
[n_b-1] + 1 != 
i
) {

186 if (
n_b
 == 
m_b
) {

187 
m_b
 = m_b? m_b<<1 : 8;

188 
b
 = (
uint64_t
*)
	`realloc
(b, 8 * 
m_b
);

190 
b
[
n_b
++] = (
uint64_t
)
imax
<<32 | 
i
;

191 } else if ((int)(
b
[
n_b
-1]>>32) < 
imax
) b[n_b-1] = (
uint64_t
)imax<<32 | 
i
;

193 if (
imax
 > 
gmax
) {

194 
gmax
 = 
imax
; 
te
 = 
i
;

195 for (
j
 = 0; 
	`LIKELY
(j < 
slen
); ++j)

196 
	`_mm_store_si128
(
Hmax
 + 
j
, 
	`_mm_load_si128
(
H1
 + j));

197 if (
gmax
 + 
q
->
shift
 >= 255 || gmax >= 
endsc
) break;

199 
S
 = 
H1
; H1 = 
H0
; H0 = S;

201 
r
.
score
 = 
gmax
 + 
q
->
shift
 < 255? gmax : 255;

202 
r
.
te
 = te;

203 if (
r
.
score
 != 255) {

204 int 
max
 = -1, 
low
, 
high
, 
qlen
 = 
slen
 * 16;

205 
uint8_t
 *
t
 = (uint8_t*)
Hmax
;

206 for (
i
 = 0; i < 
qlen
; ++i, ++
t
)

207 if ((int)*
t
 > 
max
) max = *t, 
r
.
qe
 = 
i
 / 16 + i % 16 * 
slen
;

209 if (
b
) {

210 
i
 = (
r
.
score
 + 
q
->
max
 - 1) / q->max;

211 
low
 = 
te
 - 
i
; 
high
 = te + i;

212 for (
i
 = 0; i < 
n_b
; ++i) {

213 int 
e
 = (
int32_t
)
b
[
i
];

214 if ((
e
 < 
low
 || e > 
high
) && (int)(
b
[
i
]>>32) > 
r
.
score2
)

215 
r
.
score2
 = 
b
[
i
]>>32, r.
te2
 = 
e
;

219 
	`free
(
b
);

220 return 
r
;

221 
	}
}

223 
kswr_t
 
	$ksw_i16
(
kswq_t
 *
q
, int 
tlen
, const 
uint8_t
 *
target
, int 
_gapo
, int 
_gape
, int 
xtra
)

225 int 
slen
, 
i
, 
m_b
, 
n_b
, 
te
 = -1, 
gmax
 = 0, 
minsc
, 
endsc
;

226 
uint64_t
 *
b
;

227 
__m128i
 
zero
, 
gapoe
, 
gape
, *
H0
, *
H1
, *
E
, *
Hmax
;

228 
kswr_t
 
r
;

230 #define 
	#__max_8
(
ret
, 
xx
) do { \

231 (
xx
) = 
	`_mm_max_epi16
((xx), 
	`_mm_srli_si128
((xx), 8)); \

232 (
xx
) = 
	`_mm_max_epi16
((xx), 
	`_mm_srli_si128
((xx), 4)); \

233 (
xx
) = 
	`_mm_max_epi16
((xx), 
	`_mm_srli_si128
((xx), 2)); \

234 (
ret
) = 
	`_mm_extract_epi16
((
xx
), 0); \

235 } while (0)

	)

238 
r
 = 
g_defr
;

239 
minsc
 = (
xtra
&
KSW_XSUBO
)? xtra&0xffff : 0x10000;

240 
endsc
 = (
xtra
&
KSW_XSTOP
)? xtra&0xffff : 0x10000;

241 
m_b
 = 
n_b
 = 0; 
b
 = 0;

242 
zero
 = 
	`_mm_set1_epi32
(0);

243 
gapoe
 = 
	`_mm_set1_epi16
(
_gapo
 + 
_gape
);

244 
gape
 = 
	`_mm_set1_epi16
(
_gape
);

245 
H0
 = 
q
->H0; 
H1
 = q->H1; 
E
 = q->E; 
Hmax
 = q->Hmax;

246 
slen
 = 
q
->slen;

247 for (
i
 = 0; i < 
slen
; ++i) {

248 
	`_mm_store_si128
(
E
 + 
i
, 
zero
);

249 
	`_mm_store_si128
(
H0
 + 
i
, 
zero
);

250 
	`_mm_store_si128
(
Hmax
 + 
i
, 
zero
);

253 for (
i
 = 0; i < 
tlen
; ++i) {

254 int 
j
, 
k
, 
imax
;

255 
__m128i
 
e
, 
h
, 
f
 = 
zero
, 
max
 = zero, *
S
 = 
q
->
qp
 + 
target
[
i
] * 
slen
;

256 
h
 = 
	`_mm_load_si128
(
H0
 + 
slen
 - 1);

257 
h
 = 
	`_mm_slli_si128
(h, 2);

258 for (
j
 = 0; 
	`LIKELY
(j < 
slen
); ++j) {

259 
h
 = 
	`_mm_adds_epi16
(h, *
S
++);

260 
e
 = 
	`_mm_load_si128
(
E
 + 
j
);

261 
h
 = 
	`_mm_max_epi16
(h, 
e
);

262 
h
 = 
	`_mm_max_epi16
(h, 
f
);

263 
max
 = 
	`_mm_max_epi16
(max, 
h
);

264 
	`_mm_store_si128
(
H1
 + 
j
, 
h
);

265 
h
 = 
	`_mm_subs_epu16
(h, 
gapoe
);

266 
e
 = 
	`_mm_subs_epu16
(e, 
gape
);

267 
e
 = 
	`_mm_max_epi16
(e, 
h
);

268 
	`_mm_store_si128
(
E
 + 
j
, 
e
);

269 
f
 = 
	`_mm_subs_epu16
(f, 
gape
);

270 
f
 = 
	`_mm_max_epi16
(f, 
h
);

271 
h
 = 
	`_mm_load_si128
(
H0
 + 
j
);

273 for (
k
 = 0; 
	`LIKELY
(k < 16); ++k) {

274 
f
 = 
	`_mm_slli_si128
(f, 2);

275 for (
j
 = 0; 
	`LIKELY
(j < 
slen
); ++j) {

276 
h
 = 
	`_mm_load_si128
(
H1
 + 
j
);

277 
h
 = 
	`_mm_max_epi16
(h, 
f
);

278 
	`_mm_store_si128
(
H1
 + 
j
, 
h
);

279 
h
 = 
	`_mm_subs_epu16
(h, 
gapoe
);

280 
f
 = 
	`_mm_subs_epu16
(f, 
gape
);

281 if(
	`UNLIKELY
(!
	`_mm_movemask_epi8
(
	`_mm_cmpgt_epi16
(
f
, 
h
)))) goto 
end_loop8
;

284 
end_loop8
:

285 
	`__max_8
(
imax
, 
max
);

286 if (
imax
 >= 
minsc
) {

287 if (
n_b
 == 0 || (
int32_t
)
b
[n_b-1] + 1 != 
i
) {

288 if (
n_b
 == 
m_b
) {

289 
m_b
 = m_b? m_b<<1 : 8;

290 
b
 = (
uint64_t
*)
	`realloc
(b, 8 * 
m_b
);

292 
b
[
n_b
++] = (
uint64_t
)
imax
<<32 | 
i
;

293 } else if ((int)(
b
[
n_b
-1]>>32) < 
imax
) b[n_b-1] = (
uint64_t
)imax<<32 | 
i
;

295 if (
imax
 > 
gmax
) {

296 
gmax
 = 
imax
; 
te
 = 
i
;

297 for (
j
 = 0; 
	`LIKELY
(j < 
slen
); ++j)

298 
	`_mm_store_si128
(
Hmax
 + 
j
, 
	`_mm_load_si128
(
H1
 + j));

299 if (
gmax
 >= 
endsc
) break;

301 
S
 = 
H1
; H1 = 
H0
; H0 = S;

303 
r
.
score
 = 
gmax
; r.
te
 = te;

305 int 
max
 = -1, 
low
, 
high
, 
qlen
 = 
slen
 * 8;

306 
uint16_t
 *
t
 = (uint16_t*)
Hmax
;

307 for (
i
 = 0, 
r
.
qe
 = -1; i < 
qlen
; ++i, ++
t
)

308 if ((int)*
t
 > 
max
) max = *t, 
r
.
qe
 = 
i
 / 8 + i % 8 * 
slen
;

309 if (
b
) {

310 
i
 = (
r
.
score
 + 
q
->
max
 - 1) / q->max;

311 
low
 = 
te
 - 
i
; 
high
 = te + i;

312 for (
i
 = 0; i < 
n_b
; ++i) {

313 int 
e
 = (
int32_t
)
b
[
i
];

314 if ((
e
 < 
low
 || e > 
high
) && (int)(
b
[
i
]>>32) > 
r
.
score2
)

315 
r
.
score2
 = 
b
[
i
]>>32, r.
te2
 = 
e
;

319 
	`free
(
b
);

320 return 
r
;

321 
	}
}

323 static void 
	$revseq
(int 
l
, 
uint8_t
 *
s
)

325 int 
i
, 
t
;

326 for (
i
 = 0; i < 
l
>>1; ++i)

327 
t
 = 
s
[
i
], s[i] = s[
l
 - 1 - i], s[l - 1 - i] = t;

328 
	}
}

330 
kswr_t
 
	$ksw_align
(int 
qlen
, 
uint8_t
 *
query
, int 
tlen
, uint8_t *
target
, int 
m
, const 
int8_t
 *
mat
, int 
gapo
, int 
gape
, int 
xtra
, 
kswq_t
 **
qry
)

332 int 
size
;

333 
kswq_t
 *
q
;

334 
kswr_t
 
r
, 
rr
;

335 
	`kswr_t
 (*
func
)(
kswq_t
*, int, const 
uint8_t
*, int, int, int);

337 
q
 = (
qry
 && *qry)? *qry : 
	`ksw_qinit
((
xtra
&
KSW_XBYTE
)? 1 : 2, 
qlen
, 
query
, 
m
, 
mat
);

338 if (
qry
 && *qry == 0) *qry = 
q
;

339 
func
 = 
q
->
size
 == 2? 
ksw_i16
 : 
ksw_u8
;

340 
size
 = 
q
->size;

341 
r
 = 
	`func
(
q
, 
tlen
, 
target
, 
gapo
, 
gape
, 
xtra
);

342 if (
qry
 == 0) 
	`free
(
q
);

343 if ((
xtra
&
KSW_XSTART
) == 0 || ((xtra&
KSW_XSUBO
) && 
r
.
score
 < (xtra&0xffff))) return r;

344 
	`revseq
(
r
.
qe
 + 1, 
query
); revseq(r.
te
 + 1, 
target
);

345 
q
 = 
	`ksw_qinit
(
size
, 
r
.
qe
 + 1, 
query
, 
m
, 
mat
);

346 
rr
 = 
	`func
(
q
, 
tlen
, 
target
, 
gapo
, 
gape
, 
KSW_XSTOP
 | 
r
.
score
);

347 
	`revseq
(
r
.
qe
 + 1, 
query
); revseq(r.
te
 + 1, 
target
);

348 
	`free
(
q
);

349 if (
r
.
score
 == 
rr
.score)

350 
r
.
tb
 = r.
te
 - 
rr
.te, r.
qb
 = r.
qe
 - rr.qe;

351 return 
r
;

352 
	}
}

359 
int32_t
 
	mh
, 
	me
;

360 } 
	teh_t
;

362 int 
	$ksw_extend
(int 
qlen
, const 
uint8_t
 *
query
, int 
tlen
, const uint8_t *
target
, int 
m
, const 
int8_t
 *
mat
, int 
gapo
, int 
gape
, int 
w
, int 
h0
, int *
_qle
, int *
_tle
)

364 
eh_t
 *
eh
;

365 
int8_t
 *
qp
;

366 int 
i
, 
j
, 
k
, 
gapoe
 = 
gapo
 + 
gape
, 
beg
, 
end
, 
max
, 
max_i
, 
max_j
, 
max_gap
;

367 if (
h0
 < 0) h0 = 0;

369 
qp
 = 
	`malloc
(
qlen
 * 
m
);

370 
eh
 = 
	`calloc
(
qlen
 + 1, 8);

372 for (
k
 = 
i
 = 0; k < 
m
; ++k) {

373 const 
int8_t
 *
p
 = &
mat
[
k
 * 
m
];

374 for (
j
 = 0; j < 
qlen
; ++j) 
qp
[
i
++] = 
p
[
query
[j]];

377 
eh
[0].
h
 = 
h0
; eh[1].h = h0 > 
gapoe
? h0 - gapoe : 0;

378 for (
j
 = 2; j <= 
qlen
 && 
eh
[j-1].
h
 > 
gape
; ++j)

379 
eh
[
j
].
h
 = eh[j-1].h - 
gape
;

381 
k
 = 
m
 * m;

382 for (
i
 = 0, 
max
 = 0; i < 
k
; ++i)

383 
max
 = max > 
mat
[
i
]? max : mat[i];

384 
max_gap
 = (int)((double)(
qlen
 * 
max
 - 
gapo
) / 
gape
 + 1.);

385 
max_gap
 = max_gap > 1? max_gap : 1;

386 
w
 = w < 
max_gap
? w : max_gap;

388 
max
 = 
h0
, 
max_i
 = 
max_j
 = -1;

389 
beg
 = 0, 
end
 = 
qlen
;

390 for (
i
 = 0; 
	`LIKELY
(i < 
tlen
); ++i) {

391 int 
f
 = 0, 
h1
, 
m
 = 0, 
mj
 = -1;

392 
int8_t
 *
q
 = &
qp
[
target
[
i
] * 
qlen
];

394 
h1
 = 
h0
 - (
gapo
 + 
gape
 * (
i
 + 1));

395 if (
h1
 < 0) h1 = 0;

397 if (
beg
 < 
i
 - 
w
) beg = i - w;

398 if (
end
 > 
i
 + 
w
 + 1) end = i + w + 1;

399 if (
end
 > 
qlen
) end = qlen;

400 for (
j
 = 
beg
; 
	`LIKELY
(j < 
end
); ++j) {

406 
eh_t
 *
p
 = &
eh
[
j
];

407 int 
h
 = 
p
->h, 
e
 = p->e;

408 
p
->
h
 = 
h1
;

409 
h
 += 
q
[
j
];

410 
h
 = h > 
e
? h : e;

411 
h
 = h > 
f
? h : f;

412 
h1
 = 
h
;

413 
mj
 = 
m
 > 
h
? mj : 
j
;

414 
m
 = m > 
h
? m : h;

415 
h
 -= 
gapoe
;

416 
h
 = h > 0? h : 0;

417 
e
 -= 
gape
;

418 
e
 = e > 
h
? e : h;

419 
p
->
e
 = e;

420 
f
 -= 
gape
;

421 
f
 = f > 
h
? f : h;

423 
eh
[
end
].
h
 = 
h1
; eh[end].
e
 = 0;

424 if (
m
 == 0) break;

425 if (
m
 > 
max
) max = m, 
max_i
 = 
i
, 
max_j
 = 
mj
;

427 for (
j
 = 
mj
; j >= 
beg
 && 
eh
[j].
h
; --j);

428 
beg
 = 
j
 + 1;

429 for (
j
 = 
mj
 + 2; j <= 
end
 && 
eh
[j].
h
; ++j);

430 
end
 = 
j
;

433 
	`free
(
eh
); free(
qp
);

434 if (
_qle
) *_qle = 
max_j
 + 1;

435 if (
_tle
) *_tle = 
max_i
 + 1;

436 return 
max
;

437 
	}
}

443 #define 
	#MINUS_INF
 -0x40000000

	)

445 static 
inline
 
uint32_t
 *
	$push_cigar
(int *
n_cigar
, int *
m_cigar
, 
uint32_t
 *
cigar
, int 
op
, int 
len
)

447 if (*
n_cigar
 == 0 || 
op
 != (
cigar
[(*n_cigar) - 1]&0xf)) {

448 if (*
n_cigar
 == *
m_cigar
) {

449 *
m_cigar
 = *m_cigar? (*m_cigar)<<1 : 4;

450 
cigar
 = 
	`realloc
(cigar, (*
m_cigar
) << 2);

452 
cigar
[(*
n_cigar
)++] = 
len
<<4 | 
op
;

453 } else 
cigar
[(*
n_cigar
)-1] += 
len
<<4;

454 return 
cigar
;

455 
	}
}

457 int 
	$ksw_global
(int 
qlen
, const 
uint8_t
 *
query
, int 
tlen
, const uint8_t *
target
, int 
m
, const 
int8_t
 *
mat
, int 
gapo
, int 
gape
, int 
w
, int *
n_cigar_
, 
uint32_t
 **
cigar_
)

459 
eh_t
 *
eh
;

460 
int8_t
 *
qp
;

461 int 
i
, 
j
, 
k
, 
gapoe
 = 
gapo
 + 
gape
, 
score
, 
n_col
;

462 
uint8_t
 *
z
;

463 if (
n_cigar_
) *n_cigar_ = 0;

465 
n_col
 = 
qlen
 < 2*
w
+1? qlen : 2*w+1;

466 
z
 = 
	`malloc
(
n_col
 * 
tlen
);

467 
qp
 = 
	`malloc
(
qlen
 * 
m
);

468 
eh
 = 
	`calloc
(
qlen
 + 1, 8);

470 for (
k
 = 
i
 = 0; k < 
m
; ++k) {

471 const 
int8_t
 *
p
 = &
mat
[
k
 * 
m
];

472 for (
j
 = 0; j < 
qlen
; ++j) 
qp
[
i
++] = 
p
[
query
[j]];

475 
eh
[0].
h
 = 0; eh[0].
e
 = 
MINUS_INF
;

476 for (
j
 = 1; j <= 
qlen
 && j <= 
w
; ++j)

477 
eh
[
j
].
h
 = -(
gapo
 + 
gape
 * j), eh[j].
e
 = 
MINUS_INF
;

478 for (; 
j
 <= 
qlen
; ++j) 
eh
[j].
h
 = eh[j].
e
 = 
MINUS_INF
;

480 for (
i
 = 0; 
	`LIKELY
(i < 
tlen
); ++i) {

481 
int32_t
 
f
 = 
MINUS_INF
, 
h1
, 
beg
, 
end
;

482 
int8_t
 *
q
 = &
qp
[
target
[
i
] * 
qlen
];

483 
uint8_t
 *
zi
 = &
z
[
i
 * 
n_col
];

484 
beg
 = 
i
 > 
w
? i - w : 0;

485 
end
 = 
i
 + 
w
 + 1 < 
qlen
? i + w + 1 : qlen;

486 
h1
 = 
beg
 == 0? -(
gapo
 + 
gape
 * (
i
 + 1)) : 
MINUS_INF
;

487 for (
j
 = 
beg
; 
	`LIKELY
(j < 
end
); ++j) {

490 
eh_t
 *
p
 = &
eh
[
j
];

491 
int32_t
 
h
 = 
p
->h, 
e
 = p->e;

492 
uint8_t
 
d
;

493 
p
->
h
 = 
h1
;

494 
h
 += 
q
[
j
];

495 
d
 = 
h
 > 
e
? 0 : 1;

496 
h
 = h > 
e
? h : e;

497 
d
 = 
h
 > 
f
? d : 2;

498 
h
 = h > 
f
? h : f;

499 
h1
 = 
h
;

500 
h
 -= 
gapoe
;

501 
e
 -= 
gape
;

502 
d
 |= 
e
 > 
h
? 1<<2 : 0;

503 
e
 = e > 
h
? e : h;

504 
p
->
e
 = e;

505 
f
 -= 
gape
;

506 
d
 |= 
f
 > 
h
? 2<<4 : 0;

507 
f
 = f > 
h
? f : h;

508 
zi
[
j
 - 
beg
] = 
d
;

510 
eh
[
end
].
h
 = 
h1
; eh[end].
e
 = 
MINUS_INF
;

512 
score
 = 
eh
[
qlen
].
h
;

513 if (
n_cigar_
 && 
cigar_
) {

514 int 
n_cigar
 = 0, 
m_cigar
 = 0, 
which
 = 0;

515 
uint32_t
 *
cigar
 = 0, 
tmp
;

516 
i
 = 
tlen
 - 1; 
k
 = (i + 
w
 + 1 < 
qlen
? i + w + 1 : qlen) - 1;

517 while (
i
 >= 0 && 
k
 >= 0) {

518 
which
 = 
z
[
i
 * 
n_col
 + (
k
 - (i > 
w
? i - w : 0))] >> (which<<1) & 3;

519 if (
which
 == 0) 
cigar
 = 
	`push_cigar
(&
n_cigar
, &
m_cigar
, cigar, 0, 1), --
i
, --
k
;

520 else if (
which
 == 1) 
cigar
 = 
	`push_cigar
(&
n_cigar
, &
m_cigar
, cigar, 2, 1), --
i
;

521 else 
cigar
 = 
	`push_cigar
(&
n_cigar
, &
m_cigar
, cigar, 1, 1), --
k
;

523 if (
i
 >= 0) 
cigar
 = 
	`push_cigar
(&
n_cigar
, &
m_cigar
, cigar, 2, i + 1);

524 if (
k
 >= 0) 
cigar
 = 
	`push_cigar
(&
n_cigar
, &
m_cigar
, cigar, 1, k + 1);

525 for (
i
 = 0; i < 
n_cigar
>>1; ++i)

526 
tmp
 = 
cigar
[
i
], cigar[i] = cigar[
n_cigar
-1-i], cigar[n_cigar-1-i] = tmp;

527 *
n_cigar_
 = 
n_cigar
, *
cigar_
 = 
cigar
;

529 
	`free
(
eh
); free(
qp
); free(
z
);

530 return 
score
;

531 
	}
}

537 #ifdef 
_KSW_MAIN


539 #include 
	~<unistd.h
>

540 #include 
	~<stdio.h
>

541 #include 
	~<zlib.h
>

542 #include 
	~"kseq.h
"

543 
	$KSEQ_INIT
(
gzFile
, 
gzread
)

545 unsigned char 
seq_nt4_table
[256] = {

562 
	}
};

564 int 
	$main
(int 
argc
, char *
argv
[])

566 int 
c
, 
sa
 = 1, 
sb
 = 3, 
i
, 
j
, 
k
, 
forward_only
 = 0, 
max_rseq
 = 0;

567 
int8_t
 
mat
[25];

568 int 
gapo
 = 5, 
gape
 = 2, 
minsc
 = 0, 
xtra
 = 
KSW_XSTART
;

569 
uint8_t
 *
rseq
 = 0;

570 
gzFile
 
fpt
, 
fpq
;

571 
kseq_t
 *
kst
, *
ksq
;

574 while ((
c
 = 
	`getopt
(
argc
, 
argv
, "a:b:q:r:ft:1")) >= 0) {

575 switch (
c
) {

576 case 'a': 
sa
 = 
	`atoi
(
optarg
); break;

577 case 'b': 
sb
 = 
	`atoi
(
optarg
); break;

578 case 'q': 
gapo
 = 
	`atoi
(
optarg
); break;

579 case 'r': 
gape
 = 
	`atoi
(
optarg
); break;

580 case 't': 
minsc
 = 
	`atoi
(
optarg
); break;

581 case 'f': 
forward_only
 = 1; break;

582 case '1': 
xtra
 |= 
KSW_XBYTE
; break;

585 if (
optind
 + 2 > 
argc
) {

586 
	`fprintf
(
stderr
, "Usage: ksw [-1] [-f] [-a%d] [-b%d] [-q%d] [-r%d] [-t%d] <target.fa> <query.fa>\n", 
sa
, 
sb
, 
gapo
, 
gape
, 
minsc
);

589 if (
minsc
 > 0xffff) minsc = 0xffff;

590 
xtra
 |= 
KSW_XSUBO
 | 
minsc
;

592 for (
i
 = 
k
 = 0; i < 4; ++i) {

593 for (
j
 = 0; j < 4; ++j)

594 
mat
[
k
++] = 
i
 == 
j
? 
sa
 : -
sb
;

595 
mat
[
k
++] = 0;

597 for (
j
 = 0; j < 5; ++j) 
mat
[
k
++] = 0;

599 
fpt
 = 
	`gzopen
(
argv
[
optind
], "r"); 
kst
 = 
	`kseq_init
(fpt);

600 
fpq
 = 
	`gzopen
(
argv
[
optind
+1], "r"); 
ksq
 = 
	`kseq_init
(fpq);

602 while (
	`kseq_read
(
ksq
) > 0) {

603 
kswq_t
 *
q
[2] = {0, 0};

604 
kswr_t
 
r
;

605 for (
i
 = 0; i < (int)
ksq
->
seq
.
l
; ++i) ksq->seq.
s
[i] = 
seq_nt4_table
[(int)ksq->seq.s[i]];

606 if (!
forward_only
) {

607 if ((int)
ksq
->
seq
.
m
 > 
max_rseq
) {

608 
max_rseq
 = 
ksq
->
seq
.
m
;

609 
rseq
 = (
uint8_t
*)
	`realloc
(rseq, 
max_rseq
);

611 for (
i
 = 0, 
j
 = 
ksq
->
seq
.
l
 - 1; i < (int)ksq->seq.l; ++i, --j)

612 
rseq
[
j
] = 
ksq
->
seq
.
s
[
i
] == 4? 4 : 3 - ksq->seq.s[i];

614 
	`gzrewind
(
fpt
); 
	`kseq_rewind
(
kst
);

615 while (
	`kseq_read
(
kst
) > 0) {

616 for (
i
 = 0; i < (int)
kst
->
seq
.
l
; ++i) kst->seq.
s
[i] = 
seq_nt4_table
[(int)kst->seq.s[i]];

617 
r
 = 
	`ksw_align
(
ksq
->
seq
.
l
, (
uint8_t
*)ksq->seq.
s
, 
kst
->seq.l, (uint8_t*)kst->seq.s, 5, 
mat
, 
gapo
, 
gape
, 
xtra
, &
q
[0]);

618 if (
r
.
score
 >= 
minsc
)

619 
	`printf
("%s\t%d\t%d\t%s\t%d\t%d\t%d\t%d\t%d\n", 
kst
->
name
.
s
, 
r
.
tb
, r.
te
+1, 
ksq
->name.s, r.
qb
, r.
qe
+1, r.
score
, r.
score2
, r.
te2
);

620 if (
rseq
) {

621 
r
 = 
	`ksw_align
(
ksq
->
seq
.
l
, 
rseq
, 
kst
->seq.l, (
uint8_t
*)kst->seq.
s
, 5, 
mat
, 
gapo
, 
gape
, 
xtra
, &
q
[1]);

622 if (
r
.
score
 >= 
minsc
)

623 
	`printf
("%s\t%d\t%d\t%s\t%d\t%d\t%d\t%d\t%d\n", 
kst
->
name
.
s
, 
r
.
tb
, r.
te
+1, 
ksq
->name.s, (int)ksq->
seq
.
l
 - r.
qb
, (int)ksq->seq.l - 1 - r.
qe
, r.
score
, r.
score2
, r.
te2
);

626 
	`free
(
q
[0]); free(q[1]);

628 
	`free
(
rseq
);

629 
	`kseq_destroy
(
kst
); 
	`gzclose
(
fpt
);

630 
	`kseq_destroy
(
ksq
); 
	`gzclose
(
fpq
);

632 
	}
}

	@deps/klib/ksw.h

1 #ifndef 
__AC_KSW_H


2 #define 
	#__AC_KSW_H


	)

4 #include 
	~<stdint.h
>

6 #define 
	#KSW_XBYTE
 0x10000

	)

7 #define 
	#KSW_XSTOP
 0x20000

	)

8 #define 
	#KSW_XSUBO
 0x40000

	)

9 #define 
	#KSW_XSTART
 0x80000

	)

11 struct 
	g_kswq_t
;

12 typedef struct 
_kswq_t
 
	tkswq_t
;

15 int 
	mscore
;

16 int 
	mte
, 
	mqe
;

17 int 
	mscore2
, 
	mte2
;

18 int 
	mtb
, 
	mqb
;

19 } 
	tkswr_t
;

21 #ifdef 
__cplusplus


63 
kswr_t
 
ksw_align
(int 
qlen
, 
uint8_t
 *
query
, int 
tlen
, uint8_t *
target
, int 
m
, const 
int8_t
 *
mat
, int 
gapo
, int 
gape
, int 
xtra
, 
kswq_t
 **
qry
);

65 int 
ksw_extend
(int 
qlen
, const 
uint8_t
 *
query
, int 
tlen
, const uint8_t *
target
, int 
m
, const 
int8_t
 *
mat
, int 
gapo
, int 
gape
, int 
w
, int 
h0
, int *
_qle
, int *
_tle
);

66 int 
ksw_global
(int 
qlen
, const 
uint8_t
 *
query
, int 
tlen
, const uint8_t *
target
, int 
m
, const 
int8_t
 *
mat
, int 
gapo
, int 
gape
, int 
w
, int *
_n_cigar
, 
uint32_t
 **
_cigar
);

68 #ifdef 
__cplusplus


	@deps/klib/kthread.c

1 #include 
	~<pthread.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<limits.h
>

9 struct 
	gkt_for_t
;

12 struct 
kt_for_t
 *
	mt
;

13 long 
	mi
;

14 } 
	tktf_worker_t
;

16 typedef struct 
	skt_for_t
 {

17 int 
	mn_threads
;

18 long 
	mn
;

19 
ktf_worker_t
 *
	mw
;

20 void (*
	mfunc
)(void*,long,int);

21 void *
	mdata
;

22 } 
	tkt_for_t
;

24 static 
inline
 long 
	$steal_work
(
kt_for_t
 *
t
)

26 int 
i
, 
min_i
 = -1;

27 long 
k
, 
min
 = 
LONG_MAX
;

28 for (
i
 = 0; i < 
t
->
n_threads
; ++i)

29 if (
min
 > 
t
->
w
[
i
].i) min = t->w[i].i, 
min_i
 = i;

30 
k
 = 
	`__sync_fetch_and_add
(&
t
->
w
[
min_i
].
i
, t->
n_threads
);

31 return 
k
 >= 
t
->
n
? -1 : k;

32 
	}
}

34 static void *
	$ktf_worker
(void *
data
)

36 
ktf_worker_t
 *
w
 = (ktf_worker_t*)
data
;

37 long 
i
;

39 
i
 = 
	`__sync_fetch_and_add
(&
w
->i, w->
t
->
n_threads
);

40 if (
i
 >= 
w
->
t
->
n
) break;

41 
w
->
t
->
	`func
(w->t->
data
, 
i
, w - w->t->w);

43 while ((
i
 = 
	`steal_work
(
w
->
t
)) >= 0)

44 
w
->
t
->
	`func
(w->t->
data
, 
i
, w - w->t->w);

45 
	`pthread_exit
(0);

46 
	}
}

48 void 
	$kt_for
(int 
n_threads
, void (*
func
)(void*,long,int), void *
data
, long 
n
)

50 if (
n_threads
 > 1) {

51 int 
i
;

52 
kt_for_t
 
t
;

53 
pthread_t
 *
tid
;

54 
t
.
func
 = func, t.
data
 = data, t.
n_threads
 = n_threads, t.
n
 = n;

55 
t
.
w
 = (
ktf_worker_t
*)
	`alloca
(
n_threads
 * sizeof(ktf_worker_t));

56 
tid
 = (
pthread_t
*)
	`alloca
(
n_threads
 * sizeof(pthread_t));

57 for (
i
 = 0; i < 
n_threads
; ++i)

58 
t
.
w
[
i
].t = &t, t.w[i].i = i;

59 for (
i
 = 0; i < 
n_threads
; ++i) 
	`pthread_create
(&
tid
[i], 0, 
ktf_worker
, &
t
.
w
[i]);

60 for (
i
 = 0; i < 
n_threads
; ++i) 
	`pthread_join
(
tid
[i], 0);

62 long 
j
;

63 for (
j
 = 0; j < 
n
; ++j) 
	`func
(
data
, j, 0);

65 
	}
}

71 struct 
	gkt_forpool_t
;

74 struct 
kt_forpool_t
 *
	mt
;

75 long 
	mi
;

76 int 
	maction
;

77 } 
	tkto_worker_t
;

79 typedef struct 
	skt_forpool_t
 {

80 int 
	mn_threads
, 
	mn_pending
;

81 long 
	mn
;

82 
pthread_t
 *
	mtid
;

83 
kto_worker_t
 *
	mw
;

84 void (*
	mfunc
)(void*,long,int);

85 void *
	mdata
;

86 
pthread_mutex_t
 
	mmutex
;

87 
pthread_cond_t
 
	mcv_m
, 
	mcv_s
;

88 } 
	tkt_forpool_t
;

90 static 
inline
 long 
	$kt_fp_steal_work
(
kt_forpool_t
 *
t
)

92 int 
i
, 
min_i
 = -1;

93 long 
k
, 
min
 = 
LONG_MAX
;

94 for (
i
 = 0; i < 
t
->
n_threads
; ++i)

95 if (
min
 > 
t
->
w
[
i
].i) min = t->w[i].i, 
min_i
 = i;

96 
k
 = 
	`__sync_fetch_and_add
(&
t
->
w
[
min_i
].
i
, t->
n_threads
);

97 return 
k
 >= 
t
->
n
? -1 : k;

98 
	}
}

100 static void *
	$kt_fp_worker
(void *
data
)

102 
kto_worker_t
 *
w
 = (kto_worker_t*)
data
;

103 
kt_forpool_t
 *
fp
 = 
w
->
t
;

105 long 
i
;

106 int 
action
;

107 
	`pthread_mutex_lock
(&
fp
->
mutex
);

108 if (--
fp
->
n_pending
 == 0)

109 
	`pthread_cond_signal
(&
fp
->
cv_m
);

110 
w
->
action
 = 0;

111 while (
w
->
action
 == 0) 
	`pthread_cond_wait
(&
fp
->
cv_s
, &fp->
mutex
);

112 
action
 = 
w
->action;

113 
	`pthread_mutex_unlock
(&
fp
->
mutex
);

114 if (
action
 < 0) break;

116 
i
 = 
	`__sync_fetch_and_add
(&
w
->i, 
fp
->
n_threads
);

117 if (
i
 >= 
fp
->
n
) break;

118 
fp
->
	`func
(fp->
data
, 
i
, 
w
 - fp->w);

120 while ((
i
 = 
	`kt_fp_steal_work
(
fp
)) >= 0)

121 
fp
->
	`func
(fp->
data
, 
i
, 
w
 - fp->w);

123 
	`pthread_exit
(0);

124 
	}
}

126 void *
	$kt_forpool_init
(int 
n_threads
)

128 
kt_forpool_t
 *
fp
;

129 int 
i
;

130 
fp
 = (
kt_forpool_t
*)
	`calloc
(1, sizeof(kt_forpool_t));

131 
fp
->
n_threads
 = fp->
n_pending
 = n_threads;

132 
fp
->
tid
 = (
pthread_t
*)
	`calloc
(fp->
n_threads
, sizeof(pthread_t));

133 
fp
->
w
 = (
kto_worker_t
*)
	`calloc
(fp->
n_threads
, sizeof(kto_worker_t));

134 for (
i
 = 0; i < 
fp
->
n_threads
; ++i) fp->
w
[i].
t
 = fp;

135 
	`pthread_mutex_init
(&
fp
->
mutex
, 0);

136 
	`pthread_cond_init
(&
fp
->
cv_m
, 0);

137 
	`pthread_cond_init
(&
fp
->
cv_s
, 0);

138 for (
i
 = 0; i < 
fp
->
n_threads
; ++i) 
	`pthread_create
(&fp->
tid
[i], 0, 
kt_fp_worker
, &fp->
w
[i]);

139 
	`pthread_mutex_lock
(&
fp
->
mutex
);

140 while (
fp
->
n_pending
) 
	`pthread_cond_wait
(&fp->
cv_m
, &fp->
mutex
);

141 
	`pthread_mutex_unlock
(&
fp
->
mutex
);

142 return 
fp
;

143 
	}
}

145 void 
	$kt_forpool_destroy
(void *
_fp
)

147 
kt_forpool_t
 *
fp
 = (kt_forpool_t*)
_fp
;

148 int 
i
;

149 for (
i
 = 0; i < 
fp
->
n_threads
; ++i) fp->
w
[i].
action
 = -1;

150 
	`pthread_cond_broadcast
(&
fp
->
cv_s
);

151 for (
i
 = 0; i < 
fp
->
n_threads
; ++i) 
	`pthread_join
(fp->
tid
[i], 0);

152 
	`pthread_cond_destroy
(&
fp
->
cv_s
);

153 
	`pthread_cond_destroy
(&
fp
->
cv_m
);

154 
	`pthread_mutex_destroy
(&
fp
->
mutex
);

155 
	`free
(
fp
->
w
); free(fp->
tid
); free(fp);

156 
	}
}

158 void 
	$kt_forpool
(void *
_fp
, void (*
func
)(void*,long,int), void *
data
, long 
n
)

160 
kt_forpool_t
 *
fp
 = (kt_forpool_t*)
_fp
;

161 long 
i
;

162 if (
fp
 && fp->
n_threads
 > 1) {

163 
fp
->
n
 = n, fp->
func
 = func, fp->
data
 = data, fp->
n_pending
 = fp->
n_threads
;

164 for (
i
 = 0; i < 
fp
->
n_threads
; ++i) fp->
w
[i].i = i, fp->w[i].
action
 = 1;

165 
	`pthread_mutex_lock
(&
fp
->
mutex
);

166 
	`pthread_cond_broadcast
(&
fp
->
cv_s
);

167 while (
fp
->
n_pending
) 
	`pthread_cond_wait
(&fp->
cv_m
, &fp->
mutex
);

168 
	`pthread_mutex_unlock
(&
fp
->
mutex
);

169 } else for (
i
 = 0; i < 
n
; ++i) 
	`func
(
data
, i, 0);

170 
	}
}

176 struct 
	gktp_t
;

179 struct 
ktp_t
 *
	mpl
;

180 
int64_t
 
	mindex
;

181 int 
	mstep
;

182 void *
	mdata
;

183 } 
	tktp_worker_t
;

185 typedef struct 
	sktp_t
 {

186 void *
	mshared
;

187 void *(*
	mfunc
)(void*, int, void*);

188 
int64_t
 
	mindex
;

189 int 
	mn_workers
, 
	mn_steps
;

190 
ktp_worker_t
 *
	mworkers
;

191 
pthread_mutex_t
 
	mmutex
;

192 
pthread_cond_t
 
	mcv
;

193 } 
	tktp_t
;

195 static void *
	$ktp_worker
(void *
data
)

197 
ktp_worker_t
 *
w
 = (ktp_worker_t*)
data
;

198 
ktp_t
 *
p
 = 
w
->
pl
;

199 while (
w
->
step
 < 
p
->
n_steps
) {

201 
	`pthread_mutex_lock
(&
p
->
mutex
);

203 int 
i
;

205 for (
i
 = 0; i < 
p
->
n_workers
; ++i) {

206 if (
w
 == &
p
->
workers
[
i
]) continue;

207 if (
p
->
workers
[
i
].
step
 <= 
w
->step && p->workers[i].
index
 < w->index)

210 if (
i
 == 
p
->
n_workers
) break;

211 
	`pthread_cond_wait
(&
p
->
cv
, &p->
mutex
);

213 
	`pthread_mutex_unlock
(&
p
->
mutex
);

216 
w
->
data
 = 
p
->
	`func
(p->
shared
, w->
step
, w->step? w->data : 0);

219 
	`pthread_mutex_lock
(&
p
->
mutex
);

220 
w
->
step
 = w->step == 
p
->
n_steps
 - 1 || w->
data
? (w->step + 1) % p->n_steps : p->n_steps;

221 if (
w
->
step
 == 0) w->
index
 = 
p
->index++;

222 
	`pthread_cond_broadcast
(&
p
->
cv
);

223 
	`pthread_mutex_unlock
(&
p
->
mutex
);

225 
	`pthread_exit
(0);

226 
	}
}

228 void 
	$kt_pipeline
(int 
n_threads
, void *(*
func
)(void*, int, void*), void *
shared_data
, int 
n_steps
)

230 
ktp_t
 
aux
;

231 
pthread_t
 *
tid
;

232 int 
i
;

234 if (
n_threads
 < 1) n_threads = 1;

235 
aux
.
n_workers
 = 
n_threads
;

236 
aux
.
n_steps
 = n_steps;

237 
aux
.
func
 = func;

238 
aux
.
shared
 = 
shared_data
;

239 
aux
.
index
 = 0;

240 
	`pthread_mutex_init
(&
aux
.
mutex
, 0);

241 
	`pthread_cond_init
(&
aux
.
cv
, 0);

243 
aux
.
workers
 = (
ktp_worker_t
*)
	`alloca
(
n_threads
 * sizeof(ktp_worker_t));

244 for (
i
 = 0; i < 
n_threads
; ++i) {

245 
ktp_worker_t
 *
w
 = &
aux
.
workers
[
i
];

246 
w
->
step
 = 0; w->
pl
 = &
aux
; w->
data
 = 0;

247 
w
->
index
 = 
aux
.index++;

250 
tid
 = (
pthread_t
*)
	`alloca
(
n_threads
 * sizeof(pthread_t));

251 for (
i
 = 0; i < 
n_threads
; ++i) 
	`pthread_create
(&
tid
[i], 0, 
ktp_worker
, &
aux
.
workers
[i]);

252 for (
i
 = 0; i < 
n_threads
; ++i) 
	`pthread_join
(
tid
[i], 0);

254 
	`pthread_mutex_destroy
(&
aux
.
mutex
);

255 
	`pthread_cond_destroy
(&
aux
.
cv
);

256 
	}
}

	@deps/klib/kthread.h

1 #ifndef 
KTHREAD_H


2 #define 
	#KTHREAD_H


	)

4 #ifdef 
__cplusplus


8 void 
kt_for
(int 
n_threads
, void (*
func
)(void*,long,int), void *
data
, long 
n
);

9 void 
kt_pipeline
(int 
n_threads
, void *(*
func
)(void*, int, void*), void *
shared_data
, int 
n_steps
);

11 void *
kt_forpool_init
(int 
n_threads
);

12 void 
kt_forpool_destroy
(void *
_fp
);

13 void 
kt_forpool
(void *
_fp
, void (*
func
)(void*,long,int), void *
data
, long 
n
);

15 #ifdef 
__cplusplus


	@deps/klib/kurl.c

1 #include 
	~<stdio.h
>

2 #include 
	~<fcntl.h
>

3 #include 
	~<ctype.h
>

4 #include 
	~<assert.h
>

5 #include 
	~<stdint.h
>

6 #include 
	~<stdlib.h
>

7 #include 
	~<unistd.h
>

8 #include 
	~<string.h
>

9 #include 
	~<curl/curl.h
>

10 #include 
	~"kurl.h
"

16 #define 
	#KU_DEF_BUFLEN
 0x8000

	)

17 #define 
	#KU_MAX_SKIP
 (
KU_DEF_BUFLEN
<<1)

18 

	)

19 #define 
	#kurl_isfile
(
u
) ((u)->
fd
 >= 0)

	)

21 #ifndef 
kroundup32


22 #define 
	#kroundup32
(
x
) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

	)

25 struct 
	skurl_t
 {

26 
CURLM
 *
	mmulti
;

27 
CURL
 *
	mcurl
;

28 
uint8_t
 *
	mbuf
;

29 
off_t
 
	moff0
;

30 int 
	mfd
;

31 int 
	mm_buf
;

32 int 
	ml_buf
;

33 int 
	mp_buf
;

34 int 
	mdone_reading
;

35 int 
	merr
;

36 struct 
curl_slist
 *
	mhdr
;

40 char *
	murl
, *
	mdate
, *
	mauth
;

41 } 
	ts3aux_t
;

43 int 
	$kurl_init
(void)

45 return 
	`curl_global_init
(
CURL_GLOBAL_DEFAULT
);

46 
	}
}

48 void 
	$kurl_destroy
(void)

50 
	`curl_global_cleanup
();

51 
	}
}

53 static int 
	$prepare
(
kurl_t
 *
ku
, int 
do_seek
)

55 if (
	`kurl_isfile
(
ku
)) {

56 if (
do_seek
 && 
	`lseek
(
ku
->
fd
, ku->
off0
, 
SEEK_SET
) != ku->off0)

59 int 
rc
;

60 
rc
 = 
	`curl_multi_remove_handle
(
ku
->
multi
, ku->
curl
);

61 
rc
 = 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_RESUME_FROM
, ku->
off0
);

62 
rc
 = 
	`curl_multi_add_handle
(
ku
->
multi
, ku->
curl
);

64 
ku
->
p_buf
 = ku->
l_buf
 = 0;

66 
	}
}

68 static 
size_t
 
	$write_cb
(char *
ptr
, 
size_t
 
size
, size_t 
nmemb
, void *
data
)

70 
kurl_t
 *
ku
 = (kurl_t*)
data
;

71 
ssize_t
 
nbytes
 = 
size
 * 
nmemb
;

72 if (
nbytes
 + 
ku
->
l_buf
 > ku->
m_buf
)

73 return 
CURL_WRITEFUNC_PAUSE
;

74 
	`memcpy
(
ku
->
buf
 + ku->
l_buf
, 
ptr
, 
nbytes
);

75 
ku
->
l_buf
 += 
nbytes
;

76 return 
nbytes
;

77 
	}
}

79 static int 
	$fill_buffer
(
kurl_t
 *
ku
)

81 
	`assert
(
ku
->
p_buf
 == ku->
l_buf
);

82 
ku
->
off0
 += ku->
l_buf
;

83 
ku
->
p_buf
 = ku->
l_buf
 = 0;

84 if (
ku
->
done_reading
) return 0;

85 if (
	`kurl_isfile
(
ku
)) {

89 while (
ku
->
l_buf
 < ku->
m_buf
) {

90 int 
l
;

91 
l
 = 
	`read
(
ku
->
fd
, ku->
buf
 + ku->
l_buf
, ku->
m_buf
 - ku->l_buf);

92 if (
l
 == 0) break;

93 
ku
->
l_buf
 += 
l
;

95 if (
ku
->
l_buf
 < ku->
m_buf
) ku->
done_reading
 = 1;

97 int 
n_running
, 
rc
;

98 
fd_set
 
fdr
, 
fdw
, 
fde
;

100 int 
maxfd
 = -1;

101 long 
curl_to
 = -1;

102 struct 
timeval
 
to
;

104 
to
.
tv_sec
 = 10, to.
tv_usec
 = 0;

105 
	`curl_multi_timeout
(
ku
->
multi
, &
curl_to
);

106 if (
curl_to
 >= 0) {

107 
to
.
tv_sec
 = 
curl_to
 / 1000;

108 if (
to
.
tv_sec
 > 1) to.tv_sec = 1;

109 else 
to
.
tv_usec
 = (
curl_to
 % 1000) * 1000;

111 
	`FD_ZERO
(&
fdr
); FD_ZERO(&
fdw
); FD_ZERO(&
fde
);

112 
	`curl_multi_fdset
(
ku
->
multi
, &
fdr
, &
fdw
, &
fde
, &
maxfd
);

113 if (
maxfd
 >= 0 && (
rc
 = 
	`select
(maxfd+1, &
fdr
, &
fdw
, &
fde
, &
to
)) < 0) break;

114 if (
maxfd
 < 0) {

115 struct 
timespec
 
req
, 
rem
;

116 
req
.
tv_sec
 = 0; req.
tv_nsec
 = 100000000;

117 
	`nanosleep
(&
req
, &
rem
);

119 
	`curl_easy_pause
(
ku
->
curl
, 
CURLPAUSE_CONT
);

120 
rc
 = 
	`curl_multi_perform
(
ku
->
multi
, &
n_running
);

121 } while (
n_running
 && 
ku
->
l_buf
 < ku->
m_buf
 - 
CURL_MAX_WRITE_SIZE
);

122 if (
ku
->
l_buf
 < ku->
m_buf
 - 
CURL_MAX_WRITE_SIZE
) ku->
done_reading
 = 1;

124 return 
ku
->
l_buf
;

125 
	}
}

127 int 
	$kurl_close
(
kurl_t
 *
ku
)

129 if (
ku
 == 0) return 0;

130 if (
ku
->
fd
 < 0) {

131 
	`curl_multi_remove_handle
(
ku
->
multi
, ku->
curl
);

132 
	`curl_easy_cleanup
(
ku
->
curl
);

133 
	`curl_multi_cleanup
(
ku
->
multi
);

134 if (
ku
->
hdr
) 
	`curl_slist_free_all
(ku->hdr);

135 } else 
	`close
(
ku
->
fd
);

136 
	`free
(
ku
->
buf
);

137 
	`free
(
ku
);

139 
	}
}

141 
kurl_t
 *
	$kurl_open
(const char *
url
, 
kurl_opt_t
 *
opt
)

143 extern 
s3aux_t
 
	`s3_parse
(const char *
url
, const char *
_id
, const char *
_secret
, const char *
fn
);

144 const char *
p
, *
q
;

145 
kurl_t
 *
ku
;

146 int 
fd
 = -1, 
is_file
 = 1, 
failed
 = 0;

148 
p
 = 
	`strstr
(
url
, "://");

149 if (
p
 && *p) {

150 for (
q
 = 
url
; q != 
p
; ++q)

151 if (!
	`isalnum
(*
q
)) break;

152 if (
q
 == 
p
) 
is_file
 = 0;

154 if (
is_file
 && (
fd
 = 
	`open
(
url
, 
O_RDONLY
)) < 0) return 0;

156 
ku
 = (
kurl_t
*)
	`calloc
(1, sizeof(kurl_t));

157 
ku
->
fd
 = 
is_file
? fd : -1;

158 if (!
	`kurl_isfile
(
ku
)) {

159 
ku
->
multi
 = 
	`curl_multi_init
();

160 
ku
->
curl
 = 
	`curl_easy_init
();

161 if (
	`strstr
(
url
, "s3://") == url) {

162 
s3aux_t
 
a
;

163 
a
 = 
	`s3_parse
(
url
, (
opt
? opt->
s3keyid
 : 0), (opt? opt->
s3secretkey
 : 0), (opt? opt->
s3key_fn
 : 0));

164 if (
a
.
url
 == 0 || a.
date
 == 0 || a.
auth
 == 0) {

165 
	`kurl_close
(
ku
);

168 
ku
->
hdr
 = 
	`curl_slist_append
(ku->hdr, 
a
.
date
);

169 
ku
->
hdr
 = 
	`curl_slist_append
(ku->hdr, 
a
.
auth
);

170 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_URL
, 
a
.
url
);

171 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_HTTPHEADER
, ku->
hdr
);

172 
	`free
(
a
.
date
); free(a.
auth
); free(a.
url
);

173 } else 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_URL
, 
url
);

174 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_WRITEDATA
, ku);

175 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_VERBOSE
, 0L);

176 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_NOSIGNAL
, 1L);

177 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_WRITEFUNCTION
, 
write_cb
);

178 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_SSL_VERIFYPEER
, 0L);

179 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_SSL_VERIFYHOST
, 0L);

180 
	`curl_easy_setopt
(
ku
->
curl
, 
CURLOPT_FOLLOWLOCATION
, 1L);

182 
ku
->
m_buf
 = 
KU_DEF_BUFLEN
;

183 if (!
	`kurl_isfile
(
ku
) && ku->
m_buf
 < 
CURL_MAX_WRITE_SIZE
 * 2)

184 
ku
->
m_buf
 = 
CURL_MAX_WRITE_SIZE
 * 2;

185 
ku
->
buf
 = (
uint8_t
*)
	`calloc
(ku->
m_buf
, 1);

186 if (
	`kurl_isfile
(
ku
)) 
failed
 = (
	`fill_buffer
(ku) <= 0);

187 else 
failed
 = (
	`prepare
(
ku
, 0) < 0 || 
	`fill_buffer
(ku) <= 0);

188 if (
failed
) {

189 
	`kurl_close
(
ku
);

192 return 
ku
;

193 
	}
}

195 
kurl_t
 *
	$kurl_dopen
(int 
fd
)

197 
kurl_t
 *
ku
;

198 
ku
 = (
kurl_t
*)
	`calloc
(1, sizeof(kurl_t));

199 
ku
->
fd
 = fd;

200 
ku
->
m_buf
 = 
KU_DEF_BUFLEN
;

201 
ku
->
buf
 = (
uint8_t
*)
	`calloc
(ku->
m_buf
, 1);

202 if (
	`prepare
(
ku
, 0) < 0 || 
	`fill_buffer
(ku) <= 0) {

203 
	`kurl_close
(
ku
);

206 return 
ku
;

207 
	}
}

209 int 
	$kurl_buflen
(
kurl_t
 *
ku
, int 
len
)

211 if (
len
 <= 0 || len < 
ku
->
l_buf
) return ku->
m_buf
;

212 if (!
	`kurl_isfile
(
ku
) && 
len
 < 
CURL_MAX_WRITE_SIZE
 * 2) return ku->
m_buf
;

213 
ku
->
m_buf
 = 
len
;

214 
	`kroundup32
(
ku
->
m_buf
);

215 
ku
->
buf
 = (
uint8_t
*)
	`realloc
(ku->buf, ku->
m_buf
);

216 return 
ku
->
m_buf
;

217 
	}
}

219 
ssize_t
 
	$kurl_read
(
kurl_t
 *
ku
, void *
buf
, 
size_t
 
nbytes
)

221 
ssize_t
 
rest
 = 
nbytes
;

222 if (
ku
->
l_buf
 == 0) return 0;

223 while (
rest
) {

224 if (
ku
->
l_buf
 - ku->
p_buf
 >= 
rest
) {

225 if (
buf
) 
	`memcpy
((
uint8_t
*)buf + (
nbytes
 - 
rest
), 
ku
->buf + ku->
p_buf
, rest);

226 
ku
->
p_buf
 += 
rest
;

227 
rest
 = 0;

229 int 
ret
;

230 if (
buf
 && 
ku
->
l_buf
 > ku->
p_buf
)

231 
	`memcpy
((
uint8_t
*)
buf
 + (
nbytes
 - 
rest
), 
ku
->buf + ku->
p_buf
, ku->
l_buf
 - ku->p_buf);

232 
rest
 -= 
ku
->
l_buf
 - ku->
p_buf
;

233 
ku
->
p_buf
 = ku->
l_buf
;

234 
ret
 = 
	`fill_buffer
(
ku
);

235 if (
ret
 <= 0) break;

238 return 
nbytes
 - 
rest
;

239 
	}
}

241 
off_t
 
	$kurl_seek
(
kurl_t
 *
ku
, 
off_t
 
offset
, int 
whence
)

243 
off_t
 
new_off
 = -1, 
cur_off
;

244 int 
failed
 = 0, 
seek_end
 = 0;

245 if (
ku
 == 0) return -1;

246 
cur_off
 = 
ku
->
off0
 + ku->
p_buf
;

247 if (
whence
 == 
SEEK_SET
) 
new_off
 = 
offset
;

248 else if (
whence
 == 
SEEK_CUR
) 
new_off
 += 
cur_off
 + 
offset
;

249 else if (
whence
 == 
SEEK_END
 && 
	`kurl_isfile
(
ku
)) 
new_off
 = 
	`lseek
(ku->
fd
, 
offset
, SEEK_END), 
seek_end
 = 1;

251 
ku
->
err
 = 
KURL_INV_WHENCE
;

254 if (
new_off
 < 0) {

255 
ku
->
err
 = 
KURL_SEEK_OUT
;

258 if (!
seek_end
 && 
new_off
 >= 
cur_off
 && new_off - cur_off + 
ku
->
p_buf
 < ku->
l_buf
) {

259 
ku
->
p_buf
 += 
new_off
 - 
cur_off
;

260 return 
ku
->
off0
 + ku->
p_buf
;

262 if (
seek_end
 || 
new_off
 < 
cur_off
 || new_off - cur_off > 
KU_MAX_SKIP
) {

263 
ku
->
off0
 = 
new_off
;

264 
ku
->
done_reading
 = 0;

265 if (
	`prepare
(
ku
, 1) < 0 || 
	`fill_buffer
(ku) <= 0) 
failed
 = 1;

267 
off_t
 
r
;

268 
r
 = 
	`kurl_read
(
ku
, 0, 
new_off
 - 
cur_off
);

269 if (
r
 + 
cur_off
 != 
new_off
) 
failed
 = 1;

271 if (
failed
) 
ku
->
err
 = 
KURL_SEEK_OUT
, ku->
l_buf
 = ku->
p_buf
 = 0, 
new_off
 = -1;

272 return 
new_off
;

273 
	}
}

275 
off_t
 
	$kurl_tell
(const 
kurl_t
 *
ku
)

277 if (
ku
 == 0) return -1;

278 return 
ku
->
off0
 + ku->
p_buf
;

279 
	}
}

281 int 
	$kurl_eof
(const 
kurl_t
 *
ku
)

283 if (
ku
 == 0) return 1;

284 return (
ku
->
l_buf
 == 0);

285 
	}
}

287 int 
	$kurl_fileno
(const 
kurl_t
 *
ku
)

289 if (
ku
 == 0) return -1;

290 return 
ku
->
fd
;

291 
	}
}

293 int 
	$kurl_error
(const 
kurl_t
 *
ku
)

295 if (
ku
 == 0) return 
KURL_NULL
;

296 return 
ku
->
err
;

297 
	}
}

305 #define 
	#HASH_LENGTH
 20

	)

306 #define 
	#BLOCK_LENGTH
 64

	)

308 typedef struct 
	ssha1nfo
 {

309 union { 
uint8_t
 
	mb
[
BLOCK_LENGTH
]; 
uint32_t
 
	mw
[BLOCK_LENGTH/4]; } 
	mbuf
;

310 
uint8_t
 
	mbufOffset
;

311 union { 
uint8_t
 
	mb
[
HASH_LENGTH
]; 
uint32_t
 
	mw
[HASH_LENGTH/4]; } 
	mstate
;

312 
uint32_t
 
	mbyteCount
;

313 
uint8_t
 
	mkeyBuffer
[
BLOCK_LENGTH
];

314 
uint8_t
 
	minnerHash
[
HASH_LENGTH
];

315 } 
	tsha1nfo
;

317 void 
	$sha1_init
(
sha1nfo
 *
s
)

319 const 
uint8_t
 
table
[] = { 0x01,0x23,0x45,0x67, 0x89,0xab,0xcd,0xef, 0xfe,0xdc,0xba,0x98, 0x76,0x54,0x32,0x10, 0xf0,0xe1,0xd2,0xc3 };

320 
	`memcpy
(
s
->
state
.
b
, 
table
, 
HASH_LENGTH
);

321 
s
->
byteCount
 = 0;

322 
s
->
bufOffset
 = 0;

323 
	}
}

325 #define 
	#rol32
(
value
, 
bits
) (((value) << (bits)) | ((value) >> (32 - (bits))))

	)

327 static void 
	$sha1_hashBlock
(
sha1nfo
 *
s
)

329 
uint32_t
 
i
, 
t
, 
a
 = 
s
->
state
.
w
[0], 
b
 = s->state.w[1], 
c
 = s->state.w[2], 
d
 = s->state.w[3], 
e
 = s->state.w[4];

330 for (
i
 = 0; i < 80; i++) {

331 if (
i
 >= 16) {

332 
t
 = 
s
->
buf
.
w
[(
i
+13)&15] ^ s->buf.w[(i+8)&15] ^ s->buf.w[(i+2)&15] ^ s->buf.w[i&15];

333 
s
->
buf
.
w
[
i
&15] = 
	`rol32
(
t
, 1);

335 if (
i
 < 20) 
t
 = 0x5a827999 + (
d
 ^ (
b
 & (
c
 ^ d)));

336 else if (
i
 < 40) 
t
 = 0x6ed9eba1 + (
b
 ^ 
c
 ^ 
d
);

337 else if (
i
 < 60) 
t
 = 0x8f1bbcdc + ((
b
 & 
c
) | (
d
 & (b | c)));

338 else 
t
 = 0xca62c1d6 + (
b
 ^ 
c
 ^ 
d
);

339 
t
 += 
	`rol32
(
a
, 5) + 
e
 + 
s
->
buf
.
w
[
i
&15];

340 
e
 = 
d
; d = 
c
; c = 
	`rol32
(
b
, 30); b = 
a
; a = 
t
;

342 
s
->
state
.
w
[0] += 
a
; s->state.w[1] += 
b
; s->state.w[2] += 
c
; s->state.w[3] += 
d
; s->state.w[4] += 
e
;

343 
	}
}

345 static 
inline
 void 
	$sha1_add
(
sha1nfo
 *
s
, 
uint8_t
 
data
)

347 
s
->
buf
.
b
[s->
bufOffset
 ^ 3] = 
data
;

348 if (++
s
->
bufOffset
 == 
BLOCK_LENGTH
) {

349 
	`sha1_hashBlock
(
s
);

350 
s
->
bufOffset
 = 0;

352 
	}
}

354 void 
	$sha1_write1
(
sha1nfo
 *
s
, 
uint8_t
 
data
)

356 ++
s
->
byteCount
;

357 
	`sha1_add
(
s
, 
data
);

358 
	}
}

360 void 
	$sha1_write
(
sha1nfo
 *
s
, const char *
data
, 
size_t
 
len
)

362 while (
len
--) 
	`sha1_write1
(
s
, (
uint8_t
)*
data
++);

363 
	}
}

365 const 
uint8_t
 *
	$sha1_final
(
sha1nfo
 *
s
)

367 int 
i
;

368 
	`sha1_add
(
s
, 0x80);

369 while (
s
->
bufOffset
 != 56) 
	`sha1_add
(s, 0);

370 
	`sha1_add
(
s
, 0);

371 
	`sha1_add
(
s
, 0);

372 
	`sha1_add
(
s
, 0);

373 
	`sha1_add
(
s
, s->
byteCount
 >> 29);

374 
	`sha1_add
(
s
, s->
byteCount
 >> 21);

375 
	`sha1_add
(
s
, s->
byteCount
 >> 13);

376 
	`sha1_add
(
s
, s->
byteCount
 >> 5);

377 
	`sha1_add
(
s
, s->
byteCount
 << 3);

378 for (
i
 = 0; i < 5; ++i) {

379 
uint32_t
 
a
 = 
s
->
state
.
w
[
i
];

380 
s
->
state
.
w
[
i
] = 
a
<<24 | (a<<8&0x00ff0000) | (a>>8&0x0000ff00) | a>>24;

382 return 
s
->
state
.
b
;

383 
	}
}

385 #define 
	#HMAC_IPAD
 0x36

	)

386 #define 
	#HMAC_OPAD
 0x5c

	)

388 void 
	$sha1_init_hmac
(
sha1nfo
 *
s
, const 
uint8_t
* 
key
, int 
l_key
)

390 
uint8_t
 
i
;

391 
	`memset
(
s
->
keyBuffer
, 0, 
BLOCK_LENGTH
);

392 if (
l_key
 > 
BLOCK_LENGTH
) {

393 
	`sha1_init
(
s
);

394 while (
l_key
--) 
	`sha1_write1
(
s
, *
key
++);

395 
	`memcpy
(
s
->
keyBuffer
, 
	`sha1_final
(s), 
HASH_LENGTH
);

396 } else 
	`memcpy
(
s
->
keyBuffer
, 
key
, 
l_key
);

397 
	`sha1_init
(
s
);

398 for (
i
 = 0; i < 
BLOCK_LENGTH
; ++i)

399 
	`sha1_write1
(
s
, s->
keyBuffer
[
i
] ^ 
HMAC_IPAD
);

400 
	}
}

402 const 
uint8_t
 *
	$sha1_final_hmac
(
sha1nfo
 *
s
)

404 
uint8_t
 
i
;

405 
	`memcpy
(
s
->
innerHash
, 
	`sha1_final
(s), 
HASH_LENGTH
);

406 
	`sha1_init
(
s
);

407 for (
i
 = 0; i < 
BLOCK_LENGTH
; ++i) 
	`sha1_write1
(
s
, s->
keyBuffer
[i] ^ 
HMAC_OPAD
);

408 for (
i
 = 0; i < 
HASH_LENGTH
; ++i) 
	`sha1_write1
(
s
, s->
innerHash
[i]);

409 return 
	`sha1_final
(
s
);

410 
	}
}

416 #include 
	~<time.h
>

417 #include 
	~<ctype.h
>

419 static void 
	$s3_sign
(const char *
key
, const char *
data
, char 
out
[29])

421 const char *
b64tab
 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

422 const 
uint8_t
 *
digest
;

423 int 
i
, 
j
, 
rest
;

424 
sha1nfo
 
s
;

425 
	`sha1_init_hmac
(&
s
, (
uint8_t
*)
key
, 
	`strlen
(key));

426 
	`sha1_write
(&
s
, 
data
, 
	`strlen
(data));

427 
digest
 = 
	`sha1_final_hmac
(&
s
);

428 for (
j
 = 
i
 = 0, 
rest
 = 8; i < 20; ++j) {

429 if (
rest
 <= 6) {

430 int 
next
 = 
i
 < 19? 
digest
[i+1] : 0;

431 
out
[
j
] = 
b64tab
[(int)(
digest
[
i
] << (6-
rest
) & 0x3f) | 
next
 >> (rest+2)], ++i, rest += 2;

432 } else 
out
[
j
] = 
b64tab
[(int)
digest
[
i
] >> (
rest
-6) & 0x3f], rest -= 6;

434 
out
[
j
++] = '='; out[j] = 0;

435 
	}
}

437 static char *
	$s3_read_awssecret
(const char *
fn
)

439 char *
p
, *
secret
, 
buf
[128], *
path
;

440 
FILE
 *
fp
;

441 int 
l
;

442 if (
fn
 == 0) {

443 char *
home
;

444 
home
 = 
	`getenv
("HOME");

445 if (
home
 == 0) return 0;

446 
l
 = 
	`strlen
(
home
) + 12;

447 
path
 = (char*)
	`malloc
(
	`strlen
(
home
) + 12);

448 
	`strcat
(
	`strcpy
(
path
, 
home
), "/.awssecret");

449 } else 
path
 = (char*)
fn
;

450 
fp
 = 
	`fopen
(
path
, "r");

451 if (
path
 != 
fn
) 
	`free
(path);

452 if (
fp
 == 0) return 0;

453 
l
 = 
	`fread
(
buf
, 1, 127, 
fp
);

454 
	`fclose
(
fp
);

455 
buf
[
l
] = 0;

456 for (
p
 = 
buf
; *p != 0 && *p != '\n'; ++p);

457 if (*
p
 == 0) return 0;

458 *
p
 = 0; 
secret
 = p + 1;

459 for (++
p
; *p != 0 && *p != '\n'; ++p);

460 *
p
 = 0;

461 
l
 = 
p
 - 
buf
 + 1;

462 
p
 = (char*)
	`malloc
(
l
);

463 
	`memcpy
(
p
, 
buf
, 
l
);

464 return 
p
;

465 
	}
}

467 typedef struct { int 
	ml
, 
	mm
; char *
	ms
; } 
	tkstring_t
;

469 static 
inline
 int 
	$kputsn
(const char *
p
, int 
l
, 
kstring_t
 *
s
)

471 if (
s
->
l
 + l + 1 >= s->
m
) {

472 
s
->
m
 = s->
l
 + l + 2;

473 
	`kroundup32
(
s
->
m
);

474 
s
->s = (char*)
	`realloc
(s->s, s->
m
);

476 
	`memcpy
(
s
->s + s->
l
, 
p
, l);

477 
s
->
l
 += l;

478 
s
->s[s->
l
] = 0;

479 return 
l
;

480 
	}
}

482 
s3aux_t
 
	$s3_parse
(const char *
url
, const char *
_id
, const char *
_secret
, const char *
fn_secret
)

484 const char *
id
, *
secret
, *
bucket
, *
obj
;

485 char *
id_secret
 = 0, 
date
[64], 
sig
[29];

486 
time_t
 
t
;

487 struct 
tm
 
tmt
;

488 
s3aux_t
 
a
 = {0,0};

489 
kstring_t
 
str
 = {0,0,0};

491 if (
	`strstr
(
url
, "s3://") != url) return 
a
;

492 
bucket
 = 
url
 + 5;

493 for (
obj
 = 
bucket
; *obj && *obj != '/'; ++obj);

494 if (*
obj
 == 0) return 
a
;

496 if (
_id
 == 0 || 
_secret
 == 0) {

497 
id_secret
 = 
	`s3_read_awssecret
(
fn_secret
);

498 if (
id_secret
 == 0) return 
a
;

499 
id
 = 
id_secret
;

500 
secret
 = 
id_secret
 + 
	`strlen
(
id
) + 1;

501 } else 
id
 = 
_id
, 
secret
 = 
_secret
;

503 
	`kputsn
("https://", 8, &
str
);

504 
	`kputsn
(
bucket
, 
obj
 - bucket, &
str
);

505 
	`kputsn
(".s3.amazonaws.com", 17, &
str
);

506 
	`kputsn
(
obj
, 
	`strlen
(obj), &
str
);

507 
a
.
url
 = 
str
.
s
;

509 
str
.
l
 = str.
m
 = 0; str.
s
 = 0;

510 
t
 = 
	`time
(0);

511 
	`strftime
(
date
, 64, "%a, %d %b %Y %H:%M:%S +0000", 
	`gmtime_r
(&
t
, &
tmt
));

512 
	`kputsn
("Date: ", 6, &
str
);

513 
	`kputsn
(
date
, 
	`strlen
(date), &
str
);

514 
a
.
date
 = 
str
.
s
;

516 
str
.
l
 = str.
m
 = 0; str.
s
 = 0;

517 
	`kputsn
("GET\n\n\n", 6, &
str
);

518 
	`kputsn
(
date
, 
	`strlen
(date), &
str
);

519 
	`kputsn
("\n", 1, &
str
);

520 
	`kputsn
(
bucket
-1, 
	`strlen
(bucket-1), &
str
);

521 
	`s3_sign
(
secret
, 
str
.
s
, 
sig
);

523 
str
.
l
 = 0;

524 
	`kputsn
("Authorization: AWS ", 19, &
str
);

525 
	`kputsn
(
id
, 
	`strlen
(id), &
str
);

526 
	`kputsn
(":", 1, &
str
);

527 
	`kputsn
(
sig
, 
	`strlen
(sig), &
str
);

528 
a
.
auth
 = 
str
.
s
;

530 return 
a
;

531 
	}
}

537 #ifdef 
KURL_MAIN


538 int 
	$main
(int 
argc
, char *
argv
[])

540 
kurl_t
 *
f
;

541 int 
c
, 
l
, 
l_buf
 = 0x10000;

542 
off_t
 
start
 = 0, 
rest
 = -1;

543 
uint8_t
 *
buf
;

544 char *
p
;

545 
kurl_opt_t
 
opt
;

547 
	`memset
(&
opt
, 0, sizeof(
kurl_opt_t
));

548 while ((
c
 = 
	`getopt
(
argc
, 
argv
, "c:l:a:")) >= 0) {

549 if (
c
 == 'c') 
start
 = 
	`strtol
(
optarg
, &
p
, 0);

550 else if (
c
 == 'l') 
rest
 = 
	`strtol
(
optarg
, &
p
, 0);

551 else if (
c
 == 'a') 
opt
.
s3key_fn
 = 
optarg
;

553 if (
optind
 == 
argc
) {

554 
	`fprintf
(
stderr
, "Usage: kurl [-c start] [-l length] <url>\n");

557 
	`kurl_init
();

558 
f
 = 
	`kurl_open
(
argv
[
optind
], &
opt
);

559 if (
f
 == 0) {

560 
	`fprintf
(
stderr
, "ERROR: fail to open URL\n");

563 if (
start
 > 0) {

564 if (
	`kurl_seek
(
f
, 
start
, 
SEEK_SET
) < 0) {

565 
	`kurl_close
(
f
);

566 
	`fprintf
(
stderr
, "ERROR: fail to seek\n");

570 
buf
 = (
uint8_t
*)
	`calloc
(
l_buf
, 1);

571 while (
rest
 != 0) {

572 int 
to_read
 = 
rest
 > 0 && rest < 
l_buf
? rest : l_buf;

573 
l
 = 
	`kurl_read
(
f
, 
buf
, 
to_read
);

574 if (
l
 == 0) break;

575 
	`fwrite
(
buf
, 1, 
l
, 
stdout
);

576 
rest
 -= 
l
;

578 
	`free
(
buf
);

579 
	`kurl_close
(
f
);

580 
	`kurl_destroy
();

582 
	}
}

	@deps/klib/kurl.h

1 #ifndef 
KURL_H


2 #define 
	#KURL_H


	)

4 #include 
	~<sys/types.h
>

6 #define 
	#KURL_NULL
 1

	)

7 #define 
	#KURL_INV_WHENCE
 2

	)

8 #define 
	#KURL_SEEK_OUT
 3

	)

9 #define 
	#KURL_NO_AUTH
 4

	)

11 struct 
	gkurl_t
;

12 typedef struct 
kurl_t
 
	tkurl_t
;

15 const char *
	ms3keyid
;

16 const char *
	ms3secretkey
;

17 const char *
	ms3key_fn
;

18 } 
	tkurl_opt_t
;

20 #ifdef 
__cplusplus


24 int 
kurl_init
(void);

25 void 
kurl_destroy
(void);

27 
kurl_t
 *
kurl_open
(const char *
url
, 
kurl_opt_t
 *
opt
);

28 
kurl_t
 *
kurl_dopen
(int 
fd
);

29 int 
kurl_close
(
kurl_t
 *
ku
);

30 
ssize_t
 
kurl_read
(
kurl_t
 *
ku
, void *
buf
, 
size_t
 
nbytes
);

31 
off_t
 
kurl_seek
(
kurl_t
 *
ku
, off_t 
offset
, int 
whence
);

32 int 
kurl_buflen
(
kurl_t
 *
ku
, int 
len
);

34 
off_t
 
kurl_tell
(const 
kurl_t
 *
ku
);

35 int 
kurl_eof
(const 
kurl_t
 *
ku
);

36 int 
kurl_fileno
(const 
kurl_t
 *
ku
);

37 int 
kurl_error
(const 
kurl_t
 *
ku
);

39 #ifdef 
__cplusplus


43 #ifndef 
KNETFILE_H


44 #define 
	#KNETFILE_H


	)

45 typedef 
kurl_t
 
	tknetFile
;

46 #define 
	#knet_open
(
fn
, 
mode
) 
	`kurl_open
(fn, 0)

	)

47 #define 
	#knet_dopen
(
fd
, 
mode
) 
	`kurl_dopen
(fd)

	)

48 #define 
	#knet_close
(
fp
) 
	`kurl_close
(fp)

	)

49 #define 
	#knet_read
(
fp
, 
buf
, 
len
) 
	`kurl_read
(fp, buf, len)

	)

50 #define 
	#knet_seek
(
fp
, 
off
, 
whence
) 
	`kurl_seek
(fp, off, whence)

	)

51 #define 
	#knet_tell
(
fp
) 
	`kurl_tell
(fp)

	)

52 #define 
	#knet_fileno
(
fp
) 
	`kurl_fileno
(fp)

	)

53 #define 
	#knet_win32_init
() 
	`kurl_init
()

	)

54 #define 
	#knet_win32_destroy
() 
	`kurl_destroy
()

	)

	@deps/klib/kvec.h

48 #ifndef 
AC_KVEC_H


49 #define 
	#AC_KVEC_H


	)

51 #include 
	~<stdlib.h
>

53 #define 
	#kv_roundup32
(
x
) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))

	)

55 #define 
	#kvec_t
(
type
) struct { 
size_t
 
n
, 
m
; type *
a
; }

	)

56 #define 
	#kv_init
(
v
) ((v).
n
 = (v).
m
 = 0, (v).
a
 = 0)

	)

57 #define 
	#kv_destroy
(
v
) 
	`free
((v).
a
)

	)

58 #define 
	#kv_A
(
v
, 
i
) ((v).
a
[(i)])

	)

59 #define 
	#kv_pop
(
v
) ((v).
a
[--(v).
n
])

	)

60 #define 
	#kv_size
(
v
) ((v).
n
)

	)

61 #define 
	#kv_max
(
v
) ((v).
m
)

	)

63 #define 
	#kv_resize
(
type
, 
v
, 
s
) ((v).
m
 = (s), (v).
a
 = (type*)
	`realloc
((v).a, sizeof(type) * (v).m))

	)

65 #define 
	#kv_copy
(
type
, 
v1
, 
v0
) do { \

66 if ((
v1
).
m
 < (
v0
).
n
) 
	`kv_resize
(
type
, v1, (v0).n); \

67 (
v1
).
n
 = (
v0
).n; \

68 
	`memcpy
((
v1
).
a
, (
v0
).a, sizeof(
type
) * (v0).
n
); \

70 

	)

71 #define 
	#kv_push
(
type
, 
v
, 
x
) do { \

72 if ((
v
).
n
 == (v).
m
) { \

73 (
v
).
m
 = (v).m? (v).m<<1 : 2; \

74 (
v
).
a
 = (
type
*)
	`realloc
((v).a, sizeof(type) * (v).
m
); \

76 (
v
).
a
[(v).
n
++] = (
x
); \

77 } while (0)

	)

79 #define 
	#kv_pushp
(
type
, 
v
) (((v).
n
 == (v).
m
)? \

80 ((
v
).
m
 = ((v).m? (v).m<<1 : 2), \

81 (
v
).
a
 = (
type
*)
	`realloc
((v).a, sizeof(type) * (v).
m
), 0) \

82 : 0), ((
v
).
a
 + ((v).
n
++))

	)

84 #define 
	#kv_a
(
type
, 
v
, 
i
) (((v).
m
 <= (
size_t
)(i)? \

85 ((
v
).
m
 = (v).
n
 = (
i
) + 1, 
	`kv_roundup32
((v).m), \

86 (
v
).
a
 = (
type
*)
	`realloc
((v).a, sizeof(type) * (v).
m
), 0) \

87 : (
v
).
n
 <= (
size_t
)(
i
)? (v).n = (i) + 1 \

88 : 0), (
v
).
a
[(
i
)])

	)

	@deps/klib/test/kbit_test.c

1 #include 
	~<stdlib.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<time.h
>

4 #include 
	~<emmintrin.h
>

5 #include 
	~"kbit.h
"

8 
inline
 static int 
	$bt1_pop64
(
uint64_t
 
x
)

10 
x
 -= ((x >> 1) & 0x5555555555555555llu);

11 
x
 = (x & 0x3333333333333333llu) + ((x >> 2) & 0x3333333333333333llu);

12 
x
 = (x + (x >> 4)) & 0x0F0F0F0F0F0F0F0Fllu;

13 
x
 = x + (x >> 8);

14 
x
 = x + (x >> 16);

15 
x
 = x + (x >> 32);

16 return 
x
 & 0x3F;

17 
	}
}

19 
inline
 static int 
	$bt1_countInU64
(
uint64_t
 
dw
, int 
c
)

21 
uint64_t
 
dwA
 = 
dw
 & 0xAAAAAAAAAAAAAAAAllu;

22 
uint64_t
 
dwNA
 = 
dw
 & ~0xAAAAAAAAAAAAAAAAllu;

23 
uint64_t
 
tmp
;

24 switch (
c
) {

25 case 0: 
tmp
 = (
dwA
 >> 1) | 
dwNA
; break;

26 case 1: 
tmp
 = ~(
dwA
 >> 1) & 
dwNA
; break;

27 case 2: 
tmp
 = (
dwA
 >> 1) & ~
dwNA
; break;

28 default: 
tmp
 = (
dwA
 >> 1) & 
dwNA
;

30 
tmp
 = 
	`bt1_pop64
(tmp);

31 if (
c
 == 0) 
tmp
 = 32 - tmp;

32 return (int)
tmp
;

33 
	}
}

36 static 
uint32_t
 
	$sse2_bit_count32
(const 
__m128i
* 
block
, const __m128i* 
block_end
)

38 const unsigned 
mu1
 = 0x55555555;

39 const unsigned 
mu2
 = 0x33333333;

40 const unsigned 
mu3
 = 0x0F0F0F0F;

41 const unsigned 
mu4
 = 0x0000003F;

43 
uint32_t
 
tcnt
[4];

46 
__m128i
 
m1
 = 
	`_mm_set_epi32
 (
mu1
, mu1, mu1, mu1);

47 
__m128i
 
m2
 = 
	`_mm_set_epi32
 (
mu2
, mu2, mu2, mu2);

48 
__m128i
 
m3
 = 
	`_mm_set_epi32
 (
mu3
, mu3, mu3, mu3);

49 
__m128i
 
m4
 = 
	`_mm_set_epi32
 (
mu4
, mu4, mu4, mu4);

50 
__m128i
 
mcnt
;

51 
mcnt
 = 
	`_mm_xor_si128
(
m1
, m1);

53 
__m128i
 
tmp1
, 
tmp2
;

56 
__m128i
 
b
 = 
	`_mm_load_si128
(
block
);

57 ++
block
;

60 
tmp1
 = 
	`_mm_srli_epi32
(
b
, 1);

61 
tmp1
 = 
	`_mm_and_si128
(tmp1, 
m1
);

62 
tmp2
 = 
	`_mm_and_si128
(
b
, 
m1
);

63 
b
 = 
	`_mm_add_epi32
(
tmp1
, 
tmp2
);

66 
tmp1
 = 
	`_mm_srli_epi32
(
b
, 2);

67 
tmp1
 = 
	`_mm_and_si128
(tmp1, 
m2
);

68 
tmp2
 = 
	`_mm_and_si128
(
b
, 
m2
);

69 
b
 = 
	`_mm_add_epi32
(
tmp1
, 
tmp2
);

72 
tmp1
 = 
	`_mm_srli_epi32
(
b
, 4);

73 
b
 = 
	`_mm_add_epi32
(b, 
tmp1
);

74 
b
 = 
	`_mm_and_si128
(b, 
m3
);

77 
tmp1
 = 
	`_mm_srli_epi32
 (
b
, 8);

78 
b
 = 
	`_mm_add_epi32
(b, 
tmp1
);

81 
tmp1
 = 
	`_mm_srli_epi32
 (
b
, 16);

82 
b
 = 
	`_mm_add_epi32
(b, 
tmp1
);

83 
b
 = 
	`_mm_and_si128
(b, 
m4
);

85 
mcnt
 = 
	`_mm_add_epi32
(mcnt, 
b
);

87 } while (
block
 < 
block_end
);

89 
	`_mm_store_si128
((
__m128i
*)
tcnt
, 
mcnt
);

91 return 
tcnt
[0] + tcnt[1] + tcnt[2] + tcnt[3];

92 
	}
}

94 int 
	$main
(void)

96 int 
i
, 
N
 = 100000000;

97 
uint64_t
 *
x
, 
cnt
;

98 
clock_t
 
t
;

99 int 
c
 = 1;

101 
x
 = (
uint64_t
*)
	`calloc
(
N
, 8);

102 
	`srand48
(11);

103 for (
i
 = 0; i < 
N
; ++i)

104 
x
[
i
] = (
uint64_t
)
	`lrand48
() << 32 ^ lrand48();

106 
	`fprintf
(
stderr
, "\n===> Calculate # of 1 in an integer (popcount) <===\n");

108 
t
 = 
	`clock
(); 
cnt
 = 0;

109 for (
i
 = 0; i < 
N
; ++i) 
cnt
 += 
	`kbi_popcount64
(
x
[i]);

110 
	`fprintf
(
stderr
, "%20s\t%20ld\t%10.6f\n", "kbit", (long)
cnt
, (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

112 
t
 = 
	`clock
(); 
cnt
 = 0;

113 for (
i
 = 0; i < 
N
; ++i) 
cnt
 += 
	`bt1_pop64
(
x
[i]);

114 
	`fprintf
(
stderr
, "%20s\t%20ld\t%10.6f\n", "wiki-popcount_2", (long)
cnt
, (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

116 
t
 = 
	`clock
(); 
cnt
 = 0;

117 for (
i
 = 0; i < 
N
; ++i) 
cnt
 += 
	`__builtin_popcountl
(
x
[i]);

118 
	`fprintf
(
stderr
, "%20s\t%20ld\t%10.6f\n", "__builtin_popcountl", (long)
cnt
, (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

120 
t
 = 
	`clock
(); 
cnt
 = 0;

121 
cnt
 += 
	`sse2_bit_count32
((
__m128i
*)
x
, (__m128i*)(x+
N
));

122 
	`fprintf
(
stderr
, "%20s\t%20ld\t%10.6f\n", "SSE2-32bit", (long)
cnt
, (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

124 
	`fprintf
(
stderr
, "\n===> Count '%c' in 2-bit encoded integers <===\n", "ACGT"[
c
]);

126 
t
 = 
	`clock
(); 
cnt
 = 0;

127 for (
i
 = 0; i < 
N
; ++i) 
cnt
 += 
	`kbi_DNAcount64
(
x
[i], 
c
);

128 
	`fprintf
(
stderr
, "%20s\t%20ld\t%10.6f\n", "kbit", (long)
cnt
, (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

130 
t
 = 
	`clock
(); 
cnt
 = 0;

131 for (
i
 = 0; i < 
N
; ++i) 
cnt
 += 
	`bt1_countInU64
(
x
[i], 
c
);

132 
	`fprintf
(
stderr
, "%20s\t%20ld\t%10.6f\n", "bowtie1", (long)
cnt
, (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

134 
	`fprintf
(
stderr
, "\n");

135 
	`free
(
x
);

137 
	}
}

	@deps/klib/test/kbtree_test.c

1 #include 
	~<stdio.h
>

2 #include 
	~<assert.h
>

3 #include 
	~<time.h
>

4 #include 
	~<stdlib.h
>

5 #include 
	~<stdint.h
>

6 #include 
	~<string.h
>

8 typedef const char *
	tstr_t
;

10 #include 
	~"kbtree.h
"

11 
	$KBTREE_INIT
(int, 
uint32_t
, 
kb_generic_cmp
)

12 
	$KBTREE_INIT
(
str
, 
str_t
, 
kb_str_cmp
)

14 static int 
data_size
 = 5000000;

15 static unsigned *
int_data
;

16 static char **
str_data
;

18 void 
	$ht_init_data
()

20 int 
i
;

21 char 
buf
[256];

22 
	`printf
("--- generating data... ");

23 
	`srand48
(11);

24 
int_data
 = (unsigned*)
	`calloc
(
data_size
, sizeof(unsigned));

25 
str_data
 = (char**)
	`calloc
(
data_size
, sizeof(char*));

26 for (
i
 = 0; i < 
data_size
; ++i) {

27 
int_data
[
i
] = (unsigned)(
data_size
 * 
	`drand48
() / 4) * 271828183u;

28 
	`sprintf
(
buf
, "%x", 
int_data
[
i
]);

29 
str_data
[
i
] = 
	`strdup
(
buf
);

31 
	`printf
("done!\n");

32 
	}
}

33 void 
	$ht_destroy_data
()

35 int 
i
;

36 for (
i
 = 0; i < 
data_size
; ++i) 
	`free
(
str_data
[i]);

37 
	`free
(
str_data
); free(
int_data
);

38 
	}
}

40 void 
	$ht_khash_int
()

42 int 
i
;

43 unsigned *
data
 = 
int_data
;

44 
uint32_t
 *
l
, *
u
;

45 
	`kbtree_t
(int) *
h
;

47 
h
 = 
	`kb_init
(int, 
KB_DEFAULT_SIZE
);

48 for (
i
 = 0; i < 
data_size
; ++i) {

49 if (
	`kb_get
(int, 
h
, 
data
[
i
]) == 0) 
	`kb_put
(int, h, data[i]);

50 else 
	`kb_del
(int, 
h
, 
data
[
i
]);

52 
	`printf
("[ht_khash_int] size: %d\n", 
	`kb_size
(
h
));

54 int 
cnt
 = 0;

55 
uint32_t
 
x
, 
y
;

56 
	`kb_interval
(int, 
h
, 2174625464u, &
l
, &
u
);

57 
	`printf
("interval for 2174625464: (%u, %u)\n", 
l
? *l : 0, 
u
? *u : 0);

58 #define 
	#traverse_f
(
p
) { if (
cnt
 == 0) 
y
 = *p; ++cnt; }

	)

59 
	`__kb_traverse
(
uint32_t
, 
h
, 
traverse_f
);

60 
	`__kb_get_first
(
uint32_t
, 
h
, 
x
);

61 
	`printf
("# of elements from traversal: %d\n", 
cnt
);

62 
	`printf
("first element: %d == %d\n", 
x
, 
y
);

64 
	`__kb_destroy
(
h
);

65 
	}
}

66 void 
	$ht_khash_str
()

68 int 
i
;

69 char **
data
 = 
str_data
;

70 
	`kbtree_t
(
str
) *
h
;

72 
h
 = 
	`kb_init
(
str
, 
KB_DEFAULT_SIZE
);

73 for (
i
 = 0; i < 
data_size
; ++i) {

74 if (
	`kb_get
(
str
, 
h
, 
data
[
i
]) == 0) 
	`kb_put
(str, h, data[i]);

75 else 
	`kb_del
(
str
, 
h
, 
data
[
i
]);

77 
	`printf
("[ht_khash_int] size: %d\n", 
	`kb_size
(
h
));

78 
	`__kb_destroy
(
h
);

79 
	}
}

80 void 
	$ht_timing
(void (*
f
)(void))

82 
clock_t
 
t
 = 
	`clock
();

83 (*
f
)();

84 
	`printf
("[ht_timing] %.3lf sec\n", (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

85 
	}
}

86 int 
	$main
(int 
argc
, char *
argv
[])

88 if (
argc
 > 1) 
data_size
 = 
	`atoi
(
argv
[1]);

89 
	`ht_init_data
();

90 
	`ht_timing
(
ht_khash_int
);

91 
	`ht_timing
(
ht_khash_str
);

92 
	`ht_destroy_data
();

94 
	}
}

	@deps/klib/test/kgraph_test.c

1 #include 
	~<stdio.h
>

2 #include 
	~"kgraph.h
"

4 
	$KHASH_INIT2
(
e32
, extern, 
uint32_t
, int, 1, 
kh_int_hash_func
, 
kh_int_hash_equal
)

7 int 
i
;

8 
	`khash_t
(
e32
) *
_arc
;

9 } 
	tvertex_t
;

11 
	$KGRAPH_INIT
(
g
, extern, 
vertex_t
, int, 
e32
)

12 
	$KGRAPH_PRINT
(
g
, extern)

14 int 
	$main
()

16 int *
pb
, *
pe
;

17 
	`kgraph_t
(
g
) *g;

18 
g
 = 
	`kg_init_g
();

19 
	`kg_put_a_g
(
g
, 10, 20, 0, &
pb
, &
pe
);

20 
	`kg_put_a_g
(
g
, 20, 30, 0, &
pb
, &
pe
);

21 
	`kg_put_a_g
(
g
, 30, 10, 1, &
pb
, &
pe
);

22 
	`kg_del_v_g
(
g
, 20);

23 
	`kg_print_g
(
g
);

24 
	`kg_destroy_g
(
g
);

26 
	}
}

	@deps/klib/test/khash_keith.c

12 #include 
	~<stdio.h
>

13 #include 
	~"khash.h
"

14 
	$KHASH_MAP_INIT_STR
(
str
, int)

16 
inline
 void 
	$int2str
(int 
c
, int 
base
, char *
ret
)

18 const char *
tab
 = "0123456789abcdef";

19 if (
c
 == 0) 
ret
[0] = '0', ret[1] = 0;

21 int 
l
, 
x
, 
y
;

22 char 
buf
[16];

23 for (
l
 = 0, 
x
 = 
c
 < 0? -c : c; x > 0; x /= 
base
) 
buf
[l++] = 
tab
[x%base];

24 if (
c
 < 0) 
buf
[
l
++] = '-';

25 for (
x
 = 
l
 - 1, 
y
 = 0; x >= 0; --x) 
ret
[y++] = 
buf
[x];

26 
ret
[
y
] = 0;

28 
	}
}

30 #ifndef 
_USE_STRDUP


31 #define 
	#BLOCK_SIZE
 0x100000

	)

32 int 
	$main
(int 
argc
, char *
argv
[])

34 char **
mem
 = 0;

35 int 
i
, 
l
, 
n
 = 1000000, 
ret
, 
block_end
 = 0, 
curr
 = 0, 
c
 = 0;

36 
	`khash_t
(
str
) *
h
;

37 
h
 = 
	`kh_init
(
str
);

38 if (
argc
 > 1) 
n
 = 
	`atoi
(
argv
[1]);

39 
mem
 = 
	`malloc
(sizeof(void*));

40 
mem
[0] = 
	`malloc
(
BLOCK_SIZE
);

41 
curr
 = 
block_end
 = 0;

42 for (
i
 = 1; i <= 
n
; ++i) {

43 char 
buf
[16];

44 
	`int2str
(
i
, 16, 
buf
);

45 
khint_t
 
k
 = 
	`kh_put
(
str
, 
h
, 
buf
, &
ret
);

46 
l
 = 
	`strlen
(
buf
) + 1;

47 if (
block_end
 + 
l
 > 
BLOCK_SIZE
) {

48 ++
curr
; 
block_end
 = 0;

49 
mem
 = 
	`realloc
(mem, (
curr
 + 1) * sizeof(void*));

50 
mem
[
curr
] = 
	`malloc
(
BLOCK_SIZE
);

52 
	`memcpy
(
mem
[
curr
] + 
block_end
, 
buf
, 
l
);

53 
	`kh_key
(
h
, 
k
) = 
mem
[
curr
] + 
block_end
;

54 
block_end
 += 
l
;

55 
	`kh_val
(
h
, 
k
) = 
i
;

57 for (
i
 = 1; i <= 
n
; ++i) {

58 char 
buf
[16];

59 
	`int2str
(
i
, 10, 
buf
);

60 
khint_t
 
k
 = 
	`kh_get
(
str
, 
h
, 
buf
);

61 if (
k
 != 
	`kh_end
(
h
)) ++
c
;

63 
	`printf
("%d\n", 
c
);

64 for (
ret
 = 0; ret <= 
curr
; ++ret) 
	`free
(
mem
[ret]);

65 
	`free
(
mem
);

66 
	`kh_destroy
(
str
, 
h
);

68 
	}
}

70 int 
	$main
(int 
argc
, char *
argv
[])

72 int 
i
, 
l
, 
n
 = 1000000, 
ret
, 
c
 = 0;

73 
	`khash_t
(
str
) *
h
;

74 
khint_t
 
k
;

75 
h
 = 
	`kh_init
(
str
);

76 if (
argc
 > 1) 
n
 = 
	`atoi
(
argv
[1]);

77 for (
i
 = 1; i <= 
n
; ++i) {

78 char 
buf
[16];

79 
	`int2str
(
i
, 16, 
buf
);

80 
k
 = 
	`kh_put
(
str
, 
h
, 
	`strdup
(
buf
), &
ret
);

81 
	`kh_val
(
h
, 
k
) = 
i
;

83 for (
i
 = 1; i <= 
n
; ++i) {

84 char 
buf
[16];

85 
	`int2str
(
i
, 10, 
buf
);

86 
k
 = 
	`kh_get
(
str
, 
h
, 
buf
);

87 if (
k
 != 
	`kh_end
(
h
)) ++
c
;

89 for (
k
 = 
	`kh_begin
(
h
); k != 
	`kh_end
(h); ++k)

90 if (
	`kh_exist
(
h
, 
k
)) 
	`free
((char*)
	`kh_key
(h, k));

91 
	`printf
("%d\n", 
c
);

92 
	`kh_destroy
(
str
, 
h
);

94 
	}
}

	@deps/klib/test/khash_keith2.c

12 #include 
	~<stdio.h
>

13 #include 
	~"khash.h
"

14 
	$KHASH_MAP_INIT_STR
(
str
, int)

16 
inline
 void 
	$int2str
(int 
c
, int 
base
, char *
ret
)

18 const char *
tab
 = "0123456789abcdef";

19 if (
c
 == 0) 
ret
[0] = '0', ret[1] = 0;

21 int 
l
, 
x
, 
y
;

22 char 
buf
[16];

23 for (
l
 = 0, 
x
 = 
c
 < 0? -c : c; x > 0; x /= 
base
) 
buf
[l++] = 
tab
[x%base];

24 if (
c
 < 0) 
buf
[
l
++] = '-';

25 for (
x
 = 
l
 - 1, 
y
 = 0; x >= 0; --x) 
ret
[y++] = 
buf
[x];

26 
ret
[
y
] = 0;

28 
	}
}

30 int 
	$main
(int 
argc
, char *
argv
[])

32 int 
i
, 
l
, 
n
 = 1000, 
ret
;

33 
	`khash_t
(
str
) *
h
, *
h2
;

34 
khint_t
 
k
;

35 
h
 = 
	`kh_init
(
str
);

36 
h2
 = 
	`kh_init
(
str
);

37 if (
argc
 > 1) 
n
 = 
	`atoi
(
argv
[1]);

38 for (
i
 = 0; i < 10000; ++i) {

39 char 
buf
[32];

40 
	`strcpy
(
buf
, "foo_");

41 
	`int2str
(
i
, 10, 
buf
+4);

42 
k
 = 
	`kh_put
(
str
, 
h
, 
	`strdup
(
buf
), &
ret
);

43 
	`kh_val
(
h
, 
k
) = 
i
;

45 for (
i
 = 0; i < 
n
; ++i) {

46 for (
k
 = 
	`kh_begin
(
h
); k != 
	`kh_end
(h); ++k) {

47 if (
	`kh_exist
(
h
, 
k
)) {

48 
khint_t
 
k2
 = 
	`kh_put
(
str
, 
h2
, 
	`kh_key
(
h
, 
k
), &
ret
);

49 if (
ret
) {

50 
	`kh_key
(
h2
, 
k2
) = 
	`strdup
(kh_key(
h
, 
k
));

51 
	`kh_val
(
h2
, 
k2
) = kh_val(
h
, 
k
);

52 } else 
	`kh_val
(
h2
, 
k2
) += kh_val(
h
, 
k
);

56 
k
 = 
	`kh_get
(
str
, 
h
, "foo_1"); 
	`printf
("%d", 
	`kh_val
(h, k));

57 
k
 = 
	`kh_get
(
str
, 
h
, "foo_9999"); 
	`printf
(" %d", 
	`kh_val
(h, k));

58 
k
 = 
	`kh_get
(
str
, 
h2
, "foo_1"); 
	`printf
(" %d", 
	`kh_val
(h2, k));

59 
k
 = 
	`kh_get
(
str
, 
h2
, "foo_9999"); 
	`printf
(" %d\n", 
	`kh_val
(h2, k));

60 for (
k
 = 
	`kh_begin
(
h
); k != 
	`kh_end
(h); ++k)

61 if (
	`kh_exist
(
h
, 
k
)) 
	`free
((char*)
	`kh_key
(h, k));

62 for (
k
 = 
	`kh_begin
(
h2
); k != 
	`kh_end
(h2); ++k)

63 if (
	`kh_exist
(
h2
, 
k
)) 
	`free
((char*)
	`kh_key
(h2, k));

64 
	`kh_destroy
(
str
, 
h
);

65 
	`kh_destroy
(
str
, 
h2
);

67 
	}
}

	@deps/klib/test/khash_test.c

1 #include 
	~<stdio.h
>

2 #include 
	~<assert.h
>

3 #include 
	~<time.h
>

4 #include 
	~<stdlib.h
>

5 #include 
	~<string.h
>

7 #include 
	~"khash.h
"

8 
	$KHASH_SET_INIT_STR
(
str
)

9 
	$KHASH_MAP_INIT_INT
(int, unsigned char)

12 unsigned 
key
;

13 unsigned char 
val
;

14 } 
	tint_unpack_t
;

17 unsigned 
key
;

18 unsigned char 
val
;

19 } 
	t__attribute__
 ((
	t__packed__
)) 
	tint_packed_t
;

21 #define 
	#hash_eq
(
a
, 
b
) ((a).
key
 == (b).key)

	)

22 #define 
	#hash_func
(
a
) ((a).
key
)

	)

24 
	$KHASH_INIT
(
iun
, 
int_unpack_t
, char, 0, 
hash_func
, 
hash_eq
)

25 
	$KHASH_INIT
(
ipk
, 
int_packed_t
, char, 0, 
hash_func
, 
hash_eq
)

27 static int 
data_size
 = 5000000;

28 static unsigned *
int_data
;

29 static char **
str_data
;

31 void 
	$ht_init_data
()

33 int 
i
;

34 char 
buf
[256];

35 
khint32_t
 
x
 = 11;

36 
	`printf
("--- generating data... ");

37 
int_data
 = (unsigned*)
	`calloc
(
data_size
, sizeof(unsigned));

38 
str_data
 = (char**)
	`calloc
(
data_size
, sizeof(char*));

39 for (
i
 = 0; i < 
data_size
; ++i) {

40 
int_data
[
i
] = (unsigned)(
data_size
 * ((double)
x
 / 
UINT_MAX
) / 4) * 271828183u;

41 
	`sprintf
(
buf
, "%x", 
int_data
[
i
]);

42 
str_data
[
i
] = 
	`strdup
(
buf
);

43 
x
 = 1664525L * x + 1013904223L;

45 
	`printf
("done!\n");

46 
	}
}

48 void 
	$ht_destroy_data
()

50 int 
i
;

51 for (
i
 = 0; i < 
data_size
; ++i) 
	`free
(
str_data
[i]);

52 
	`free
(
str_data
); free(
int_data
);

53 
	}
}

55 void 
	$ht_khash_int
()

57 int 
i
, 
ret
;

58 unsigned *
data
 = 
int_data
;

59 
	`khash_t
(int) *
h
;

60 unsigned 
k
;

62 
h
 = 
	`kh_init
(int);

63 for (
i
 = 0; i < 
data_size
; ++i) {

64 
k
 = 
	`kh_put
(int, 
h
, 
data
[
i
], &
ret
);

65 
	`kh_val
(
h
, 
k
) = 
i
&0xff;

66 if (!
ret
) 
	`kh_del
(int, 
h
, 
k
);

68 
	`printf
("[ht_khash_int] size: %u\n", 
	`kh_size
(
h
));

69 
	`kh_destroy
(int, 
h
);

70 
	}
}

72 void 
	$ht_khash_str
()

74 int 
i
, 
ret
;

75 char **
data
 = 
str_data
;

76 
	`khash_t
(
str
) *
h
;

77 unsigned 
k
;

79 
h
 = 
	`kh_init
(
str
);

80 for (
i
 = 0; i < 
data_size
; ++i) {

81 
k
 = 
	`kh_put
(
str
, 
h
, 
data
[
i
], &
ret
);

82 if (!
ret
) 
	`kh_del
(
str
, 
h
, 
k
);

84 
	`printf
("[ht_khash_int] size: %u\n", 
	`kh_size
(
h
));

85 
	`kh_destroy
(
str
, 
h
);

86 
	}
}

88 void 
	$ht_khash_unpack
()

90 int 
i
, 
ret
;

91 unsigned *
data
 = 
int_data
;

92 
	`khash_t
(
iun
) *
h
;

93 unsigned 
k
;

95 
h
 = 
	`kh_init
(
iun
);

96 for (
i
 = 0; i < 
data_size
; ++i) {

97 
int_unpack_t
 
x
;

98 
x
.
key
 = 
data
[
i
]; x.
val
 = i&0xff;

99 
k
 = 
	`kh_put
(
iun
, 
h
, 
x
, &
ret
);

100 if (!
ret
) 
	`kh_del
(
iun
, 
h
, 
k
);

102 
	`printf
("[ht_khash_unpack] size: %u (sizeof=%ld)\n", 
	`kh_size
(
h
), sizeof(
int_unpack_t
));

103 
	`kh_destroy
(
iun
, 
h
);

104 
	}
}

106 void 
	$ht_khash_packed
()

108 int 
i
, 
ret
;

109 unsigned *
data
 = 
int_data
;

110 
	`khash_t
(
ipk
) *
h
;

111 unsigned 
k
;

113 
h
 = 
	`kh_init
(
ipk
);

114 for (
i
 = 0; i < 
data_size
; ++i) {

115 
int_packed_t
 
x
;

116 
x
.
key
 = 
data
[
i
]; x.
val
 = i&0xff;

117 
k
 = 
	`kh_put
(
ipk
, 
h
, 
x
, &
ret
);

118 if (!
ret
) 
	`kh_del
(
ipk
, 
h
, 
k
);

120 
	`printf
("[ht_khash_packed] size: %u (sizeof=%ld)\n", 
	`kh_size
(
h
), sizeof(
int_packed_t
));

121 
	`kh_destroy
(
ipk
, 
h
);

122 
	}
}

124 void 
	$ht_timing
(void (*
f
)(void))

126 
clock_t
 
t
 = 
	`clock
();

127 (*
f
)();

128 
	`printf
("[ht_timing] %.3lf sec\n", (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

129 
	}
}

131 int 
	$main
(int 
argc
, char *
argv
[])

133 if (
argc
 > 1) 
data_size
 = 
	`atoi
(
argv
[1]);

134 
	`ht_init_data
();

135 
	`ht_timing
(
ht_khash_int
);

136 
	`ht_timing
(
ht_khash_str
);

137 
	`ht_timing
(
ht_khash_unpack
);

138 
	`ht_timing
(
ht_khash_packed
);

139 
	`ht_destroy_data
();

141 
	}
}

	@deps/klib/test/klist_test.c

1 #include 
	~<stdio.h
>

2 #include 
	~"klist.h
"

4 #define 
	#__int_free
(
x
)

	)

5 
	$KLIST_INIT
(32, int, 
__int_free
)

7 int 
	$main
()

9 
	`klist_t
(32) *
kl
;

10 
	`kliter_t
(32) *
p
;

11 
kl
 = 
	`kl_init
(32);

12 *
	`kl_pushp
(32, 
kl
) = 1;

13 *
	`kl_pushp
(32, 
kl
) = 10;

14 
	`kl_shift
(32, 
kl
, 0);

15 for (
p
 = 
	`kl_begin
(
kl
); p != 
	`kl_end
(kl); p = 
	`kl_next
(p))

16 
	`printf
("%d\n", 
	`kl_val
(
p
));

17 
	`kl_destroy
(32, 
kl
);

19 
	}
}

	@deps/klib/test/kmin_test.c

1 #include 
	~<stdio.h
>

2 #include 
	~<math.h
>

3 #include 
	~"kmath.h
"

5 static int 
	gn_evals
;

7 double 
	$f_Chebyquad
(int 
n
, double *
x
, void *
data
)

9 int 
i
, 
j
;

10 double 
y
[20][20], 
f
;

11 int 
np
, 
iw
;

12 double 
sum
;

13 for (
j
 = 0; j != 
n
; ++j) {

14 
y
[0][
j
] = 1.;

15 
y
[1][
j
] = 2. * 
x
[j] - 1.;

17 for (
i
 = 1; i != 
n
; ++i)

18 for (
j
 = 0; j != 
n
; ++j)

19 
y
[
i
+1][
j
] = 2. * y[1][j] * y[i][j] - y[i-1][j];

20 
f
 = 0.;

21 
np
 = 
n
 + 1;

22 
iw
 = 1;

23 for (
i
 = 0; i != 
np
; ++i) {

24 
sum
 = 0.;

25 for (
j
 = 0; j != 
n
; ++j) 
sum
 += 
y
[
i
][j];

26 
sum
 /= 
n
;

27 if (
iw
 > 0) 
sum
 += 1. / ((
i
 - 1) * (i + 1));

28 
iw
 = -iw;

29 
f
 += 
sum
 * sum;

31 ++
n_evals
;

32 return 
f
;

33 
	}
}

35 int 
	$main
()

37 double 
x
[20], 
y
;

38 int 
n
, 
i
;

39 
	`printf
("\nMinimizer: Hooke-Jeeves\n");

40 for (
n
 = 2; n <= 8; n += 2) {

41 for (
i
 = 0; i != 
n
; ++i) 
x
[i] = (double)(i + 1) / n;

42 
n_evals
 = 0;

43 
y
 = 
	`kmin_hj
(
f_Chebyquad
, 
n
, 
x
, 0, 
KMIN_RADIUS
, 
KMIN_EPS
, 
KMIN_MAXCALL
);

44 
	`printf
("n=%d,min=%.8lg,n_evals=%d\n", 
n
, 
y
, 
n_evals
);

46 
	`printf
("\n");

48 
	}
}

	@deps/klib/test/kseq_bench.c

1 #include 
	~<zlib.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<time.h
>

4 #include 
	~<stdint.h
>

5 #include 
	~<stdlib.h
>

6 #include 
	~"kseq.h
"

8 #define 
	#BUF_SIZE
 4096

	)

9 
	$KSTREAM_INIT
(
gzFile
, 
gzread
, 
BUF_SIZE
)

11 int 
	$main
(int 
argc
, char *
argv
[])

13 
gzFile
 
fp
;

14 
clock_t
 
t
;

15 if (
argc
 == 1) {

16 
	`fprintf
(
stderr
, "Usage: kseq_bench <in.gz>\n");

20 
uint8_t
 *
buf
 = 
	`malloc
(
BUF_SIZE
);

21 
fp
 = 
	`gzopen
(
argv
[1], "r");

22 
t
 = 
	`clock
();

23 while (
	`gzread
(
fp
, 
buf
, 
BUF_SIZE
) > 0);

24 
	`fprintf
(
stderr
, "[gzread] %.2f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

25 
	`gzclose
(
fp
);

26 
	`free
(
buf
);

29 
kstream_t
 *
ks
;

30 
fp
 = 
	`gzopen
(
argv
[1], "r");

31 
ks
 = 
	`ks_init
(
fp
);

32 
t
 = 
	`clock
();

33 while (
	`ks_getc
(
ks
) >= 0);

34 
	`fprintf
(
stderr
, "[ks_getc] %.2f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

35 
	`ks_destroy
(
ks
);

36 
	`gzclose
(
fp
);

39 
kstream_t
 *
ks
;

40 
kstring_t
 *
s
;

41 int 
dret
;

42 
s
 = 
	`calloc
(1, sizeof(
kstring_t
));

43 
fp
 = 
	`gzopen
(
argv
[1], "r");

44 
ks
 = 
	`ks_init
(
fp
);

45 
t
 = 
	`clock
();

46 while (
	`ks_getuntil
(
ks
, '\n', 
s
, &
dret
) >= 0);

47 
	`fprintf
(
stderr
, "[ks_getuntil] %.2f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

48 
	`ks_destroy
(
ks
);

49 
	`gzclose
(
fp
);

50 
	`free
(
s
->s); free(s);

52 if (
argc
 == 2) {

53 
fp
 = 
	`gzopen
(
argv
[1], "r");

54 
t
 = 
	`clock
();

55 while (
	`gzgetc
(
fp
) >= 0);

56 
	`fprintf
(
stderr
, "[gzgetc] %.2f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

57 
	`gzclose
(
fp
);

59 if (
argc
 == 2) {

60 char *
buf
 = 
	`malloc
(
BUF_SIZE
);

61 
fp
 = 
	`gzopen
(
argv
[1], "r");

62 
t
 = 
	`clock
();

63 while (
	`gzgets
(
fp
, 
buf
, 
BUF_SIZE
) > 0);

64 
	`fprintf
(
stderr
, "[gzgets] %.2f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

65 
	`gzclose
(
fp
);

66 
	`free
(
buf
);

69 
	}
}

	@deps/klib/test/kseq_bench2.c

1 #include 
	~<stdio.h
>

2 #include 
	~<time.h
>

3 #include 
	~<stdint.h
>

4 #include 
	~<stdlib.h
>

5 #include 
	~<fcntl.h
>

6 #include 
	~"kseq.h
"

7 
	$KSTREAM_INIT
(int, 
read
, 4096)

9 #define 
	#BUF_SIZE
 65536

	)

11 int 
	$main
(int 
argc
, char *
argv
[])

13 
clock_t
 
t
;

14 if (
argc
 == 1) {

15 
	`fprintf
(
stderr
, "Usage: %s <in.txt>\n", 
argv
[0]);

19 
FILE
 *
fp
;

20 char *
s
;

21 
t
 = 
	`clock
();

22 
s
 = 
	`malloc
(
BUF_SIZE
);

23 
fp
 = 
	`fopen
(
argv
[1], "r");

24 while (
	`fgets
(
s
, 
BUF_SIZE
, 
fp
));

25 
	`fclose
(
fp
);

26 
	`fprintf
(
stderr
, "[fgets] %.2f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

29 int 
fd
, 
dret
;

30 
kstream_t
 *
ks
;

31 
kstring_t
 
s
;

32 
t
 = 
	`clock
();

33 
s
.
l
 = s.
m
 = 0; s.s = 0;

34 
fd
 = 
	`open
(
argv
[1], 
O_RDONLY
);

35 
ks
 = 
	`ks_init
(
fd
);

36 while (
	`ks_getuntil
(
ks
, '\n', &
s
, &
dret
) >= 0);

37 
	`free
(
s
.s);

38 
	`ks_destroy
(
ks
);

39 
	`close
(
fd
);

40 
	`fprintf
(
stderr
, "[kstream] %.2f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

43 
	}
}

	@deps/klib/test/kseq_test.c

1 #include 
	~<zlib.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~"kseq.h
"

4 
	$KSEQ_INIT
(
gzFile
, 
gzread
)

6 int 
	$main
(int 
argc
, char *
argv
[])

8 
gzFile
 
fp
;

9 
kseq_t
 *
seq
;

10 int 
l
;

11 if (
argc
 == 1) {

12 
	`fprintf
(
stderr
, "Usage: %s <in.fasta>\n", 
argv
[0]);

15 
fp
 = 
	`gzopen
(
argv
[1], "r");

16 
seq
 = 
	`kseq_init
(
fp
);

17 while ((
l
 = 
	`kseq_read
(
seq
)) >= 0) {

18 
	`printf
("name: %s\n", 
seq
->
name
.
s
);

19 if (
seq
->
comment
.
l
) 
	`printf
("comment: %s\n", seq->comment.
s
);

20 
	`printf
("seq: %s\n", 
seq
->seq.
s
);

21 if (
seq
->
qual
.
l
) 
	`printf
("qual: %s\n", seq->qual.
s
);

23 
	`printf
("return value: %d\n", 
l
);

24 
	`kseq_destroy
(
seq
);

25 
	`gzclose
(
fp
);

27 
	}
}

	@deps/klib/test/ksort_test.c

1 #include 
	~<stdlib.h
>

2 #include 
	~<string.h
>

3 #include 
	~<stdio.h
>

4 #include 
	~<time.h
>

5 #include 
	~"ksort.h
"

7 
	$KSORT_INIT_GENERIC
(int)

9 int 
	$main
(int 
argc
, char *
argv
[])

11 int 
i
, 
N
 = 10000000;

12 int *
array
, 
x
;

13 
clock_t
 
t1
, 
t2
;

14 if (
argc
 > 1) 
N
 = 
	`atoi
(
argv
[1]);

15 
array
 = (int*)
	`malloc
(sizeof(int) * 
N
);

17 
	`srand48
(11);

18 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

19 
t1
 = 
	`clock
();

20 
x
 = 
	`ks_ksmall
(int, 
N
, 
array
, 10500);

21 
t2
 = 
	`clock
();

22 
	`fprintf
(
stderr
, "ksmall [%d]: %.3lf\n", 
x
, (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

24 
	`srand48
(11);

25 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

26 
t1
 = 
	`clock
();

27 
	`ks_introsort
(int, 
N
, 
array
);

28 
t2
 = 
	`clock
();

29 
	`fprintf
(
stderr
, "introsort [%d]: %.3lf\n", 
array
[10500], (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

30 for (
i
 = 0; i < 
N
-1; ++i) {

31 if (
array
[
i
] > array[i+1]) {

32 
	`fprintf
(
stderr
, "Bug in introsort!\n");

33 
	`exit
(1);

37 #ifndef 
_ALIGNED_ONLY


39 
	`srand48
(11);

40 unsigned char *
a
;

41 int *
b
;

42 
a
 = 
	`malloc
(
N
 * sizeof(int) + 1);

43 
b
 = (int*)(
a
 + 1);

44 for (
i
 = 0; i < 
N
; ++i) 
b
[i] = (int)
	`lrand48
();

45 
t1
 = 
	`clock
();

46 
	`ks_introsort
(int, 
N
, 
b
);

47 
t2
 = 
	`clock
();

48 
	`fprintf
(
stderr
, "introsort [%d]: %.3lf (unaligned: 0x%lx) \n", 
b
[10500], (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
, (
size_t
)b);

52 
t1
 = 
	`clock
();

53 
	`ks_introsort
(int, 
N
, 
array
);

54 
t2
 = 
	`clock
();

55 
	`fprintf
(
stderr
, "introsort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

57 
	`srand48
(11);

58 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

59 
t1
 = 
	`clock
();

60 
	`ks_combsort
(int, 
N
, 
array
);

61 
t2
 = 
	`clock
();

62 
	`fprintf
(
stderr
, "combsort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

63 for (
i
 = 0; i < 
N
-1; ++i) {

64 if (
array
[
i
] > array[i+1]) {

65 
	`fprintf
(
stderr
, "Bug in combsort!\n");

66 
	`exit
(1);

70 
	`srand48
(11);

71 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

72 
t1
 = 
	`clock
();

73 
	`ks_mergesort
(int, 
N
, 
array
, 0);

74 
t2
 = 
	`clock
();

75 
	`fprintf
(
stderr
, "mergesort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

76 for (
i
 = 0; i < 
N
-1; ++i) {

77 if (
array
[
i
] > array[i+1]) {

78 
	`fprintf
(
stderr
, "Bug in mergesort!\n");

79 
	`exit
(1);

83 
t1
 = 
	`clock
();

84 
	`ks_mergesort
(int, 
N
, 
array
, 0);

85 
t2
 = 
	`clock
();

86 
	`fprintf
(
stderr
, "mergesort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

88 
	`srand48
(11);

89 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

90 
t1
 = 
	`clock
();

91 
	`ks_heapmake
(int, 
N
, 
array
);

92 
	`ks_heapsort
(int, 
N
, 
array
);

93 
t2
 = 
	`clock
();

94 
	`fprintf
(
stderr
, "heapsort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

95 for (
i
 = 0; i < 
N
-1; ++i) {

96 if (
array
[
i
] > array[i+1]) {

97 
	`fprintf
(
stderr
, "Bug in heapsort!\n");

98 
	`exit
(1);

102 
	`free
(
array
);

104 
	}
}

	@deps/klib/test/ksort_test.cc

1 #include 
	~<stdlib.h
>

2 #include 
	~<string.h
>

3 #include 
	~<stdio.h
>

4 #include 
	~<time.h
>

5 #include 
	~<algorithm
>

7 #include 
	~"ksort.h
"

8 
	$KSORT_INIT_GENERIC
(int)

10 
using
 
namespace
 
std
;

68 static 
inline
 void 
	$sort2
 (int * 
numbers
) {

69 int 
tmp
;

71 if (
numbers
[0] <= numbers[1]) return;

72 
tmp
 = 
numbers
[0];

73 
numbers
[0] = numbers[1];

74 
numbers
[1] = 
tmp
;

75 
	}
}

77 static 
inline
 void 
	$sort3
 (int * 
numbers
) {

78 int 
tmp
;

80 if (
numbers
[0] <= numbers[1]) {

81 if (
numbers
[1] <= numbers[2]) return;

82 if (
numbers
[2] <= numbers[0]) {

83 
tmp
 = 
numbers
[0];

84 
numbers
[0] = numbers[2];

85 
numbers
[2] = numbers[1];

86 
numbers
[1] = 
tmp
;

89 
tmp
 = 
numbers
[1];

91 
tmp
 = 
numbers
[0];

92 if (
numbers
[0] <= numbers[2]) {

93 
numbers
[0] = numbers[1];

94 
numbers
[1] = 
tmp
;

97 if (
numbers
[2] <= numbers[1]) {

98 
numbers
[0] = numbers[2];

99 
numbers
[2] = 
tmp
;

102 
numbers
[0] = numbers[1];

104 
numbers
[1] = numbers[2];

105 
numbers
[2] = 
tmp
;

106 
	}
}

108 static 
inline
 void 
	$sort4
 (int * 
num
) {

109 int 
tmp
;

110 if (
num
[0] < num[1]) {

111 if (
num
[1] < num[2]) {

112 if (
num
[1] < num[3]) {

113 if (
num
[2] >= num[3]) {

114 
tmp
 = 
num
[2];

115 
num
[2] = num[3];

116 
num
[3] = 
tmp
;

119 
tmp
 = 
num
[1];

120 if (
num
[0] < num[3]) {

121 
num
[1] = num[3];

123 
num
[1] = num[0];

124 
num
[0] = num[3];

126 
num
[3] = num[2];

127 
num
[2] = 
tmp
;

130 if (
num
[0] < num[2]) {

131 if (
num
[2] < num[3]) {

132 if (
num
[1] < num[3]) {

133 
tmp
 = 
num
[1];

135 
tmp
 = 
num
[3];

136 
num
[3] = num[1];

138 
num
[1] = num[2];

139 
num
[2] = 
tmp
;

141 if (
num
[0] < num[3]) {

142 
tmp
 = 
num
[3];

144 
tmp
 = 
num
[0];

145 
num
[0] = num[3];

147 
num
[3] = num[1];

148 
num
[1] = 
tmp
;

151 if (
num
[0] < num[3]) {

152 
tmp
 = 
num
[0];

153 
num
[0] = num[2];

154 if (
num
[1] < num[3]) {

155 
num
[2] = num[1];

157 
num
[2] = num[3];

158 
num
[3] = num[1];

160 
num
[1] = 
tmp
;

162 if (
num
[2] < num[3]) {

163 
tmp
 = 
num
[0];

164 
num
[0] = num[2];

165 
num
[2] = 
tmp
;

166 
tmp
 = 
num
[1];

167 
num
[1] = num[3];

169 
tmp
 = 
num
[1];

170 
num
[1] = num[2];

171 
num
[2] = num[0];

172 
num
[0] = num[3];

174 
num
[3] = 
tmp
;

179 
tmp
 = 
num
[0];

180 if (
tmp
 < 
num
[2]) {

181 if (
tmp
 < 
num
[3]) {

182 
num
[0] = num[1];

183 
num
[1] = 
tmp
;

184 if (
num
[2] >= num[3]) {

185 
tmp
 = 
num
[2];

186 
num
[2] = num[3];

187 
num
[3] = 
tmp
;

190 if (
num
[1] < num[3]) {

191 
num
[0] = num[1];

192 
num
[1] = num[3];

194 
num
[0] = num[3];

196 
num
[3] = num[2];

197 
num
[2] = 
tmp
;

200 if (
num
[1] < num[2]) {

201 if (
num
[2] < num[3]) {

202 
num
[0] = num[1];

203 
num
[1] = num[2];

204 if (
tmp
 < 
num
[3]) {

205 
num
[2] = 
tmp
;

207 
num
[2] = num[3];

208 
num
[3] = 
tmp
;

211 if (
num
[1] < num[3]) {

212 
num
[0] = num[1];

213 
num
[1] = num[3];

215 
num
[0] = num[3];

217 
num
[3] = 
tmp
;

220 if (
num
[1] < num[3]) {

221 
num
[0] = num[2];

222 if (
tmp
 < 
num
[3]) {

223 
num
[2] = 
tmp
;

225 
num
[2] = num[3];

226 
num
[3] = 
tmp
;

229 if (
num
[2] < num[3]) {

230 
num
[0] = num[2];

231 
num
[2] = num[1];

232 
num
[1] = num[3];

233 
num
[3] = 
tmp
;

235 
num
[0] = num[3];

236 
num
[3] = 
tmp
;

237 
tmp
 = 
num
[1];

238 
num
[1] = num[2];

239 
num
[2] = 
tmp
;

245 
	}
}

247 static 
inline
 void 
	$sortAlt2
 (int * 
numbers
, int * 
altNumbers
) {

248 if (
numbers
[0] <= numbers[1]) {

249 
altNumbers
[0] = 
numbers
[0];

250 
altNumbers
[1] = 
numbers
[1];

252 
altNumbers
[0] = 
numbers
[1];

253 
altNumbers
[1] = 
numbers
[0];

255 
	}
}

257 static 
inline
 void 
	$sortAlt3
 (int * 
numbers
, int * 
altNumbers
) {

258 if (
numbers
[0] <= numbers[1]) {

259 if (
numbers
[1] <= numbers[2]) {

260 
altNumbers
[0] = 
numbers
[0];

261 
altNumbers
[1] = 
numbers
[1];

262 
altNumbers
[2] = 
numbers
[2];

263 } else if (
numbers
[2] <= numbers[0]) {

264 
altNumbers
[0] = 
numbers
[2];

265 
altNumbers
[1] = 
numbers
[0];

266 
altNumbers
[2] = 
numbers
[1];

268 
altNumbers
[0] = 
numbers
[0];

269 
altNumbers
[1] = 
numbers
[2];

270 
altNumbers
[2] = 
numbers
[1];

273 if (
numbers
[0] <= numbers[2]) {

274 
altNumbers
[0] = 
numbers
[1];

275 
altNumbers
[1] = 
numbers
[0];

276 
altNumbers
[2] = 
numbers
[2];

277 } else if (
numbers
[2] <= numbers[1]) {

278 
altNumbers
[0] = 
numbers
[2];

279 
altNumbers
[1] = 
numbers
[1];

280 
altNumbers
[2] = 
numbers
[0];

282 
altNumbers
[0] = 
numbers
[1];

283 
altNumbers
[1] = 
numbers
[2];

284 
altNumbers
[2] = 
numbers
[0];

287 
	}
}

293 
inline
 void 
	$insertSort
 (int 
numbers
[], int 
qty
) {

294 int 
i
, 
j
, 
idx
, 
q4
;

295 int 
tmp
;

297 if (
qty
 <= 4) {

298 if (
qty
 == 4) 
	`sort4
 (
numbers
);

299 else if (
qty
 == 3) 
	`sort3
 (
numbers
);

300 else if (
qty
 == 2) 
	`sort2
 (
numbers
);

304 
q4
 = 
qty
 - 4;

306 for (
i
=0; i < 
q4
; i++) {

307 
idx
 = 
i
;

308 for (
j
=
i
+1; j < 
qty
; j++) {

309 if (
numbers
[
j
] < numbers[
idx
]) idx = j;

311 if (
idx
 != 
i
) {

312 
tmp
 = 
numbers
[
idx
];

313 
numbers
[
idx
] = numbers[
i
];

314 
numbers
[
i
] = 
tmp
;

318 
	`sort4
 (
numbers
 + 
q4
);

319 
	}
}

326 static void 
	$siftDown
 (int 
numbers
[], int 
top
, int 
last
) {

327 int 
tmp
 = 
numbers
[
top
];

328 int 
maxIdx
 = 
top
;

330 while (
last
 >= (
maxIdx
 += maxIdx)) {

335 if (
maxIdx
 != 
last
 && 
numbers
[maxIdx] < numbers[maxIdx + 1]) maxIdx++;

337 if (
tmp
 >= 
numbers
[
maxIdx
]) break;

338 
numbers
[
top
] = numbers[
maxIdx
];

339 
top
 = 
maxIdx
;

341 
numbers
[
top
] = 
tmp
;

342 
	}
}

346 static void 
	$siftDown0
 (int 
numbers
[], int 
last
) {

347 int 
tmp
;

349 if (
numbers
[0] < numbers[1]) {

350 
tmp
 = 
numbers
[1];

351 
numbers
[1] = numbers[0];

352 
	`siftDown
 (
numbers
, 1, 
last
);

354 
tmp
 = 
numbers
[0];

356 
numbers
[0] = numbers[
last
];

357 
numbers
[
last
] = 
tmp
;

358 
	}
}

360 void 
	$heapSort
 (int 
numbers
[], int 
qty
) {

361 int 
i
;

363 if (
qty
 <= 4) {

364 if (
qty
 == 4) 
	`sort4
 (
numbers
);

365 else if (
qty
 == 3) 
	`sort3
 (
numbers
);

366 else if (
qty
 == 2) 
	`sort2
 (
numbers
);

370 
i
 = 
qty
 / 2;

372 for ( 
qty
--; 
i
 > 0; i--) 
	`siftDown
 (
numbers
, i, qty);

373 for (
i
 = 
qty
; i > 0; i--) 
	`siftDown0
 (
numbers
, i);

374 
	}
}

380 static int 
	$medianOf3
 (int * 
numbers
, int 
i
, int 
j
) {

381 int 
tmp
;

383 if (
numbers
[0] <= numbers[
i
]) {

384 if (
numbers
[
j
] <= numbers[0]) return numbers[0];

385 if (
numbers
[
i
] <= numbers[
j
]) j = i;

388 if (
numbers
[0] <= numbers[
j
]) return numbers[0];

389 if (
numbers
[
j
] <= numbers[
i
]) j = i;

392 
tmp
 = 
numbers
[
j
];

393 
numbers
[
j
] = numbers[0];

394 
numbers
[0] = 
tmp
;

395 return 
tmp
;

396 
	}
}

398 static void 
	$quickSortRecurse
 (int * 
numbers
, int 
left
, int 
right
) {

399 int 
pivot
, 
lTmp
, 
rTmp
;

401 
qsrStart
:;

403 #if 
	`defined
(
__GNUC__
)

404 if (
right
 <= 
left
 + 8) {

405 
	`insertSort
 (
numbers
 + 
left
, 
right
 - left + 1);

409 if (
right
 <= 
left
 + 3) {

410 if (
right
 == 
left
 + 1) {

411 
	`sort2
 (
numbers
 + 
left
);

412 } else if (
right
 == 
left
 + 2) {

413 
	`sort3
 (
numbers
 + 
left
);

414 } else if (
right
 == 
left
 + 3) {

415 
	`sort4
 (
numbers
 + 
left
);

421 
lTmp
 = 
left
;

422 
rTmp
 = 
right
;

424 
pivot
 = 
	`medianOf3
 (
numbers
 + 
left
, (
right
-left) >> 1, right-1-left);

426 goto 
QStart
;

429 
right
--;

430 if (
left
 >= 
right
) goto 
QEnd
;

431 
QStart
:;

432 } while (
numbers
[
right
] > 
pivot
);

433 
numbers
[
left
] = numbers[
right
];

435 
left
++;

436 if (
left
 >= 
right
) {

437 
left
 = 
right
;

438 goto 
QEnd
;

440 } while (
numbers
[ 
left
] < 
pivot
);

441 
numbers
[
right
] = numbers[
left
];

443 
QEnd
:;

444 
numbers
[
left
] = 
pivot
;

448 if (
left
-1 - 
lTmp
 <= 
rTmp
 - left - 1) {

449 if (
lTmp
 < 
left
) 
	`quickSortRecurse
 (
numbers
, lTmp, left-1);

452 
left
++;

453 
right
 = 
rTmp
;

455 if (
rTmp
 > 
left
) 
	`quickSortRecurse
 (
numbers
, left+1, rTmp);

458 
right
 = 
left
 - 1;

459 
left
 = 
lTmp
;

463 goto 
qsrStart
;

464 
	}
}

466 void 
	$quickSort
 (int 
numbers
[], int 
qty
) {

467 if (
qty
 < 2) return;

468 
	`quickSortRecurse
 (
numbers
, 0, 
qty
 - 1);

469 
	}
}

475 static void 
mergesortInPlace
 (int * 
numbers
, int * 
altNumbers
, int 
qty
);

479 static void 
	$mergesortExchange
 (int * 
numbers
, int * 
altNumbers
, int 
qty
) {

480 int 
half
, 
i0
, 
i1
, 
i
;

482 if (
qty
 == 2) {

483 
	`sortAlt2
 (
numbers
, 
altNumbers
);

486 if (
qty
 == 3) {

487 
	`sortAlt3
 (
numbers
, 
altNumbers
);

491 
half
 = (
qty
 + 1)/2;

493 
	`mergesortInPlace
 (
numbers
, 
altNumbers
, 
half
);

494 
	`mergesortInPlace
 (
numbers
 + 
half
, 
altNumbers
, 
qty
 - half);

496 
i0
 = 0; 
i1
 = 
half
;

498 for (
i
=0; i < 
qty
; i++) {

499 if (
i1
 >= 
qty
 || (
i0
 < 
half
 && 
numbers
[i0] < numbers[i1])) {

500 
altNumbers
[
i
] = 
numbers
[
i0
];

501 
i0
++;

503 
altNumbers
[
i
] = 
numbers
[
i1
];

504 
i1
++;

507 
	}
}

511 static void 
	$mergesortInPlace
 (int * 
numbers
, int * 
altNumbers
, int 
qty
) {

512 int 
half
, 
i0
, 
i1
, 
i
;

515 if (
qty
 == 2) {

516 
	`sort2
 (
numbers
);

519 if (
qty
 == 3) {

520 
	`sort3
 (
numbers
);

523 if (
qty
 == 4) {

524 
	`sort4
 (
numbers
);

528 if (
qty
 <= 12) {

529 
	`insertSort
 (
numbers
, 
qty
);

534 
half
 = (
qty
 + 1)/2;

536 
	`mergesortExchange
 (
numbers
, 
altNumbers
, 
half
);

537 
	`mergesortExchange
 (
numbers
 + 
half
, 
altNumbers
 + half, 
qty
 - half);

539 
i0
 = 0; 
i1
 = 
half
;

541 for (
i
=0; i < 
qty
; i++) {

542 if (
i1
 >= 
qty
 || (
i0
 < 
half
 && 
altNumbers
[i0] < altNumbers[i1])) {

543 
numbers
[
i
] = 
altNumbers
[
i0
];

544 
i0
++;

546 
numbers
[
i
] = 
altNumbers
[
i1
];

547 
i1
++;

550 
	}
}

552 #include 
	~<stdlib.h
>

554 void 
	$mergeSort
 (int 
numbers
[], int 
qty
) {

555 int * 
tmpArray
;

557 if (
qty
 <= 12) {

558 
	`insertSort
 (
numbers
, 
qty
);

562 
tmpArray
 = (int *) 
	`malloc
 (
qty
 * sizeof (int));

563 
	`mergesortInPlace
 (
numbers
, 
tmpArray
, 
qty
);

564 
	`free
 (
tmpArray
);

565 
	}
}

575 #define 
	#rstype_t
 unsigned

	)

576 #define 
	#rskey
(
x
) (x)

	)

578 #define 
	#RS_MIN_SIZE
 64

	)

581 
rstype_t
 *
	mb
, *
	me
;

582 } 
	trsbucket_t
;

584 void 
	$rs_sort
(
rstype_t
 *
beg
, rstype_t *
end
, int 
n_bits
, int 
s
)

586 
rstype_t
 *
i
;

587 int 
size
 = 1<<
n_bits
, 
m
 = size - 1;

588 
rsbucket_t
 *
k
, 
b
[
size
], *
be
 = b + size;

590 for (
k
 = 
b
; k != 
be
; ++k) k->b = k->
e
 = 
beg
;

591 for (
i
 = 
beg
; i != 
end
; ++i) ++
b
[
	`rskey
(*i)>>
s
&
m
].
e
;

592 for (
k
 = 
b
 + 1; k != 
be
; ++k)

593 
k
->
e
 += (k-1)->e - 
beg
, k->
b
 = (k-1)->e;

594 for (
k
 = 
b
; k != 
be
;) {

595 if (
k
->
b
 != k->
e
) {

596 
rsbucket_t
 *
l
;

597 if ((
l
 = 
b
 + (
	`rskey
(*
k
->b)>>
s
&
m
)) != k) {

598 
rstype_t
 
tmp
 = *
k
->
b
, 
swap
;

600 
swap
 = 
tmp
; tmp = *
l
->
b
; *l->b++ = swap;

601 
l
 = 
b
 + (
	`rskey
(
tmp
)>>
s
&
m
);

602 } while (
l
 != 
k
);

603 *
k
->
b
++ = 
tmp
;

604 } else ++
k
->
b
;

605 } else ++
k
;

607 for (
b
->b = 
beg
, 
k
 = b + 1; k != 
be
; ++k) k->b = (k-1)->
e
;

608 if (
s
) {

609 
s
 = s > 
n_bits
? s - n_bits : 0;

610 for (
k
 = 
b
; k != 
be
; ++k)

611 if (
k
->
e
 - k->
b
 > 
RS_MIN_SIZE
) 
	`rs_sort
(k->b, k->e, 
n_bits
, 
s
);

612 else if (
k
->
e
 - k->
b
 > 1)

613 for (
i
 = 
k
->
b
 + 1; i < k->
e
; ++i)

614 if (
	`rskey
(*
i
) < rskey(*(i - 1))) {

615 
rstype_t
 *
j
, 
tmp
 = *
i
;

616 for (
j
 = 
i
; j > 
k
->
b
 && 
	`rskey
(
tmp
) < rskey(*(j-1)); --j)

617 *
j
 = *(j - 1);

618 *
j
 = 
tmp
;

621 
	}
}

627 static 
inline
 void 
	$rs_insertsort
(
rstype_t
 *
s
, rstype_t *
t
)

629 
rstype_t
 *
i
;

630 for (
i
 = 
s
 + 1; i < 
t
; ++i) {

631 if (
	`rskey
(*
i
) < rskey(*(i - 1))) {

632 
rstype_t
 *
j
, 
tmp
 = *
i
;

633 for (
j
 = 
i
; j > 
s
 && 
	`rskey
(
tmp
) < rskey(*(j-1)); --j)

634 *
j
 = *(j - 1);

635 *
j
 = 
tmp
;

638 
	}
}

673 void 
	$radix_sort
(unsigned *
array
, int 
offset
, int 
end
, int 
shift
) {

674 int 
x
, 
y
, 
value
, 
temp
;

675 int 
last
[256] = { 0 }, 
pointer
[256];

677 for (
x
=
offset
; x<
end
; ++x) {

678 ++
last
[(
array
[
x
] >> 
shift
) & 0xFF];

681 
last
[0] += 
offset
;

682 
pointer
[0] = 
offset
;

683 for (
x
=1; x<256; ++x) {

684 
pointer
[
x
] = 
last
[x-1];

685 
last
[
x
] += last[x-1];

688 for (
x
=0; x<256; ++x) {

689 while (
pointer
[
x
] != 
last
[x]) {

690 
value
 = 
array
[
pointer
[
x
]];

691 
y
 = (
value
 >> 
shift
) & 0xFF;

692 while (
x
 != 
y
) {

693 
temp
 = 
array
[
pointer
[
y
]];

694 
array
[
pointer
[
y
]++] = 
value
;

695 
value
 = 
temp
;

696 
y
 = (
value
 >> 
shift
) & 0xFF;

698 
array
[
pointer
[
x
]++] = 
value
;

702 if (
shift
 > 0) {

703 
shift
 -= 8;

704 for (
x
=0; x<256; ++x) {

705 
temp
 = 
x
 > 0 ? 
pointer
[x] - pointer[x-1] : pointer[0] - 
offset
;

706 if (
temp
 > 64) {

707 
	`radix_sort
(
array
, 
pointer
[
x
] - 
temp
, pointer[x], 
shift
);

708 } else if (
temp
 > 1) 
	`rs_insertsort
(
array
 + 
pointer
[
x
] - temp, array + pointer[x]);

711 
	}
}

716 
	gtemplate
< 
class
 
	g_Type
, unsigned long 
	gPowerOfTwoRadix
, unsigned long 
	gLog2ofPowerOfTwoRadix
, long 
	gThreshold
 >

717 
inline
 void 
	$_RadixSort_Unsigned_PowerOf2Radix_1
( 
_Type
* 
a
, long 
last
, _Type 
bitMask
, unsigned long 
shiftRightAmount
 )

719 const unsigned long 
numberOfBins
 = 
PowerOfTwoRadix
;

720 unsigned long 
count
[ 
numberOfBins
 ];

721 for( unsigned long 
i
 = 0; i < 
numberOfBins
; i++ )

722 
count
[ 
i
 ] = 0;

723 for ( long 
_current
 = 0; _current <= 
last
; _current++ )

725 unsigned long 
digit
 = (unsigned long)(( 
a
[ 
_current
 ] & 
bitMask
 ) >> 
shiftRightAmount
 );

726 
count
[ 
digit
 ]++;

728 long 
startOfBin
[ 
numberOfBins
 ], 
endOfBin
[ numberOfBins ], 
nextBin
;

729 
startOfBin
[ 0 ] = 
endOfBin
[ 0 ] = 
nextBin
 = 0;

730 for( unsigned long 
i
 = 1; i < 
numberOfBins
; i++ )

731 
startOfBin
[ 
i
 ] = 
endOfBin
[ i ] = startOfBin[ i - 1 ] + 
count
[ i - 1 ];

732 for ( long 
_current
 = 0; _current <= 
last
; )

734 unsigned long 
digit
;

735 
_Type
 
tmp
 = 
a
[ 
_current
 ];

736 while ( 
true
 ) {

737 
digit
 = (unsigned long)(( 
tmp
 & 
bitMask
 ) >> 
shiftRightAmount
 );

738 if ( 
endOfBin
[ 
digit
 ] == 
_current
 )

740 
_Type
 
tmp2
;

742 
tmp2
 = 
a
[
endOfBin
[
digit
]]; a[endOfBin[digit]] = 
tmp
; tmp = tmp2;

743 
endOfBin
[ 
digit
 ]++;

745 
a
[ 
_current
 ] = 
tmp
;

746 
endOfBin
[ 
digit
 ]++;

747 
_current
++;

748 while( 
_current
 >= 
startOfBin
[ 
nextBin
 ] && nextBin < 
numberOfBins
 )

749 
nextBin
++;

750 while( 
endOfBin
[ 
nextBin
 - 1 ] == 
startOfBin
[ nextBin ] && nextBin < 
numberOfBins
 )

751 
nextBin
++;

752 if ( 
_current
 < 
endOfBin
[ 
nextBin
 - 1 ] )

753 
_current
 = 
endOfBin
[ 
nextBin
 - 1 ];

755 
bitMask
 >>= 
Log2ofPowerOfTwoRadix
;

756 if ( 
bitMask
 != 0 )

758 if ( 
shiftRightAmount
 >= 
Log2ofPowerOfTwoRadix
 ) shiftRightAmount -= Log2ofPowerOfTwoRadix;

759 else 
shiftRightAmount
 = 0;

760 for( unsigned long 
i
 = 0; i < 
numberOfBins
; i++ )

762 long 
numberOfElements
 = 
endOfBin
[ 
i
 ] - 
startOfBin
[ i ];

763 if ( 
numberOfElements
 >= 
Threshold
 )

764 
_RadixSort_Unsigned_PowerOf2Radix_1
< 
_Type
, 
PowerOfTwoRadix
, 
Log2ofPowerOfTwoRadix
, 
Threshold
 >( &
a
[ 
startOfBin
[ 
i
 ]], 
numberOfElements
 - 1, 
bitMask
, 
shiftRightAmount
 );

765 else if ( 
numberOfElements
 >= 2 )

766 
	`rs_insertsort
(&
a
[ 
startOfBin
[ 
i
 ]], &a[ 
endOfBin
[ i ]]);

769 
	}
}

770 
inline
 void 
	$RadixSortInPlace_HybridUnsigned_Radix256
( unsigned* 
a
, unsigned long 
a_size
 )

772 if ( 
a_size
 < 2 ) return;

773 unsigned long 
bitMask
 = 0xFF000000;

774 unsigned long 
shiftRightAmount
 = 24;

775 if ( 
a_size
 >= 32 )

776 
_RadixSort_Unsigned_PowerOf2Radix_1
<unsigned, 256, 8, 32>(
a
, 
a_size
 - 1, 
bitMask
, 
shiftRightAmount
 );

778 
	`rs_insertsort
(
a
, a + 
a_size
);

779 
	}
}

781 struct 
	sintcmp_t
 {

782 
inline
 int 
operator
() (int 
	ma
, int 
	mb
) const {

783 return 
	ma
 < 
	mb
? -1 : 
a
 > 
b
? 1 : 0;

787 int 
	$compare_int
(int 
a
, int 
b
)

789 return 
a
 < 
b
? -1 : a > b? 1 : 0;

790 
	}
}

791 int 
	$compare
(const void *
a
, const void *
b
)

793 return *((int*)
a
) - *((int*)
b
);

794 
	}
}

796 int 
	$main
(int 
argc
, char *
argv
[])

798 int 
i
, 
N
 = 50000000;

799 int *
array
, *
temp
;

800 
clock_t
 
t1
, 
t2
;

801 if (
argc
 == 1) 
	`fprintf
(
stderr
, "Usage: %s [%d]\n", 
argv
[0], 
N
);

802 if (
argc
 > 1) 
N
 = 
	`atoi
(
argv
[1]);

803 
temp
 = (int*)
	`malloc
(sizeof(int) * 
N
);

804 
array
 = (int*)
	`malloc
(sizeof(int) * 
N
);

806 
	`srand48
(11);

807 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

808 
t1
 = 
	`clock
();

809 
	`rs_sort
((unsigned*)
array
, (unsigned*)array + 
N
, 8, 24);

810 
t2
 = 
	`clock
();

811 
	`fprintf
(
stderr
, "radix sort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

812 for (
i
 = 0; i < 
N
-1; ++i) {

813 if (
array
[
i
] > array[i+1]) {

814 
	`fprintf
(
stderr
, "Bug in radix sort!\n");

815 
	`exit
(1);

818 
t1
 = 
	`clock
();

819 
	`rs_sort
((unsigned*)
array
, (unsigned*)array + 
N
, 8, 24);

820 
t2
 = 
	`clock
();

821 
	`fprintf
(
stderr
, "radix sort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

823 
	`srand48
(11);

824 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

825 
t1
 = 
	`clock
();

826 
	`RadixSortInPlace_HybridUnsigned_Radix256
((unsigned*)
array
, 
N
);

828 
t2
 = 
	`clock
();

829 
	`fprintf
(
stderr
, "vd's radix sort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

830 for (
i
 = 0; i < 
N
-1; ++i) {

831 if (
array
[
i
] > array[i+1]) {

832 
	`fprintf
(
stderr
, "Bug in radix sort!\n");

833 
	`exit
(1);

836 
t1
 = 
	`clock
();

837 
	`RadixSortInPlace_HybridUnsigned_Radix256
((unsigned*)
array
, 
N
);

839 
t2
 = 
	`clock
();

840 
	`fprintf
(
stderr
, "vd's radix sort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

842 
	`srand48
(11);

843 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

844 
t1
 = 
	`clock
();

845 
	`sort
(
array
, array+
N
);

846 
t2
 = 
	`clock
();

847 
	`fprintf
(
stderr
, "STL introsort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

848 
t1
 = 
	`clock
();

849 
	`sort
(
array
, array+
N
);

850 
t2
 = 
	`clock
();

851 
	`fprintf
(
stderr
, "STL introsort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

853 
	`srand48
(11);

854 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

855 
t1
 = 
	`clock
();

856 
	`stable_sort
(
array
, array+
N
);

857 
t2
 = 
	`clock
();

858 
	`fprintf
(
stderr
, "STL stablesort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

859 
t1
 = 
	`clock
();

860 
	`stable_sort
(
array
, array+
N
);

861 
t2
 = 
	`clock
();

862 
	`fprintf
(
stderr
, "STL stablesort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

864 
	`srand48
(11);

865 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

866 
t1
 = 
	`clock
();

867 
	`make_heap
(
array
, array+
N
);

868 
	`sort_heap
(
array
, array+
N
);

869 
t2
 = 
	`clock
();

870 
	`fprintf
(
stderr
, "STL heapsort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

871 for (
i
 = 0; i < 
N
-1; ++i) {

872 if (
array
[
i
] > array[i+1]) {

873 
	`fprintf
(
stderr
, "Bug in heap_sort!\n");

874 
	`exit
(1);

877 
t1
 = 
	`clock
();

878 
	`make_heap
(
array
, array+
N
);

879 
	`sort_heap
(
array
, array+
N
);

880 
t2
 = 
	`clock
();

881 
	`fprintf
(
stderr
, "STL heapsort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

883 
	`srand48
(11);

884 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

885 
t1
 = 
	`clock
();

886 
	`ks_combsort
(int, 
N
, 
array
);

887 
t2
 = 
	`clock
();

888 
	`fprintf
(
stderr
, "combsort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

889 for (
i
 = 0; i < 
N
-1; ++i) {

890 if (
array
[
i
] > array[i+1]) {

891 
	`fprintf
(
stderr
, "Bug in combsort!\n");

892 
	`exit
(1);

896 
	`srand48
(11);

897 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

898 
t1
 = 
	`clock
();

899 
	`qsort
(
array
, 
N
, sizeof(int), 
compare
);

900 
t2
 = 
	`clock
();

901 
	`fprintf
(
stderr
, "libc qsort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

903 
	`srand48
(11);

904 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

905 
t1
 = 
	`clock
();

906 
	`ks_introsort
(int, 
N
, 
array
);

907 
t2
 = 
	`clock
();

908 
	`fprintf
(
stderr
, "my introsort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

909 for (
i
 = 0; i < 
N
-1; ++i) {

910 if (
array
[
i
] > array[i+1]) {

911 
	`fprintf
(
stderr
, "Bug in intro_sort!\n");

912 
	`exit
(1);

915 
t1
 = 
	`clock
();

916 
	`ks_introsort
(int, 
N
, 
array
);

917 
t2
 = 
	`clock
();

918 
	`fprintf
(
stderr
, "introsort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

920 
	`srand48
(11);

921 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

922 
t1
 = 
	`clock
();

923 
	`ks_mergesort
(int, 
N
, 
array
, 0);

924 
t2
 = 
	`clock
();

925 
	`fprintf
(
stderr
, "iterative mergesort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

926 for (
i
 = 0; i < 
N
-1; ++i) {

927 if (
array
[
i
] > array[i+1]) {

928 
	`fprintf
(
stderr
, "Bug in merge_sort!\n");

929 
	`exit
(1);

932 
t1
 = 
	`clock
();

933 
	`ks_mergesort
(int, 
N
, 
array
, 0);

934 
t2
 = 
	`clock
();

935 
	`fprintf
(
stderr
, "iterative mergesort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

937 
	`srand48
(11);

938 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

939 
t1
 = 
	`clock
();

940 
	`ks_heapmake
(int, 
N
, 
array
);

941 
	`ks_heapsort
(int, 
N
, 
array
);

942 
t2
 = 
	`clock
();

943 
	`fprintf
(
stderr
, "my heapsort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

944 for (
i
 = 0; i < 
N
-1; ++i) {

945 if (
array
[
i
] > array[i+1]) {

946 
	`fprintf
(
stderr
, "Bug in heap_sort!\n");

947 
	`exit
(1);

950 
t1
 = 
	`clock
();

951 
	`ks_heapmake
(int, 
N
, 
array
);

952 
	`ks_heapsort
(int, 
N
, 
array
);

953 
t2
 = 
	`clock
();

954 
	`fprintf
(
stderr
, "heapsort (sorted): %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

956 
	`srand48
(11);

957 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

958 
t1
 = 
	`clock
();

959 
	`heapSort
(
array
, 
N
);

960 
t2
 = 
	`clock
();

961 
	`fprintf
(
stderr
, "Paul's heapsort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

962 for (
i
 = 0; i < 
N
-1; ++i) {

963 if (
array
[
i
] > array[i+1]) {

964 
	`fprintf
(
stderr
, "Bug in intro_sort!\n");

965 
	`exit
(1);

969 
	`srand48
(11);

970 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

971 
t1
 = 
	`clock
();

972 
	`quickSort
(
array
, 
N
);

973 
t2
 = 
	`clock
();

974 
	`fprintf
(
stderr
, "Paul's quicksort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

975 for (
i
 = 0; i < 
N
-1; ++i) {

976 if (
array
[
i
] > array[i+1]) {

977 
	`fprintf
(
stderr
, "Bug in intro_sort!\n");

978 
	`exit
(1);

982 
	`srand48
(11);

983 for (
i
 = 0; i < 
N
; ++i) 
array
[i] = (int)
	`lrand48
();

984 
t1
 = 
	`clock
();

985 
	`mergeSort
(
array
, 
N
);

986 
t2
 = 
	`clock
();

987 
	`fprintf
(
stderr
, "Paul's mergesort: %.3lf\n", (double)(
t2
-
t1
)/
CLOCKS_PER_SEC
);

988 for (
i
 = 0; i < 
N
-1; ++i) {

989 if (
array
[
i
] > array[i+1]) {

990 
	`fprintf
(
stderr
, "Bug in intro_sort!\n");

991 
	`exit
(1);

995 
	`free
(
array
); free(
temp
);

997 
	}
}

	@deps/klib/test/kstring_bench.c

1 #include 
	~<stdio.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<time.h
>

4 #include 
	~"kstring.h
"

6 #define 
	#N
 10000000

	)

8 int 
	$main
()

10 int 
i
;

11 
clock_t
 
t
;

12 
kstring_t
 
s
, 
s2
;

13 
	`srand48
(11);

14 
s
.
l
 = s.
m
 = 0; s.s = 0;

15 
t
 = 
	`clock
();

16 for (
i
 = 0; i < 
N
; ++i) {

17 int 
x
 = 
	`lrand48
();

18 
s
.
l
 = 0;

19 
	`kputw
(
x
, &
s
);

21 
	`fprintf
(
stderr
, "kputw: %lf\n", (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

22 
	`srand48
(11);

23 
t
 = 
	`clock
();

24 for (
i
 = 0; i < 
N
; ++i) {

25 int 
x
 = 
	`lrand48
();

26 
s
.
l
 = 0;

27 
	`ksprintf
(&
s
, "%d", 
x
);

29 
	`fprintf
(
stderr
, "ksprintf: %lf\n", (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

31 
	`srand48
(11);

32 
s2
.
l
 = s2.
m
 = 0; s2.
s
 = 0;

33 
t
 = 
	`clock
();

34 for (
i
 = 0; i < 
N
; ++i) {

35 int 
x
 = 
	`lrand48
();

36 
s2
.
l
 = 
s
.l = 0;

37 
	`kputw
(
x
, &
s2
);

38 
	`kputs
(
s2
.
s
, &s);

40 
	`fprintf
(
stderr
, "kputw+kputs: %lf\n", (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

41 
	`srand48
(11);

42 
t
 = 
	`clock
();

43 for (
i
 = 0; i < 
N
; ++i) {

44 int 
x
 = 
	`lrand48
();

45 
s2
.
l
 = 
s
.l = 0;

46 
	`kputw
(
x
, &
s2
);

47 
	`ksprintf
(&
s
, "%s", 
s2
.s);

49 
	`fprintf
(
stderr
, "kputw+ksprintf: %lf\n", (double)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

51 
	}
}

	@deps/klib/test/kstring_bench2.c

1 #include 
	~<string.h
>

2 #include 
	~<stdio.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<time.h
>

5 #include 
	~"kstring.h
"

7 #ifdef 
__APPLE__


8 #define 
	#HAVE_STRNSTR


	)

11 #ifdef 
__linux__


12 #define 
	#HAVE_MEMMEM


	)

15 static int 
	gstr_len
 = 1024*1024*128;

16 static int 
	gpat_len
 = 30;

17 static int 
	galphabet
 = 2;

18 static int 
	grepeat
 = 50;

20 char *
	$gen_data
(int 
len
, int 
a
)

22 char *
data
;

23 int 
i
;

24 long 
x
;

25 
	`srand48
(11);

26 
data
 = 
	`malloc
(
len
);

27 for (
i
 = 0; i < 
len
; ++i)

28 
data
[
i
] = (int)(
a
 * 
	`drand48
()) + '!';

29 
data
[
str_len
 - 1] = 0;

30 return 
data
;

31 
	}
}

33 char *
	$BoyerMoore
( unsigned char *
data
, unsigned int 
dataLength
, unsigned char *
string
, unsigned int 
strLength
 )

35 unsigned int 
skipTable
[256], 
i
;

36 unsigned char *
search
;

37 register unsigned char 
lastChar
;

39 if (
strLength
 == 0)

40 return 
NULL
;

42 for (
i
 = 0; i < 256; i++)

43 
skipTable
[
i
] = 
strLength
;

44 
search
 = 
string
;

45 
i
 = --
strLength
;

47 
skipTable
[*
search
++] = 
i
;

48 } while (
i
--);

49 
lastChar
 = *--
search
;

50 
search
 = 
data
 + 
strLength
;

51 
dataLength
 -= 
strLength
+(strLength-1);

52 while ((int)
dataLength
 > 0 ) {

53 unsigned int 
skip
;

54 
skip
 = 
skipTable
[*
search
];

55 
search
 += 
skip
;

56 
dataLength
 -= 
skip
;

57 
skip
 = 
skipTable
[*
search
];

58 
search
 += 
skip
;

59 
dataLength
 -= 
skip
;

60 
skip
 = 
skipTable
[*
search
];

61 if (*
search
 != 
lastChar
) {

62 
search
 += 
skip
;

63 
dataLength
 -= 
skip
;

66 
i
 = 
strLength
;

68 if (
i
-- == 0) return 
search
;

69 } while (*--
search
 == 
string
[
i
]);

70 
search
 += (
strLength
 - 
i
 + 1);

71 
dataLength
--;

73 return 
NULL
;

74 
	}
}

76 int 
	$main
()

78 char *
data
;

79 int 
i
;

80 
clock_t
 
t
;

81 
t
 = 
	`clock
();

82 
data
 = 
	`gen_data
(
str_len
, 
alphabet
);

83 
	`fprintf
(
stderr
, "Generate data in %.3f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

85 
t
 = 
	`clock
(); 
	`srand48
(1331);

86 for (
i
 = 0; i < 
repeat
; ++i) {

87 int 
y
 = 
	`lrand48
() % (
str_len
 - 
pat_len
);

88 char *
ret
;

89 
ret
 = 
	`kmemmem
(
data
, 
str_len
, data + 
y
, 
pat_len
, 0);

92 
	`fprintf
(
stderr
, "Search patterns in %.3f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

95 
t
 = 
	`clock
(); 
	`srand48
(1331);

96 for (
i
 = 0; i < 
repeat
; ++i) {

97 int 
y
 = 
	`lrand48
() % (
str_len
 - 
pat_len
);

98 char *
ret
;

99 
ret
 = 
	`BoyerMoore
(
data
, 
str_len
, data + 
y
, 
pat_len
);

102 
	`fprintf
(
stderr
, "Search patterns in %.3f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

104 #ifdef 
HAVE_STRNSTR


106 char *
tmp
;

107 
t
 = 
	`clock
(); 
	`srand48
(1331);

108 
tmp
 = 
	`calloc
(
pat_len
+1, 1);

109 for (
i
 = 0; i < 
repeat
; ++i) {

110 int 
y
 = 
	`lrand48
() % (
str_len
 - 
pat_len
);

111 char *
ret
;

112 
	`memcpy
(
tmp
, 
data
 + 
y
, 
pat_len
);

113 
ret
 = 
	`strnstr
(
data
, 
tmp
, 
str_len
);

115 
	`fprintf
(
stderr
, "Search patterns in %.3f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

118 #ifdef 
HAVE_MEMMEM


120 
t
 = 
	`clock
(); 
	`srand48
(1331);

121 for (
i
 = 0; i < 
repeat
; ++i) {

122 int 
y
 = 
	`lrand48
() % (
str_len
 - 
pat_len
);

123 char *
ret
;

124 
ret
 = 
	`memmem
(
data
, 
str_len
, data + 
y
, 
pat_len
);

127 
	`fprintf
(
stderr
, "Search patterns in %.3f sec\n", (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

131 
	}
}

	@deps/klib/test/kstring_test.c

1 #include 
	~<limits.h
>

2 #include 
	~<stdarg.h
>

3 #include 
	~<stdio.h
>

4 #include 
	~<stdlib.h
>

5 #include 
	~<string.h
>

7 #include 
	~"kstring.h
"

9 int 
	gnfail
 = 0;

11 void 
	$check
(const char *
what
, const 
kstring_t
 *
ks
, const char *
correct
)

13 if (
ks
->
l
 != 
	`strlen
(
correct
) || 
	`strcmp
(ks->
s
, correct) != 0) {

14 
	`fprintf
(
stderr
, "%s produced \"%.*s\" (\"%s\" is correct)\tFAIL\n", 
what
, (int)(
ks
->
l
), ks->
s
, 
correct
);

15 
nfail
++;

17 
	}
}

19 void 
	$test_kputw
(
kstring_t
 *
ks
, int 
n
)

21 char 
buf
[16];

23 
ks
->
l
 = 0;

24 
	`kputw
(
n
, 
ks
);

26 
	`sprintf
(
buf
, "%d", 
n
);

27 
	`check
("kputw()", 
ks
, 
buf
);

28 
	}
}

30 void 
	$test_kputl
(
kstring_t
 *
ks
, long 
n
)

32 char 
buf
[24];

34 
ks
->
l
 = 0;

35 
	`kputl
(
n
, 
ks
);

37 
	`sprintf
(
buf
, "%ld", 
n
);

38 
	`check
("kputl()", 
ks
, 
buf
);

39 
	}
}

41 static char *
	$mem_gets
(char *
buf
, int 
buflen
, void *
vtextp
)

43 const char **
textp
 = (const char **) 
vtextp
;

45 const char *
nl
 = 
	`strchr
(*
textp
, '\n');

46 
size_t
 
n
 = 
nl
? nl - *
textp
 + 1 : 
	`strlen
(*textp);

48 if (
n
 == 0) return 
NULL
;

50 if (
n
 > 
buflen
-1) n = buflen-1;

51 
	`memcpy
(
buf
, *
textp
, 
n
);

52 
buf
[
n
] = '\0';

53 *
textp
 += 
n
;

54 return 
buf
;

55 
	}
}

57 void 
	$test_kgetline
(
kstring_t
 *
ks
, const char *
text
, ...)

59 const char *
exp
;

60 
va_list
 
arg
;

62 
	`va_start
(
arg
, 
text
);

63 while ((
exp
 = 
	`va_arg
(
arg
, const char *)) != 
NULL
) {

64 
ks
->
l
 = 0;

65 if (
	`kgetline
(
ks
, 
mem_gets
, &
text
) != 0) 
	`kputs
("EOF", ks);

66 
	`check
("kgetline()", 
ks
, 
exp
);

68 
	`va_end
(
arg
);

70 
ks
->
l
 = 0;

71 if (
	`kgetline
(
ks
, 
mem_gets
, &
text
) == 0) 
	`check
("kgetline()", ks, "EOF");

72 
	}
}

74 int 
	$main
(int 
argc
, char **
argv
)

76 
kstring_t
 
ks
;

78 
ks
.
l
 = ks.
m
 = 0;

79 
ks
.
s
 = 
NULL
;

81 
	`test_kputw
(&
ks
, 0);

82 
	`test_kputw
(&
ks
, 1);

83 
	`test_kputw
(&
ks
, 37);

84 
	`test_kputw
(&
ks
, 12345);

85 
	`test_kputw
(&
ks
, -12345);

86 
	`test_kputw
(&
ks
, 
INT_MAX
);

87 
	`test_kputw
(&
ks
, -
INT_MAX
);

88 
	`test_kputw
(&
ks
, 
INT_MIN
);

90 
	`test_kputl
(&
ks
, 0);

91 
	`test_kputl
(&
ks
, 1);

92 
	`test_kputl
(&
ks
, 37);

93 
	`test_kputl
(&
ks
, 12345);

94 
	`test_kputl
(&
ks
, -12345);

95 
	`test_kputl
(&
ks
, 
INT_MAX
);

96 
	`test_kputl
(&
ks
, -
INT_MAX
);

97 
	`test_kputl
(&
ks
, 
INT_MIN
);

98 
	`test_kputl
(&
ks
, 
LONG_MAX
);

99 
	`test_kputl
(&
ks
, -
LONG_MAX
);

100 
	`test_kputl
(&
ks
, 
LONG_MIN
);

102 
	`test_kgetline
(&
ks
, "", 
NULL
);

103 
	`test_kgetline
(&
ks
, "apple", "apple", 
NULL
);

104 
	`test_kgetline
(&
ks
, "banana\n", "banana", 
NULL
);

105 
	`test_kgetline
(&
ks
, "carrot\r\n", "carrot", 
NULL
);

106 
	`test_kgetline
(&
ks
, "\n", "", 
NULL
);

107 
	`test_kgetline
(&
ks
, "\n\n", "", "", 
NULL
);

108 
	`test_kgetline
(&
ks
, "foo\nbar", "foo", "bar", 
NULL
);

109 
	`test_kgetline
(&
ks
, "foo\nbar\n", "foo", "bar", 
NULL
);

110 
	`test_kgetline
(&
ks
,

113 "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 
NULL
);

115 if (
argc
 > 1) {

116 
FILE
 *
f
 = 
	`fopen
(
argv
[1], "r");

117 if (
f
) {

118 for (
ks
.
l
 = 0; 
	`kgetline
(&ks, (
kgets_func
 *)
fgets
, 
f
) == 0; ks.l = 0)

119 
	`puts
(
ks
.
s
);

120 
	`fclose
(
f
);

124 
	`free
(
ks
.
s
);

126 if (
nfail
 > 0) {

127 
	`fprintf
(
stderr
, "Total failures: %d\n", 
nfail
);

128 return 
EXIT_FAILURE
;

131 return 
EXIT_SUCCESS
;

132 
	}
}

	@deps/klib/test/kthread_test.c

1 #include 
	~<stdio.h
>

2 #include 
	~<assert.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<pthread.h
>

5 #if 
HAVE_CILK


6 #include 
	~<cilk/cilk.h
>

7 #include 
	~<cilk/cilk_api.h
>

11 int 
	mmax_iter
, 
	mw
, 
	mh
;

12 double 
	mxmin
, 
	mxmax
, 
	mymin
, 
	mymax
;

13 int *
	mk
;

14 } 
	tglobal_t
;

16 static void 
	$compute
(void *
_g
, int 
i
, int 
tid
)

18 
global_t
 *
g
 = (global_t*)
_g
;

19 double 
x
, 
x0
 = 
g
->
xmin
 + (g->
xmax
 - g->xmin) * (
i
%g->
w
) / g->w;

20 double 
y
, 
y0
 = 
g
->
ymin
 + (g->
ymax
 - g->ymin) * (
i
/g->
w
) / g->
h
;

21 int 
k
;

23 
	`assert
(
g
->
k
[
i
] < 0);

24 
x
 = 
x0
, 
y
 = 
y0
;

25 for (
k
 = 0; k < 
g
->
max_iter
; ++k) {

26 double 
z
 = 
x
 * 
y
;

27 
x
 *= x; 
y
 *= y;

28 if (
x
 + 
y
 >= 4) break;

29 
x
 = x - 
y
 + 
x0
;

30 
y
 = 
z
 + z + 
y0
;

32 
g
->
k
[
i
] = k;

33 
	}
}

35 void 
kt_for
(int 
n_threads
, int 
n_items
, void (*
func
)(void*,int,int), void *
data
);

37 int 
	$main
(int 
argc
, char *
argv
[])

39 int 
i
, 
tmp
, 
tot
, 
type
 = 0, 
n_threads
 = 2;

40 
global_t
 
global
 = { 10240*100, 800, 600, -2., -1.2, -1.2, 1.2, 0 };

43 if (
argc
 > 1) {

44 
type
 = 
argv
[1][0] == 'o'? 2 : argv[1][0] == 'c'? 3 : argv[1][0] == 'n'? 1 : 0;

45 if (
argv
[1][0] >= '0' && argv[1][0] <= '9')

46 
n_threads
 = 
	`atoi
(
argv
[1]);

48 
	`fprintf
(
stderr
, "Usage: ./a.out [openmp | cilk | #threads]\n");

50 
tot
 = 
global
.
w
 * global.
h
;

51 
global
.
k
 = 
	`calloc
(
tot
, sizeof(int));

52 for (
i
 = 0; i < 
tot
; ++i) 
global
.
k
[i] = -1;

53 if (
type
 == 0) {

54 
	`kt_for
(
n_threads
, 
tot
, 
compute
, &
global
);

55 } else if (
type
 == 2) {

56 #pragma 
omp
 
parallel
 for

57 for (
i
 = 0; i < 
tot
; ++i)

58 
	`compute
(&
global
, 
i
, 0);

59 } else if (
type
 == 3) {

60 #if 
HAVE_CILK


61 
	`cilk_for
 (
i
 = 0; i < 
tot
; ++i)

62 
	`compute
(&
global
, 
i
, 0);

65 for (
i
 = 
tmp
 = 0; i < 
tot
; ++i) tmp += (
global
.
k
[i] < 0);

66 
	`free
(
global
.
k
);

67 
	`assert
(
tmp
 == 0);

69 
	}
}

	@deps/klib/test/kthread_test2.c

1 #include 
	~<stdio.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<string.h
>

4 #include 
	~<assert.h
>

6 void 
kt_for
(int 
n_threads
, void (*
func
)(void*,long,int), void *
data
, long 
n
);

7 void 
	`kt_pipeline
(int 
n_threads
, void *(*
func
)(void*, int, void*), void *
shared_data
, int 
n_steps
);

10 
FILE
 *
fp
;

11 int 
max_lines
, 
buf_size
, 
n_threads
;

12 char *
buf
;

13 } 
	tpipeline_t
;

16 int 
n_lines
;

17 char **
lines
;

18 } 
	tstep_t
;

20 static void 
	$worker_for
(void *
_data
, long 
i
, int 
tid
)

22 
step_t
 *
step
 = (step_t*)
_data
;

23 char *
s
 = 
step
->
lines
[
i
];

24 int 
t
, 
l
, 
j
;

25 
l
 = 
	`strlen
(
s
) - 1;

26 
	`assert
(
s
[
l
] == '\n');

27 for (
j
 = 0; j < 
l
>>1; ++j)

28 
t
 = 
s
[
j
], s[j] = s[
l
 - 1 - j], s[l - 1 - j] = t;

29 
	}
}

31 static void *
	$worker_pipeline
(void *
shared
, int 
step
, void *
in
)

33 
pipeline_t
 *
p
 = (pipeline_t*)
shared
;

34 if (
step
 == 0) {

35 
step_t
 *
s
;

36 
s
 = 
	`calloc
(1, sizeof(
step_t
));

37 
s
->
lines
 = 
	`calloc
(
p
->
max_lines
, sizeof(char*));

38 while (
	`fgets
(
p
->
buf
, p->
buf_size
, p->
fp
) != 0) {

39 
s
->
lines
[s->
n_lines
] = 
	`strdup
(
p
->
buf
);

40 if (++
s
->
n_lines
 >= 
p
->
max_lines
)

43 if (
s
->
n_lines
) return s;

44 } else if (
step
 == 1) {

45 
	`kt_for
(
p
->
n_threads
, 
worker_for
, 
in
, ((
step_t
*)in)->
n_lines
);

46 return 
in
;

47 } else if (
step
 == 2) {

48 
step_t
 *
s
 = (step_t*)
in
;

49 while (
s
->
n_lines
 > 0) {

50 
	`fputs
(
s
->
lines
[--s->
n_lines
], 
stdout
);

51 
	`free
(
s
->
lines
[s->
n_lines
]);

53 
	`free
(
s
->
lines
); free(s);

56 
	}
}

58 int 
	$main
(int 
argc
, char *
argv
[])

60 
pipeline_t
 
pl
;

61 int 
pl_threads
;

62 if (
argc
 == 1) {

63 
	`fprintf
(
stderr
, "Usage: reverse <in.txt> [pipeline_threads [for_threads]]\n");

66 
pl
.
fp
 = 
	`strcmp
(
argv
[1], "-")? 
	`fopen
(argv[1], "r") : 
stdin
;

67 if (
pl
.
fp
 == 0) {

68 
	`fprintf
(
stderr
, "ERROR: failed to open the input file.\n");

71 
pl_threads
 = 
argc
 > 2? 
	`atoi
(
argv
[2]) : 3;

72 
pl
.
max_lines
 = 4096;

73 
pl
.
buf_size
 = 0x10000;

74 
pl
.
n_threads
 = 
argc
 > 3? 
	`atoi
(
argv
[3]) : 1;

75 
pl
.
buf
 = 
	`calloc
(pl.
buf_size
, 1);

76 
	`kt_pipeline
(
pl_threads
, 
worker_pipeline
, &
pl
, 3);

77 
	`free
(
pl
.
buf
);

78 if (
pl
.
fp
 != 
stdin
) 
	`fclose
(pl.fp);

80 
	}
}

	@deps/klib/test/kvec_test.cc

1 #include 
	~<vector
>

2 #include 
	~<time.h
>

3 #include 
	~<stdio.h
>

4 #include 
	~<stdlib.h
>

5 #include 
	~"kvec.h
"

7 int 
	$main
()

9 int 
M
 = 10, 
N
 = 20000000, 
i
, 
j
;

10 
clock_t
 
t
;

11 
t
 = 
	`clock
();

12 for (
i
 = 0; i < 
M
; ++i) {

13 int *
array
 = (int*)
	`malloc
(
N
 * sizeof(int));

14 for (
j
 = 0; j < 
N
; ++j) 
array
[j] = j;

15 
	`free
(
array
);

17 
	`printf
("C array, preallocated: %.3f sec\n",

18 (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

19 
t
 = 
	`clock
();

20 for (
i
 = 0; i < 
M
; ++i) {

21 int *
array
 = 0, 
max
 = 0;

22 for (
j
 = 0; j < 
N
; ++j) {

23 if (
j
 == 
max
) {

24 
max
 = !max? 1 : max << 1;

25 
array
 = (int*)
	`realloc
(array, sizeof(int)*
max
);

27 
array
[
j
] = j;

29 
	`free
(
array
);

31 
	`printf
("C array, dynamic: %.3f sec\n",

32 (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

33 
t
 = 
	`clock
();

34 for (
i
 = 0; i < 
M
; ++i) {

35 
	`kvec_t
(int) 
array
;

36 
	`kv_init
(
array
);

37 
	`kv_resize
(int, 
array
, 
N
);

38 for (
j
 = 0; j < 
N
; ++j) 
	`kv_a
(int, 
array
, j) = j;

39 
	`kv_destroy
(
array
);

41 
	`printf
("C vector, dynamic(kv_a): %.3f sec\n",

42 (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

43 
t
 = 
	`clock
();

44 for (
i
 = 0; i < 
M
; ++i) {

45 
	`kvec_t
(int) 
array
;

46 
	`kv_init
(
array
);

47 for (
j
 = 0; j < 
N
; ++j)

48 
	`kv_push
(int, 
array
, 
j
);

49 
	`kv_destroy
(
array
);

51 
	`printf
("C vector, dynamic(kv_push): %.3f sec\n",

52 (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

53 
t
 = 
	`clock
();

54 for (
i
 = 0; i < 
M
; ++i) {

55 
std
::
vector
<int> 
array
;

56 
array
.
	`reserve
(
N
);

57 for (
j
 = 0; j < 
N
; ++j) 
array
[j] = j;

59 
	`printf
("C++ vector, preallocated: %.3f sec\n",

60 (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

61 
t
 = 
	`clock
();

62 for (
i
 = 0; i < 
M
; ++i) {

63 
std
::
vector
<int> 
array
;

64 for (
j
 = 0; j < 
N
; ++j) 
array
.
	`push_back
(j);

66 
	`printf
("C++ vector, dynamic: %.3f sec\n",

67 (float)(
	`clock
() - 
t
) / 
CLOCKS_PER_SEC
);

69 
	}
}

	@deps/picotest/picotest.c

22 #ifdef 
_WINDOWS


23 #include 
	~"wincompat.h
"

25 #include 
	~<stdarg.h
>

26 #include 
	~<stdio.h
>

27 #include 
	~<string.h
>

28 #include 
	~"picotest.h
"

30 int 
	gtest_index
[32] = {1};

31 static int 
	gtest_fail
[32];

32 static int 
	gtest_level
 = 0;

34 static void 
	$indent
(void)

36 int 
i
;

37 for (
i
 = 0; i != 
test_level
; ++i)

38 
	`printf
(" ");

39 
	}
}

41 
__attribute__
((
	$format
 (
printf
, 1, 2)))

42 void 
	$note
(const char *
fmt
, ...)

44 
va_list
 
arg
;

46 
	`indent
();

47 
	`printf
("# ");

49 
	`va_start
(
arg
, 
fmt
);

50 
	`vprintf
(
fmt
, 
arg
);

51 
	`va_end
(
arg
);

53 
	`printf
("\n");

54 
	`fflush
(
stdout
);

55 
	}
}

57 
__attribute__
((
	$format
 (
printf
, 2, 3)))

58 void 
	$_ok
(int 
cond
, const char *
fmt
, ...)

60 
va_list
 
arg
;

62 if (! 
cond
)

63 
test_fail
[
test_level
] = 1;

64 
	`indent
();

66 
	`printf
("%s %d - ", 
cond
 ? "ok" : "not ok", 
test_index
[
test_level
]++);

67 
	`va_start
(
arg
, 
fmt
);

68 
	`vprintf
(
fmt
, 
arg
);

69 
	`va_end
(
arg
);

71 
	`printf
("\n");

72 
	`fflush
(
stdout
);

73 
	}
}

75 int 
	$done_testing
(void)

77 
	`indent
();

78 
	`printf
("1..%d\n", 
test_index
[
test_level
] - 1);

79 
	`fflush
(
stdout
);

80 return 
test_fail
[
test_level
];

81 
	}
}

83 void 
	$subtest
(const char *
name
, void (*
cb
)(void))

85 ++
test_level
;

87 
test_index
[
test_level
] = 1;

88 
test_fail
[
test_level
] = 0;

90 
	`note
("Subtest: %s", 
name
);

92 
	`cb
();

94 
	`done_testing
();

96 --
test_level
;

97 
	`_ok
(! 
test_fail
[
test_level
 + 1], "%s", 
name
);

98 
test_index
[
test_level
 + 1] = 0;

99 
test_fail
[
test_level
 + 1] = 0;

100 
	}
}

102 int 
	$test_is_at
(int 
index
, ...)

104 
va_list
 
arg
;

105 
	`va_start
(
arg
, 
index
);

106 
size_t
 
level
;

108 for (
level
 = 0; 
index
 == 
test_index
[level] && index != 0; ++level)

109 
index
 = 
	`va_arg
(
arg
, int);

111 
	`va_end
(
arg
);

112 return 
index
 == 
test_index
[
level
] && index == 0;

113 
	}
}

	@deps/picotest/picotest.h

22 #ifndef 
picotest_h


23 #define 
	#picotest_h


	)

25 #ifdef 
__cplusplus


29 extern int 
test_index
[32];

31 void 
note
(const char *
fmt
, ...) 
__attribute__
((
format
 (
printf
, 1, 2)));

32 void 
_ok
(int 
cond
, const char *
fmt
, ...) 
__attribute__
((
format
 (
printf
, 2, 3)));

33 #define 
	#ok
(
cond
) 
	`_ok
(cond, "%s %d", 
__FILE__
, 
__LINE__
)

	)

34 int 
done_testing
(void);

35 void 
subtest
(const char *
name
, void (*
cb
)(void));

40 int 
test_is_at
(int 
index
, ...);

42 #ifdef 
__cplusplus


	@deps/picotls/deps/cifra/extra_vecs/openssl-hash.c

1 #include 
	~<stdint.h
>

2 #include 
	~<stdio.h
>

4 #include 
	~<openssl/evp.h
>

6 #define 
	#MAX_LENGTH
 1024

	)

8 static void 
	$printhex
(const 
uint8_t
 *
buf
, 
size_t
 
len
)

10 for (
size_t
 
i
 = 0; i < 
len
; i++)

11 
	`printf
("%02x", 
buf
[
i
]);

12 
	}
}

23 static void 
	$emit_length_test
(const char *
name
, const 
EVP_MD
 *
h
, 
size_t
 
max
)

25 
EVP_MD_CTX
 
outer
, 
inner
;

26 
	`EVP_DigestInit
(&
outer
, 
h
);

27 
uint8_t
 
digest
[
EVP_MAX_MD_SIZE
];

28 unsigned int 
digestlen
;

30 for (
size_t
 
n
 = 0; n < 
max
; n++)

32 
	`EVP_DigestInit
(&
inner
, 
h
);

33 for (
size_t
 
i
 = 0; i < 
n
; i++)

35 
uint8_t
 
byte
 = 
n
 & 0xff;

36 
	`EVP_DigestUpdate
(&
inner
, &
byte
, 1);

38 
digestlen
 = sizeof 
digest
;

39 
	`EVP_DigestFinal
(&
inner
, 
digest
, &
digestlen
);

41 
	`EVP_DigestUpdate
(&
outer
, 
digest
, 
digestlen
);

44 
digestlen
 = sizeof 
digest
;

45 
	`EVP_DigestFinal
(&
outer
, 
digest
, &
digestlen
);

47 
	`printf
("%s(%zu) = ", 
name
, 
max
);

48 
	`printhex
(
digest
, (
size_t
) 
digestlen
);

49 
	`printf
("\n");

50 
	}
}

52 int 
	$main
(void)

54 
	`emit_length_test
("SHA1", 
	`EVP_sha1
(), 
MAX_LENGTH
);

55 
	`emit_length_test
("SHA224", 
	`EVP_sha224
(), 
MAX_LENGTH
);

56 
	`emit_length_test
("SHA256", 
	`EVP_sha256
(), 
MAX_LENGTH
);

57 
	`emit_length_test
("SHA384", 
	`EVP_sha384
(), 
MAX_LENGTH
);

58 
	`emit_length_test
("SHA512", 
	`EVP_sha512
(), 
MAX_LENGTH
);

60 
	}
}

	@deps/picotls/deps/cifra/shitlisp/sl-cifra.c

1 #include 
	~"handy.h
"

2 #include 
	~"dstr.h
"

3 #include 
	~"shitlisp.h
"

4 #include 
	~"aes.h
"

5 #include 
	~"sha2.h
"

6 #include 
	~"hmac.h
"

7 #include 
	~"pbkdf2.h
"

9 #include 
	~<assert.h
>

11 static 
sl_value
 * 
	$aes_block_fn
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
,

12 void (*
blockfn
)(const 
cf_aes_context
 *
ctx
,

13 const 
uint8_t
 *
in
,

14 
uint8_t
 *
out
))

16 
sl_iter
 
it
 = 
	`sl_iter_start
(
args
);

17 
sl_value
 *
key
 = 
	`sl_iter_convert
(&
it
, 
sl_preprocess_eval
, 
sl_assert_bytes
, 
tab
);

18 
sl_value
 *
block
 = 
	`sl_iter_convert
(&
it
, 
sl_preprocess_eval
, 
sl_assert_bytes
, 
tab
);

20 
sl_value
 *
ret
 = 
NULL
;

22 if (!
key
 || !
block
 ||

23 (
key
->
u
.
bytes
.
len
 != 16 && key->u.bytes.len != 24 && key->u.bytes.len != 32) ||

24 
block
->
u
.
bytes
.
len
 != 
AES_BLOCKSZ
)

26 
ret
 = 
	`sl_get_nil
();

27 goto 
x_err
;

30 
cf_aes_context
 
ctx
;

31 
	`cf_aes_init
(&
ctx
, 
key
->
u
.
bytes
.
buf
, key->u.bytes.
len
);

32 
uint8_t
 
blockout
[
AES_BLOCKSZ
];

33 
	`blockfn
(&
ctx
, 
block
->
u
.
bytes
.
buf
, 
blockout
);

34 
ret
 = 
	`sl_new_bytes
(
blockout
, 
AES_BLOCKSZ
);

35 
	`cf_aes_finish
(&
ctx
);

37 
x_err
:

38 
	`sl_decref
(
key
);

39 
	`sl_decref
(
block
);

40 return 
ret
;

41 
	}
}

43 static 
sl_value
 * 
	$aes_block_encrypt
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

45 return 
	`aes_block_fn
(
self
, 
args
, 
tab
, 
cf_aes_encrypt
);

46 
	}
}

48 static 
sl_value
 * 
	$aes_block_decrypt
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

50 return 
	`aes_block_fn
(
self
, 
args
, 
tab
, 
cf_aes_decrypt
);

51 
	}
}

54 static 
sl_value
 * 
	$hash_fn
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
, const 
cf_chash
 *
h
)

56 
sl_iter
 
it
 = 
	`sl_iter_start
(
args
);

57 
sl_value
 *
msg
 = 
	`sl_iter_convert
(&
it
, 
sl_preprocess_eval
, 
sl_assert_bytes
, 
tab
);

59 if (!
msg
)

60 return 
	`sl_get_nil
();

62 
cf_chash_ctx
 
ctx
;

63 
	`assert
(
h
->
ctxsz
 <= 
CF_CHASH_MAXCTX
);

64 
h
->
	`init
(&
ctx
);

65 
h
->
	`update
(&
ctx
, 
msg
->
u
.
bytes
.
buf
, msg->u.bytes.
len
);

66 
	`sl_decref
(
msg
);

68 
uint8_t
 
result
[
CF_MAXHASH
];

69 
	`assert
(
h
->
hashsz
 <= 
CF_MAXHASH
);

70 
h
->
	`digest
(&
ctx
, 
result
);

72 return 
	`sl_new_bytes
(
result
, 
h
->
hashsz
);

73 
	}
}

75 static 
sl_value
 * 
	$sha224
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

77 return 
	`hash_fn
(
self
, 
args
, 
tab
, &
cf_sha224
);

78 
	}
}

80 static 
sl_value
 * 
	$sha256
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

82 return 
	`hash_fn
(
self
, 
args
, 
tab
, &
cf_sha256
);

83 
	}
}

85 static 
sl_value
 * 
	$sha384
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

87 return 
	`hash_fn
(
self
, 
args
, 
tab
, &
cf_sha384
);

88 
	}
}

90 static 
sl_value
 * 
	$sha512
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

92 return 
	`hash_fn
(
self
, 
args
, 
tab
, &
cf_sha512
);

93 
	}
}

96 static 
sl_value
 * 
	$hmac_fn
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
, const 
cf_chash
 *
h
)

98 
sl_iter
 
it
 = 
	`sl_iter_start
(
args
);

99 
sl_value
 *
key
 = 
	`sl_iter_convert
(&
it
, 
sl_preprocess_eval
, 
sl_assert_bytes
, 
tab
);

100 
sl_value
 *
msg
 = 
	`sl_iter_convert
(&
it
, 
sl_preprocess_eval
, 
sl_assert_bytes
, 
tab
);

102 if (!
key
 || !
msg
)

104 
	`sl_decref
(
key
);

105 
	`sl_decref
(
msg
);

106 return 
	`sl_get_nil
();

109 
uint8_t
 
result
[
CF_MAXHASH
];

110 
	`cf_hmac
(
key
->
u
.
bytes
.
buf
, key->u.bytes.
len
,

111 
msg
->
u
.
bytes
.
buf
, msg->u.bytes.
len
,

112 
result
,

113 
h
);

115 
	`sl_decref
(
key
);

116 
	`sl_decref
(
msg
);

117 return 
	`sl_new_bytes
(
result
, 
h
->
hashsz
);

118 
	}
}

120 static 
sl_value
 * 
	$hmac_sha224
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

121 { return 
	`hmac_fn
(
self
, 
args
, 
tab
, &
cf_sha224
); 
	}
}

123 static 
sl_value
 * 
	$hmac_sha256
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

124 { return 
	`hmac_fn
(
self
, 
args
, 
tab
, &
cf_sha256
); 
	}
}

126 static 
sl_value
 * 
	$hmac_sha384
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

127 { return 
	`hmac_fn
(
self
, 
args
, 
tab
, &
cf_sha384
); 
	}
}

129 static 
sl_value
 * 
	$hmac_sha512
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

130 { return 
	`hmac_fn
(
self
, 
args
, 
tab
, &
cf_sha512
); 
	}
}

134 static 
sl_value
 * 
	$do_pbkdf2
(const 
cf_chash
 *
h
, 
sl_value
 *
pw
, sl_value *
salt
,

135 
uint32_t
 
iterations
, uint32_t 
outlen
)

137 
dstr
 
out
;

138 
	`dstr_init
(&
out
);

139 if (
	`dstr_expand
(&
out
, 
outlen
))

140 return 
NULL
;

142 
	`cf_pbkdf2_hmac
(
pw
->
u
.
bytes
.
buf
, pw->u.bytes.
len
,

143 
salt
->
u
.
bytes
.
buf
, salt->u.bytes.
len
,

144 
iterations
,

145 (
uint8_t
 *) 
out
.
start
, 
outlen
,

146 
h
);

148 
sl_value
 *
ret
 = 
	`sl_new_bytes
((
uint8_t
 *) 
out
.
start
, 
outlen
);

149 
	`dstr_free
(&
out
);

150 return 
ret
;

151 
	}
}

153 static 
sl_value
 * 
	$pbkdf2_fn
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
, const 
cf_chash
 *
h
)

155 
sl_iter
 
it
 = 
	`sl_iter_start
(
args
);

156 
sl_value
 *
pw
 = 
	`sl_iter_convert
(&
it
, 
sl_preprocess_eval
, 
sl_assert_bytes
, 
tab
);

157 
sl_value
 *
salt
 = 
	`sl_iter_convert
(&
it
, 
sl_preprocess_eval
, 
sl_assert_bytes
, 
tab
);

158 
sl_value
 *
iterations
 = 
	`sl_iter_convert
(&
it
, 
sl_preprocess_eval
, 
sl_assert_integer
, 
tab
);

159 
sl_value
 *
outlen
 = 
	`sl_iter_convert
(&
it
, 
sl_preprocess_eval
, 
sl_assert_integer
, 
tab
);

161 
sl_value
 *
ret
;

163 if (!
pw
 || !
salt
 || !
iterations
 || !
outlen
)

164 
ret
 = 
	`sl_get_nil
();

167 
	`assert
(
	`bignum_len_words
(&
iterations
->
u
.
integer
.
bn
) == 1);

168 
	`assert
(
	`bignum_len_words
(&
outlen
->
u
.
integer
.
bn
) == 1);

169 
ret
 = 
	`do_pbkdf2
(
h
, 
pw
, 
salt
,

170 
iterations
->
u
.
integer
.
bn
.
v
[0],

171 
outlen
->
u
.
integer
.
bn
.
v
[0]);

174 
	`sl_decref
(
pw
);

175 
	`sl_decref
(
salt
);

176 
	`sl_decref
(
iterations
);

177 
	`sl_decref
(
outlen
);

178 return 
ret
;

179 
	}
}

181 static 
sl_value
 * 
	$pbkdf2_sha224
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

183 return 
	`pbkdf2_fn
(
self
, 
args
, 
tab
, &
cf_sha224
);

184 
	}
}

186 static 
sl_value
 * 
	$pbkdf2_sha256
(
sl_value
 *
self
, sl_value *
args
, 
sl_symboltab
 *
tab
)

188 return 
	`pbkdf2_fn
(
self
, 
args
, 
tab
, &
cf_sha256
);

189 
	}
}

191 int 
	$SL_MODULE_ENTRY
(
sl_symboltab
 *
tab
)

193 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "aes-encrypt", 
aes_block_encrypt
));

194 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "aes-decrypt", 
aes_block_decrypt
));

195 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "sha224", 
sha224
));

196 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "sha256", 
sha256
));

197 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "sha384", 
sha384
));

198 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "sha512", 
sha512
));

199 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "hmac-sha224", 
hmac_sha224
));

200 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "hmac-sha256", 
hmac_sha256
));

201 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "hmac-sha384", 
hmac_sha384
));

202 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "hmac-sha512", 
hmac_sha512
));

203 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "pbkdf2-sha224", 
pbkdf2_sha224
));

204 
	`ER
(
	`sl_symboltab_add_name_native
(
tab
, "pbkdf2-sha256", 
pbkdf2_sha256
));

206 
	}
}

	@deps/picotls/deps/cifra/src/aes.c

15 #include 
	~<string.h
>

16 #include 
	~<stdlib.h
>

18 #include 
	~"cf_config.h
"

19 #include 
	~"aes.h
"

20 #include 
	~"handy.h
"

21 #include 
	~"bitops.h
"

22 #include 
	~"tassert.h
"

24 static const 
uint8_t
 
	gS
[256] =

48 static const 
uint8_t
 
	gRcon
[11] =

53 #ifdef 
INLINE_FUNCS


54 static 
inline
 
uint32_t
 
	$word4
(
uint8_t
 
b0
, uint8_t 
b1
, uint8_t 
b2
, uint8_t 
b3
)

56 return 
b0
 << 24 | 
b1
 << 16 | 
b2
 << 8 | 
b3
;

57 
	}
}

59 static 
inline
 
uint8_t
 
	$byte
(
uint32_t
 
w
, unsigned 
x
)

63 
x
 = 3 - x;

64 return (
w
 >> (
x
 * 8)) & 0xff;

65 
	}
}

67 static 
uint32_t
 
	$round_constant
(
uint32_t
 
i
)

69 return 
Rcon
[
i
] << 24;

70 
	}
}

72 static 
uint32_t
 
	$rot_word
(
uint32_t
 
w
)

80 return 
	`rotl32
(
w
, 8);

81 
	}
}

84 #define 
	#word4
(
a
, 
b
, 
c
, 
d
) (((
uint32_t
)(a) << 24) | ((uint32_t)(b) << 16) | ((uint32_t)(c) << 8) | (d))

	)

85 #define 
	#byte
(
w
, 
x
) ((w >> ((3 - (x)) << 3)) & 0xff)

	)

86 #define 
	#round_constant
(
i
) ((
uint32_t
)(
Rcon
[i]) << 24)

	)

87 #define 
	#rot_word
(
w
) 
	`rotl32
((w), 8)

	)

89 static 
uint32_t
 
	$sub_word
(
uint32_t
 
w
, const 
uint8_t
 *
sbox
)

91 
uint8_t
 
a
 = 
	`byte
(
w
, 0),

92 
b
 = 
	`byte
(
w
, 1),

93 
c
 = 
	`byte
(
w
, 2),

94 
d
 = 
	`byte
(
w
, 3);

95 #if 
CF_CACHE_SIDE_CHANNEL_PROTECTION


96 
	`select_u8x4
(&
a
, &
b
, &
c
, &
d
, 
sbox
, 256);

98 
a
 = 
sbox
[a];

99 
b
 = 
sbox
[b];

100 
c
 = 
sbox
[c];

101 
d
 = 
sbox
[d];

103 return 
	`word4
(
a
, 
b
, 
c
, 
d
);

104 
	}
}

106 static void 
	$aes_schedule
(
cf_aes_context
 *
ctx
, const 
uint8_t
 *
key
, 
size_t
 
nkey
)

108 
size_t
 
i
,

109 
nb
 = 
AES_BLOCKSZ
 / 4,

110 
nk
 = 
nkey
 / 4,

111 
n
 = 
nb
 * (
ctx
->
rounds
 + 1);

112 
uint32_t
 *
w
 = 
ctx
->
ks
;

115 for (
i
 = 0; i < 
nk
; i++)

117 
w
[
i
] = 
	`read32_be
(
key
 + i * 4);

120 
uint32_t
 
i_div_nk
 = 1;

121 
uint32_t
 
i_mod_nk
 = 0;

123 for (; 
i
 < 
n
; i++, 
i_mod_nk
++)

125 
uint32_t
 
temp
 = 
w
[
i
 - 1];

127 if (
i_mod_nk
 == 
nk
)

129 
i_div_nk
++;

130 
i_mod_nk
 = 0;

133 if (
i_mod_nk
 == 0)

134 
temp
 = 
	`sub_word
(
	`rot_word
(temp), 
S
) ^ 
	`round_constant
(
i_div_nk
);

135 else if (
nk
 > 6 && 
i_mod_nk
 == 4)

136 
temp
 = 
	`sub_word
(temp, 
S
);

138 
w
[
i
] = w[i - 
nk
] ^ 
temp
;

140 
	}
}

142 void 
	$cf_aes_init
(
cf_aes_context
 *
ctx
, const 
uint8_t
 *
key
, 
size_t
 
nkey
)

144 
	`memset
(
ctx
, 0, sizeof *ctx);

146 switch (
nkey
)

148 #if 
CF_AES_MAXROUNDS
 >= 
AES128_ROUNDS


150 
ctx
->
rounds
 = 
AES128_ROUNDS
;

151 
	`aes_schedule
(
ctx
, 
key
, 
nkey
);

155 #if 
CF_AES_MAXROUNDS
 >= 
AES192_ROUNDS


157 
ctx
->
rounds
 = 
AES192_ROUNDS
;

158 
	`aes_schedule
(
ctx
, 
key
, 
nkey
);

162 #if 
CF_AES_MAXROUNDS
 >= 
AES256_ROUNDS


164 
ctx
->
rounds
 = 
AES256_ROUNDS
;

165 
	`aes_schedule
(
ctx
, 
key
, 
nkey
);

170 
	`abort
();

172 
	}
}

174 static void 
	$add_round_key
(
uint32_t
 
state
[4], const uint32_t 
rk
[4])

176 
state
[0] ^= 
rk
[0];

177 
state
[1] ^= 
rk
[1];

178 
state
[2] ^= 
rk
[2];

179 
state
[3] ^= 
rk
[3];

180 
	}
}

182 static void 
	$sub_block
(
uint32_t
 
state
[4])

184 
state
[0] = 
	`sub_word
(state[0], 
S
);

185 
state
[1] = 
	`sub_word
(state[1], 
S
);

186 
state
[2] = 
	`sub_word
(state[2], 
S
);

187 
state
[3] = 
	`sub_word
(state[3], 
S
);

188 
	}
}

190 static void 
	$shift_rows
(
uint32_t
 
state
[4])

192 
uint32_t
 
u
, 
v
, 
x
, 
y
;

194 
u
 = 
	`word4
(
	`byte
(
state
[0], 0),

195 
	`byte
(
state
[1], 1),

196 
	`byte
(
state
[2], 2),

197 
	`byte
(
state
[3], 3));

199 
v
 = 
	`word4
(
	`byte
(
state
[1], 0),

200 
	`byte
(
state
[2], 1),

201 
	`byte
(
state
[3], 2),

202 
	`byte
(
state
[0], 3));

204 
x
 = 
	`word4
(
	`byte
(
state
[2], 0),

205 
	`byte
(
state
[3], 1),

206 
	`byte
(
state
[0], 2),

207 
	`byte
(
state
[1], 3));

209 
y
 = 
	`word4
(
	`byte
(
state
[3], 0),

210 
	`byte
(
state
[0], 1),

211 
	`byte
(
state
[1], 2),

212 
	`byte
(
state
[2], 3));

214 
state
[0] = 
u
;

215 
state
[1] = 
v
;

216 
state
[2] = 
x
;

217 
state
[3] = 
y
;

218 
	}
}

220 static 
uint32_t
 
	$gf_poly_mul2
(
uint32_t
 
x
)

223 ((
x
 & 0x7f7f7f7f) << 1) ^

224 (((
x
 & 0x80808080) >> 7) * 0x1b);

225 
	}
}

227 static 
uint32_t
 
	$mix_column
(
uint32_t
 
x
)

229 
uint32_t
 
x2
 = 
	`gf_poly_mul2
(
x
);

230 return 
x2
 ^ 
	`rotr32
(
x
 ^ x2, 24) ^ rotr32(x, 16) ^ rotr32(x, 8);

231 
	}
}

233 static void 
	$mix_columns
(
uint32_t
 
state
[4])

235 
state
[0] = 
	`mix_column
(state[0]);

236 
state
[1] = 
	`mix_column
(state[1]);

237 
state
[2] = 
	`mix_column
(state[2]);

238 
state
[3] = 
	`mix_column
(state[3]);

239 
	}
}

241 void 
	$cf_aes_encrypt
(const 
cf_aes_context
 *
ctx
,

242 const 
uint8_t
 
in
[
AES_BLOCKSZ
],

243 
uint8_t
 
out
[
AES_BLOCKSZ
])

245 
	`assert
(
ctx
->
rounds
 == 
AES128_ROUNDS
 ||

246 
ctx
->
rounds
 == 
AES192_ROUNDS
 ||

247 
ctx
->
rounds
 == 
AES256_ROUNDS
);

249 
uint32_t
 
state
[4] = {

250 
	`read32_be
(
in
 + 0),

251 
	`read32_be
(
in
 + 4),

252 
	`read32_be
(
in
 + 8),

253 
	`read32_be
(
in
 + 12)

256 const 
uint32_t
 *
round_keys
 = 
ctx
->
ks
;

257 
	`add_round_key
(
state
, 
round_keys
);

258 
round_keys
 += 4;

260 
uint32_t
 
round
;

261 for (
round
 = 1; round < 
ctx
->
rounds
; round++)

263 
	`sub_block
(
state
);

264 
	`shift_rows
(
state
);

265 
	`mix_columns
(
state
);

266 
	`add_round_key
(
state
, 
round_keys
);

267 
round_keys
 += 4;

270 
	`sub_block
(
state
);

271 
	`shift_rows
(
state
);

272 
	`add_round_key
(
state
, 
round_keys
);

274 
	`write32_be
(
state
[0], 
out
 + 0);

275 
	`write32_be
(
state
[1], 
out
 + 4);

276 
	`write32_be
(
state
[2], 
out
 + 8);

277 
	`write32_be
(
state
[3], 
out
 + 12);

278 
	}
}

280 #if 
CF_AES_ENCRYPT_ONLY
 == 0

281 static const 
uint8_t
 
	gS_inv
[256] =

305 static void 
	$inv_sub_block
(
uint32_t
 
state
[4])

307 
state
[0] = 
	`sub_word
(state[0], 
S_inv
);

308 
state
[1] = 
	`sub_word
(state[1], 
S_inv
);

309 
state
[2] = 
	`sub_word
(state[2], 
S_inv
);

310 
state
[3] = 
	`sub_word
(state[3], 
S_inv
);

311 
	}
}

313 static void 
	$inv_shift_rows
(
uint32_t
 
state
[4])

315 
uint32_t
 
u
, 
v
, 
x
, 
y
;

317 
u
 = 
	`word4
(
	`byte
(
state
[0], 0),

318 
	`byte
(
state
[3], 1),

319 
	`byte
(
state
[2], 2),

320 
	`byte
(
state
[1], 3));

322 
v
 = 
	`word4
(
	`byte
(
state
[1], 0),

323 
	`byte
(
state
[0], 1),

324 
	`byte
(
state
[3], 2),

325 
	`byte
(
state
[2], 3));

327 
x
 = 
	`word4
(
	`byte
(
state
[2], 0),

328 
	`byte
(
state
[1], 1),

329 
	`byte
(
state
[0], 2),

330 
	`byte
(
state
[3], 3));

332 
y
 = 
	`word4
(
	`byte
(
state
[3], 0),

333 
	`byte
(
state
[2], 1),

334 
	`byte
(
state
[1], 2),

335 
	`byte
(
state
[0], 3));

337 
state
[0] = 
u
;

338 
state
[1] = 
v
;

339 
state
[2] = 
x
;

340 
state
[3] = 
y
;

341 
	}
}

343 static 
uint32_t
 
	$inv_mix_column
(
uint32_t
 
x
)

345 
uint32_t
 
x2
 = 
	`gf_poly_mul2
(
x
),

346 
x4
 = 
	`gf_poly_mul2
(
x2
),

347 
x9
 = 
x
 ^ 
	`gf_poly_mul2
(
x4
),

348 
x11
 = 
x2
 ^ 
x9
,

349 
x13
 = 
x4
 ^ 
x9
;

351 return 
x
 ^ 
x2
 ^ 
x13
 ^ 
	`rotr32
(
x11
, 24) ^ rotr32(x13, 16) ^ rotr32(
x9
, 8);

352 
	}
}

354 static void 
	$inv_mix_columns
(
uint32_t
 
state
[4])

356 
state
[0] = 
	`inv_mix_column
(state[0]);

357 
state
[1] = 
	`inv_mix_column
(state[1]);

358 
state
[2] = 
	`inv_mix_column
(state[2]);

359 
state
[3] = 
	`inv_mix_column
(state[3]);

360 
	}
}

362 void 
	$cf_aes_decrypt
(const 
cf_aes_context
 *
ctx
,

363 const 
uint8_t
 
in
[
AES_BLOCKSZ
],

364 
uint8_t
 
out
[
AES_BLOCKSZ
])

366 
	`assert
(
ctx
->
rounds
 == 
AES128_ROUNDS
 ||

367 
ctx
->
rounds
 == 
AES192_ROUNDS
 ||

368 
ctx
->
rounds
 == 
AES256_ROUNDS
);

370 
uint32_t
 
state
[4] = {

371 
	`read32_be
(
in
 + 0),

372 
	`read32_be
(
in
 + 4),

373 
	`read32_be
(
in
 + 8),

374 
	`read32_be
(
in
 + 12)

377 const 
uint32_t
 *
round_keys
 = &
ctx
->
ks
[ctx->
rounds
 << 2];

378 
	`add_round_key
(
state
, 
round_keys
);

379 
round_keys
 -= 4;

381 
uint32_t
 
round
;

382 for (
round
 = 
ctx
->
rounds
 - 1; round != 0; round--)

384 
	`inv_shift_rows
(
state
);

385 
	`inv_sub_block
(
state
);

386 
	`add_round_key
(
state
, 
round_keys
);

387 
	`inv_mix_columns
(
state
);

388 
round_keys
 -= 4;

391 
	`inv_shift_rows
(
state
);

392 
	`inv_sub_block
(
state
);

393 
	`add_round_key
(
state
, 
round_keys
);

395 
	`write32_be
(
state
[0], 
out
 + 0);

396 
	`write32_be
(
state
[1], 
out
 + 4);

397 
	`write32_be
(
state
[2], 
out
 + 8);

398 
	`write32_be
(
state
[3], 
out
 + 12);

399 
	}
}

401 void 
	$cf_aes_decrypt
(const 
cf_aes_context
 *
ctx
,

402 const 
uint8_t
 
in
[
AES_BLOCKSZ
],

403 
uint8_t
 
out
[
AES_BLOCKSZ
])

405 
	`abort
();

406 
	}
}

409 void 
	$cf_aes_finish
(
cf_aes_context
 *
ctx
)

411 
	`mem_clean
(
ctx
, sizeof *ctx);

412 
	}
}

414 const 
cf_prp
 
	gcf_aes
 = {

415 .
blocksz
 = 
AES_BLOCKSZ
,

416 .
	gencrypt
 = (
cf_prp_block
) 
cf_aes_encrypt
,

417 .
	gdecrypt
 = (
cf_prp_block
) 
cf_aes_decrypt


	@deps/picotls/deps/cifra/src/aes.h

27 #ifndef 
AES_H


28 #define 
	#AES_H


	)

30 #include 
	~<stddef.h
>

31 #include 
	~<stdint.h
>

33 #include 
	~"prp.h
"

38 #define 
	#AES_BLOCKSZ
 16

	)

48 #define 
	#AES128_ROUNDS
 10

	)

49 #define 
	#AES192_ROUNDS
 12

	)

50 #define 
	#AES256_ROUNDS
 14

	)

60 #ifndef 
CF_AES_MAXROUNDS


61 #define 
	#CF_AES_MAXROUNDS
 
AES256_ROUNDS


	)

69 #ifndef 
CF_AES_ENCRYPT_ONLY


70 #define 
	#CF_AES_ENCRYPT_ONLY
 0

	)

97 
uint32_t
 
	mrounds
;

98 
uint32_t
 
	mks
[
AES_BLOCKSZ
 / 4 * (
CF_AES_MAXROUNDS
 + 1)];

99 } 
	tcf_aes_context
;

109 extern void 
cf_aes_init
(
cf_aes_context
 *
ctx
,

110 const 
uint8_t
 *
key
,

111 
size_t
 
nkey
);

123 extern void 
cf_aes_encrypt
(const 
cf_aes_context
 *
ctx
,

124 const 
uint8_t
 
in
[
AES_BLOCKSZ
],

125 
uint8_t
 
out
[
AES_BLOCKSZ
]);

137 extern void 
cf_aes_decrypt
(const 
cf_aes_context
 *
ctx
,

138 const 
uint8_t
 
in
[
AES_BLOCKSZ
],

139 
uint8_t
 
out
[
AES_BLOCKSZ
]);

145 extern void 
cf_aes_finish
(
cf_aes_context
 *
ctx
);

150 extern const 
cf_prp
 
cf_aes
;

	@deps/picotls/deps/cifra/src/arm/boot.c

1 #include 
	~<stdint.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<string.h
>

5 extern int 
main
(void);

8 extern 
uint32_t
 
__etext
;

9 extern 
uint32_t
 
__data_start__
, 
__data_end__
;

10 extern 
uint32_t
 
__bss_start__
, 
__bss_end__
;

11 extern 
uint32_t
 
__StackTop
;

13 #define 
	#ATTR_SECTION
(
sec
) 
	`__attribute__
 ((
	`section
 (sec)))

	)

16 void 
Reset_Handler
(void);

17 void 
SysTick_Handler
(void);

18 void 
infinite_loop
(void);

19 void 
do_nothing
(void);

21 typedef void (*
	tvector_fn
)(void);

24 
uint32_t
 *
stack_top
;

25 
vector_fn
 
reset
, 
nmi
, 
hard_fault
, 
mmu_fault
, 
bus_fault
, 
usage_fault
;

26 
vector_fn
 
reserved0
[4];

27 
vector_fn
 
svc
, 
debug_monitor
;

28 
vector_fn
 
reserved1
;

29 
vector_fn
 
pendsv
, 
systick
;

30 
vector_fn
 
irq
[128];

31 } 
	tvectors_t
;

33 #define 
	#COPY2
(
v
) v, 
	)
v

34 #define 
	#COPY4
(
v
) 
	`COPY2
(v), COPY2(v)

	)

35 #define 
	#COPY8
(
v
) 
	`COPY4
(v), COPY4(v)

	)

36 #define 
	#COPY16
(
v
) 
	`COPY8
(v), COPY8(v)

	)

37 #define 
	#COPY32
(
v
) 
	`COPY16
(v), COPY16(v)

	)

38 #define 
	#COPY64
(
v
) 
	`COPY32
(v), COPY32(v)

	)

39 #define 
	#COPY128
(
v
) 
	`COPY64
(v), COPY64(v)

	)

41 
vectors_t
 
vectors
 
	`ATTR_SECTION
(".isr_vector") = {

42 .
stack_top
 = &
__StackTop
,

43 .
reset
 = 
Reset_Handler
,

44 .
nmi
 = 
do_nothing
,

45 .
hard_fault
 = 
infinite_loop
,

46 .
mmu_fault
 = 
infinite_loop
,

47 .
bus_fault
 = 
infinite_loop
,

48 .
usage_fault
 = 
infinite_loop
,

49 .
svc
 = 
do_nothing
,

50 .
debug_monitor
 = 
do_nothing
,

51 .
pendsv
 = 
do_nothing
,

52 .
systick
 = 
SysTick_Handler
,

53 .
irq
 = { 
	`COPY128
(
do_nothing
) }

54 
	}
};

57 void 
	$Reset_Handler
(void)

60 
uint32_t
 
data_bytes
 = (&
__data_end__
 - &
__data_start__
) * 4;

61 
	`memcpy
(&
__etext
, &
__data_start__
, 
data_bytes
);

64 
uint32_t
 
bss_bytes
 = (&
__bss_end__
 - &
__bss_start__
) * 4;

65 
	`memset
(&
__bss_start__
, 0, 
bss_bytes
);

67 
	`main
();

70 
	}
}

72 void 
	$__assert_func
(const char *
file
, int 
line
, const char *
func
, const char *
expr
)

76 
	}
}

78 void 
	$infinite_loop
(void)

82 
	}
}

84 void 
	$do_nothing
(void)

86 
	}
}

88 
uint32_t
 
	gticks
 = 0;

90 void 
	$SysTick_Handler
(void)

92 
ticks
++;

93 
	}
}

95 
uint32_t
 
	$get_ticks
(void)

97 return 
ticks
;

98 
	}
}

100 void 
	$reset_ticks
(void)

102 
ticks
 = 0;

103 
	}
}

105 void *
	$memmove
(void *
vtarg
, const void *
vsrc
, 
size_t
 
len
)

107 if (
vsrc
 > 
vtarg
)

108 return 
	`memcpy
(
vtarg
, 
vsrc
, 
len
);

109 else if (
vsrc
 == 
vtarg
)

110 return 
vtarg
;

112 
uint8_t
 *
targ
 = 
vtarg
;

113 const 
uint8_t
 *
src
 = 
vsrc
;

115 for (
size_t
 
i
 = 
len
; i != 0; i++)

116 
targ
[
i
 - 1] = 
src
[i - 1];

117 return 
vtarg
;

118 
	}
}

120 int 
	$memcmp
(const void *
va
, const void *
vb
, 
size_t
 
len
)

122 const 
uint8_t
 *
a
 = 
va
, *
b
 = 
vb
;

124 for (
size_t
 
i
 = 0; i < 
len
; i++)

126 if (
a
[
i
] != 
b
[i])

127 return 
a
[
i
] < 
b
[i] ? -1 : 1;

131 
	}
}

133 
size_t
 
	$strlen
(const char *
c
)

135 
size_t
 
r
 = 0;

136 while (*
c
++) 
r
++;

137 return 
r
;

138 
	}
}

140 void 
	$abort
(void)

144 
	}
}

	@deps/picotls/deps/cifra/src/arm/ext/cutest.h

3 #ifndef 
CUTEST_H


4 #define 
	#CUTEST_H


	)

7 #define 
	#TEST_LIST
 const struct 
test__
 
test_list__
[]

	)

8 #define 
	#TEST_CHECK
(
cond
) 
	`test_check__
((cond), 
__FILE__
, 
__LINE__
, #cond)

	)

12 #include 
	~"../semihost.h
"

14 struct 
	stest__


16 const char *
	mname
;

17 void (*
	mfunc
)(void);

20 extern const struct 
test__
 
test_list__
[];

22 static void 
	$test_check__
(int 
cond
, const char *
file
, int 
line
, const char *
expr
)

24 if (
cond
)

27 
	`emit
("Failed!\n");

28 
	`emit
("File: "); emit(
file
); emit("\n");

29 
	`emit
("Line: "); 
	`emit_uint32
(
line
); emit("\n");

30 
	`emit
("Expr: "); emit(
expr
); emit("\n");

31 
	`quit_failure
();

32 
	}
}

34 static void 
	$run_test__
(const struct 
test__
 *
t
)

36 
	`emit
(" "); emit(
t
->
name
); emit(": ");

37 
t
->
	`func
();

38 
	`emit
("OK\n");

39 
	}
}

41 int 
	$main
(void)

43 
	`emit
("Running tests:\n");

45 for (const struct 
test__
 *
t
 = 
test_list__
;

46 
t
->
name
;

47 
t
++)

49 
	`run_test__
(
t
);

51 
	`emit
("Success\n");

52 
	`quit_success
();

53 
	}
}

	@deps/picotls/deps/cifra/src/arm/main.c

1 #ifndef 
TEST


2 #error 
You
 
must
 
select
 
a
 
function
 
to
 
test
.

5 #include 
	~"semihost.h
"

6 #include 
	~"aes.h
"

7 #include 
	~"hmac.h
"

8 #include 
	~"sha2.h
"

9 #include 
	~"sha3.h
"

10 #include 
	~"modes.h
"

11 #include 
	~"salsa20.h
"

12 #include 
	~"curve25519.h
"

13 #include 
	~"poly1305.h
"

14 #include 
	~"norx.h
"

15 #include 
	~"chacha20poly1305.h
"

17 #include 
	~<stdio.h
>

19 typedef void (*
	tmeasure_fn
)(void);

20 static 
uint32_t
 
bracket
;

22 static void 
	$do_nothing
(void)

24 
	}
}

26 static void 
	$stack_64w
(void)

28 volatile 
uint32_t
 
words
[64];

29 
words
[0] = 0;

30 
words
[63] = 0;

31 (void) 
words
[63];

32 
	}
}

34 static void 
	$stack_8w
(void)

36 volatile 
uint32_t
 
words
[8];

37 
words
[0] = 0;

38 
words
[7] = 0;

39 (void) 
words
[7];

40 
	}
}

42 static void 
	$hashtest_sha256
(void)

44 
uint8_t
 
hash
[
CF_SHA256_HASHSZ
];

45 
cf_sha256_context
 
ctx
;

46 
	`cf_sha256_init
(&
ctx
);

47 
	`cf_sha256_update
(&
ctx
, "", 0);

48 
	`cf_sha256_digest_final
(&
ctx
, 
hash
);

49 
	}
}

51 static void 
	$hashtest_sha512
(void)

53 
uint8_t
 
hash
[
CF_SHA512_HASHSZ
];

54 
cf_sha512_context
 
ctx
;

55 
	`cf_sha512_init
(&
ctx
);

56 
	`cf_sha512_update
(&
ctx
, "", 0);

57 
	`cf_sha512_digest_final
(&
ctx
, 
hash
);

58 
	}
}

60 static void 
	$hashtest_sha3_256
(void)

62 
uint8_t
 
hash
[
CF_SHA3_256_HASHSZ
];

63 
cf_sha3_context
 
ctx
;

64 
	`cf_sha3_256_init
(&
ctx
);

65 
	`cf_sha3_256_update
(&
ctx
, "", 0);

66 
	`cf_sha3_256_digest_final
(&
ctx
, 
hash
);

67 
	}
}

69 static void 
	$hashtest_sha3_512
(void)

71 
uint8_t
 
hash
[
CF_SHA3_512_HASHSZ
];

72 
cf_sha3_context
 
ctx
;

73 
	`cf_sha3_512_init
(&
ctx
);

74 
	`cf_sha3_512_update
(&
ctx
, "", 0);

75 
	`cf_sha3_512_digest_final
(&
ctx
, 
hash
);

76 
	}
}

78 static void 
	$aes128block_test
(void)

80 
uint8_t
 
key
[16] = { 0 }, 
block
[16] = { 0 };

81 
cf_aes_context
 
ctx
;

82 
	`cf_aes_init
(&
ctx
, 
key
, sizeof key);

83 
	`cf_aes_encrypt
(&
ctx
, 
block
, block);

84 
	}
}

86 static void 
	$aes128sched_test
(void)

88 
uint8_t
 
key
[16] = { 0 };

89 
cf_aes_context
 
ctx
;

90 
	`cf_aes_init
(&
ctx
, 
key
, sizeof key);

91 
	}
}

93 static void 
	$aes256block_test
(void)

95 
uint8_t
 
key
[32] = { 0 }, 
block
[16] = { 0 };

96 
cf_aes_context
 
ctx
;

97 
	`cf_aes_init
(&
ctx
, 
key
, sizeof key);

98 
	`cf_aes_encrypt
(&
ctx
, 
block
, block);

99 
	}
}

101 static void 
	$aes256sched_test
(void)

103 
uint8_t
 
key
[32] = { 0 };

104 
cf_aes_context
 
ctx
;

105 
	`cf_aes_init
(&
ctx
, 
key
, sizeof key);

106 
	}
}

108 static void 
	$aes128gcm_test
(void)

110 
uint8_t
 
key
[16] = { 0 };

111 
cf_aes_context
 
ctx
;

112 
	`cf_aes_init
(&
ctx
, 
key
, sizeof key);

114 
uint8_t
 
msg
[16] = { 0 };

115 
uint8_t
 
aad
[16] = { 0 };

116 
uint8_t
 
nonce
[12] = { 0 };

117 
uint8_t
 
cipher
[16] = { 0 };

118 
uint8_t
 
tag
[16] = { 0 };

120 
	`cf_gcm_encrypt
(&
cf_aes
, &
ctx
,

121 
msg
, sizeof msg,

122 
aad
, sizeof aad,

123 
nonce
, sizeof nonce,

124 
cipher
,

125 
tag
, sizeof tag);

126 
	}
}

128 static void 
	$aes128eax_test
(void)

130 
uint8_t
 
key
[16] = { 0 };

131 
cf_aes_context
 
ctx
;

132 
	`cf_aes_init
(&
ctx
, 
key
, sizeof key);

134 
uint8_t
 
msg
[16] = { 0 };

135 
uint8_t
 
aad
[16] = { 0 };

136 
uint8_t
 
nonce
[12] = { 0 };

137 
uint8_t
 
cipher
[16] = { 0 };

138 
uint8_t
 
tag
[16] = { 0 };

140 
	`cf_eax_encrypt
(&
cf_aes
, &
ctx
,

141 
msg
, sizeof msg,

142 
aad
, sizeof aad,

143 
nonce
, sizeof nonce,

144 
cipher
,

145 
tag
, sizeof tag);

146 
	}
}

148 static void 
	$aes128ccm_test
(void)

150 
uint8_t
 
key
[16] = { 0 };

151 
cf_aes_context
 
ctx
;

152 
	`cf_aes_init
(&
ctx
, 
key
, sizeof key);

154 
uint8_t
 
msg
[16] = { 0 };

155 
uint8_t
 
aad
[16] = { 0 };

156 
uint8_t
 
nonce
[11] = { 0 };

157 
uint8_t
 
cipher
[16] = { 0 };

158 
uint8_t
 
tag
[16] = { 0 };

160 
	`cf_ccm_encrypt
(&
cf_aes
, &
ctx
,

161 
msg
, sizeof msg, 4,

162 
aad
, sizeof aad,

163 
nonce
, sizeof nonce,

164 
cipher
,

165 
tag
, sizeof tag);

166 
	}
}

168 static void 
	$salsa20_test
(void)

170 
uint8_t
 
key
[32] = { 0 };

171 
uint8_t
 
nonce
[8] = { 0 };

172 
uint8_t
 
msg
[64] = { 0 };

173 
uint8_t
 
cipher
[64] = { 0 };

175 
cf_salsa20_ctx
 
ctx
;

176 
	`cf_salsa20_init
(&
ctx
, 
key
, sizeof key, 
nonce
);

177 
	`cf_salsa20_cipher
(&
ctx
, 
msg
, 
cipher
, sizeof msg);

178 
	}
}

180 static void 
	$chacha20_test
(void)

182 
uint8_t
 
key
[32] = { 0 };

183 
uint8_t
 
nonce
[8] = { 0 };

184 
uint8_t
 
msg
[64] = { 0 };

185 
uint8_t
 
cipher
[64] = { 0 };

187 
cf_chacha20_ctx
 
ctx
;

188 
	`cf_chacha20_init
(&
ctx
, 
key
, sizeof key, 
nonce
);

189 
	`cf_chacha20_cipher
(&
ctx
, 
msg
, 
cipher
, sizeof msg);

190 
	}
}

192 static void 
	$curve25519_test
(void)

194 
uint8_t
 
secret
[32] = { 1 };

195 
uint8_t
 
pubkey
[32];

196 
	`cf_curve25519_mul_base
(
pubkey
, 
secret
);

197 
	}
}

199 static const 
uint8_t
 *
	gmac_message
 = (const uint8_t *) "hello world";

200 static const 
size_t
 
	gmac_message_len
 = 11;

202 static void 
	$poly1305_test
(void)

204 
uint8_t
 
key
[32] = { 0 },

205 
nonce
[16] = { 0 },

206 
encnonce
[16],

207 
mac
[16];

209 
cf_aes_context
 
aes
;

210 
	`cf_aes_init
(&
aes
, 
key
, 16);

211 
	`cf_aes_encrypt
(&
aes
, 
nonce
, 
encnonce
);

213 
cf_poly1305
 
poly
;

214 
	`cf_poly1305_init
(&
poly
, 
key
 + 16, 
encnonce
);

215 
	`cf_poly1305_update
(&
poly
, 
mac_message
, 
mac_message_len
);

216 
	`cf_poly1305_finish
(&
poly
, 
mac
);

217 
	}
}

219 static void 
	$hmacsha256_test
(void)

221 
uint8_t
 
key
[32] = { 0 },

222 
mac
[32] = { 0 };

224 
cf_hmac_ctx
 
ctx
;

225 
	`cf_hmac_init
(&
ctx
, &
cf_sha256
, 
key
, sizeof key);

226 
	`cf_hmac_update
(&
ctx
, 
mac_message
, 
mac_message_len
);

227 
	`cf_hmac_finish
(&
ctx
, 
mac
);

228 
	}
}

230 static void 
	$norx_test
(void)

232 
uint8_t
 
key
[16] = { 0 };

233 
uint8_t
 
msg
[16] = { 0 };

234 
uint8_t
 
aad
[16] = { 0 };

235 
uint8_t
 
nonce
[8] = { 0 };

236 
uint8_t
 
cipher
[16] = { 0 };

237 
uint8_t
 
tag
[16] = { 0 };

239 
	`cf_norx32_encrypt
(
key
,

240 
nonce
,

241 
aad
, sizeof aad,

242 
msg
, sizeof msg,

243 
NULL
, 0,

244 
cipher
,

245 
tag
);

246 
	}
}

248 #ifndef 
BRACKET_MODE


249 #define 
	#AEADPERF_LEN
 1

	)

251 #define 
	#AEADPERF_LEN
 
BRACKET_END


	)

254 static 
uint8_t
 
	gaead_msg
[
AEADPERF_LEN
] = { 0 };

255 static 
uint8_t
 
	gaead_cipher
[
AEADPERF_LEN
] = { 0 };

256 static 
uint8_t
 
	gaead_aad
[16] = { 0 };

257 static 
uint8_t
 
	gaead_key
[32] = { 0 };

258 static 
uint8_t
 
	gaead_nonce
[16] = { 0 };

259 static 
uint8_t
 
	gaead_tag
[16] = { 0 };

261 static void 
	$aeadperf_norx
(void)

263 
	`cf_norx32_encrypt
(
aead_key
, 
aead_nonce
,

264 
aead_aad
, sizeof aead_aad,

265 
aead_msg
, 
bracket
,

266 
NULL
, 0,

267 
aead_cipher
, 
aead_tag
);

268 
	}
}

270 static void 
	$aeadperf_chacha20poly1305
(void)

272 
	`cf_chacha20poly1305_encrypt
(
aead_key
, 
aead_nonce
,

273 
aead_aad
, sizeof aead_aad,

274 
aead_msg
, 
bracket
,

275 
aead_cipher
, 
aead_tag
);

276 
	}
}

277 static void 
	$aeadperf_aes128gcm
(void)

279 
cf_aes_context
 
ctx
;

280 
	`cf_aes_init
(&
ctx
, 
aead_key
, 16);

282 
	`cf_gcm_encrypt
(&
cf_aes
, &
ctx
,

283 
aead_msg
, 
bracket
,

284 
aead_aad
, sizeof aead_aad,

285 
aead_nonce
, 12,

286 
aead_cipher
,

287 
aead_tag
, 16);

288 
	}
}

290 static void 
	$aeadperf_aes128ccm
(void)

292 
cf_aes_context
 
ctx
;

293 
	`cf_aes_init
(&
ctx
, 
aead_key
, 16);

295 
	`cf_ccm_encrypt
(&
cf_aes
, &
ctx
,

296 
aead_msg
, 
bracket
,

298 
aead_aad
, sizeof aead_aad,

299 
aead_nonce
, 11,

300 
aead_cipher
,

301 
aead_tag
, 16);

302 
	}
}

304 static void 
	$aeadperf_aes128eax
(void)

306 
cf_aes_context
 
ctx
;

307 
	`cf_aes_init
(&
ctx
, 
aead_key
, 16);

309 
	`cf_eax_encrypt
(&
cf_aes
, &
ctx
,

310 
aead_msg
, 
bracket
,

311 
aead_aad
, sizeof aead_aad,

312 
aead_nonce
, 12,

313 
aead_cipher
,

314 
aead_tag
, 16);

315 
	}
}

317 static void 
	$aeadperf_aes256gcm
(void)

319 
cf_aes_context
 
ctx
;

320 
	`cf_aes_init
(&
ctx
, 
aead_key
, 32);

322 
	`cf_gcm_encrypt
(&
cf_aes
, &
ctx
,

323 
aead_msg
, 
bracket
,

324 
aead_aad
, sizeof aead_aad,

325 
aead_nonce
, 12,

326 
aead_cipher
,

327 
aead_tag
, 16);

328 
	}
}

330 static void 
	$aeadperf_aes256ccm
(void)

332 
cf_aes_context
 
ctx
;

333 
	`cf_aes_init
(&
ctx
, 
aead_key
, 32);

335 
	`cf_ccm_encrypt
(&
cf_aes
, &
ctx
,

336 
aead_msg
, 
bracket
,

338 
aead_aad
, sizeof aead_aad,

339 
aead_nonce
, 11,

340 
aead_cipher
,

341 
aead_tag
, 16);

342 
	}
}

344 static void 
	$aeadperf_aes256eax
(void)

346 
cf_aes_context
 
ctx
;

347 
	`cf_aes_init
(&
ctx
, 
aead_key
, 32);

349 
	`cf_eax_encrypt
(&
cf_aes
, &
ctx
,

350 
aead_msg
, 
bracket
,

351 
aead_aad
, sizeof aead_aad,

352 
aead_nonce
, 12,

353 
aead_cipher
,

354 
aead_tag
, 16);

355 
	}
}

358 extern 
uint32_t
 
__HeapLimit
;

360 #define 
	#STACK_MAGIC
 0x57ac34df

	)

362 static 
__attribute__
((
noinline
)) void 
	$clear_stack
(void)

364 
uint32_t
 *
stack_start
 = &
__HeapLimit
;

365 
uint32_t
 
ss
 = 0, *
stack_stop
 = &ss;

366 
size_t
 
words
 = 
stack_stop
 - 
stack_start
;

367 for (
size_t
 
i
 = 0; i < 
words
; i++)

368 
stack_start
[
i
] = 
STACK_MAGIC
;

369 
	}
}

371 static 
__attribute__
((
noinline
)) 
uint32_t
 
	$measure_stack
(void)

373 
uint32_t
 *
stack_start
 = &
__HeapLimit
;

374 
uint32_t
 
ss
, *
stack_stop
 = &ss;

375 
size_t
 
words
 = 
stack_stop
 - 
stack_start
;

376 for (
size_t
 
i
 = 0; i < 
words
; i++)

377 if (
stack_start
[
i
] != 
STACK_MAGIC
)

378 return 
words
 - 
i
 + 4;

381 
	}
}

383 static void 
	$measure
(
measure_fn
 
fn
)

385 
	`clear_stack
();

386 
uint32_t
 
start_cycles
 = 
	`reset_cycles
();

387 
	`fn
();

388 
uint32_t
 
end_cycles
 = 
	`get_cycles
();

389 
uint32_t
 
stack_words
 = 
	`measure_stack
();

391 
	`emit
("cycles = ");

392 
	`emit_uint32
(
end_cycles
 - 
start_cycles
);

393 
	`emit
("\n");

394 
	`emit
("stack = ");

395 
	`emit_uint32
(
stack_words
 << 2);

396 
	`emit
("\n");

397 
	}
}

399 #define 
	#STRING_
(
x
) #x

	)

400 #define 
	#STRING
(
x
) 
	`STRING_
(x)

	)

402 int 
	$main
(void)

404 
	`emit
(
	`STRING
(
TEST
) "\n");

405 #ifdef 
BRACKET_MODE


406 for (
bracket
 = 
BRACKET_START
; bracket <= 
BRACKET_END
; bracket += 
BRACKET_STEP
)

408 
	`emit
("bracket = ");

409 
	`emit_uint32
(
bracket
);

410 
	`emit
("\n");

411 
	`measure
(
TEST
);

414 
	`measure
(
TEST
);

416 
	`quit_success
();

418 (void) 
bracket
;

419 (void) 
do_nothing
;

420 (void) 
stack_8w
;

421 (void) 
stack_64w
;

422 (void) 
hashtest_sha256
;

423 (void) 
hashtest_sha512
;

424 (void) 
hashtest_sha3_256
;

425 (void) 
hashtest_sha3_512
;

426 (void) 
aes128block_test
;

427 (void) 
aes128sched_test
;

428 (void) 
aes256block_test
;

429 (void) 
aes256sched_test
;

430 (void) 
aes128gcm_test
;

431 (void) 
aes128eax_test
;

432 (void) 
aes128ccm_test
;

433 (void) 
salsa20_test
;

434 (void) 
chacha20_test
;

435 (void) 
curve25519_test
;

436 (void) 
poly1305_test
;

437 (void) 
hmacsha256_test
;

438 (void) 
norx_test
;

439 (void) 
aeadperf_norx
;

440 (void) 
aeadperf_chacha20poly1305
;

441 (void) 
aeadperf_aes128gcm
;

442 (void) 
aeadperf_aes128ccm
;

443 (void) 
aeadperf_aes128eax
;

444 (void) 
aeadperf_aes256gcm
;

445 (void) 
aeadperf_aes256ccm
;

446 (void) 
aeadperf_aes256eax
;

447 
	}
}

	@deps/picotls/deps/cifra/src/arm/semihost.c

1 #include 
	~<stdint.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<stdarg.h
>

4 #include 
	~<string.h
>

6 #include 
	~"semihost.h
"

8 #define 
	#OP_WRITE0
 0x04

	)

9 #define 
	#OP_EXIT
 0x18

	)

10 #define 
	#OP_EXIT_ARG_FAILURE
 0x0

	)

11 #define 
	#OP_EXIT_ARG_SUCCESS
 0x20026

	)

13 extern 
uint32_t
 
semihost
(uint32_t, volatile void *);

15 
__attribute__
((
noreturn
))

16 void 
	$quit_success
(void)

18 
	`semihost
(
OP_EXIT
, (void *) 
OP_EXIT_ARG_SUCCESS
);

21 
	}
}

23 
__attribute__
((
noreturn
))

24 void 
	$quit_failure
(void)

26 
	`semihost
(
OP_EXIT
, (void *) 
OP_EXIT_ARG_FAILURE
);

29 
	}
}

31 void 
	$emit
(const char *
buf
)

33 
	`semihost
(
OP_WRITE0
, (volatile void *) 
buf
);

34 
	}
}

36 static void 
	$emit_extent
(const char *
start
, const char *
end
)

38 char 
buf
[32+1];

39 
size_t
 
bufmax
 = sizeof(
buf
) - 1;

40 
buf
[32] = 0;

42 
size_t
 
bytes
 = 
end
 - 
start
 + 1;

44 while (
bytes
 >= 
bufmax
)

46 
	`memcpy
(
buf
, 
start
, 
bufmax
);

47 
	`emit
(
buf
);

48 
bytes
 -= 
bufmax
;

49 
start
 += 
bufmax
;

52 if (
bytes
 == 0)

55 
	`memcpy
(
buf
, 
start
, 
bytes
);

56 
buf
[
bytes
] = 0;

57 
	`emit
(
buf
);

58 
	}
}

60 void 
	$emitf
(const char *
fmt
, ...)

62 const char *
start
 = 
fmt
, *
end
 = fmt;

64 
va_list
 
args
;

65 
	`va_start
(
args
, 
fmt
);

67 while (*
fmt
)

69 switch (*
fmt
)

72 
	`emit_extent
(
start
, 
end
);

74 switch (
fmt
[1])

77 
	`emit
("%");

81 
	`emit_uint32
(
	`va_arg
(
args
, 
uint32_t
));

85 
	`emit
(
	`va_arg
(
args
, const char *));

88 
start
 = 
end
 = 
fmt
 + 2;

92 
end
 = 
fmt
;

96 
fmt
++;

99 
	`va_end
(
args
);

100 
	`emit_extent
(
start
, 
end
);

101 
	}
}

103 static const char *
	ghex_chars
 = "0123456789abcdef";

105 void 
	$emit_hex
(const void *
ptr
, 
size_t
 
len
)

107 const 
uint8_t
 *
bb
 = 
ptr
;

108 char 
byte
[3];

110 
byte
[2] = 0;

112 for (
size_t
 
i
 = 0; i < 
len
; i++)

114 
byte
[0] = 
hex_chars
[(
bb
[
i
] >> 4) & 0xf];

115 
byte
[1] = 
hex_chars
[
bb
[
i
] & 0xf];

116 
	`emit
(
byte
);

118 
	}
}

120 void 
	$emit_uint32
(
uint32_t
 
x
)

122 char 
buf
[sizeof "0x11223344"];

123 
buf
[0] = '0';

124 
buf
[1] = 'x';

125 
buf
[2] = 
hex_chars
[(
x
 >> 28) & 0xf];

126 
buf
[3] = 
hex_chars
[(
x
 >> 24) & 0xf];

127 
buf
[4] = 
hex_chars
[(
x
 >> 20) & 0xf];

128 
buf
[5] = 
hex_chars
[(
x
 >> 16) & 0xf];

129 
buf
[6] = 
hex_chars
[(
x
 >> 12) & 0xf];

130 
buf
[7] = 
hex_chars
[(
x
 >> 8) & 0xf];

131 
buf
[8] = 
hex_chars
[(
x
 >> 4) & 0xf];

132 
buf
[9] = 
hex_chars
[
x
 & 0xf];

133 
buf
[10] = 0;

135 
	`emit
(
buf
);

136 
	}
}

140 volatile 
uint32_t
 
	mctrl
;

141 volatile 
uint32_t
 
	mreload
;

142 volatile 
uint32_t
 
	mcurrent
;

143 } 
	tsystick
;

145 #define 
	#SysTick
 ((
systick
 *)0xe000e010)

	)

147 #define 
	#STCTRL_SYSCLOCK
 0x04

	)

148 #define 
	#STCTRL_TICKINT
 0x02

	)

149 #define 
	#STCTRL_ENABLE
 0x01

	)

151 #define 
	#STCTRL_MAX
 0xffffff

	)

152 #define 
	#STCTRL_SHIFT
 24

	)

154 extern 
uint32_t
 
get_ticks
(void);

155 extern void 
reset_ticks
(void);

157 
uint32_t
 
	$reset_cycles
(void)

159 
SysTick
->
reload
 = 
STCTRL_MAX
;

160 
SysTick
->
ctrl
 = 
STCTRL_SYSCLOCK
 | 
STCTRL_TICKINT
 | 
STCTRL_ENABLE
;

161 
SysTick
->
current
 = 0;

162 
	`reset_ticks
();

163 return 
	`get_ticks
();

164 
	}
}

166 
uint32_t
 
	$get_cycles
(void)

168 return (
	`get_ticks
() << 
STCTRL_SHIFT
) + (
STCTRL_MAX
 - 
SysTick
->
current
);

169 
	}
}

	@deps/picotls/deps/cifra/src/arm/semihost.h

1 #ifndef 
SEMIHOST_H


2 #define 
	#SEMIHOST_H


	)

4 #include 
	~<stdint.h
>

5 #include 
	~<stdlib.h
>

8 
__attribute__
((
noreturn
))

9 void 
quit_success
(void);

12 
__attribute__
((
noreturn
))

13 void 
quit_failure
(void);

16 void 
emit
(const char *
buf
);

24 void 
emitf
(const char *
fmt
, ...);

27 void 
emit_hex
(const void *
ptr
, 
size_t
 
len
);

31 void 
emit_uint32
(
uint32_t
 
v
);

35 
uint32_t
 
reset_cycles
(void);

38 
uint32_t
 
get_cycles
(void);

	@deps/picotls/deps/cifra/src/arm/unacl/scalarmult.c

60 #include 
	~<inttypes.h
>

68 typedef 
uint8_t
 
	tuint8
;

69 typedef 
uint16_t
 
	tuint16
;

70 typedef 
uint32_t
 
	tuint32
;

71 typedef 
uint64_t
 
	tuint64
;

72 typedef 
uintptr_t
 
	tuintptr
;

74 typedef 
int8_t
 
	tint8
;

75 typedef 
int16_t
 
	tint16
;

76 typedef 
int32_t
 
	tint32
;

77 typedef 
int64_t
 
	tint64
;

78 typedef 
intptr_t
 
	tintptr
;

82 typedef union 
	uUN_256bitValue_


84 
uint8
 
	mas_uint8
[32];

85 
uint16
 
	mas_uint16
[16];

86 
uint32
 
	mas_uint32
[8];

87 
uint64
 
	mas_uint64
[4];

88 } 
	tUN_256bitValue
;

92 typedef union 
	uUN_512bitValue_


94 
uint8
 
	mas_uint8
[64];

95 
uint16
 
	mas_uint16
[32];

96 
uint32
 
	mas_uint32
[16];

97 
uint64
 
	mas_uint64
[8];

98 
UN_256bitValue
 
	mas_256_bitValue
[2];

99 } 
	tUN_512bitValue
;

101 typedef 
UN_256bitValue
 
	tfe25519
;

108 
fe25519_reduceTo256Bits_asm
(

109 
fe25519
 *
res
,

110 const 
UN_512bitValue
 *
in


113 #define 
	#fe25519_mpyWith121666
 
fe25519_mpyWith121666_asm


	)

115 
fe25519_mpyWith121666_asm
 (

116 
fe25519
* 
out
,

117 const 
fe25519
* 
in


120 #define 
	#multiply256x256
 
multiply256x256_asm


	)

122 
multiply256x256
(

123 
UN_512bitValue
* 
result
,

124 const 
UN_256bitValue
* 
x
,

125 const 
UN_256bitValue
* 
y


128 #define 
	#square256
 
square256_asm


	)

130 
square256
(

131 
UN_512bitValue
* 
result
,

132 const 
UN_256bitValue
* 
x


140 
	$fe25519_cpy
(

141 
fe25519
* 
dest
,

142 const 
fe25519
* 
source


145 
uint32
 
ctr
;

147 for (
ctr
 = 0; ctr < 8; ctr++)

149 
dest
->
as_uint32
[
ctr
] = 
source
->as_uint32[ctr];

151 
	}
}

154 
	$fe25519_unpack
(

155 volatile 
fe25519
* 
out
,

156 const unsigned char 
in
[32]

159 
uint8
 
ctr
;

161 for (
ctr
 = 0; ctr < 32; ctr++)

163 
out
->
as_uint8
[
ctr
] = 
in
[ctr];

165 
out
->
as_uint8
[31] &= 0x7f;

166 
	}
}

169 
	$fe25519_sub
(

170 
fe25519
* 
out
,

171 const 
fe25519
* 
baseValue
,

172 const 
fe25519
* 
valueToSubstract


175 
uint16
 
ctr
;

176 
int64
 
accu
 = 0;

180 
accu
 = 
baseValue
->
as_uint32
[7];

181 
accu
 -= 
valueToSubstract
->
as_uint32
[7];

185 
out
->
as_uint32
[7] = ((
uint32
)
accu
) | 0x80000000ul;

187 
accu
 = 19 * ((
int32
)(accu >> 31) - 1);

191 for (
ctr
 = 0; ctr < 7; ctr += 1)

193 
accu
 += 
baseValue
->
as_uint32
[
ctr
];

194 
accu
 -= 
valueToSubstract
->
as_uint32
[
ctr
];

196 
out
->
as_uint32
[
ctr
] = (
uint32
)
accu
;

197 
accu
 >>= 32;

199 
accu
 += 
out
->
as_uint32
[7];

200 
out
->
as_uint32
[7] = (
uint32
)
accu
;

201 
	}
}

204 
	$fe25519_add
(

205 
fe25519
* 
out
,

206 const 
fe25519
* 
baseValue
,

207 const 
fe25519
* 
valueToAdd


210 
uint16
 
ctr
 = 0;

211 
uint64
 
accu
 = 0;

215 
accu
 = 
baseValue
->
as_uint32
[7];

216 
accu
 += 
valueToAdd
->
as_uint32
[7];

217 
out
->
as_uint32
[7] = ((
uint32
)
accu
) & 0x7ffffffful;

219 
accu
 = ((
uint32
)(accu >> 31)) * 19;

221 for (
ctr
 = 0; ctr < 7; ctr += 1)

223 
accu
 += 
baseValue
->
as_uint32
[
ctr
];

224 
accu
 += 
valueToAdd
->
as_uint32
[
ctr
];

226 
out
->
as_uint32
[
ctr
] = (
uint32
)
accu
;

227 
accu
 >>= 32;

229 
accu
 += 
out
->
as_uint32
[7];

230 
out
->
as_uint32
[7] = (
uint32
)
accu
;

231 
	}
}

234 
	$fe25519_mul
(

235 
fe25519
* 
result
,

236 const 
fe25519
* 
in1
,

237 const 
fe25519
* 
in2


240 
UN_512bitValue
 
tmp
;

242 
	`multiply256x256
(&
tmp
, 
in1
, 
in2
);

243 
	`fe25519_reduceTo256Bits_asm
(
result
,&
tmp
);

244 
	}
}

247 
	$fe25519_square
(

248 
fe25519
* 
result
,

249 const 
fe25519
* 
in


252 
UN_512bitValue
 
tmp
;

254 
	`square256
(&
tmp
, 
in
);

255 
	`fe25519_reduceTo256Bits_asm
(
result
,&
tmp
);

256 
	}
}

259 
	$fe25519_reduceCompletely
(

260 volatile 
fe25519
* 
inout


263 
uint32
 
numberOfTimesToSubstractPrime
;

264 
uint32
 
initialGuessForNumberOfTimesToSubstractPrime
 = 
inout
->
as_uint32
[7] >>

266 
uint64
 
accu
;

267 
uint8
 
ctr
;

279 
accu
 = 
initialGuessForNumberOfTimesToSubstractPrime
 * 19 + 19;

281 for (
ctr
 = 0; ctr < 7; ctr++)

283 
accu
 += 
inout
->
as_uint32
[
ctr
];

284 
accu
 >>= 32;

286 
accu
 += 
inout
->
as_uint32
[7];

288 
numberOfTimesToSubstractPrime
 = (
uint32
)(
accu
 >> 31);

291 
accu
 = 
numberOfTimesToSubstractPrime
 * 19;

293 for (
ctr
 = 0; ctr < 7; ctr++)

295 
accu
 += 
inout
->
as_uint32
[
ctr
];

296 
inout
->
as_uint32
[
ctr
] = (
uint32
)
accu
;

297 
accu
 >>= 32;

299 
accu
 += 
inout
->
as_uint32
[7];

300 
inout
->
as_uint32
[7] = 
accu
 & 0x7ffffffful;

301 
	}
}

308 
	$fe25519_pack
(

309 unsigned char 
out
[32],

310 volatile 
fe25519
* 
in


313 
uint8
 
ctr
;

315 
	`fe25519_reduceCompletely
(
in
);

317 for (
ctr
 = 0; ctr < 32; ctr++)

319 
out
[
ctr
] = 
in
->
as_uint8
[ctr];

321 
	}
}

325 
	$fe25519_invert_useProvidedScratchBuffers
(

326 
fe25519
* 
r
,

327 const 
fe25519
* 
x
,

328 
fe25519
* 
t0
,

329 
fe25519
* 
t1
,

330 
fe25519
* 
t2


333 
fe25519
 *
z11
 = 
r
;

334 
fe25519
 *
z2_10_0
 = 
t1
;

335 
fe25519
 *
z2_50_0
 = 
t2
;

336 
fe25519
 *
z2_100_0
 = 
z2_10_0
;

338 
uint8
 
i
;

341 
fe25519
 *
z2
 = 
z2_50_0
;

343  
	`fe25519_square
(
z2
, 
x
);

344  
	`fe25519_square
(
t0
, 
z2
);

345  
	`fe25519_square
(
t0
, t0);

346  
	`fe25519_mul
(
z2_10_0
, 
t0
, 
x
);

347  
	`fe25519_mul
(
z11
, 
z2_10_0
, 
z2
);

352  
	`fe25519_square
(
t0
, 
z11
);

353  
	`fe25519_mul
(
z2_10_0
, 
t0
, z2_10_0);

355  
	`fe25519_square
(
t0
, 
z2_10_0
);

356  
	`fe25519_square
(
t0
, t0);

357  
	`fe25519_square
(
t0
, t0);

358  
	`fe25519_square
(
t0
, t0);

359  
	`fe25519_square
(
t0
, t0);

360  
	`fe25519_mul
(
z2_10_0
, 
t0
, z2_10_0);

362  
	`fe25519_square
(
t0
, 
z2_10_0
);

364  for (
i
 = 1; i < 10; i ++)

366 
	`fe25519_square
(
t0
, t0);

368  
	`fe25519_mul
(
z2_50_0
, 
t0
, 
z2_10_0
);

370  
	`fe25519_square
(
t0
, 
z2_50_0
);

372  for (
i
 = 1; i < 20; i ++)

374 
	`fe25519_square
(
t0
, t0);

376  
	`fe25519_mul
(
t0
, t0, 
z2_50_0
);

378  
	`fe25519_square
(
t0
, t0);

380  for (
i
 = 1; i < 10; i ++)

382 
	`fe25519_square
(
t0
, t0);

384  
	`fe25519_mul
(
z2_50_0
, 
t0
, 
z2_10_0
);

386  
	`fe25519_square
(
t0
, 
z2_50_0
);

388  for (
i
 = 1; i < 50; i ++)

390 
	`fe25519_square
(
t0
, t0);

392  
	`fe25519_mul
(
z2_100_0
, 
t0
, 
z2_50_0
);

394  
	`fe25519_square
(
t0
, 
z2_100_0
);

396  for (
i
 = 1; i < 100; i ++)

398 
	`fe25519_square
(
t0
, t0);

400  
	`fe25519_mul
(
t0
, t0, 
z2_100_0
);

402  for (
i
 = 0; i < 50; i ++)

404 
	`fe25519_square
(
t0
, t0);

406  
	`fe25519_mul
(
t0
, t0, 
z2_50_0
);

408  for (
i
 = 0; i < 5; i ++)

410 
	`fe25519_square
(
t0
, t0);

412  
	`fe25519_mul
(
r
, 
t0
, 
z11
);

413 
	}
}

416 
	$fe25519_setzero
(

417 
fe25519
* 
out


420 
uint8
 
ctr
;

422 for (
ctr
 = 0; ctr < 8; ctr++)

424 
out
->
as_uint32
[
ctr
] = 0;

426 
	}
}

429 
	$fe25519_setone
(

430 
fe25519
* 
out


433 
uint8
 
ctr
;

435 
out
->
as_uint32
[0] = 1;

437 for (
ctr
 = 1; ctr < 8; ctr++)

439 
out
->
as_uint32
[
ctr
] = 0;

441 
	}
}

473 
	$fe25519_cswap
(

474 
fe25519
* 
in1
,

475 
fe25519
* 
in2
,

476 int 
condition


479 
int32
 
mask
 = 
condition
;

480 
uint32
 
ctr
;

482 
mask
 = -mask;

484 for (
ctr
 = 0; ctr < 8; ctr++)

486 
uint32
 
val1
 = 
in1
->
as_uint32
[
ctr
];

487 
uint32
 
val2
 = 
in2
->
as_uint32
[
ctr
];

488 
uint32
 
temp
 = 
val1
;

490 
val1
 ^= 
mask
 & (
val2
 ^ val1);

491 
val2
 ^= 
mask
 & (val2 ^ 
temp
);

494 
in1
->
as_uint32
[
ctr
] = 
val1
;

495 
in2
->
as_uint32
[
ctr
] = 
val2
;

497 
	}
}

503 typedef struct 
	s_ST_curve25519ladderstepWorkingState


506 
fe25519
 
	mx0
;

509 
fe25519
 
	mxp
;

510 
fe25519
 
	mzp
;

511 
fe25519
 
	mxq
;

512 
fe25519
 
	mzq
;

514 volatile 
UN_256bitValue
 
	ms
;

516 int 
	mnextScalarBitToProcess
;

517 
uint8
 
	mpreviousProcessedBit
;

519 #ifdef 
DH_SWAP_BY_POINTERS


520 
fe25519
 *
	mpXp
;

521 
fe25519
 *
	mpZp
;

522 
fe25519
 *
	mpXq
;

523 
fe25519
 *
	mpZq
;

526 } 
	tST_curve25519ladderstepWorkingState
;

529 
	$curve25519_ladderstep
(

530 
ST_curve25519ladderstepWorkingState
* 
pState


548 
fe25519
 
t1
, 
t2
;

550 #ifdef 
DH_SWAP_BY_POINTERS


551 
fe25519
 *
b1
=
pState
->
pXp
; fe25519 *
b2
=pState->
pZp
;

552 
fe25519
 *
b3
=
pState
->
pXq
; fe25519 *
b4
=pState->
pZq
;

554 
fe25519
 *
b1
=&
pState
->
xp
; fe25519 *
b2
=&pState->
zp
;

555 
fe25519
 *
b3
=&
pState
->
xq
; fe25519 *
b4
=&pState->
zq
;

558 
fe25519
 *
b5
= &
t1
; fe25519 *
b6
=&
t2
;

560 
	`fe25519_add
(
b5
,
b1
,
b2
);

561 
	`fe25519_sub
(
b6
,
b1
,
b2
);

562 
	`fe25519_add
(
b1
,
b3
,
b4
);

563 
	`fe25519_sub
(
b2
,
b3
,
b4
);

564 
	`fe25519_mul
(
b3
,
b2
,
b5
);

565 
	`fe25519_mul
(
b2
,
b1
,
b6
);

566 
	`fe25519_add
(
b1
,
b2
,
b3
);

567 
	`fe25519_sub
(
b4
,
b3
,
b2
);

568 
	`fe25519_square
(
b3
,
b1
);

569 
	`fe25519_square
(
b1
,
b4
);

570 
	`fe25519_mul
(
b4
,
b1
,&
pState
->
x0
);

571 
	`fe25519_square
(
b1
,
b5
);

572 
	`fe25519_square
(
b5
,
b6
);

573 
	`fe25519_sub
(
b2
,
b1
,
b5
);

574 
	`fe25519_mul
(
b1
,
b5
,b1);

575 
	`fe25519_mpyWith121666
 (
b6
,
b2
);

576 
	`fe25519_add
(
b6
,b6,
b5
);

577 
	`fe25519_mul
(
b2
,
b6
,b2);

578 
	}
}

581 
	$curve25519_cswap
(

582 
ST_curve25519ladderstepWorkingState
* 
state
,

583 
uint8
 
b


586 #ifdef 
DH_SWAP_BY_POINTERS


587 
	`swapPointersConditionally
 ((void **) &
state
->
pXp
,(void **) &state->
pXq
,
b
);

588 
	`swapPointersConditionally
 ((void **) &
state
->
pZp
,(void **) &state->
pZq
,
b
);

590 
	`fe25519_cswap
 (&
state
->
xp
, &state->
xq
,
b
);

591 
	`fe25519_cswap
 (&
state
->
zp
, &state->
zq
,
b
);

593 
	}
}

595 #if 
DH_REPLACE_LAST_THREE_LADDERSTEPS_WITH_DOUBLINGS


598 
	$curve25519_doublePointP
 (
ST_curve25519ladderstepWorkingState
* 
pState
)

618 #ifdef 
DH_SWAP_BY_POINTERS


619 
fe25519
 *
pA
 = 
pState
->
pXq
;

620 
fe25519
 *
pB
 = 
pState
->
pZq
;

621 
fe25519
 *
pX
 = 
pState
->
pXp
;

622 
fe25519
 *
pZ
 = 
pState
->
pZp
;

624 
fe25519
 *
pA
 = &
pState
->
xq
;

625 
fe25519
 *
pB
 = &
pState
->
zq
;

626 
fe25519
 *
pX
 = &
pState
->
xp
;

627 
fe25519
 *
pZ
 = &
pState
->
zp
;

631 
	`fe25519_add
(
pA
, 
pX
, 
pZ
);

633 
	`fe25519_square
 (
pA
,pA);

635 
	`fe25519_sub
(
pB
, 
pX
, 
pZ
);

637 
	`fe25519_square
 (
pB
,pB);

639 
	`fe25519_mul
 (
pX
,
pA
,
pB
);

641 
	`fe25519_sub
 (
pZ
,
pA
,
pB
);

643 
	`fe25519_mpyWith121666
 (
pA
,
pZ
);

645 
	`fe25519_add
 (
pB
,
pA
,pB);

647 
	`fe25519_mul
 (
pZ
,pZ,
pB
);

648 
	}
}

653 
	$crypto_scalarmult_curve25519
(

654 unsigned char* 
r
,

655 const unsigned char* 
s
,

656 const unsigned char* 
p


659 
ST_curve25519ladderstepWorkingState
 
state
;

660 unsigned char 
i
;

664 for (
i
 = 0; i < 32; i++)

666 
state
.
s
.
as_uint8
 [
i
] = s[i];

668 #if 
DH_REPLACE_LAST_THREE_LADDERSTEPS_WITH_DOUBLINGS


672 
state
.
s
.
as_uint8
 [0] &= 248;

674 
state
.
s
.
as_uint8
 [31] &= 127;

675 
state
.
s
.
as_uint8
 [31] |= 64;

678 
	`fe25519_unpack
 (&
state
.
x0
, 
p
);

682 
	`fe25519_setone
 (&
state
.
zq
);

683 
	`fe25519_cpy
 (&
state
.
xq
, &state.
x0
);

685 
	`fe25519_setone
(&
state
.
xp
);

686 
	`fe25519_setzero
(&
state
.
zp
);

688 
state
.
nextScalarBitToProcess
 = 254;

690 #ifdef 
DH_SWAP_BY_POINTERS


692 
state
.
pXp
 = &state.
xp
;

693 
state
.
pZp
 = &state.
zp
;

694 
state
.
pXq
 = &state.
xq
;

695 
state
.
pZq
 = &state.
zq
;

698 
state
.
previousProcessedBit
 = 0;

700 #if 
DH_REPLACE_LAST_THREE_LADDERSTEPS_WITH_DOUBLINGS


702 while (
state
.
nextScalarBitToProcess
 >= 3)

705 while (
state
.
nextScalarBitToProcess
 >= 0)

708 
uint8
 
byteNo
 = 
state
.
nextScalarBitToProcess
 >> 3;

709 
uint8
 
bitNo
 = 
state
.
nextScalarBitToProcess
 & 7;

710 
uint8
 
bit
;

711 
uint8
 
swap
;

713 
bit
 = 1 & (
state
.
s
.
as_uint8
 [
byteNo
] >> 
bitNo
);

714 
swap
 = 
bit
 ^ 
state
.
previousProcessedBit
;

715 
state
.
previousProcessedBit
 = 
bit
;

716 
	`curve25519_cswap
(&
state
, 
swap
);

717 
	`curve25519_ladderstep
(&
state
);

718 
state
.
nextScalarBitToProcess
 --;

721 
	`curve25519_cswap
(&
state
,state.
previousProcessedBit
);

723 #if 
DH_REPLACE_LAST_THREE_LADDERSTEPS_WITH_DOUBLINGS


724 
	`curve25519_doublePointP
 (&
state
);

725 
	`curve25519_doublePointP
 (&
state
);

726 
	`curve25519_doublePointP
 (&
state
);

729 #ifdef 
DH_SWAP_BY_POINTERS


731 
	`fe25519_invert_useProvidedScratchBuffers
 (
state
.
pZp
, state.pZp, state.
pXq
,state.
pZq
,&state.
x0
);

732 
	`fe25519_mul
(
state
.
pXp
, state.pXp, state.
pZp
);

733 
	`fe25519_reduceCompletely
(
state
.
pXp
);

735 
	`fe25519_pack
 (
r
, 
state
.
pXp
);

738 
	`fe25519_invert_useProvidedScratchBuffers
 (&
state
.
zp
, &state.zp, &state.
xq
, &state.
zq
, &state.
x0
);

739 
	`fe25519_mul
(&
state
.
xp
, &state.xp, &state.
zp
);

740 
	`fe25519_reduceCompletely
(&
state
.
xp
);

742 
	`fe25519_pack
 (
r
, &
state
.
xp
);

746 
	}
}

749 
	$crypto_scalarmult_curve25519_base
(

750 unsigned char* 
q
,

751 const unsigned char* 
n


754 static const 
uint8
 
base
[32] =

760 return 
	`crypto_scalarmult_curve25519
(
q
, 
n
, 
base
);

761 
	}
}

	@deps/picotls/deps/cifra/src/bitops.h

15 #ifndef 
BITOPS_H


16 #define 
	#BITOPS_H


	)

18 #include 
	~<stdint.h
>

19 #include 
	~<stddef.h
>

21 #ifdef 
_WINDOWS


22 #include 
	~<intrin.h
>

29 static 
inline
 
uint32_t
 
	$rotr32
(
uint32_t
 
x
, unsigned 
n
)

31 return (
x
 >> 
n
) | (x << (32 - n));

32 
	}
}

36 static 
inline
 
uint32_t
 
	$rotl32
(
uint32_t
 
x
, unsigned 
n
)

38 return (
x
 << 
n
) | (x >> (32 - n));

39 
	}
}

43 static 
inline
 
uint64_t
 
	$rotr64
(
uint64_t
 
x
, unsigned 
n
)

45 return (
x
 >> 
n
) | (x << (64 - n));

46 
	}
}

50 static 
inline
 
uint64_t
 
	$rotl64
(
uint64_t
 
x
, unsigned 
n
)

52 return (
x
 << 
n
) | (x >> (64 - n));

53 
	}
}

56 static 
inline
 
uint32_t
 
	$read32_be
(const 
uint8_t
 
buf
[4])

58 return (
buf
[0] << 24) |

59 (
buf
[1] << 16) |

60 (
buf
[2] << 8) |

61 (
buf
[3]);

62 
	}
}

65 static 
inline
 
uint32_t
 
	$read32_le
(const 
uint8_t
 
buf
[4])

67 return (
buf
[3] << 24) |

68 (
buf
[2] << 16) |

69 (
buf
[1] << 8) |

70 (
buf
[0]);

71 
	}
}

74 static 
inline
 
uint64_t
 
	$read64_be
(const 
uint8_t
 
buf
[8])

76 
uint32_t
 
hi
 = 
	`read32_be
(
buf
),

77 
lo
 = 
	`read32_be
(
buf
 + 4);

78 return ((
uint64_t
)
hi
) << 32 |

79 
lo
;

80 
	}
}

83 static 
inline
 
uint64_t
 
	$read64_le
(const 
uint8_t
 
buf
[8])

85 
uint32_t
 
hi
 = 
	`read32_le
(
buf
 + 4),

86 
lo
 = 
	`read32_le
(
buf
);

87 return ((
uint64_t
)
hi
) << 32 |

88 
lo
;

89 
	}
}

92 static 
inline
 void 
	$write32_be
(
uint32_t
 
v
, 
uint8_t
 
buf
[4])

94 *
buf
++ = (
v
 >> 24) & 0xff;

95 *
buf
++ = (
v
 >> 16) & 0xff;

96 *
buf
++ = (
v
 >> 8) & 0xff;

97 *
buf
 = 
v
 & 0xff;

98 
	}
}

101 static 
inline
 void 
	$write32_le
(
uint32_t
 
v
, 
uint8_t
 
buf
[4])

103 *
buf
++ = 
v
 & 0xff;

104 *
buf
++ = (
v
 >> 8) & 0xff;

105 *
buf
++ = (
v
 >> 16) & 0xff;

106 *
buf
 = (
v
 >> 24) & 0xff;

107 
	}
}

110 static 
inline
 void 
	$write64_be
(
uint64_t
 
v
, 
uint8_t
 
buf
[8])

112 *
buf
++ = (
v
 >> 56) & 0xff;

113 *
buf
++ = (
v
 >> 48) & 0xff;

114 *
buf
++ = (
v
 >> 40) & 0xff;

115 *
buf
++ = (
v
 >> 32) & 0xff;

116 *
buf
++ = (
v
 >> 24) & 0xff;

117 *
buf
++ = (
v
 >> 16) & 0xff;

118 *
buf
++ = (
v
 >> 8) & 0xff;

119 *
buf
 = 
v
 & 0xff;

120 
	}
}

123 static 
inline
 void 
	$write64_le
(
uint64_t
 
v
, 
uint8_t
 
buf
[8])

125 *
buf
++ = 
v
 & 0xff;

126 *
buf
++ = (
v
 >> 8) & 0xff;

127 *
buf
++ = (
v
 >> 16) & 0xff;

128 *
buf
++ = (
v
 >> 24) & 0xff;

129 *
buf
++ = (
v
 >> 32) & 0xff;

130 *
buf
++ = (
v
 >> 40) & 0xff;

131 *
buf
++ = (
v
 >> 48) & 0xff;

132 *
buf
 = (
v
 >> 56) & 0xff;

133 
	}
}

137 static 
inline
 void 
	$xor_b8
(
uint8_t
 *
out
, const uint8_t *
in
, uint8_t 
b8
, 
size_t
 
len
)

139 
size_t
 
i
;

140 for (
i
 = 0; i < 
len
; i++)

141 
out
[
i
] = 
in
[i] ^ 
b8
;

142 
	}
}

146 static 
inline
 void 
	$xor_bb
(
uint8_t
 *
out
, const uint8_t *
x
, const uint8_t *
y
, 
size_t
 
len
)

148 
size_t
 
i
;

149 for (
i
 = 0; i < 
len
; i++)

150 
out
[
i
] = 
x
[i] ^ 
y
[i];

151 
	}
}

155 static 
inline
 void 
	$xor_words
(
uint32_t
 *
out
, const uint32_t *
x
, 
size_t
 
nwords
)

157 
size_t
 
i
;

158 for (
i
 = 0; i < 
nwords
; i++)

159 
out
[
i
] ^= 
x
[i];

160 
	}
}

163 static 
inline
 
uint32_t
 
	$mask_u32
(
uint32_t
 
x
, uint32_t 
y
)

165 
uint32_t
 
diff
 = 
x
 ^ 
y
;

166 
uint32_t
 
diff_is_zero
 = ~
diff
 & (diff - 1);

167 return (
uint32_t
)(-(
int32_t
)(
diff_is_zero
 >> 31));

168 
	}
}

171 static 
inline
 
uint8_t
 
	$mask_u8
(
uint32_t
 
x
, uint32_t 
y
)

173 
uint32_t
 
diff
 = 
x
 ^ 
y
;

174 
uint8_t
 
diff_is_zero
 = ~
diff
 & (diff - 1);

175 return - (
diff_is_zero
 >> 7);

176 
	}
}

180 static 
inline
 
uint32_t
 
	$select_u32
(
uint32_t
 
i
, volatile const uint32_t *
tab
, uint32_t 
n
)

182 
uint32_t
 
r
 = 0, 
ii
;

184 for (
ii
 = 0; ii < 
n
; ii++)

186 
uint32_t
 
mask
 = 
	`mask_u32
(
i
, 
ii
);

187 
r
 = (r & ~
mask
) | (
tab
[
ii
] & mask);

190 return 
r
;

191 
	}
}

195 static 
inline
 
uint8_t
 
	$select_u8
(
uint32_t
 
i
, volatile const 
uint8_t
 *
tab
, uint32_t 
n
)

197 
uint8_t
 
r
 = 0;

198 
uint32_t
 
ii
;

200 for (
ii
 = 0; ii < 
n
; ii++)

202 
uint8_t
 
mask
 = 
	`mask_u8
(
i
, 
ii
);

203 
r
 = (r & ~
mask
) | (
tab
[
ii
] & mask);

206 return 
r
;

207 
	}
}

211 static 
inline
 void 
	$select_u8x4
(
uint8_t
 *
a
, uint8_t *
b
, uint8_t *
c
, uint8_t *
d
,

212 volatile const 
uint8_t
 *
tab
, 
uint32_t
 
n
)

214 
uint8_t
 
ra
 = 0,

215 
rb
 = 0,

216 
rc
 = 0,

217 
rd
 = 0;

218 
uint8_t
 
mask
;

219 
uint32_t
 
i
;

221 for (
i
 = 0; i < 
n
; i++)

223 
uint8_t
 
item
 = 
tab
[
i
];

225 
mask
 = 
	`mask_u8
(*
a
, 
i
); 
ra
 = (ra & ~mask) | (
item
 & mask);

226 
mask
 = 
	`mask_u8
(*
b
, 
i
); 
rb
 = (rb & ~mask) | (
item
 & mask);

227 
mask
 = 
	`mask_u8
(*
c
, 
i
); 
rc
 = (rc & ~mask) | (
item
 & mask);

228 
mask
 = 
	`mask_u8
(*
d
, 
i
); 
rd
 = (rd & ~mask) | (
item
 & mask);

231 *
a
 = 
ra
;

232 *
b
 = 
rb
;

233 *
c
 = 
rc
;

234 *
d
 = 
rd
;

235 
	}
}

238 static 
inline
 void 
	$select_xor128
(
uint32_t
 
out
[4],

239 const 
uint32_t
 
if0
[4],

240 const 
uint32_t
 
if1
[4],

241 
uint8_t
 
bit
)

243 
uint32_t
 
mask1
 = 
	`mask_u32
(
bit
, 1);

244 
uint32_t
 
mask0
 = ~
mask1
;

246 
out
[0] ^= (
if0
[0] & 
mask0
) | (
if1
[0] & 
mask1
);

247 
out
[1] ^= (
if0
[1] & 
mask0
) | (
if1
[1] & 
mask1
);

248 
out
[2] ^= (
if0
[2] & 
mask0
) | (
if1
[2] & 
mask1
);

249 
out
[3] ^= (
if0
[3] & 
mask0
) | (
if1
[3] & 
mask1
);

250 
	}
}

254 static 
inline
 void 
	$incr_le
(
uint8_t
 *
v
, 
size_t
 
len
)

256 
size_t
 
i
 = 0;

259 if (++
v
[
i
] != 0)

261 
i
++;

262 if (
i
 == 
len
)

265 
	}
}

269 static 
inline
 void 
	$incr_be
(
uint8_t
 *
v
, 
size_t
 
len
)

271 
len
--;

274 if (++
v
[
len
] != 0)

276 if (
len
 == 0)

278 
len
--;

280 
	}
}

284 static 
inline
 void 
	$copy_bytes_unaligned
(
uint8_t
 *
out
, const uint8_t *
in
, 
size_t
 
len
, uint8_t 
offset
)

286 
uint8_t
 
byte_off
 = 
offset
 / 8;

287 
uint8_t
 
bit_off
 = 
offset
 & 7;

288 
uint8_t
 
rmask
 = (1 << 
bit_off
) - 1;

289 
uint8_t
 
lmask
 = ~
rmask
;

290 
size_t
 
i
;

292 for (
i
 = 0; i < 
len
; i++)

294 
out
[
i
] = (
in
[i + 
byte_off
] << 
bit_off
) & 
lmask
;

295 
out
[
i
] |= (
in
[i + 
byte_off
 + 1] >> (8 - 
bit_off
)) & 
rmask
;

297 
	}
}

299 static 
inline
 
uint32_t
 
	$count_trailing_zeroes
(
uint32_t
 
x
)

301 #ifdef 
_WINDOWS


302 
uint32_t
 
r
 = 0;

303 
	`_BitScanReverse
(&
r
, 
x
);

304 return (31 - 
r
);

306 return (
uint32_t
) 
	`__builtin_ctzl
(
x
);

308 
	}
}

	@deps/picotls/deps/cifra/src/blockwise.c

15 #include 
	~"blockwise.h
"

16 #include 
	~"bitops.h
"

17 #include 
	~"handy.h
"

18 #include 
	~"tassert.h
"

20 #include 
	~<string.h
>

22 void 
	$cf_blockwise_accumulate
(
uint8_t
 *
partial
, 
size_t
 *
npartial
, size_t 
nblock
,

23 const void *
inp
, 
size_t
 
nbytes
,

24 
cf_blockwise_in_fn
 
process
,

25 void *
ctx
)

27 
	`cf_blockwise_accumulate_final
(
partial
, 
npartial
, 
nblock
,

28 
inp
, 
nbytes
,

29 
process
, process, 
ctx
);

30 
	}
}

32 void 
	$cf_blockwise_accumulate_final
(
uint8_t
 *
partial
, 
size_t
 *
npartial
, size_t 
nblock
,

33 const void *
inp
, 
size_t
 
nbytes
,

34 
cf_blockwise_in_fn
 
process
,

35 
cf_blockwise_in_fn
 
process_final
,

36 void *
ctx
)

38 const 
uint8_t
 *
bufin
 = 
inp
;

39 
	`assert
(
partial
 && *
npartial
 < 
nblock
);

40 
	`assert
(
inp
 || !
nbytes
);

41 
	`assert
(
process
 && 
ctx
);

44 if (*
npartial
 && 
nbytes
)

46 
size_t
 
space
 = 
nblock
 - *
npartial
;

47 
size_t
 
taken
 = 
	`MIN
(
space
, 
nbytes
);

49 
	`memcpy
(
partial
 + *
npartial
, 
bufin
, 
taken
);

51 
bufin
 += 
taken
;

52 
nbytes
 -= 
taken
;

53 *
npartial
 += 
taken
;

56 if (*
npartial
 == 
nblock
)

58 if (
nbytes
 == 0)

59 
	`process_final
(
ctx
, 
partial
);

61 
	`process
(
ctx
, 
partial
);

62 *
npartial
 = 0;

69 while (
nbytes
 >= 
nblock
)

72 
	`assert
(*
npartial
 == 0);

74 if (
nbytes
 == 
nblock
)

75 
	`process_final
(
ctx
, 
bufin
);

77 
	`process
(
ctx
, 
bufin
);

78 
bufin
 += 
nblock
;

79 
nbytes
 -= 
nblock
;

83 while (
nbytes
)

85 
size_t
 
space
 = 
nblock
 - *
npartial
;

86 
size_t
 
taken
 = 
	`MIN
(
space
, 
nbytes
);

88 
	`memcpy
(
partial
 + *
npartial
, 
bufin
, 
taken
);

90 
bufin
 += 
taken
;

91 
nbytes
 -= 
taken
;

92 *
npartial
 += 
taken
;

96 
	`assert
(*
npartial
 < 
nblock
);

98 
	}
}

100 void 
	$cf_blockwise_xor
(
uint8_t
 *
partial
, 
size_t
 *
npartial
, size_t 
nblock
,

101 const void *
inp
, void *
outp
, 
size_t
 
nbytes
,

102 
cf_blockwise_out_fn
 
process
, void *
ctx
)

104 const 
uint8_t
 *
inb
 = 
inp
;

105 
uint8_t
 *
outb
 = 
outp
;

107 
	`assert
(
partial
 && *
npartial
 < 
nblock
);

108 
	`assert
(
inp
 || !
nbytes
);

109 
	`assert
(
process
 && 
ctx
);

111 while (
nbytes
)

114 if (*
npartial
 == 0)

116 
	`process
(
ctx
, 
partial
);

117 *
npartial
 = 
nblock
;

120 
size_t
 
offset
 = 
nblock
 - *
npartial
;

121 
size_t
 
taken
 = 
	`MIN
(*
npartial
, 
nbytes
);

122 
	`xor_bb
(
outb
, 
inb
, 
partial
 + 
offset
, 
taken
);

123 *
npartial
 -= 
taken
;

124 
nbytes
 -= 
taken
;

125 
outb
 += 
taken
;

126 
inb
 += 
taken
;

128 
	}
}

130 void 
	$cf_blockwise_acc_byte
(
uint8_t
 *
partial
, 
size_t
 *
npartial
,

131 
size_t
 
nblock
,

132 
uint8_t
 
byte
, 
size_t
 
nbytes
,

133 
cf_blockwise_in_fn
 
process
,

134 void *
ctx
)

137 int 
filled
 = 0;

139 while (
nbytes
)

141 
size_t
 
start
 = *
npartial
;

142 
size_t
 
count
 = 
	`MIN
(
nbytes
, 
nblock
 - 
start
);

144 if (!
filled
)

145 
	`memset
(
partial
 + 
start
, 
byte
, 
count
);

147 if (
start
 == 0 && 
count
 == 
nblock
)

148 
filled
 = 1;

150 if (
start
 + 
count
 == 
nblock
)

152 
	`process
(
ctx
, 
partial
);

153 *
npartial
 = 0;

155 *
npartial
 += 
count
;

158 
nbytes
 -= 
count
;

160 
	}
}

162 void 
	$cf_blockwise_acc_pad
(
uint8_t
 *
partial
, 
size_t
 *
npartial
,

163 
size_t
 
nblock
,

164 
uint8_t
 
fbyte
, uint8_t 
mbyte
, uint8_t 
lbyte
,

165 
size_t
 
nbytes
,

166 
cf_blockwise_in_fn
 
process
,

167 void *
ctx
)

170 switch (
nbytes
)

173 case 1: 
fbyte
 ^= 
lbyte
;

174 
	`cf_blockwise_accumulate
(
partial
, 
npartial
, 
nblock
, &
fbyte
, 1, 
process
, 
ctx
);

177 
	`cf_blockwise_accumulate
(
partial
, 
npartial
, 
nblock
, &
fbyte
, 1, 
process
, 
ctx
);

178 
	`cf_blockwise_accumulate
(
partial
, 
npartial
, 
nblock
, &
lbyte
, 1, 
process
, 
ctx
);

181 
	`cf_blockwise_accumulate
(
partial
, 
npartial
, 
nblock
, &
fbyte
, 1, 
process
, 
ctx
);

185 if (
lbyte
 != 
mbyte
)

187 
	`cf_blockwise_acc_byte
(
partial
, 
npartial
, 
nblock
, 
mbyte
, 
nbytes
 - 2, 
process
, 
ctx
);

188 
	`cf_blockwise_accumulate
(
partial
, 
npartial
, 
nblock
, &
lbyte
, 1, 
process
, 
ctx
);

190 
	`cf_blockwise_acc_byte
(
partial
, 
npartial
, 
nblock
, 
mbyte
, 
nbytes
 - 1, 
process
, 
ctx
);

195 
	}
}

	@deps/picotls/deps/cifra/src/blockwise.h

15 #ifndef 
BLOCKWISE_H


16 #define 
	#BLOCKWISE_H


	)

18 #include 
	~<stdint.h
>

19 #include 
	~<stddef.h
>

22 typedef void (*
	tcf_blockwise_in_fn
)(void *
	tctx
, const 
	tuint8_t
 *
	tdata
);

25 typedef void (*
	tcf_blockwise_out_fn
)(void *
	tctx
, 
	tuint8_t
 *
	tdata
);

41 void 
	`cf_blockwise_accumulate
(
uint8_t
 *
partial
, 
size_t
 *
npartial
,

42 
size_t
 
nblock
,

43 const void *
input
, 
size_t
 
nbytes
,

44 
cf_blockwise_in_fn
 
process
,

45 void *
ctx
);

65 void 
	`cf_blockwise_accumulate_final
(
uint8_t
 *
partial
, 
size_t
 *
npartial
,

66 
size_t
 
nblock
,

67 const void *
input
, 
size_t
 
nbytes
,

68 
cf_blockwise_in_fn
 
process
,

69 
cf_blockwise_in_fn
 
process_final
,

70 void *
ctx
);

89 void 
	`cf_blockwise_xor
(
uint8_t
 *
partial
, 
size_t
 *
npartial
,

90 
size_t
 
nblock
,

91 const void *
input
, void *
output
, 
size_t
 
nbytes
,

92 
cf_blockwise_out_fn
 
newblock
,

93 void *
ctx
);

110 void 
	`cf_blockwise_acc_byte
(
uint8_t
 *
partial
, 
size_t
 *
npartial
,

111 
size_t
 
nblock
,

112 
uint8_t
 
byte
, 
size_t
 
nbytes
,

113 
cf_blockwise_in_fn
 
process
,

114 void *
ctx
);

140 void 
	`cf_blockwise_acc_pad
(
uint8_t
 *
partial
, 
size_t
 *
npartial
,

141 
size_t
 
nblock
,

142 
uint8_t
 
fbyte
, uint8_t 
mbyte
, uint8_t 
lbyte
,

143 
size_t
 
nbytes
,

144 
cf_blockwise_in_fn
 
process
,

145 void *
ctx
);

	@deps/picotls/deps/cifra/src/cbcmac.c

15 #include 
	~"handy.h
"

16 #include 
	~"prp.h
"

17 #include 
	~"modes.h
"

18 #include 
	~"bitops.h
"

19 #include 
	~"blockwise.h
"

20 #include 
	~"gf128.h
"

21 #include 
	~"tassert.h
"

23 #include 
	~<string.h
>

25 void 
	$cf_cbcmac_stream_init
(
cf_cbcmac_stream
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
)

27 
	`memset
(
ctx
, 0, sizeof *ctx);

28 
ctx
->
prp
 = prp;

29 
ctx
->
prpctx
 = prpctx;

30 
	`cf_cbcmac_stream_reset
(
ctx
);

31 
	}
}

33 void 
	$cf_cbcmac_stream_reset
(
cf_cbcmac_stream
 *
ctx
)

35 
uint8_t
 
iv_zero
[
CF_MAXBLOCK
] = { 0 };

36 
	`cf_cbc_init
(&
ctx
->
cbc
, ctx->
prp
, ctx->
prpctx
, 
iv_zero
);

37 
	`mem_clean
(
ctx
->
buffer
, sizeof ctx->buffer);

38 
ctx
->
used
 = 0;

39 
	}
}

41 static void 
	$cbcmac_process
(void *
vctx
, const 
uint8_t
 *
block
)

43 
cf_cbcmac_stream
 *
ctx
 = 
vctx
;

44 
uint8_t
 
output
[
CF_MAXBLOCK
];

45 
	`cf_cbc_encrypt
(&
ctx
->
cbc
, 
block
, 
output
, 1);

46 
	}
}

48 void 
	$cf_cbcmac_stream_update
(
cf_cbcmac_stream
 *
ctx
, const 
uint8_t
 *
data
, 
size_t
 
len
)

50 
	`cf_blockwise_accumulate
(
ctx
->
buffer
, &ctx->
used
, ctx->
prp
->
blocksz
,

51 
data
, 
len
,

52 
cbcmac_process
,

53 
ctx
);

54 
	}
}

56 void 
	$cf_cbcmac_stream_finish_block_zero
(
cf_cbcmac_stream
 *
ctx
)

58 if (
ctx
->
used
 == 0)

61 
	`memset
(
ctx
->
buffer
 + ctx->
used
, 0, ctx->
prp
->
blocksz
 - ctx->used);

62 
	`cbcmac_process
(
ctx
, ctx->
buffer
);

63 
ctx
->
used
 = 0;

64 
	}
}

66 void 
	$cf_cbcmac_stream_nopad_final
(
cf_cbcmac_stream
 *
ctx
, 
uint8_t
 
out
[
CF_MAXBLOCK
])

68 
	`assert
(
ctx
->
used
 == 0);

69 
	`memcpy
(
out
, 
ctx
->
cbc
.
block
, ctx->
prp
->
blocksz
);

70 
	}
}

72 void 
	$cf_cbcmac_stream_pad_final
(
cf_cbcmac_stream
 *
ctx
, 
uint8_t
 
out
[
CF_MAXBLOCK
])

74 
uint8_t
 
npad
 = 
ctx
->
prp
->
blocksz
 - ctx->
used
;

75 
	`cf_blockwise_acc_byte
(
ctx
->
buffer
, &ctx->
used
, ctx->
prp
->
blocksz
,

76 
npad
, npad,

77 
cbcmac_process
, 
ctx
);

78 
	`cf_cbcmac_stream_nopad_final
(
ctx
, 
out
);

79 
	}
}

	@deps/picotls/deps/cifra/src/ccm.c

15 #include 
	~"handy.h
"

16 #include 
	~"prp.h
"

17 #include 
	~"modes.h
"

18 #include 
	~"tassert.h
"

20 #include 
	~<string.h
>

22 #define 
	#CCM_ADATA_PRESENT
 0x40

	)

24 static void 
	$write_be
(
uint8_t
 *
out
, 
size_t
 
value
, size_t 
bytes
)

26 while (
bytes
)

28 
out
[
bytes
 - 1] = 
value
 & 0xff;

29 
value
 >>= 8;

30 
bytes
--;

33 
	`assert
(
value
 == 0);

34 
	}
}

36 static void 
	$zero_pad
(
cf_cbcmac_stream
 *
cm
)

38 
	`cf_cbcmac_stream_finish_block_zero
(
cm
);

39 
	}
}

42 static void 
	$add_aad
(
cf_cbcmac_stream
 *
cm
, 
uint8_t
 
block
[
CF_MAXBLOCK
],

43 const 
uint8_t
 *
header
, 
size_t
 
nheader
)

45 
	`assert
(
nheader
 <= 0xffffffff);

48 if (
nheader
 < 0xff00)

50 
	`write_be
(
block
, 
nheader
, 2);

51 
	`cf_cbcmac_stream_update
(
cm
, 
block
, 2);

53 
	`write_be
(
block
, 0xfffe, 2);

54 
	`write_be
(
block
 + 2, 
nheader
, 4);

55 
	`cf_cbcmac_stream_update
(
cm
, 
block
, 6);

58 
	`cf_cbcmac_stream_update
(
cm
, 
header
, 
nheader
);

59 
	`zero_pad
(
cm
);

60 
	}
}

62 static void 
	$add_block0
(
cf_cbcmac_stream
 *
cm
,

63 
uint8_t
 
block
[
CF_MAXBLOCK
], 
size_t
 
nblock
,

64 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

65 
size_t
 
L
, size_t 
nplain
,

66 
size_t
 
nheader
, size_t 
ntag
)

69 
block
[0] = ((
nheader
 == 0) ? 0x00 : 
CCM_ADATA_PRESENT
) |

70 ((
ntag
 - 2) / 2) << 3 |

71 (
L
 - 1);

72 
	`memcpy
(
block
 + 1, 
nonce
, 
nnonce
);

73 
	`write_be
(
block
 + 1 + 
nnonce
, 
nplain
, 
L
);

75 
	`cf_cbcmac_stream_update
(
cm
, 
block
, 
nblock
);

76 
	}
}

78 static void 
	$build_ctr_nonce
(
uint8_t
 
ctr_nonce
[
CF_MAXBLOCK
],

79 
size_t
 
L
,

80 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
)

82 
ctr_nonce
[0] = (
L
 - 1);

83 
	`memcpy
(
ctr_nonce
 + 1, 
nonce
, 
nnonce
);

84 
	`memset
(
ctr_nonce
 + 1 + 
nnonce
, 0, 
L
);

85 
	}
}

87 void 
	$cf_ccm_encrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

88 const 
uint8_t
 *
plain
, 
size_t
 
nplain
, size_t 
L
,

89 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

90 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

91 
uint8_t
 *
cipher
,

92 
uint8_t
 *
tag
, 
size_t
 
ntag
)

94 
uint8_t
 
block
[
CF_MAXBLOCK
];

96 
	`assert
(
ntag
 >= 4 && ntag <= 16 && ntag % 2 == 0);

97 
	`assert
(
L
 >= 2 && L <= 8);

98 
	`assert
(
nnonce
 == 
prp
->
blocksz
 - 
L
 - 1);

100 
cf_cbcmac_stream
 
cm
;

101 
	`cf_cbcmac_stream_init
(&
cm
, 
prp
, 
prpctx
);

104 
	`add_block0
(&
cm
, 
block
, 
prp
->
blocksz
,

105 
nonce
, 
nnonce
,

106 
L
, 
nplain
, 
nheader
, 
ntag
);

109 if (
nheader
)

110 
	`add_aad
(&
cm
, 
block
, 
header
, 
nheader
);

113 
	`cf_cbcmac_stream_update
(&
cm
, 
plain
, 
nplain
);

114 
	`zero_pad
(&
cm
);

117 
	`cf_cbcmac_stream_nopad_final
(&
cm
, 
block
);

121 
uint8_t
 
ctr_nonce
[
CF_MAXBLOCK
];

122 
	`build_ctr_nonce
(
ctr_nonce
, 
L
, 
nonce
, 
nnonce
);

124 
cf_ctr
 
ctr
;

125 
	`cf_ctr_init
(&
ctr
, 
prp
, 
prpctx
, 
ctr_nonce
);

126 
	`cf_ctr_custom_counter
(&
ctr
, 
prp
->
blocksz
 - 
L
, L);

129 
	`cf_ctr_cipher
(&
ctr
, 
block
, block, 
prp
->
blocksz
);

130 
	`memcpy
(
tag
, 
block
, 
ntag
);

133 
	`cf_ctr_cipher
(&
ctr
, 
plain
, 
cipher
, 
nplain
);

134 
	}
}

136 int 
	$cf_ccm_decrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

137 const 
uint8_t
 *
cipher
, 
size_t
 
ncipher
, size_t 
L
,

138 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

139 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

140 const 
uint8_t
 *
tag
, 
size_t
 
ntag
,

141 
uint8_t
 *
plain
)

143 
uint8_t
 
block
[
CF_MAXBLOCK
];

145 
	`assert
(
ntag
 >= 4 && ntag <= 16 && ntag % 2 == 0);

146 
	`assert
(
L
 >= 2 && L <= 8);

147 
	`assert
(
nnonce
 == 
prp
->
blocksz
 - 
L
 - 1);

149 
uint8_t
 
ctr_nonce
[
CF_MAXBLOCK
];

150 
	`build_ctr_nonce
(
ctr_nonce
, 
L
, 
nonce
, 
nnonce
);

152 
cf_ctr
 
ctr
;

153 
	`cf_ctr_init
(&
ctr
, 
prp
, 
prpctx
, 
ctr_nonce
);

154 
	`cf_ctr_custom_counter
(&
ctr
, 
prp
->
blocksz
 - 
L
, L);

157 
uint8_t
 
plain_tag
[
CF_MAXBLOCK
];

158 
	`cf_ctr_cipher
(&
ctr
, 
tag
, 
plain_tag
, 
ntag
);

159 
	`cf_ctr_discard_block
(&
ctr
);

162 
	`cf_ctr_cipher
(&
ctr
, 
cipher
, 
plain
, 
ncipher
);

164 
cf_cbcmac_stream
 
cm
;

165 
	`cf_cbcmac_stream_init
(&
cm
, 
prp
, 
prpctx
);

168 
	`add_block0
(&
cm
, 
block
, 
prp
->
blocksz
,

169 
nonce
, 
nnonce
,

170 
L
, 
ncipher
, 
nheader
, 
ntag
);

172 if (
nheader
)

173 
	`add_aad
(&
cm
, 
block
, 
header
, 
nheader
);

175 
	`cf_cbcmac_stream_update
(&
cm
, 
plain
, 
ncipher
);

176 
	`zero_pad
(&
cm
);

179 
	`cf_cbcmac_stream_nopad_final
(&
cm
, 
block
);

181 int 
err
 = 0;

183 if (!
	`mem_eq
(
block
, 
plain_tag
, 
ntag
))

185 
err
 = 1;

186 
	`mem_clean
(
plain
, 
ncipher
);

189 
	`mem_clean
(
block
, sizeof block);

190 
	`mem_clean
(
plain_tag
, sizeof plain_tag);

191 return 
err
;

192 
	}
}

	@deps/picotls/deps/cifra/src/cf_config.h

15 #ifndef 
CF_CONFIG_H


16 #define 
	#CF_CONFIG_H


	)

33 #ifndef 
CF_SIDE_CHANNEL_PROTECTION


34 #define 
	#CF_SIDE_CHANNEL_PROTECTION
 1

	)

42 #ifndef 
CF_TIME_SIDE_CHANNEL_PROTECTION


43 #define 
	#CF_TIME_SIDE_CHANNEL_PROTECTION
 
CF_SIDE_CHANNEL_PROTECTION


	)

55 #ifndef 
CF_CACHE_SIDE_CHANNEL_PROTECTION


56 #define 
	#CF_CACHE_SIDE_CHANNEL_PROTECTION
 
CF_SIDE_CHANNEL_PROTECTION


	)

	@deps/picotls/deps/cifra/src/chacha20.c

15 #include 
	~"bitops.h
"

16 #include 
	~"salsa20.h
"

17 #include 
	~"blockwise.h
"

18 #include 
	~"tassert.h
"

20 #include 
	~<string.h
>

21 #include 
	~<stdlib.h
>

23 void 
	$cf_chacha20_core
(const 
uint8_t
 
key0
[16],

24 const 
uint8_t
 
key1
[16],

25 const 
uint8_t
 
nonce
[16],

26 const 
uint8_t
 
constant
[16],

27 
uint8_t
 
out
[64])

29 
uint32_t
 
z0
, 
z1
, 
z2
, 
z3
, 
z4
, 
z5
, 
z6
, 
z7
,

30 
z8
, 
z9
, 
za
, 
zb
, 
zc
, 
zd
, 
ze
, 
zf
;

32 
uint32_t
 
x0
 = 
z0
 = 
	`read32_le
(
constant
 + 0),

33 
x1
 = 
z1
 = 
	`read32_le
(
constant
 + 4),

34 
x2
 = 
z2
 = 
	`read32_le
(
constant
 + 8),

35 
x3
 = 
z3
 = 
	`read32_le
(
constant
 + 12),

36 
x4
 = 
z4
 = 
	`read32_le
(
key0
 + 0),

37 
x5
 = 
z5
 = 
	`read32_le
(
key0
 + 4),

38 
x6
 = 
z6
 = 
	`read32_le
(
key0
 + 8),

39 
x7
 = 
z7
 = 
	`read32_le
(
key0
 + 12),

40 
x8
 = 
z8
 = 
	`read32_le
(
key1
 + 0),

41 
x9
 = 
z9
 = 
	`read32_le
(
key1
 + 4),

42 
xa
 = 
za
 = 
	`read32_le
(
key1
 + 8),

43 
xb
 = 
zb
 = 
	`read32_le
(
key1
 + 12),

44 
xc
 = 
zc
 = 
	`read32_le
(
nonce
 + 0),

45 
xd
 = 
zd
 = 
	`read32_le
(
nonce
 + 4),

46 
xe
 = 
ze
 = 
	`read32_le
(
nonce
 + 8),

47 
xf
 = 
zf
 = 
	`read32_le
(
nonce
 + 12);

49 #define 
	#QUARTER
(
a
, 
b
, 
c
, 
d
) \

50 
a
 += 
b
; 
d
 = 
	`rotl32
(d ^ a, 16); \

51 
c
 += 
d
; 
b
 = 
	`rotl32
(b ^ c, 12); \

52 
a
 += 
b
; 
d
 = 
	`rotl32
(d ^ a, 8); \

53 
c
 += 
d
; 
b
 = 
	`rotl32
(b ^ c, 7);

	)

55 int 
i
;

56 for (
i
 = 0; i < 10; i++)

58 
	`QUARTER
(
z0
, 
z4
, 
z8
, 
zc
);

59 
	`QUARTER
(
z1
, 
z5
, 
z9
, 
zd
);

60 
	`QUARTER
(
z2
, 
z6
, 
za
, 
ze
);

61 
	`QUARTER
(
z3
, 
z7
, 
zb
, 
zf
);

62 
	`QUARTER
(
z0
, 
z5
, 
za
, 
zf
);

63 
	`QUARTER
(
z1
, 
z6
, 
zb
, 
zc
);

64 
	`QUARTER
(
z2
, 
z7
, 
z8
, 
zd
);

65 
	`QUARTER
(
z3
, 
z4
, 
z9
, 
ze
);

68 
x0
 += 
z0
;

69 
x1
 += 
z1
;

70 
x2
 += 
z2
;

71 
x3
 += 
z3
;

72 
x4
 += 
z4
;

73 
x5
 += 
z5
;

74 
x6
 += 
z6
;

75 
x7
 += 
z7
;

76 
x8
 += 
z8
;

77 
x9
 += 
z9
;

78 
xa
 += 
za
;

79 
xb
 += 
zb
;

80 
xc
 += 
zc
;

81 
xd
 += 
zd
;

82 
xe
 += 
ze
;

83 
xf
 += 
zf
;

85 
	`write32_le
(
x0
, 
out
 + 0);

86 
	`write32_le
(
x1
, 
out
 + 4);

87 
	`write32_le
(
x2
, 
out
 + 8);

88 
	`write32_le
(
x3
, 
out
 + 12);

89 
	`write32_le
(
x4
, 
out
 + 16);

90 
	`write32_le
(
x5
, 
out
 + 20);

91 
	`write32_le
(
x6
, 
out
 + 24);

92 
	`write32_le
(
x7
, 
out
 + 28);

93 
	`write32_le
(
x8
, 
out
 + 32);

94 
	`write32_le
(
x9
, 
out
 + 36);

95 
	`write32_le
(
xa
, 
out
 + 40);

96 
	`write32_le
(
xb
, 
out
 + 44);

97 
	`write32_le
(
xc
, 
out
 + 48);

98 
	`write32_le
(
xd
, 
out
 + 52);

99 
	`write32_le
(
xe
, 
out
 + 56);

100 
	`write32_le
(
xf
, 
out
 + 60);

101 
	}
}

103 static const 
uint8_t
 *
	gchacha20_tau
 = (const uint8_t *) "expand 16-byte k";

104 static const 
uint8_t
 *
	gchacha20_sigma
 = (const uint8_t *) "expand 32-byte k";

106 static void 
	$set_key
(
cf_chacha20_ctx
 *
ctx
, const 
uint8_t
 *
key
, 
size_t
 
nkey
)

108 switch (
nkey
)

111 
	`memcpy
(
ctx
->
key0
, 
key
, 16);

112 
	`memcpy
(
ctx
->
key1
, 
key
, 16);

113 
ctx
->
constant
 = 
chacha20_tau
;

116 
	`memcpy
(
ctx
->
key0
, 
key
, 16);

117 
	`memcpy
(
ctx
->
key1
, 
key
 + 16, 16);

118 
ctx
->
constant
 = 
chacha20_sigma
;

121 
	`abort
();

123 
	}
}

125 void 
	$cf_chacha20_init
(
cf_chacha20_ctx
 *
ctx
, const 
uint8_t
 *
key
, 
size_t
 
nkey
, const uint8_t 
nonce
[8])

127 
	`set_key
(
ctx
, 
key
, 
nkey
);

128 
	`memset
(
ctx
->
nonce
, 0, sizeof ctx->nonce);

129 
	`memcpy
(
ctx
->
nonce
 + 8, nonce, 8);

130 
ctx
->
nblock
 = 0;

131 
ctx
->
ncounter
 = 8;

132 
	}
}

134 void 
	$cf_chacha20_init_custom
(
cf_chacha20_ctx
 *
ctx
, const 
uint8_t
 *
key
, 
size_t
 
nkey
,

135 const 
uint8_t
 
nonce
[16], 
size_t
 
ncounter
)

137 
	`assert
(
ncounter
 > 0);

138 
	`set_key
(
ctx
, 
key
, 
nkey
);

139 
	`memcpy
(
ctx
->
nonce
, nonce, sizeof ctx->nonce);

140 
ctx
->
nblock
 = 0;

141 
ctx
->
ncounter
 = ncounter;

142 
	}
}

144 static void 
	$cf_chacha20_next_block
(void *
vctx
, 
uint8_t
 *
out
)

146 
cf_chacha20_ctx
 *
ctx
 = 
vctx
;

147 
	`cf_chacha20_core
(
ctx
->
key0
,

148 
ctx
->
key1
,

149 
ctx
->
nonce
,

150 
ctx
->
constant
,

151 
out
);

152 
	`incr_le
(
ctx
->
nonce
, ctx->
ncounter
);

153 
	}
}

155 void 
	$cf_chacha20_cipher
(
cf_chacha20_ctx
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
bytes
)

157 
	`cf_blockwise_xor
(
ctx
->
block
, &ctx->
nblock
, 64,

158 
input
, 
output
, 
bytes
,

159 
cf_chacha20_next_block
,

160 
ctx
);

161 
	}
}

	@deps/picotls/deps/cifra/src/chacha20poly1305.c

15 #include 
	~"chacha20poly1305.h
"

16 #include 
	~"salsa20.h
"

17 #include 
	~"poly1305.h
"

18 #include 
	~"bitops.h
"

19 #include 
	~"handy.h
"

21 #define 
	#ENCRYPT
 1

	)

22 #define 
	#DECRYPT
 0

	)

24 #define 
	#SUCCESS
 0

	)

25 #define 
	#FAILURE
 1

	)

27 static int 
	$process
(const 
uint8_t
 
key
[32],

28 const 
uint8_t
 
nonce
[12],

29 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

30 const 
uint8_t
 *
input
, 
size_t
 
nbytes
,

31 
uint8_t
 *
output
,

32 int 
mode
,

33 
uint8_t
 
tag
[16])

38 
uint8_t
 
fullnonce
[16] = { 0 };

39 
	`memcpy
(
fullnonce
 + 4, 
nonce
, 12);

41 
uint8_t
 
polykey
[32] = { 0 };

42 
cf_chacha20_ctx
 
chacha
;

43 
	`cf_chacha20_init_custom
(&
chacha
, 
key
, 32, 
fullnonce
, 4);

44 
	`cf_chacha20_cipher
(&
chacha
, 
polykey
, polykey, sizeof polykey);

47 
cf_poly1305
 
poly
;

48 
	`cf_poly1305_init
(&
poly
, 
polykey
, polykey + 16);

49 
	`mem_clean
(
polykey
, sizeof polykey);

52 
	`cf_chacha20_cipher
(&
chacha
, 
polykey
, polykey, sizeof polykey);

53 
	`mem_clean
(
polykey
, sizeof polykey);

57 
uint8_t
 
padbuf
[16] = { 0 };

59 #define 
	#PADLEN
(
x
) (16 - ((x) & 0xf))

	)

62 
	`cf_poly1305_update
(&
poly
, 
header
, 
nheader
);

63 
	`cf_poly1305_update
(&
poly
, 
padbuf
, 
	`PADLEN
(
nheader
));

66 if (
mode
 == 
ENCRYPT
)

70 
	`cf_chacha20_cipher
(&
chacha
, 
input
, 
output
, 
nbytes
);

71 
	`cf_poly1305_update
(&
poly
, 
output
, 
nbytes
);

75 
	`cf_poly1305_update
(&
poly
, 
input
, 
nbytes
);

79 
	`cf_poly1305_update
(&
poly
, 
padbuf
, 
	`PADLEN
(
nbytes
));

82 
	`write64_le
(
nheader
, 
padbuf
);

83 
	`write64_le
(
nbytes
, 
padbuf
 + 8);

84 
	`cf_poly1305_update
(&
poly
, 
padbuf
, sizeof padbuf);

88 if (
mode
 == 
ENCRYPT
)

90 
	`cf_poly1305_finish
(&
poly
, 
tag
);

91 
	`mem_clean
(&
chacha
, sizeof chacha);

92 return 
SUCCESS
;

97 
uint8_t
 
checktag
[16];

98 
	`cf_poly1305_finish
(&
poly
, 
checktag
);

100 if (
	`mem_eq
(
checktag
, 
tag
, sizeof checktag))

102 
	`cf_chacha20_cipher
(&
chacha
, 
input
, 
output
, 
nbytes
);

103 
	`mem_clean
(&
chacha
, sizeof chacha);

104 
	`mem_clean
(
checktag
, sizeof checktag);

105 return 
SUCCESS
;

107 
	`mem_clean
(
output
, 
nbytes
);

108 
	`mem_clean
(&
chacha
, sizeof chacha);

109 
	`mem_clean
(
checktag
, sizeof checktag);

110 return 
FAILURE
;

112 
	}
}

114 void 
	$cf_chacha20poly1305_encrypt
(const 
uint8_t
 
key
[32],

115 const 
uint8_t
 
nonce
[12],

116 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

117 const 
uint8_t
 *
plaintext
, 
size_t
 
nbytes
,

118 
uint8_t
 *
ciphertext
,

119 
uint8_t
 
tag
[16])

121 
	`process
(
key
,

122 
nonce
,

123 
header
, 
nheader
,

124 
plaintext
, 
nbytes
,

125 
ciphertext
,

126 
ENCRYPT
,

127 
tag
);

128 
	}
}

130 int 
	$cf_chacha20poly1305_decrypt
(const 
uint8_t
 
key
[32],

131 const 
uint8_t
 
nonce
[12],

132 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

133 const 
uint8_t
 *
ciphertext
, 
size_t
 
nbytes
,

134 const 
uint8_t
 
tag
[16],

135 
uint8_t
 *
plaintext
)

137 
uint8_t
 
ourtag
[16];

138 
	`memcpy
(
ourtag
, 
tag
, sizeof ourtag);

140 return 
	`process
(
key
,

141 
nonce
,

142 
header
, 
nheader
,

143 
ciphertext
, 
nbytes
,

144 
plaintext
,

145 
DECRYPT
,

146 
ourtag
);

147 
	}
}

	@deps/picotls/deps/cifra/src/chacha20poly1305.h

15 #ifndef 
CHACHA20POLY1305_H


16 #define 
	#CHACHA20POLY1305_H


	)

18 #include 
	~<stdint.h
>

19 #include 
	~<stddef.h
>

45 void 
cf_chacha20poly1305_encrypt
(const 
uint8_t
 
key
[32],

46 const 
uint8_t
 
nonce
[12],

47 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

48 const 
uint8_t
 *
plaintext
, 
size_t
 
nbytes
,

49 
uint8_t
 *
ciphertext
,

50 
uint8_t
 
tag
[16]);

66 int 
cf_chacha20poly1305_decrypt
(const 
uint8_t
 
key
[32],

67 const 
uint8_t
 
nonce
[12],

68 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

69 const 
uint8_t
 *
ciphertext
, 
size_t
 
nbytes
,

70 const 
uint8_t
 
tag
[16],

71 
uint8_t
 *
plaintext
);

	@deps/picotls/deps/cifra/src/chash.c

15 #include 
	~"chash.h
"

16 #include 
	~"handy.h
"

17 #include 
	~"tassert.h
"

19 void 
	$cf_hash
(const 
cf_chash
 *
h
, const void *
m
, 
size_t
 
nm
, 
uint8_t
 *
out
)

21 
cf_chash_ctx
 
ctx
;

22 
	`assert
(
h
);

23 
h
->
	`init
(&
ctx
);

24 
h
->
	`update
(&
ctx
, 
m
, 
nm
);

25 
h
->
	`digest
(&
ctx
, 
out
);

26 
	`mem_clean
(&
ctx
, sizeof ctx);

27 
	}
}

	@deps/picotls/deps/cifra/src/chash.h

15 #ifndef 
CHASH_H


16 #define 
	#CHASH_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

38 typedef void (*
	tcf_chash_init
)(void *
	tctx
);

51 typedef void (*
	tcf_chash_update
)(void *
	tctx
, const void *
	tdata
, 
	tsize_t
 
	tcount
);

69 typedef void (*
	tcf_chash_digest
)(const void *
	tctx
, 
	tuint8_t
 *
	thash
);

92 
size_t
 
hashsz
;

93 
size_t
 
blocksz
;

95 
cf_chash_init
 
init
;

96 
cf_chash_update
 
update
;

97 
cf_chash_digest
 
digest
;

98 } 
	tcf_chash
;

104 #define 
	#CF_CHASH_MAXCTX
 360

	)

108 #define 
	#CF_CHASH_MAXBLK
 128

	)

112 #define 
	#CF_MAXHASH
 64

	)

118 
uint8_t
 
ctx
[
CF_CHASH_MAXCTX
];

119 
uint16_t
 
u16
;

120 
uint32_t
 
u32
;

121 
uint64_t
 
u64
;

122 } 
	tcf_chash_ctx
;

135 void 
	`cf_hash
(const 
cf_chash
 *
h
, const void *
m
, 
size_t
 
nm
, 
uint8_t
 *
out
);

	@deps/picotls/deps/cifra/src/cmac.c

15 #include 
	~"handy.h
"

16 #include 
	~"prp.h
"

17 #include 
	~"modes.h
"

18 #include 
	~"bitops.h
"

19 #include 
	~"blockwise.h
"

20 #include 
	~"gf128.h
"

21 #include 
	~"tassert.h
"

23 #include 
	~<string.h
>

25 void 
	$cf_cmac_init
(
cf_cmac
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
)

27 
uint8_t
 
L
[
CF_MAXBLOCK
];

28 
	`assert
(
prp
->
blocksz
 == 16);

30 
	`mem_clean
(
ctx
, sizeof *ctx);

33 
	`mem_clean
(
L
, 
prp
->
blocksz
);

34 
prp
->
	`encrypt
(
prpctx
, 
L
, L);

37 
cf_gf128
 
gf
;

38 
	`cf_gf128_frombytes_be
(
L
, 
gf
);

39 
	`cf_gf128_double
(
gf
, gf);

40 
	`cf_gf128_tobytes_be
(
gf
, 
ctx
->
B
);

43 
	`cf_gf128_double
(
gf
, gf);

44 
	`cf_gf128_tobytes_be
(
gf
, 
ctx
->
P
);

46 
ctx
->
prp
 = prp;

47 
ctx
->
prpctx
 = prpctx;

48 
	}
}

50 void 
	$cf_cmac_sign
(
cf_cmac
 *
ctx
, const 
uint8_t
 *
data
, 
size_t
 
len
, uint8_t 
out
[
CF_MAXBLOCK
])

52 
cf_cmac_stream
 
stream
;

53 
stream
.
cmac
 = *
ctx
;

54 
	`cf_cmac_stream_reset
(&
stream
);

55 
	`cf_cmac_stream_update
(&
stream
, 
data
, 
len
, 1);

56 
	`cf_cmac_stream_final
(&
stream
, 
out
);

57 
	}
}

59 void 
	$cf_cmac_stream_init
(
cf_cmac_stream
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
)

61 
	`cf_cmac_init
(&
ctx
->
cmac
, 
prp
, 
prpctx
);

62 
	`cf_cmac_stream_reset
(
ctx
);

63 
	}
}

65 void 
	$cf_cmac_stream_reset
(
cf_cmac_stream
 *
ctx
)

67 
uint8_t
 
iv_zero
[
CF_MAXBLOCK
] = { 0 };

68 
	`cf_cbc_init
(&
ctx
->
cbc
, ctx->
cmac
.
prp
, ctx->cmac.
prpctx
, 
iv_zero
);

69 
	`mem_clean
(
ctx
->
buffer
, sizeof ctx->buffer);

70 
ctx
->
used
 = 0;

71 
ctx
->
processed
 = 0;

72 
ctx
->
finalised
 = 0;

73 
	}
}

75 static void 
	$cmac_process
(void *
vctx
, const 
uint8_t
 *
block
)

77 
cf_cmac_stream
 *
ctx
 = 
vctx
;

78 
uint8_t
 
output
[
CF_MAXBLOCK
];

79 
	`cf_cbc_encrypt
(&
ctx
->
cbc
, 
block
, 
output
, 1);

80 
ctx
->
processed
 += ctx->
cmac
.
prp
->
blocksz
;

81 
	}
}

83 static void 
	$cmac_process_final
(
cf_cmac_stream
 *
ctx
, const 
uint8_t
 *
block
,

84 const 
uint8_t
 *
xor
)

86 
uint8_t
 
input
[
CF_MAXBLOCK
];

87 
uint8_t
 
output
[
CF_MAXBLOCK
];

88 
	`xor_bb
(
input
, 
block
, 
xor
, 
ctx
->
cmac
.
prp
->
blocksz
);

89 
	`cf_cbc_encrypt
(&
ctx
->
cbc
, 
input
, 
output
, 1);

90 
ctx
->
processed
 += ctx->
cmac
.
prp
->
blocksz
;

92 
	}
}

94 static void 
	$cmac_process_final_nopad
(void *
vctx
, const 
uint8_t
 *
block
)

96 
cf_cmac_stream
 *
ctx
 = 
vctx
;

97 
	`cmac_process_final
(
ctx
, 
block
, ctx->
cmac
.
B
);

98 
ctx
->
finalised
 = 1;

99 
	}
}

101 static void 
	$cmac_process_final_pad
(void *
vctx
, const 
uint8_t
 *
block
)

103 
cf_cmac_stream
 *
ctx
 = 
vctx
;

104 
	`cmac_process_final
(
ctx
, 
block
, ctx->
cmac
.
P
);

105 
ctx
->
finalised
 = 1;

106 
	}
}

108 void 
	$cf_cmac_stream_update
(
cf_cmac_stream
 *
ctx
, const 
uint8_t
 *
data
, 
size_t
 
len
, int 
isfinal
)

110 
size_t
 
blocksz
 = 
ctx
->
cmac
.
prp
->blocksz;

111 
cf_blockwise_in_fn
 
final_fn
 = 
cmac_process
;

112 int 
needpad
 = 0;

114 if (
isfinal
)

116 int 
whole_number_of_blocks
 = ((
len
 + 
ctx
->
used
) & 0xf) == 0;

117 int 
empty_message
 = 
len
 == 0 && 
ctx
->
used
 == 0 && ctx->
processed
 == 0;

119 
	`assert
(!
ctx
->
finalised
);

120 
	`assert
(
len
 != 0 || 
empty_message
);

124 if (
whole_number_of_blocks
 && !
empty_message
)

125 
final_fn
 = 
cmac_process_final_nopad
;

127 
needpad
 = 1;

131 
	`cf_blockwise_accumulate_final
(
ctx
->
buffer
, &ctx->
used
, 
blocksz
,

132 
data
, 
len
,

133 
cmac_process
,

134 
final_fn
, 
ctx
);

137 if (
needpad
)

139 
	`cf_blockwise_acc_pad
(
ctx
->
buffer
, &ctx->
used
, 
blocksz
,

140 0x80, 0x00, 0x00, 
blocksz
 - 
ctx
->
used
,

141 
cmac_process_final_pad
, 
ctx
);

143 
	}
}

145 void 
	$cf_cmac_stream_final
(
cf_cmac_stream
 *
ctx
, 
uint8_t
 
out
[
CF_MAXBLOCK
])

147 
	`assert
(
ctx
->
finalised
);

148 
	`memcpy
(
out
, 
ctx
->
cbc
.
block
, ctx->
cmac
.
prp
->
blocksz
);

149 
	}
}

	@deps/picotls/deps/cifra/src/curve25519.c

15 #if 
defined
(
CORTEX_M0
) || defined(
CORTEX_M3
) || defined(
CORTEX_M4
)

16 #include 
	~"arm/unacl/scalarmult.c
"

18 void 
	$cf_curve25519_mul
(
uint8_t
 
out
[32], const uint8_t 
scalar
[32], const uint8_t 
point
[32])

20 
	`crypto_scalarmult_curve25519
(
out
, 
scalar
, 
point
);

21 
	}
}

23 void 
	$cf_curve25519_mul_base
(
uint8_t
 
out
[32], const uint8_t 
scalar
[32])

25 
	`crypto_scalarmult_curve25519_base
(
out
, 
scalar
);

26 
	}
}

28 #include 
	~"curve25519.tweetnacl.c
"

	@deps/picotls/deps/cifra/src/curve25519.donna.c

48 #include 
	~"curve25519.h
"

50 #include 
	~<string.h
>

51 #include 
	~<stdint.h
>

53 #ifdef 
_MSC_VER


54 #define 
	#inline
 
__inline


	)

57 typedef 
uint8_t
 
	tu8
;

58 typedef 
int32_t
 
	ts32
;

59 typedef 
int64_t
 
	tlimb
;

70 static void 
	$fsum
(
limb
 *
output
, const limb *
in
) {

71 unsigned 
i
;

72 for (
i
 = 0; i < 10; i += 2) {

73 
output
[0+
i
] = output[0+i] + 
in
[0+i];

74 
output
[1+
i
] = output[1+i] + 
in
[1+i];

76 
	}
}

80 static void 
	$fdifference
(
limb
 *
output
, const limb *
in
) {

81 unsigned 
i
;

82 for (
i
 = 0; i < 10; ++i) {

83 
output
[
i
] = 
in
[i] - output[i];

85 
	}
}

88 static void 
	$fscalar_product
(
limb
 *
output
, const limb *
in
, const limb 
scalar
) {

89 unsigned 
i
;

90 for (
i
 = 0; i < 10; ++i) {

91 
output
[
i
] = 
in
[i] * 
scalar
;

93 
	}
}

101 static void 
	$fproduct
(
limb
 *
output
, const limb *
in2
, const limb *
in
) {

102 
output
[0] = ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[0]);

103 
output
[1] = ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[1]) +

104 ((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[0]);

105 
output
[2] = 2 * ((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[1]) +

106 ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[2]) +

107 ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[0]);

108 
output
[3] = ((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[2]) +

109 ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[1]) +

110 ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[3]) +

111 ((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[0]);

112 
output
[4] = ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[2]) +

113 2 * (((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[3]) +

114 ((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[1])) +

115 ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[4]) +

116 ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[0]);

117 
output
[5] = ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[3]) +

118 ((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[2]) +

119 ((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[4]) +

120 ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[1]) +

121 ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[5]) +

122 ((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[0]);

123 
output
[6] = 2 * (((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[3]) +

124 ((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[5]) +

125 ((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[1])) +

126 ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[4]) +

127 ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[2]) +

128 ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[6]) +

129 ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[0]);

130 
output
[7] = ((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[4]) +

131 ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[3]) +

132 ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[5]) +

133 ((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[2]) +

134 ((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[6]) +

135 ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[1]) +

136 ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[7]) +

137 ((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[0]);

138 
output
[8] = ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[4]) +

139 2 * (((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[5]) +

140 ((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[3]) +

141 ((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[7]) +

142 ((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[1])) +

143 ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[6]) +

144 ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[2]) +

145 ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[8]) +

146 ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[0]);

147 
output
[9] = ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[5]) +

148 ((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[4]) +

149 ((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[6]) +

150 ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[3]) +

151 ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[7]) +

152 ((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[2]) +

153 ((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[8]) +

154 ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[1]) +

155 ((
limb
) ((
s32
) 
in2
[0])) * ((s32) 
in
[9]) +

156 ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[0]);

157 
output
[10] = 2 * (((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[5]) +

158 ((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[7]) +

159 ((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[3]) +

160 ((
limb
) ((
s32
) 
in2
[1])) * ((s32) 
in
[9]) +

161 ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[1])) +

162 ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[6]) +

163 ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[4]) +

164 ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[8]) +

165 ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[2]);

166 
output
[11] = ((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[6]) +

167 ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[5]) +

168 ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[7]) +

169 ((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[4]) +

170 ((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[8]) +

171 ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[3]) +

172 ((
limb
) ((
s32
) 
in2
[2])) * ((s32) 
in
[9]) +

173 ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[2]);

174 
output
[12] = ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[6]) +

175 2 * (((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[7]) +

176 ((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[5]) +

177 ((
limb
) ((
s32
) 
in2
[3])) * ((s32) 
in
[9]) +

178 ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[3])) +

179 ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[8]) +

180 ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[4]);

181 
output
[13] = ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[7]) +

182 ((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[6]) +

183 ((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[8]) +

184 ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[5]) +

185 ((
limb
) ((
s32
) 
in2
[4])) * ((s32) 
in
[9]) +

186 ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[4]);

187 
output
[14] = 2 * (((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[7]) +

188 ((
limb
) ((
s32
) 
in2
[5])) * ((s32) 
in
[9]) +

189 ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[5])) +

190 ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[8]) +

191 ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[6]);

192 
output
[15] = ((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[8]) +

193 ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[7]) +

194 ((
limb
) ((
s32
) 
in2
[6])) * ((s32) 
in
[9]) +

195 ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[6]);

196 
output
[16] = ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[8]) +

197 2 * (((
limb
) ((
s32
) 
in2
[7])) * ((s32) 
in
[9]) +

198 ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[7]));

199 
output
[17] = ((
limb
) ((
s32
) 
in2
[8])) * ((s32) 
in
[9]) +

200 ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[8]);

201 
output
[18] = 2 * ((
limb
) ((
s32
) 
in2
[9])) * ((s32) 
in
[9]);

202 
	}
}

208 static void 
	$freduce_degree
(
limb
 *
output
) {

213 
output
[8] += output[18] << 4;

214 
output
[8] += output[18] << 1;

215 
output
[8] += output[18];

216 
output
[7] += output[17] << 4;

217 
output
[7] += output[17] << 1;

218 
output
[7] += output[17];

219 
output
[6] += output[16] << 4;

220 
output
[6] += output[16] << 1;

221 
output
[6] += output[16];

222 
output
[5] += output[15] << 4;

223 
output
[5] += output[15] << 1;

224 
output
[5] += output[15];

225 
output
[4] += output[14] << 4;

226 
output
[4] += output[14] << 1;

227 
output
[4] += output[14];

228 
output
[3] += output[13] << 4;

229 
output
[3] += output[13] << 1;

230 
output
[3] += output[13];

231 
output
[2] += output[12] << 4;

232 
output
[2] += output[12] << 1;

233 
output
[2] += output[12];

234 
output
[1] += output[11] << 4;

235 
output
[1] += output[11] << 1;

236 
output
[1] += output[11];

237 
output
[0] += output[10] << 4;

238 
output
[0] += output[10] << 1;

239 
output
[0] += output[10];

240 
	}
}

249 static 
inline
 
limb


250 
	$div_by_2_26
(const 
limb
 
v
)

253 const 
uint32_t
 
highword
 = (uint32_t) (((
uint64_t
) 
v
) >> 32);

255 const 
int32_t
 
sign
 = ((int32_t) 
highword
) >> 31;

257 const 
int32_t
 
roundoff
 = ((
uint32_t
) 
sign
) >> 6;

259 return (
v
 + 
roundoff
) >> 26;

260 
	}
}

265 static 
inline
 
limb


266 
	$div_by_2_25
(const 
limb
 
v
)

269 const 
uint32_t
 
highword
 = (uint32_t) (((
uint64_t
) 
v
) >> 32);

271 const 
int32_t
 
sign
 = ((int32_t) 
highword
) >> 31;

273 const 
int32_t
 
roundoff
 = ((
uint32_t
) 
sign
) >> 7;

275 return (
v
 + 
roundoff
) >> 25;

276 
	}
}

281 static void 
	$freduce_coefficients
(
limb
 *
output
) {

282 unsigned 
i
;

284 
output
[10] = 0;

286 for (
i
 = 0; i < 10; i += 2) {

287 
limb
 
over
 = 
	`div_by_2_26
(
output
[
i
]);

292 
output
[
i
] -= 
over
 << 26;

293 
output
[
i
+1] += 
over
;

301 
over
 = 
	`div_by_2_25
(
output
[
i
+1]);

302 
output
[
i
+1] -= 
over
 << 25;

303 
output
[
i
+2] += 
over
;

306 
output
[0] += output[10] << 4;

307 
output
[0] += output[10] << 1;

308 
output
[0] += output[10];

310 
output
[10] = 0;

315 
limb
 
over
 = 
	`div_by_2_26
(
output
[0]);

316 
output
[0] -= 
over
 << 26;

317 
output
[1] += 
over
;

322 
	}
}

331 
	$fmul
(
limb
 *
output
, const limb *
in
, const limb *
in2
) {

332 
limb
 
t
[19];

333 
	`fproduct
(
t
, 
in
, 
in2
);

335 
	`freduce_degree
(
t
);

336 
	`freduce_coefficients
(
t
);

338 
	`memcpy
(
output
, 
t
, sizeof(
limb
) * 10);

339 
	}
}

347 static void 
	$fsquare_inner
(
limb
 *
output
, const limb *
in
) {

348 
output
[0] = ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[0]);

349 
output
[1] = 2 * ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[1]);

350 
output
[2] = 2 * (((
limb
) ((
s32
) 
in
[1])) * ((s32) in[1]) +

351 ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[2]));

352 
output
[3] = 2 * (((
limb
) ((
s32
) 
in
[1])) * ((s32) in[2]) +

353 ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[3]));

354 
output
[4] = ((
limb
) ((
s32
) 
in
[2])) * ((s32) in[2]) +

355 4 * ((
limb
) ((
s32
) 
in
[1])) * ((s32) in[3]) +

356 2 * ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[4]);

357 
output
[5] = 2 * (((
limb
) ((
s32
) 
in
[2])) * ((s32) in[3]) +

358 ((
limb
) ((
s32
) 
in
[1])) * ((s32) in[4]) +

359 ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[5]));

360 
output
[6] = 2 * (((
limb
) ((
s32
) 
in
[3])) * ((s32) in[3]) +

361 ((
limb
) ((
s32
) 
in
[2])) * ((s32) in[4]) +

362 ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[6]) +

363 2 * ((
limb
) ((
s32
) 
in
[1])) * ((s32) in[5]));

364 
output
[7] = 2 * (((
limb
) ((
s32
) 
in
[3])) * ((s32) in[4]) +

365 ((
limb
) ((
s32
) 
in
[2])) * ((s32) in[5]) +

366 ((
limb
) ((
s32
) 
in
[1])) * ((s32) in[6]) +

367 ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[7]));

368 
output
[8] = ((
limb
) ((
s32
) 
in
[4])) * ((s32) in[4]) +

369 2 * (((
limb
) ((
s32
) 
in
[2])) * ((s32) in[6]) +

370 ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[8]) +

371 2 * (((
limb
) ((
s32
) 
in
[1])) * ((s32) in[7]) +

372 ((
limb
) ((
s32
) 
in
[3])) * ((s32) in[5])));

373 
output
[9] = 2 * (((
limb
) ((
s32
) 
in
[4])) * ((s32) in[5]) +

374 ((
limb
) ((
s32
) 
in
[3])) * ((s32) in[6]) +

375 ((
limb
) ((
s32
) 
in
[2])) * ((s32) in[7]) +

376 ((
limb
) ((
s32
) 
in
[1])) * ((s32) in[8]) +

377 ((
limb
) ((
s32
) 
in
[0])) * ((s32) in[9]));

378 
output
[10] = 2 * (((
limb
) ((
s32
) 
in
[5])) * ((s32) in[5]) +

379 ((
limb
) ((
s32
) 
in
[4])) * ((s32) in[6]) +

380 ((
limb
) ((
s32
) 
in
[2])) * ((s32) in[8]) +

381 2 * (((
limb
) ((
s32
) 
in
[3])) * ((s32) in[7]) +

382 ((
limb
) ((
s32
) 
in
[1])) * ((s32) in[9])));

383 
output
[11] = 2 * (((
limb
) ((
s32
) 
in
[5])) * ((s32) in[6]) +

384 ((
limb
) ((
s32
) 
in
[4])) * ((s32) in[7]) +

385 ((
limb
) ((
s32
) 
in
[3])) * ((s32) in[8]) +

386 ((
limb
) ((
s32
) 
in
[2])) * ((s32) in[9]));

387 
output
[12] = ((
limb
) ((
s32
) 
in
[6])) * ((s32) in[6]) +

388 2 * (((
limb
) ((
s32
) 
in
[4])) * ((s32) in[8]) +

389 2 * (((
limb
) ((
s32
) 
in
[5])) * ((s32) in[7]) +

390 ((
limb
) ((
s32
) 
in
[3])) * ((s32) in[9])));

391 
output
[13] = 2 * (((
limb
) ((
s32
) 
in
[6])) * ((s32) in[7]) +

392 ((
limb
) ((
s32
) 
in
[5])) * ((s32) in[8]) +

393 ((
limb
) ((
s32
) 
in
[4])) * ((s32) in[9]));

394 
output
[14] = 2 * (((
limb
) ((
s32
) 
in
[7])) * ((s32) in[7]) +

395 ((
limb
) ((
s32
) 
in
[6])) * ((s32) in[8]) +

396 2 * ((
limb
) ((
s32
) 
in
[5])) * ((s32) in[9]));

397 
output
[15] = 2 * (((
limb
) ((
s32
) 
in
[7])) * ((s32) in[8]) +

398 ((
limb
) ((
s32
) 
in
[6])) * ((s32) in[9]));

399 
output
[16] = ((
limb
) ((
s32
) 
in
[8])) * ((s32) in[8]) +

400 4 * ((
limb
) ((
s32
) 
in
[7])) * ((s32) in[9]);

401 
output
[17] = 2 * ((
limb
) ((
s32
) 
in
[8])) * ((s32) in[9]);

402 
output
[18] = 2 * ((
limb
) ((
s32
) 
in
[9])) * ((s32) in[9]);

403 
	}
}

413 
	$fsquare
(
limb
 *
output
, const limb *
in
) {

414 
limb
 
t
[19];

415 
	`fsquare_inner
(
t
, 
in
);

419 
	`freduce_degree
(
t
);

420 
	`freduce_coefficients
(
t
);

422 
	`memcpy
(
output
, 
t
, sizeof(
limb
) * 10);

423 
	}
}

427 
	$fexpand
(
limb
 *
output
, const 
u8
 *
input
) {

428 #define 
	#F
(
n
,
start
,
shift
,
mask
) \

429 
output
[
n
] = ((((
limb
) 
input
[
start
 + 0]) | \

430 ((
limb
) 
input
[
start
 + 1]) << 8 | \

431 ((
limb
) 
input
[
start
 + 2]) << 16 | \

432 ((
limb
) 
input
[
start
 + 3]) << 24) >> 
shift
) & 
mask
;

	)

433 
	`F
(0, 0, 0, 0x3ffffff);

434 
	`F
(1, 3, 2, 0x1ffffff);

435 
	`F
(2, 6, 3, 0x3ffffff);

436 
	`F
(3, 9, 5, 0x1ffffff);

437 
	`F
(4, 12, 6, 0x3ffffff);

438 
	`F
(5, 16, 0, 0x1ffffff);

439 
	`F
(6, 19, 1, 0x3ffffff);

440 
	`F
(7, 22, 3, 0x1ffffff);

441 
	`F
(8, 25, 4, 0x3ffffff);

442 
	`F
(9, 28, 6, 0x1ffffff);

443 #undef 
F


444 
	}
}

451 static 
s32
 
	$s32_eq
(
s32
 
a
, s32 
b
) {

452 
a
 = ~(a ^ 
b
);

453 
a
 &= a << 16;

454 
a
 &= a << 8;

455 
a
 &= a << 4;

456 
a
 &= a << 2;

457 
a
 &= a << 1;

458 return 
a
 >> 31;

459 
	}
}

463 static 
s32
 
	$s32_gte
(
s32
 
a
, s32 
b
) {

464 
a
 -= 
b
;

466 return ~(
a
 >> 31);

467 
	}
}

474 
	$fcontract
(
u8
 *
output
, 
limb
 *
input_limbs
) {

475 int 
i
;

476 int 
j
;

477 
s32
 
input
[10];

478 
s32
 
mask
;

481 for (
i
 = 0; i < 10; i++) {

482 
input
[
i
] = 
input_limbs
[i];

485 for (
j
 = 0; j < 2; ++j) {

486 for (
i
 = 0; i < 9; ++i) {

487 if ((
i
 & 1) == 1) {

490 const 
s32
 
mask
 = 
input
[
i
] >> 31;

491 const 
s32
 
carry
 = -((
input
[
i
] & 
mask
) >> 25);

492 
input
[
i
] = input[i] + (
carry
 << 25);

493 
input
[
i
+1] = input[i+1] - 
carry
;

495 const 
s32
 
mask
 = 
input
[
i
] >> 31;

496 const 
s32
 
carry
 = -((
input
[
i
] & 
mask
) >> 26);

497 
input
[
i
] = input[i] + (
carry
 << 26);

498 
input
[
i
+1] = input[i+1] - 
carry
;

505 const 
s32
 
mask
 = 
input
[9] >> 31;

506 const 
s32
 
carry
 = -((
input
[9] & 
mask
) >> 25);

507 
input
[9] = input[9] + (
carry
 << 25);

508 
input
[0] = input[0] - (
carry
 * 19);

529 const 
s32
 
mask
 = 
input
[0] >> 31;

530 const 
s32
 
carry
 = -((
input
[0] & 
mask
) >> 26);

531 
input
[0] = input[0] + (
carry
 << 26);

532 
input
[1] = input[1] - 
carry
;

537 for (
j
 = 0; j < 2; j++) {

538 for (
i
 = 0; i < 9; i++) {

539 if ((
i
 & 1) == 1) {

540 const 
s32
 
carry
 = 
input
[
i
] >> 25;

541 
input
[
i
] &= 0x1ffffff;

542 
input
[
i
+1] += 
carry
;

544 const 
s32
 
carry
 = 
input
[
i
] >> 26;

545 
input
[
i
] &= 0x3ffffff;

546 
input
[
i
+1] += 
carry
;

551 const 
s32
 
carry
 = 
input
[9] >> 25;

552 
input
[9] &= 0x1ffffff;

553 
input
[0] += 19*
carry
;

567 
mask
 = 
	`s32_gte
(
input
[0], 0x3ffffed);

568 for (
i
 = 1; i < 10; i++) {

569 if ((
i
 & 1) == 1) {

570 
mask
 &= 
	`s32_eq
(
input
[
i
], 0x1ffffff);

572 
mask
 &= 
	`s32_eq
(
input
[
i
], 0x3ffffff);

578 
input
[0] -= 
mask
 & 0x3ffffed;

580 for (
i
 = 1; i < 10; i++) {

581 if ((
i
 & 1) == 1) {

582 
input
[
i
] -= 
mask
 & 0x1ffffff;

584 
input
[
i
] -= 
mask
 & 0x3ffffff;

588 
input
[1] <<= 2;

589 
input
[2] <<= 3;

590 
input
[3] <<= 5;

591 
input
[4] <<= 6;

592 
input
[6] <<= 1;

593 
input
[7] <<= 3;

594 
input
[8] <<= 4;

595 
input
[9] <<= 6;

596 #define 
	#F
(
i
, 
s
) \

597 
output
[
s
+0] |= 
input
[
i
] & 0xff; \

598 
output
[
s
+1] = (
input
[
i
] >> 8) & 0xff; \

599 
output
[
s
+2] = (
input
[
i
] >> 16) & 0xff; \

600 
output
[
s
+3] = (
input
[
i
] >> 24) & 0xff;

	)

601 
output
[0] = 0;

602 
output
[16] = 0;

603 
	`F
(0,0);

604 
	`F
(1,3);

605 
	`F
(2,6);

606 
	`F
(3,9);

607 
	`F
(4,12);

608 
	`F
(5,16);

609 
	`F
(6,19);

610 
	`F
(7,22);

611 
	`F
(8,25);

612 
	`F
(9,28);

613 #undef 
F


614 
	}
}

627 static void 
	$fmonty
(
limb
 *
x2
, limb *
z2
,

628 
limb
 *
x3
, limb *
z3
,

629 
limb
 *
x
, limb *
z
,

630 
limb
 *
xprime
, limb *
zprime
,

631 const 
limb
 *
qmqp
 ) {

632 
limb
 
origx
[10], 
origxprime
[10], 
zzz
[19], 
xx
[19], 
zz
[19], 
xxprime
[19],

633 
zzprime
[19], 
zzzprime
[19], 
xxxprime
[19];

635 
	`memcpy
(
origx
, 
x
, 10 * sizeof(
limb
));

636 
	`fsum
(
x
, 
z
);

638 
	`fdifference
(
z
, 
origx
);

641 
	`memcpy
(
origxprime
, 
xprime
, sizeof(
limb
) * 10);

642 
	`fsum
(
xprime
, 
zprime
);

644 
	`fdifference
(
zprime
, 
origxprime
);

646 
	`fproduct
(
xxprime
, 
xprime
, 
z
);

650 
	`fproduct
(
zzprime
, 
x
, 
zprime
);

652 
	`freduce_degree
(
xxprime
);

653 
	`freduce_coefficients
(
xxprime
);

655 
	`freduce_degree
(
zzprime
);

656 
	`freduce_coefficients
(
zzprime
);

658 
	`memcpy
(
origxprime
, 
xxprime
, sizeof(
limb
) * 10);

659 
	`fsum
(
xxprime
, 
zzprime
);

661 
	`fdifference
(
zzprime
, 
origxprime
);

663 
	`fsquare
(
xxxprime
, 
xxprime
);

665 
	`fsquare
(
zzzprime
, 
zzprime
);

667 
	`fproduct
(
zzprime
, 
zzzprime
, 
qmqp
);

669 
	`freduce_degree
(
zzprime
);

670 
	`freduce_coefficients
(
zzprime
);

672 
	`memcpy
(
x3
, 
xxxprime
, sizeof(
limb
) * 10);

673 
	`memcpy
(
z3
, 
zzprime
, sizeof(
limb
) * 10);

675 
	`fsquare
(
xx
, 
x
);

677 
	`fsquare
(
zz
, 
z
);

679 
	`fproduct
(
x2
, 
xx
, 
zz
);

681 
	`freduce_degree
(
x2
);

682 
	`freduce_coefficients
(
x2
);

684 
	`fdifference
(
zz
, 
xx
);

686 
	`memset
(
zzz
 + 10, 0, sizeof(
limb
) * 9);

687 
	`fscalar_product
(
zzz
, 
zz
, 121665);

691 
	`freduce_coefficients
(
zzz
);

693 
	`fsum
(
zzz
, 
xx
);

695 
	`fproduct
(
z2
, 
zz
, 
zzz
);

697 
	`freduce_degree
(
z2
);

698 
	`freduce_coefficients
(
z2
);

700 
	}
}

712 
	$swap_conditional
(
limb
 
a
[19], limb 
b
[19], limb 
iswap
) {

713 unsigned 
i
;

714 const 
s32
 
swap
 = (s32) -
iswap
;

716 for (
i
 = 0; i < 10; ++i) {

717 const 
s32
 
x
 = 
swap
 & ( ((s32)
a
[
i
]) ^ ((s32)
b
[i]) );

718 
a
[
i
] = ((
s32
)a[i]) ^ 
x
;

719 
b
[
i
] = ((
s32
)b[i]) ^ 
x
;

721 
	}
}

729 
	$cmult
(
limb
 *
resultx
, limb *
resultz
, const 
u8
 *
n
, const limb *
q
) {

730 
limb
 
a
[19] = {0}, 
b
[19] = {1}, 
c
[19] = {1}, 
d
[19] = {0};

731 
limb
 *
nqpqx
 = 
a
, *
nqpqz
 = 
b
, *
nqx
 = 
c
, *
nqz
 = 
d
, *
t
;

732 
limb
 
e
[19] = {0}, 
f
[19] = {1}, 
g
[19] = {0}, 
h
[19] = {1};

733 
limb
 *
nqpqx2
 = 
e
, *
nqpqz2
 = 
f
, *
nqx2
 = 
g
, *
nqz2
 = 
h
;

735 unsigned 
i
, 
j
;

737 
	`memcpy
(
nqpqx
, 
q
, sizeof(
limb
) * 10);

739 for (
i
 = 0; i < 32; ++i) {

740 
u8
 
byte
 = 
n
[31 - 
i
];

741 for (
j
 = 0; j < 8; ++j) {

742 const 
limb
 
bit
 = 
byte
 >> 7;

744 
	`swap_conditional
(
nqx
, 
nqpqx
, 
bit
);

745 
	`swap_conditional
(
nqz
, 
nqpqz
, 
bit
);

746 
	`fmonty
(
nqx2
, 
nqz2
,

747 
nqpqx2
, 
nqpqz2
,

748 
nqx
, 
nqz
,

749 
nqpqx
, 
nqpqz
,

750 
q
);

751 
	`swap_conditional
(
nqx2
, 
nqpqx2
, 
bit
);

752 
	`swap_conditional
(
nqz2
, 
nqpqz2
, 
bit
);

754 
t
 = 
nqx
;

755 
nqx
 = 
nqx2
;

756 
nqx2
 = 
t
;

757 
t
 = 
nqz
;

758 
nqz
 = 
nqz2
;

759 
nqz2
 = 
t
;

760 
t
 = 
nqpqx
;

761 
nqpqx
 = 
nqpqx2
;

762 
nqpqx2
 = 
t
;

763 
t
 = 
nqpqz
;

764 
nqpqz
 = 
nqpqz2
;

765 
nqpqz2
 = 
t
;

767 
byte
 <<= 1;

771 
	`memcpy
(
resultx
, 
nqx
, sizeof(
limb
) * 10);

772 
	`memcpy
(
resultz
, 
nqz
, sizeof(
limb
) * 10);

773 
	}
}

779 
	$crecip
(
limb
 *
out
, const limb *
z
) {

780 
limb
 
z2
[10];

781 
limb
 
z9
[10];

782 
limb
 
z11
[10];

783 
limb
 
z2_5_0
[10];

784 
limb
 
z2_10_0
[10];

785 
limb
 
z2_20_0
[10];

786 
limb
 
z2_50_0
[10];

787 
limb
 
z2_100_0
[10];

788 
limb
 
t0
[10];

789 
limb
 
t1
[10];

790 int 
i
;

792  
	`fsquare
(
z2
,
z
);

793  
	`fsquare
(
t1
,
z2
);

794  
	`fsquare
(
t0
,
t1
);

795  
	`fmul
(
z9
,
t0
,
z
);

796  
	`fmul
(
z11
,
z9
,
z2
);

797  
	`fsquare
(
t0
,
z11
);

798  
	`fmul
(
z2_5_0
,
t0
,
z9
);

800  
	`fsquare
(
t0
,
z2_5_0
);

801  
	`fsquare
(
t1
,
t0
);

802  
	`fsquare
(
t0
,
t1
);

803  
	`fsquare
(
t1
,
t0
);

804  
	`fsquare
(
t0
,
t1
);

805  
	`fmul
(
z2_10_0
,
t0
,
z2_5_0
);

807  
	`fsquare
(
t0
,
z2_10_0
);

808  
	`fsquare
(
t1
,
t0
);

809  for (
i
 = 2;i < 10;i += 2) { 
	`fsquare
(
t0
,
t1
); fsquare(t1,t0); }

810  
	`fmul
(
z2_20_0
,
t1
,
z2_10_0
);

812  
	`fsquare
(
t0
,
z2_20_0
);

813  
	`fsquare
(
t1
,
t0
);

814  for (
i
 = 2;i < 20;i += 2) { 
	`fsquare
(
t0
,
t1
); fsquare(t1,t0); }

815  
	`fmul
(
t0
,
t1
,
z2_20_0
);

817  
	`fsquare
(
t1
,
t0
);

818  
	`fsquare
(
t0
,
t1
);

819  for (
i
 = 2;i < 10;i += 2) { 
	`fsquare
(
t1
,
t0
); fsquare(t0,t1); }

820  
	`fmul
(
z2_50_0
,
t0
,
z2_10_0
);

822  
	`fsquare
(
t0
,
z2_50_0
);

823  
	`fsquare
(
t1
,
t0
);

824  for (
i
 = 2;i < 50;i += 2) { 
	`fsquare
(
t0
,
t1
); fsquare(t1,t0); }

825  
	`fmul
(
z2_100_0
,
t1
,
z2_50_0
);

827  
	`fsquare
(
t1
,
z2_100_0
);

828  
	`fsquare
(
t0
,
t1
);

829  for (
i
 = 2;i < 100;i += 2) { 
	`fsquare
(
t1
,
t0
); fsquare(t0,t1); }

830  
	`fmul
(
t1
,
t0
,
z2_100_0
);

832  
	`fsquare
(
t0
,
t1
);

833  
	`fsquare
(
t1
,
t0
);

834  for (
i
 = 2;i < 50;i += 2) { 
	`fsquare
(
t0
,
t1
); fsquare(t1,t0); }

835  
	`fmul
(
t0
,
t1
,
z2_50_0
);

837  
	`fsquare
(
t1
,
t0
);

838  
	`fsquare
(
t0
,
t1
);

839  
	`fsquare
(
t1
,
t0
);

840  
	`fsquare
(
t0
,
t1
);

841  
	`fsquare
(
t1
,
t0
);

842  
	`fmul
(
out
,
t1
,
z11
);

843 
	}
}

845 void 
	$cf_curve25519_mul
(
u8
 
out
[32], const u8 
scalar
[32], const u8 
point
[32])

847 
limb
 
bp
[10], 
x
[10], 
z
[11], 
zmone
[10];

848 
uint8_t
 
e
[32];

849 int 
i
;

851 for (
i
 = 0; i < 32; ++i) 
e
[i] = 
scalar
[i];

852 
e
[0] &= 248;

853 
e
[31] &= 127;

854 
e
[31] |= 64;

856 
	`fexpand
(
bp
, 
point
);

857 
	`cmult
(
x
, 
z
, 
e
, 
bp
);

858 
	`crecip
(
zmone
, 
z
);

859 
	`fmul
(
z
, 
x
, 
zmone
);

860 
	`fcontract
(
out
, 
z
);

861 
	}
}

863 void 
	$cf_curve25519_mul_base
(
u8
 
out
[32], const u8 
scalar
[32])

865 
uint8_t
 
base
[32] = { 9 };

866 
	`cf_curve25519_mul
(
out
, 
scalar
, 
base
);

867 
	}
}

	@deps/picotls/deps/cifra/src/curve25519.h

15 #ifndef 
CURVE25519_H


16 #define 
	#CURVE25519_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

33 void 
cf_curve25519_mul
(
uint8_t
 
out
[32],

34 const 
uint8_t
 
scalar
[32],

35 const 
uint8_t
 
point
[32]);

40 void 
cf_curve25519_mul_base
(
uint8_t
 
out
[32], const uint8_t 
scalar
[32]);

	@deps/picotls/deps/cifra/src/curve25519.naclref.c

7 #include 
	~"curve25519.h
"

9 static void 
	$add
(unsigned int 
out
[32],const unsigned int 
a
[32],const unsigned int 
b
[32])

11 unsigned int 
j
;

12 unsigned int 
u
;

13 
u
 = 0;

14 for (
j
 = 0;j < 31;++j) { 
u
 += 
a
[j] + 
b
[j]; 
out
[j] = u & 255; u >>= 8; }

15 
u
 += 
a
[31] + 
b
[31]; 
out
[31] = u;

16 
	}
}

18 static void 
	$sub
(unsigned int 
out
[32],const unsigned int 
a
[32],const unsigned int 
b
[32])

20 unsigned int 
j
;

21 unsigned int 
u
;

22 
u
 = 218;

23 for (
j
 = 0;j < 31;++j) {

24 
u
 += 
a
[
j
] + 65280 - 
b
[j];

25 
out
[
j
] = 
u
 & 255;

26 
u
 >>= 8;

28 
u
 += 
a
[31] - 
b
[31];

29 
out
[31] = 
u
;

30 
	}
}

32 static void 
	$squeeze
(unsigned int 
a
[32])

34 unsigned int 
j
;

35 unsigned int 
u
;

36 
u
 = 0;

37 for (
j
 = 0;j < 31;++j) { 
u
 += 
a
[j]; a[j] = u & 255; u >>= 8; }

38 
u
 += 
a
[31]; a[31] = u & 127;

39 
u
 = 19 * (u >> 7);

40 for (
j
 = 0;j < 31;++j) { 
u
 += 
a
[j]; a[j] = u & 255; u >>= 8; }

41 
u
 += 
a
[31]; a[31] = u;

42 
	}
}

44 static const unsigned int 
	gminusp
[32] = {

48 static void 
	$freeze
(unsigned int 
a
[32])

50 unsigned int 
aorig
[32];

51 unsigned int 
j
;

52 unsigned int 
negative
;

54 for (
j
 = 0;j < 32;++j) 
aorig
[j] = 
a
[j];

55 
	`add
(
a
,a,
minusp
);

56 
negative
 = -((
a
[31] >> 7) & 1);

57 for (
j
 = 0;j < 32;++j) 
a
[j] ^= 
negative
 & (
aorig
[j] ^ a[j]);

58 
	}
}

60 static void 
	$mult
(unsigned int 
out
[32],const unsigned int 
a
[32],const unsigned int 
b
[32])

62 unsigned int 
i
;

63 unsigned int 
j
;

64 unsigned int 
u
;

66 for (
i
 = 0;i < 32;++i) {

67 
u
 = 0;

68 for (
j
 = 0;j <= 
i
;++j) 
u
 += 
a
[j] * 
b
[i - j];

69 for (
j
 = 
i
 + 1;j < 32;++j) 
u
 += 38 * 
a
[j] * 
b
[i + 32 - j];

70 
out
[
i
] = 
u
;

72 
	`squeeze
(
out
);

73 
	}
}

75 static void 
	$mult121665
(unsigned int 
out
[32],const unsigned int 
a
[32])

77 unsigned int 
j
;

78 unsigned int 
u
;

80 
u
 = 0;

81 for (
j
 = 0;j < 31;++j) { 
u
 += 121665 * 
a
[j]; 
out
[j] = u & 255; u >>= 8; }

82 
u
 += 121665 * 
a
[31]; 
out
[31] = u & 127;

83 
u
 = 19 * (u >> 7);

84 for (
j
 = 0;j < 31;++j) { 
u
 += 
out
[j]; out[j] = u & 255; u >>= 8; }

85 
u
 += 
out
[
j
]; out[j] = u;

86 
	}
}

88 static void 
	$square
(unsigned int 
out
[32],const unsigned int 
a
[32])

90 unsigned int 
i
;

91 unsigned int 
j
;

92 unsigned int 
u
;

94 for (
i
 = 0;i < 32;++i) {

95 
u
 = 0;

96 for (
j
 = 0;j < 
i
 - j;++j) 
u
 += 
a
[j] * a[i - j];

97 for (
j
 = 
i
 + 1;j < i + 32 - j;++j) 
u
 += 38 * 
a
[j] * a[i + 32 - j];

98 
u
 *= 2;

99 if ((
i
 & 1) == 0) {

100 
u
 += 
a
[
i
 / 2] * a[i / 2];

101 
u
 += 38 * 
a
[
i
 / 2 + 16] * a[i / 2 + 16];

103 
out
[
i
] = 
u
;

105 
	`squeeze
(
out
);

106 
	}
}

108 static void 
	$select
(unsigned int 
p
[64],unsigned int 
q
[64],const unsigned int 
r
[64],const unsigned int 
s
[64],unsigned int 
b
)

110 unsigned int 
j
;

111 unsigned int 
t
;

112 unsigned int 
bminus1
;

114 
bminus1
 = 
b
 - 1;

115 for (
j
 = 0;j < 64;++j) {

116 
t
 = 
bminus1
 & (
r
[
j
] ^ 
s
[j]);

117 
p
[
j
] = 
s
[j] ^ 
t
;

118 
q
[
j
] = 
r
[j] ^ 
t
;

120 
	}
}

122 static void 
	$mainloop
(unsigned int 
work
[64],const unsigned char 
e
[32])

124 unsigned int 
xzm1
[64];

125 unsigned int 
xzm
[64];

126 unsigned int 
xzmb
[64];

127 unsigned int 
xzm1b
[64];

128 unsigned int 
xznb
[64];

129 unsigned int 
xzn1b
[64];

130 unsigned int 
a0
[64];

131 unsigned int 
a1
[64];

132 unsigned int 
b0
[64];

133 unsigned int 
b1
[64];

134 unsigned int 
c1
[64];

135 unsigned int 
r
[32];

136 unsigned int 
s
[32];

137 unsigned int 
t
[32];

138 unsigned int 
u
[32];

139 unsigned int 
j
;

140 unsigned int 
b
;

141 int 
pos
;

143 for (
j
 = 0;j < 32;++j) 
xzm1
[j] = 
work
[j];

144 
xzm1
[32] = 1;

145 for (
j
 = 33;j < 64;++j) 
xzm1
[j] = 0;

147 
xzm
[0] = 1;

148 for (
j
 = 1;j < 64;++j) 
xzm
[j] = 0;

150 for (
pos
 = 254;pos >= 0;--pos) {

151 
b
 = 
e
[
pos
 / 8] >> (pos & 7);

152 
b
 &= 1;

153 
	`select
(
xzmb
,
xzm1b
,
xzm
,
xzm1
,
b
);

154 
	`add
(
a0
,
xzmb
,xzmb + 32);

155 
	`sub
(
a0
 + 32,
xzmb
,xzmb + 32);

156 
	`add
(
a1
,
xzm1b
,xzm1b + 32);

157 
	`sub
(
a1
 + 32,
xzm1b
,xzm1b + 32);

158 
	`square
(
b0
,
a0
);

159 
	`square
(
b0
 + 32,
a0
 + 32);

160 
	`mult
(
b1
,
a1
,
a0
 + 32);

161 
	`mult
(
b1
 + 32,
a1
 + 32,
a0
);

162 
	`add
(
c1
,
b1
,b1 + 32);

163 
	`sub
(
c1
 + 32,
b1
,b1 + 32);

164 
	`square
(
r
,
c1
 + 32);

165 
	`sub
(
s
,
b0
,b0 + 32);

166 
	`mult121665
(
t
,
s
);

167 
	`add
(
u
,
t
,
b0
);

168 
	`mult
(
xznb
,
b0
,b0 + 32);

169 
	`mult
(
xznb
 + 32,
s
,
u
);

170 
	`square
(
xzn1b
,
c1
);

171 
	`mult
(
xzn1b
 + 32,
r
,
work
);

172 
	`select
(
xzm
,
xzm1
,
xznb
,
xzn1b
,
b
);

175 for (
j
 = 0;j < 64;++j) 
work
[j] = 
xzm
[j];

176 
	}
}

178 static void 
	$recip
(unsigned int 
out
[32],const unsigned int 
z
[32])

180 unsigned int 
z2
[32];

181 unsigned int 
z9
[32];

182 unsigned int 
z11
[32];

183 unsigned int 
z2_5_0
[32];

184 unsigned int 
z2_10_0
[32];

185 unsigned int 
z2_20_0
[32];

186 unsigned int 
z2_50_0
[32];

187 unsigned int 
z2_100_0
[32];

188 unsigned int 
t0
[32];

189 unsigned int 
t1
[32];

190 int 
i
;

192  
	`square
(
z2
,
z
);

193  
	`square
(
t1
,
z2
);

194  
	`square
(
t0
,
t1
);

195  
	`mult
(
z9
,
t0
,
z
);

196  
	`mult
(
z11
,
z9
,
z2
);

197  
	`square
(
t0
,
z11
);

198  
	`mult
(
z2_5_0
,
t0
,
z9
);

200  
	`square
(
t0
,
z2_5_0
);

201  
	`square
(
t1
,
t0
);

202  
	`square
(
t0
,
t1
);

203  
	`square
(
t1
,
t0
);

204  
	`square
(
t0
,
t1
);

205  
	`mult
(
z2_10_0
,
t0
,
z2_5_0
);

207  
	`square
(
t0
,
z2_10_0
);

208  
	`square
(
t1
,
t0
);

209  for (
i
 = 2;i < 10;i += 2) { 
	`square
(
t0
,
t1
); square(t1,t0); }

210  
	`mult
(
z2_20_0
,
t1
,
z2_10_0
);

212  
	`square
(
t0
,
z2_20_0
);

213  
	`square
(
t1
,
t0
);

214  for (
i
 = 2;i < 20;i += 2) { 
	`square
(
t0
,
t1
); square(t1,t0); }

215  
	`mult
(
t0
,
t1
,
z2_20_0
);

217  
	`square
(
t1
,
t0
);

218  
	`square
(
t0
,
t1
);

219  for (
i
 = 2;i < 10;i += 2) { 
	`square
(
t1
,
t0
); square(t0,t1); }

220  
	`mult
(
z2_50_0
,
t0
,
z2_10_0
);

222  
	`square
(
t0
,
z2_50_0
);

223  
	`square
(
t1
,
t0
);

224  for (
i
 = 2;i < 50;i += 2) { 
	`square
(
t0
,
t1
); square(t1,t0); }

225  
	`mult
(
z2_100_0
,
t1
,
z2_50_0
);

227  
	`square
(
t1
,
z2_100_0
);

228  
	`square
(
t0
,
t1
);

229  for (
i
 = 2;i < 100;i += 2) { 
	`square
(
t1
,
t0
); square(t0,t1); }

230  
	`mult
(
t1
,
t0
,
z2_100_0
);

232  
	`square
(
t0
,
t1
);

233  
	`square
(
t1
,
t0
);

234  for (
i
 = 2;i < 50;i += 2) { 
	`square
(
t0
,
t1
); square(t1,t0); }

235  
	`mult
(
t0
,
t1
,
z2_50_0
);

237  
	`square
(
t1
,
t0
);

238  
	`square
(
t0
,
t1
);

239  
	`square
(
t1
,
t0
);

240  
	`square
(
t0
,
t1
);

241  
	`square
(
t1
,
t0
);

242  
	`mult
(
out
,
t1
,
z11
);

243 
	}
}

245 static void 
	$crypto_scalarmult
(unsigned char *
q
,

246 const unsigned char *
n
,

247 const unsigned char *
p
)

249 unsigned int 
work
[96];

250 unsigned char 
e
[32];

251 unsigned int 
i
;

252 for (
i
 = 0;i < 32;++i) 
e
[i] = 
n
[i];

253 
e
[0] &= 248;

254 
e
[31] &= 127;

255 
e
[31] |= 64;

256 for (
i
 = 0;i < 32;++i) 
work
[i] = 
p
[i];

257 
	`mainloop
(
work
,
e
);

258 
	`recip
(
work
 + 32,work + 32);

259 
	`mult
(
work
 + 64,work,work + 32);

260 
	`freeze
(
work
 + 64);

261 for (
i
 = 0;i < 32;++i) 
q
[i] = 
work
[64 + i];

262 
	}
}

264 void 
	$cf_curve25519_mul
(
uint8_t
 
out
[32], const uint8_t 
scalar
[32], const uint8_t 
point
[32])

266 
	`crypto_scalarmult
(
out
, 
scalar
, 
point
);

267 
	}
}

269 void 
	$cf_curve25519_mul_base
(
uint8_t
 
out
[32], const uint8_t 
scalar
[32])

271 
uint8_t
 
base_point
[32] = { 9 };

272 
	`cf_curve25519_mul
(
out
, 
scalar
, 
base_point
);

273 
	}
}

	@deps/picotls/deps/cifra/src/curve25519.tweetnacl.c

6 #include 
	~<stdint.h
>

7 #include 
	~<stddef.h
>

9 #include 
	~"handy.h
"

11 typedef 
int64_t
 
	tgf
[16];

13 static const 
uint8_t
 
	g_0
[16],

14 
	g_9
[32] = {9};

15 static const 
gf
 
	ggf0
,

16 
	ggf1
 = {1},

17 
	g_121665
 = {0xDB41, 1},

18 
	gD
 = {0x78a3, 0x1359, 0x4dca, 0x75eb,

22 
	gD2
 = {0xf159, 0x26b2, 0x9b94, 0xebd6,

26 
	gX
 = {0xd51a, 0x8f25, 0x2d60, 0xc956,

30 
	gY
 = {0x6658, 0x6666, 0x6666, 0x6666,

34 
	gI
 = {0xa0b0, 0x4a0e, 0x1b27, 0xc4ee,

39 static void 
	$set25519
(
gf
 
r
, const gf 
a
)

41 
size_t
 
i
;

42 for (
i
 = 0; i < 16; i++)

43 
r
[
i
] = 
a
[i];

44 
	}
}

46 static void 
	$car25519
(
gf
 
o
)

48 
int64_t
 
c
;

49 
size_t
 
i
;

51 for (
i
 = 0; i < 16; i++)

53 
o
[
i
] += (1LL << 16);

54 
c
 = 
o
[
i
] >> 16;

55 
o
[(
i
 + 1) * (i < 15)] += 
c
 - 1 + 37 * (c - 1) * (i == 15);

56 
o
[
i
] -= 
c
 << 16;

58 
	}
}

60 static void 
	$sel25519
(
gf
 
p
, gf 
q
, 
int64_t
 
b
)

62 
int64_t
 
tmp
, 
mask
 = ~(
b
-1);

63 
size_t
 
i
;

64 for (
i
 = 0; i < 16; i++)

66 
tmp
 = 
mask
 & (
p
[
i
] ^ 
q
[i]);

67 
p
[
i
] ^= 
tmp
;

68 
q
[
i
] ^= 
tmp
;

70 
	}
}

72 static void 
	$pack25519
(
uint8_t
 
out
[32], const 
gf
 
n
)

74 
size_t
 
i
, 
j
;

75 int 
b
;

76 
gf
 
m
, 
t
;

77 
	`set25519
(
t
, 
n
);

78 
	`car25519
(
t
);

79 
	`car25519
(
t
);

80 
	`car25519
(
t
);

82 for(
j
 = 0; j < 2; j++)

84 
m
[0] = 
t
[0] - 0xffed;

85 for (
i
 = 1; i < 15; i++)

87 
m
[
i
] = 
t
[i] - 0xffff - ((m[i - 1] >> 16) & 1);

88 
m
[
i
 - 1] &= 0xffff;

90 
m
[15] = 
t
[15] - 0x7fff - ((m[14] >> 16) & 1);

91 
b
 = (
m
[15] >> 16) & 1;

92 
m
[14] &= 0xffff;

93 
	`sel25519
(
t
, 
m
, 1 - 
b
);

96 for (
i
 = 0; i < 16; i++)

98 
out
[2 * 
i
] = 
t
[i] & 0xff;

99 
out
[2 * 
i
 + 1] = (
uint8_t
) (
t
[i] >> 8);

101 
	}
}

105 static void 
	$unpack25519
(
gf
 
o
, const 
uint8_t
 *
n
)

107 
size_t
 
i
;

108 for (
i
 = 0; i < 16; i++)

109 
o
[
i
] = 
n
[2 * i] + ((
int64_t
) n[2 * i + 1] << 8);

110 
o
[15] &= 0x7fff;

111 
	}
}

113 static void 
	$add
(
gf
 
o
, const gf 
a
, const gf 
b
)

115 
size_t
 
i
;

116 for (
i
 = 0; i < 16; i++)

117 
o
[
i
] = 
a
[i] + 
b
[i];

118 
	}
}

120 static void 
	$sub
(
gf
 
o
, const gf 
a
, const gf 
b
)

122 
size_t
 
i
;

123 for (
i
 = 0; i < 16; i++)

124 
o
[
i
] = 
a
[i] - 
b
[i];

125 
	}
}

127 static void 
	$mul
(
gf
 
o
, const gf 
a
, const gf 
b
)

129 
int64_t
 
t
[31];

130 
size_t
 
i
, 
j
;

132 for (
i
 = 0; i < 31; i++)

133 
t
[
i
] = 0;

135 for (
i
 = 0; i < 16; i++)

136 for (
j
 = 0; j < 16; j++)

137 
t
[
i
 + 
j
] += 
a
[i] * 
b
[j];

139 for (
i
 = 0; i < 15; i++)

140 
t
[
i
] += 38 * t[i + 16];

142 for (
i
 = 0; i < 16; i++)

143 
o
[
i
] = 
t
[i];

145 
	`car25519
(
o
);

146 
	`car25519
(
o
);

147 
	}
}

149 static void 
	$sqr
(
gf
 
o
, const gf 
a
)

151 
	`mul
(
o
, 
a
, a);

152 
	}
}

154 static void 
	$inv25519
(
gf
 
o
, const gf 
i
)

156 
gf
 
c
;

157 int 
a
;

158 for (
a
 = 0; a < 16; a++)

159 
c
[
a
] = 
i
[a];

161 for (
a
 = 253; a >= 0; a--)

163 
	`sqr
(
c
, c);

164 if(
a
 != 2 && a != 4)

165 
	`mul
(
c
, c, 
i
);

168 for (
a
 = 0; a < 16; a++)

169 
o
[
a
] = 
c
[a];

170 
	}
}

173 void 
	$cf_curve25519_mul
(
uint8_t
 *
q
, const uint8_t *
n
, const uint8_t *
p
)

175 
uint8_t
 
z
[32];

176 
gf
 
x
;

177 
gf
 
a
, 
b
, 
c
, 
d
, 
e
, 
f
;

180 
size_t
 
i
;

181 for (
i
 = 0; i < 31; i++)

182 
z
[
i
] = 
n
[i];

183 
z
[31] = (
n
[31] & 127) | 64;

184 
z
[0] &= 248;

186 
	`unpack25519
(
x
, 
p
);

188 for(
i
 = 0; i < 16; i++)

190 
b
[
i
] = 
x
[i];

191 
d
[
i
] = 
a
[i] = 
c
[i] = 0;

195 
a
[0] = 
d
[0] = 1;

197 {int 
i
;

198 for (
i
 = 254; i >= 0; i--)

200 
int64_t
 
r
 = (
z
[
i
 >> 3] >> (i & 7)) & 1;

201 
	`sel25519
(
a
, 
b
, 
r
);

202 
	`sel25519
(
c
, 
d
, 
r
);

203 
	`add
(
e
, 
a
, 
c
);

204 
	`sub
(
a
, a, 
c
);

205 
	`add
(
c
, 
b
, 
d
);

206 
	`sub
(
b
, b, 
d
);

207 
	`sqr
(
d
, 
e
);

208 
	`sqr
(
f
, 
a
);

209 
	`mul
(
a
, 
c
, a);

210 
	`mul
(
c
, 
b
, 
e
);

211 
	`add
(
e
, 
a
, 
c
);

212 
	`sub
(
a
, a, 
c
);

213 
	`sqr
(
b
, 
a
);

214 
	`sub
(
c
, 
d
, 
f
);

215 
	`mul
(
a
, 
c
, 
_121665
);

216 
	`add
(
a
, a, 
d
);

217 
	`mul
(
c
, c, 
a
);

218 
	`mul
(
a
, 
d
, 
f
);

219 
	`mul
(
d
, 
b
, 
x
);

220 
	`sqr
(
b
, 
e
);

221 
	`sel25519
(
a
, 
b
, 
r
);

222 
	`sel25519
(
c
, 
d
, 
r
);

226 
	`inv25519
(
c
, c);

227 
	`mul
(
a
, a, 
c
);

228 
	`pack25519
(
q
, 
a
);

229 
	}
}

231 void 
	$cf_curve25519_mul_base
(
uint8_t
 *
q
, const uint8_t *
n
)

233 
	`cf_curve25519_mul
(
q
, 
n
, 
_9
);

234 
	}
}

	@deps/picotls/deps/cifra/src/drbg.c

15 #include 
	~"drbg.h
"

16 #include 
	~"handy.h
"

17 #include 
	~"bitops.h
"

18 #include 
	~"sha2.h
"

19 #include 
	~"tassert.h
"

21 #include 
	~<string.h
>

23 #define 
	#MAX_DRBG_GENERATE
 0x10000ul

	)

25 static void 
	$hash_df
(const 
cf_chash
 *
H
,

26 const void *
in1
, 
size_t
 
nin1
,

27 const void *
in2
, 
size_t
 
nin2
,

28 const void *
in3
, 
size_t
 
nin3
,

29 const void *
in4
, 
size_t
 
nin4
,

30 
uint8_t
 *
out
, 
size_t
 
nout
)

32 
uint8_t
 
counter
 = 1;

33 
uint32_t
 
bits_to_return
 = 
nout
 * 8;

34 
uint8_t
 
cbuf
[4];

35 
uint8_t
 
block
[
CF_MAXHASH
];

37 
	`write32_be
(
bits_to_return
, 
cbuf
);

39 while (
nout
)

44 
cf_chash_ctx
 
ctx
;

45 
H
->
	`init
(&
ctx
);

46 
H
->
	`update
(&
ctx
, &
counter
, sizeof counter);

47 
H
->
	`update
(&
ctx
, 
cbuf
, sizeof cbuf);

48 
H
->
	`update
(&
ctx
, 
in1
, 
nin1
);

49 
H
->
	`update
(&
ctx
, 
in2
, 
nin2
);

50 
H
->
	`update
(&
ctx
, 
in3
, 
nin3
);

51 
H
->
	`update
(&
ctx
, 
in4
, 
nin4
);

52 
H
->
	`digest
(&
ctx
, 
block
);

54 
size_t
 
take
 = 
	`MIN
(
H
->
hashsz
, 
nout
);

55 
	`memcpy
(
out
, 
block
, 
take
);

56 
out
 += 
take
;

57 
nout
 -= 
take
;

59 
counter
 += 1;

61 
	}
}

63 void 
	$cf_hash_drbg_sha256_init
(
cf_hash_drbg_sha256
 *
ctx
,

64 const void *
entropy
, 
size_t
 
nentropy
,

65 const void *
nonce
, 
size_t
 
nnonce
,

66 const void *
persn
, 
size_t
 
npersn
)

68 
	`mem_clean
(
ctx
, sizeof *ctx);

73 
	`hash_df
(&
cf_sha256
,

74 
entropy
, 
nentropy
,

75 
nonce
, 
nnonce
,

76 
persn
, 
npersn
,

77 
NULL
, 0,

78 
ctx
->
V
, sizeof ctx->V);

81 
uint8_t
 
zero
 = 0;

82 
	`hash_df
(&
cf_sha256
,

83 &
zero
, sizeof zero,

84 
ctx
->
V
, sizeof ctx->V,

85 
NULL
, 0,

86 
NULL
, 0,

87 
ctx
->
C
, sizeof ctx->C);

90 
ctx
->
reseed_counter
 = 1;

91 
	}
}

96 static void 
	$add
(
uint8_t
 *
out
, 
size_t
 
nout
, const uint8_t *
in
, size_t 
nin
)

98 
	`assert
(
nout
 >= 
nin
);

100 
uint16_t
 
carry
 = 0;

101 int 
oi
, 
ii
;

103 for (
oi
 = 
nout
 - 1, 
ii
 = 
nin
 - 1;

104 
oi
 >= 0;

105 
ii
--, 
oi
--)

107 
carry
 += 
out
[
oi
];

108 if (
ii
 >= 0)

109 
carry
 += 
in
[
ii
];

110 
out
[
oi
] = 
carry
 & 0xff;

111 
carry
 >>= 8;

113 
	}
}

115 static void 
	$hash_process_addnl
(const 
cf_chash
 *
H
,

116 const void *
input
, 
size_t
 
ninput
,

117 
uint8_t
 *
V
, 
size_t
 
nV
)

119 if (!
ninput
)

123 
uint8_t
 
two
 = 2;

124 
uint8_t
 
w
[
CF_MAXHASH
];

125 
cf_chash_ctx
 
ctx
;

126 
H
->
	`init
(&
ctx
);

127 
H
->
	`update
(&
ctx
, &
two
, sizeof two);

128 
H
->
	`update
(&
ctx
, 
V
, 
nV
);

129 
H
->
	`update
(&
ctx
, 
input
, 
ninput
);

130 
H
->
	`digest
(&
ctx
, 
w
);

133 
	`add
(
V
, 
nV
, 
w
, 
H
->
hashsz
);

134 
	}
}

136 static void 
	$hash_generate
(const 
cf_chash
 *
H
,

137 
uint8_t
 *
data
, 
size_t
 
ndata
,

138 void *
out
, 
size_t
 
nout
)

140 
cf_chash_ctx
 
ctx
;

141 
uint8_t
 
w
[
CF_MAXHASH
];

142 
uint8_t
 *
bout
 = 
out
;

143 
uint8_t
 
one
 = 1;

145 while (
nout
)

148 
H
->
	`init
(&
ctx
);

149 
H
->
	`update
(&
ctx
, 
data
, 
ndata
);

150 
H
->
	`digest
(&
ctx
, 
w
);

153 
size_t
 
take
 = 
	`MIN
(
H
->
hashsz
, 
nout
);

154 
	`memcpy
(
bout
, 
w
, 
take
);

155 
bout
 += 
take
;

156 
nout
 -= 
take
;

159 
	`add
(
data
, 
ndata
, &
one
, sizeof one);

161 
	}
}

163 static void 
	$hash_step
(const 
cf_chash
 *
H
,

164 
uint8_t
 *
V
, 
size_t
 
nV
,

165 const 
uint8_t
 *
C
, 
size_t
 
nC
,

166 
uint32_t
 *
reseed_counter
)

169 
uint8_t
 
h
[
CF_MAXHASH
];

170 
uint8_t
 
three
 = 3;

171 
cf_chash_ctx
 
ctx
;

173 
H
->
	`init
(&
ctx
);

174 
H
->
	`update
(&
ctx
, &
three
, sizeof three);

175 
H
->
	`update
(&
ctx
, 
V
, 
nV
);

176 
H
->
	`digest
(&
ctx
, 
h
);

179 
uint8_t
 
reseed_counter_buf
[4];

180 
	`write32_be
(*
reseed_counter
, 
reseed_counter_buf
);

182 
	`add
(
V
, 
nV
, 
h
, 
H
->
hashsz
);

183 
	`add
(
V
, 
nV
, 
C
, 
nC
);

184 
	`add
(
V
, 
nV
, 
reseed_counter_buf
, sizeof reseed_counter_buf);

187 *
reseed_counter
 = *reseed_counter + 1;

188 
	}
}

192 static void 
	$hash_gen_request
(
cf_hash_drbg_sha256
 *
ctx
,

193 const void *
addnl
, 
size_t
 
naddnl
,

194 void *
out
, 
size_t
 
nout
)

196 
uint8_t
 
data
[440/8];

198 
	`assert
(!
	`cf_hash_drbg_sha256_needs_reseed
(
ctx
));

200 
	`hash_process_addnl
(&
cf_sha256
, 
addnl
, 
naddnl
, 
ctx
->
V
, sizeof ctx->V);

201 
	`assert
(sizeof 
data
 == sizeof 
ctx
->
V
);

202 
	`memcpy
(
data
, 
ctx
->
V
, sizeof ctx->V);

203 
	`hash_generate
(&
cf_sha256
, 
data
, sizeof data, 
out
, 
nout
);

204 
	`hash_step
(&
cf_sha256
, 
ctx
->
V
, sizeof ctx->V, ctx->
C
, sizeof ctx->C, &ctx->
reseed_counter
);

205 
	}
}

207 void 
	$cf_hash_drbg_sha256_gen_additional
(
cf_hash_drbg_sha256
 *
ctx
,

208 const void *
addnl
, 
size_t
 
naddnl
,

209 void *
out
, 
size_t
 
nout
)

211 
uint8_t
 *
bout
 = 
out
;

214 while (
nout
 != 0)

216 
size_t
 
take
 = 
	`MIN
(
MAX_DRBG_GENERATE
, 
nout
);

217 
	`hash_gen_request
(
ctx
, 
addnl
, 
naddnl
, 
bout
, 
take
);

218 
bout
 += 
take
;

219 
nout
 -= 
take
;

222 
addnl
 = 
NULL
;

223 
naddnl
 = 0;

225 
	}
}

227 void 
	$cf_hash_drbg_sha256_gen
(
cf_hash_drbg_sha256
 *
ctx
,

228 void *
out
, 
size_t
 
nout
)

230 
	`cf_hash_drbg_sha256_gen_additional
(
ctx
,

231 
NULL
, 0,

232 
out
, 
nout
);

233 
	}
}

235 void 
	$cf_hash_drbg_sha256_reseed
(
cf_hash_drbg_sha256
 *
ctx
,

236 const void *
entropy
, 
size_t
 
nentropy
,

237 const void *
addnl
, 
size_t
 
naddnl
)

242 
uint8_t
 
one
 = 1;

244 
	`memcpy
(
ctx
->
C
, ctx->
V
, sizeof ctx->C);

245 
	`hash_df
(&
cf_sha256
,

246 &
one
, sizeof one,

247 
ctx
->
C
, sizeof ctx->C,

248 
entropy
, 
nentropy
,

249 
addnl
, 
naddnl
,

250 
ctx
->
V
, sizeof ctx->V);

253 
uint8_t
 
zero
 = 0;

254 
	`hash_df
(&
cf_sha256
,

255 &
zero
, sizeof zero,

256 
ctx
->
V
, sizeof ctx->V,

257 
NULL
, 0,

258 
NULL
, 0,

259 
ctx
->
C
, sizeof ctx->C);

262 
ctx
->
reseed_counter
 = 1;

263 
	}
}

265 
uint32_t
 
	$cf_hash_drbg_sha256_needs_reseed
(const 
cf_hash_drbg_sha256
 *
ctx
)

268 return 
ctx
->
reseed_counter
 == 0;

269 
	}
}

275 static void 
	$hmac_drbg_update
(
cf_hmac_drbg
 *
ctx
,

276 const void *
in1
, 
size_t
 
nin1
,

277 const void *
in2
, 
size_t
 
nin2
,

278 const void *
in3
, 
size_t
 
nin3
)

280 
cf_hmac_ctx
 
local
;

281 const 
cf_chash
 *
H
 = 
ctx
->
hmac
.
hash
;

282 
uint8_t
 
new_key
[
CF_MAXHASH
];

283 
uint8_t
 
zero
 = 0;

286 
local
 = 
ctx
->
hmac
;

287 
	`cf_hmac_update
(&
local
, 
ctx
->
V
, 
H
->
hashsz
);

288 
	`cf_hmac_update
(&
local
, &
zero
, sizeof zero);

289 
	`cf_hmac_update
(&
local
, 
in1
, 
nin1
);

290 
	`cf_hmac_update
(&
local
, 
in2
, 
nin2
);

291 
	`cf_hmac_update
(&
local
, 
in3
, 
nin3
);

292 
	`cf_hmac_finish
(&
local
, 
new_key
);

293 
	`cf_hmac_init
(&
ctx
->
hmac
, 
H
, 
new_key
, H->
hashsz
);

294 
	`mem_clean
(
new_key
, sizeof new_key);

297 
local
 = 
ctx
->
hmac
;

298 
	`cf_hmac_update
(&
local
, 
ctx
->
V
, 
H
->
hashsz
);

299 
	`cf_hmac_finish
(&
local
, 
ctx
->
V
);

302 if (
nin1
 == 0 && 
nin2
 == 0 && 
nin3
 == 0)

306 
uint8_t
 
one
 = 1;

307 
local
 = 
ctx
->
hmac
;

308 
	`cf_hmac_update
(&
local
, 
ctx
->
V
, 
H
->
hashsz
);

309 
	`cf_hmac_update
(&
local
, &
one
, sizeof one);

310 
	`cf_hmac_update
(&
local
, 
in1
, 
nin1
);

311 
	`cf_hmac_update
(&
local
, 
in2
, 
nin2
);

312 
	`cf_hmac_update
(&
local
, 
in3
, 
nin3
);

313 
	`cf_hmac_finish
(&
local
, 
new_key
);

314 
	`cf_hmac_init
(&
ctx
->
hmac
, 
H
, 
new_key
, H->
hashsz
);

315 
	`mem_clean
(
new_key
, sizeof new_key);

318 
local
 = 
ctx
->
hmac
;

319 
	`cf_hmac_update
(&
local
, 
ctx
->
V
, 
H
->
hashsz
);

320 
	`cf_hmac_finish
(&
local
, 
ctx
->
V
);

321 
	}
}

323 void 
	$cf_hmac_drbg_init
(
cf_hmac_drbg
 *
ctx
,

324 const 
cf_chash
 *
hash
,

325 const void *
entropy
, 
size_t
 
nentropy
,

326 const void *
nonce
, 
size_t
 
nnonce
,

327 const void *
persn
, 
size_t
 
npersn
)

329 
	`mem_clean
(
ctx
, sizeof *ctx);

331 
	`assert
(
hash
->
hashsz
 <= 
CF_MAXHASH
);

335 
uint8_t
 
initial_key
[
CF_MAXHASH
];

336 
	`memset
(
initial_key
, 0x00, 
hash
->
hashsz
);

337 
	`memset
(
ctx
->
V
, 0x01, 
hash
->
hashsz
);

338 
	`cf_hmac_init
(&
ctx
->
hmac
, 
hash
, 
initial_key
, hash->
hashsz
);

342 
	`hmac_drbg_update
(
ctx
, 
entropy
, 
nentropy
, 
nonce
, 
nnonce
, 
persn
, 
npersn
);

345 
ctx
->
reseed_counter
 = 1;

346 
	}
}

348 
uint32_t
 
	$cf_hmac_drbg_needs_reseed
(const 
cf_hmac_drbg
 *
ctx
)

350 return 
ctx
->
reseed_counter
 == 0;

351 
	}
}

353 static void 
	$hmac_drbg_generate
(
cf_hmac_drbg
 *
ctx
,

354 const void *
addnl
, 
size_t
 
naddnl
,

355 void *
out
, 
size_t
 
nout
)

359 
	`assert
(!
	`cf_hmac_drbg_needs_reseed
(
ctx
));

364 if (
naddnl
)

365 
	`hmac_drbg_update
(
ctx
, 
addnl
, 
naddnl
, 
NULL
, 0, NULL, 0);

376 
uint8_t
 *
bout
 = 
out
;

377 
cf_hmac_ctx
 
local
;

379 while (
nout
)

381 
local
 = 
ctx
->
hmac
;

382 
	`cf_hmac_update
(&
local
, 
ctx
->
V
, ctx->
hmac
.
hash
->
hashsz
);

383 
	`cf_hmac_finish
(&
local
, 
ctx
->
V
);

385 
size_t
 
take
 = 
	`MIN
(
ctx
->
hmac
.
hash
->
hashsz
, 
nout
);

386 
	`memcpy
(
bout
, 
ctx
->
V
, 
take
);

387 
bout
 += 
take
;

388 
nout
 -= 
take
;

392 
	`hmac_drbg_update
(
ctx
, 
addnl
, 
naddnl
, 
NULL
, 0, NULL, 0);

395 
ctx
->
reseed_counter
++;

396 
	}
}

398 void 
	$cf_hmac_drbg_gen_additional
(
cf_hmac_drbg
 *
ctx
,

399 const void *
addnl
, 
size_t
 
naddnl
,

400 void *
out
, 
size_t
 
nout
)

402 
uint8_t
 *
bout
 = 
out
;

404 while (
nout
 != 0)

406 
size_t
 
take
 = 
	`MIN
(
MAX_DRBG_GENERATE
, 
nout
);

407 
	`hmac_drbg_generate
(
ctx
, 
addnl
, 
naddnl
, 
bout
, 
take
);

408 
bout
 += 
take
;

409 
nout
 -= 
take
;

412 
addnl
 = 
NULL
;

413 
naddnl
 = 0;

415 
	}
}

417 void 
	$cf_hmac_drbg_gen
(
cf_hmac_drbg
 *
ctx
, void *
out
, 
size_t
 
nout
)

419 
	`cf_hmac_drbg_gen_additional
(
ctx
,

420 
NULL
, 0,

421 
out
, 
nout
);

422 
	}
}

424 void 
	$cf_hmac_drbg_reseed
(
cf_hmac_drbg
 *
ctx
,

425 const void *
entropy
, 
size_t
 
nentropy
,

426 const void *
addnl
, 
size_t
 
naddnl
)

430 
	`hmac_drbg_update
(
ctx
, 
entropy
, 
nentropy
, 
addnl
, 
naddnl
, 
NULL
, 0);

433 
ctx
->
reseed_counter
 = 1;

434 
	}
}

	@deps/picotls/deps/cifra/src/drbg.h

15 #ifndef 
DRBG_H


16 #define 
	#DRBG_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

21 #include 
	~"chash.h
"

22 #include 
	~"hmac.h
"

62 
uint8_t
 
	mV
[440/8];

63 
uint8_t
 
	mC
[440/8];

64 
uint32_t
 
	mreseed_counter
;

65 } 
	tcf_hash_drbg_sha256
;

71 extern void 
cf_hash_drbg_sha256_init
(
cf_hash_drbg_sha256
 *
ctx
,

72 const void *
entropy
, 
size_t
 
nentropy
,

73 const void *
nonce
, 
size_t
 
nnonce
,

74 const void *
persn
, 
size_t
 
npersn
);

81 extern 
uint32_t
 
cf_hash_drbg_sha256_needs_reseed
(const 
cf_hash_drbg_sha256
 *
ctx
);

86 extern void 
cf_hash_drbg_sha256_reseed
(
cf_hash_drbg_sha256
 *
ctx
,

87 const void *
entropy
, 
size_t
 
nentropy
,

88 const void *
addnl
, 
size_t
 
naddnl
);

94 extern void 
cf_hash_drbg_sha256_gen
(
cf_hash_drbg_sha256
 *
ctx
,

95 void *
out
, 
size_t
 
nout
);

103 extern void 
cf_hash_drbg_sha256_gen_additional
(
cf_hash_drbg_sha256
 *
ctx
,

104 const void *
addnl
, 
size_t
 
naddnl
,

105 void *
out
, 
size_t
 
nout
);

144 
uint8_t
 
	mV
[
CF_MAXHASH
];

145 
cf_hmac_ctx
 
	mhmac
;

146 
uint32_t
 
	mreseed_counter
;

147 } 
	tcf_hmac_drbg
;

153 extern void 
cf_hmac_drbg_init
(
cf_hmac_drbg
 *
ctx
,

154 const 
cf_chash
 *
hash
,

155 const void *
entropy
, 
size_t
 
nentropy
,

156 const void *
nonce
, 
size_t
 
nnonce
,

157 const void *
persn
, 
size_t
 
npersn
);

164 extern 
uint32_t
 
cf_hmac_drbg_needs_reseed
(const 
cf_hmac_drbg
 *
ctx
);

170 extern void 
cf_hmac_drbg_reseed
(
cf_hmac_drbg
 *
ctx
,

171 const void *
entropy
, 
size_t
 
nentropy
,

172 const void *
addnl
, 
size_t
 
naddnl
);

178 extern void 
cf_hmac_drbg_gen
(
cf_hmac_drbg
 *
ctx
,

179 void *
out
, 
size_t
 
nout
);

187 extern void 
cf_hmac_drbg_gen_additional
(
cf_hmac_drbg
 *
ctx
,

188 const void *
addnl
, 
size_t
 
naddnl
,

189 void *
out
, 
size_t
 
nout
);

	@deps/picotls/deps/cifra/src/eax.c

15 #include 
	~"handy.h
"

16 #include 
	~"prp.h
"

17 #include 
	~"modes.h
"

18 #include 
	~"tassert.h
"

20 #include 
	~<string.h
>

22 static void 
	$cmac_compute_n
(
cf_cmac_stream
 *
ctx
,

23 
uint8_t
 
t
,

24 const 
uint8_t
 *
input
, 
size_t
 
ninput
,

25 
uint8_t
 
out
[
CF_MAXBLOCK
])

27 
size_t
 
blocksz
 = 
ctx
->
cmac
.
prp
->blocksz;

28 
	`assert
(
blocksz
 > 0);

30 
uint8_t
 
firstblock
[
CF_MAXBLOCK
];

31 
	`memset
(
firstblock
, 0, 
blocksz
);

32 
firstblock
[
blocksz
 - 1] = 
t
;

34 
	`cf_cmac_stream_reset
(
ctx
);

35 if (
ninput
)

37 
	`cf_cmac_stream_update
(
ctx
, 
firstblock
, 
blocksz
, 0);

38 
	`cf_cmac_stream_update
(
ctx
, 
input
, 
ninput
, 1);

40 
	`cf_cmac_stream_update
(
ctx
, 
firstblock
, 
blocksz
, 1);

43 
	`cf_cmac_stream_final
(
ctx
, 
out
);

44 
	}
}

46 void 
	$cf_eax_encrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

47 const 
uint8_t
 *
plain
, 
size_t
 
nplain
,

48 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

49 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

50 
uint8_t
 *
cipher
,

51 
uint8_t
 *
tag
, 
size_t
 
ntag
)

53 
uint8_t
 
NN
[
CF_MAXBLOCK
],

54 
HH
[
CF_MAXBLOCK
],

55 
CC
[
CF_MAXBLOCK
];

57 
cf_cmac_stream
 
cmac
;

58 
	`cf_cmac_stream_init
(&
cmac
, 
prp
, 
prpctx
);

61 
	`cmac_compute_n
(&
cmac
, 0, 
nonce
, 
nnonce
, 
NN
);

64 
	`cmac_compute_n
(&
cmac
, 1, 
header
, 
nheader
, 
HH
);

67 
cf_ctr
 
ctr
;

68 
	`cf_ctr_init
(&
ctr
, 
prp
, 
prpctx
, 
NN
);

69 
	`cf_ctr_cipher
(&
ctr
, 
plain
, 
cipher
, 
nplain
);

72 
	`cmac_compute_n
(&
cmac
, 2, 
cipher
, 
nplain
, 
CC
);

76 
	`assert
(
ntag
 <= 
prp
->
blocksz
);

77 for (
size_t
 
i
 = 0; i < 
ntag
; i++)

78 
tag
[
i
] = 
NN
[i] ^ 
CC
[i] ^ 
HH
[i];

79 
	}
}

81 int 
	$cf_eax_decrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

82 const 
uint8_t
 *
cipher
, 
size_t
 
ncipher
,

83 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

84 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

85 const 
uint8_t
 *
tag
, 
size_t
 
ntag
,

86 
uint8_t
 *
plain
)

88 
uint8_t
 
NN
[
CF_MAXBLOCK
],

89 
HH
[
CF_MAXBLOCK
],

90 
CC
[
CF_MAXBLOCK
];

92 
cf_cmac_stream
 
cmac
;

93 
	`cf_cmac_stream_init
(&
cmac
, 
prp
, 
prpctx
);

96 
	`cmac_compute_n
(&
cmac
, 0, 
nonce
, 
nnonce
, 
NN
);

99 
	`cmac_compute_n
(&
cmac
, 1, 
header
, 
nheader
, 
HH
);

102 
	`cmac_compute_n
(&
cmac
, 2, 
cipher
, 
ncipher
, 
CC
);

104 
uint8_t
 
tt
[
CF_MAXBLOCK
];

105 
	`assert
(
ntag
 && ntag <= 
prp
->
blocksz
);

106 for (
size_t
 
i
 = 0; i < 
ntag
; i++)

107 
tt
[
i
] = 
NN
[i] ^ 
CC
[i] ^ 
HH
[i];

109 if (!
	`mem_eq
(
tt
, 
tag
, 
ntag
))

112 
cf_ctr
 
ctr
;

113 
	`cf_ctr_init
(&
ctr
, 
prp
, 
prpctx
, 
NN
);

114 
	`cf_ctr_cipher
(&
ctr
, 
cipher
, 
plain
, 
ncipher
);

116 
	}
}

	@deps/picotls/deps/cifra/src/ext/cutest.h

22 #ifndef 
CUTEST_H__


23 #define 
	#CUTEST_H__


	)

55 #define 
	#TEST_LIST
 const struct 
test__
 
test_list__
[]

	)

77 #define 
	#TEST_CHECK_
(
cond
,...) 
	`test_check__
((cond), 
__FILE__
, 
__LINE__
, 
__VA_ARGS__
)

	)

78 #define 
	#TEST_CHECK
(
cond
) 
	`test_check__
((cond), 
__FILE__
, 
__LINE__
, "%s", #cond)

	)

87 #include 
	~<stdarg.h
>

88 #include 
	~<stdio.h
>

89 #include 
	~<stdlib.h
>

90 #include 
	~<string.h
>

92 #if 
defined
(
unix
) || defined(
__unix__
) || defined(
__unix
) || defined(
__APPLE__
)

93 #define 
	#CUTEST_UNIX__
 1

	)

94 #include 
	~<errno.h
>

95 #include 
	~<unistd.h
>

96 #include 
	~<sys/types.h
>

97 #include 
	~<sys/wait.h
>

98 #include 
	~<signal.h
>

101 #if 
defined
(
_WIN32
) || defined(
__WIN32__
) || defined(
__WINDOWS__
)

102 #define 
	#CUTEST_WIN__
 1

	)

103 #include 
	~<windows.h
>

104 #include 
	~<io.h
>

107 #ifdef 
__cplusplus


108 #include 
	~<exception
>

116 #ifdef 
__cplusplus


121 struct 
	stest__
 {

122 const char* 
name
;

123 void (*
func
)(void);

126 extern const struct 
test__
 
test_list__
[];

127 extern int 
test_verbose_level__
;

128 extern const struct 
test__
* 
test_current_unit__
;

129 extern int 
test_current_already_logged__
;

130 extern int 
test_current_failures__
;

131 extern int 
test_colorize__
;

134 #define 
	#CUTEST_COLOR_DEFAULT__
 0

	)

135 #define 
	#CUTEST_COLOR_GREEN__
 1

	)

136 #define 
	#CUTEST_COLOR_RED__
 2

	)

137 #define 
	#CUTEST_COLOR_DEFAULT_INTENSIVE__
 3

	)

138 #define 
	#CUTEST_COLOR_GREEN_INTENSIVE__
 4

	)

139 #define 
	#CUTEST_COLOR_RED_INTENSIVE__
 5

	)

141 
size_t


142 
test_print_in_color
(int 
color
, const char* 
fmt
, ...)

144 
va_list
 
	gargs
;

145 char 
	gbuffer
[256];

146 
size_t
 
	gn
;

148 
va_start
(
args
, 
fmt
);

149 
vsnprintf
(
buffer
, sizeof(buffer), 
fmt
, 
args
);

150 
va_end
(
args
);

151 
	gbuffer
[sizeof(
buffer
)-1] = '\0';

153 if(!
	gtest_colorize__
) {

154 return 
printf
("%s", 
buffer
);

157 #if 
defined
 
CUTEST_UNIX__


158 const char* 
	gcol_str
;

159 switch(
	gcolor
) {

160 case 
	gCUTEST_COLOR_GREEN__
: 
col_str
 = "\e[0;32m"; break;

161 case 
	gCUTEST_COLOR_RED__
: 
col_str
 = "\e[0;31m"; break;

162 case 
	gCUTEST_COLOR_GREEN_INTENSIVE__
: 
col_str
 = "\e[1;32m"; break;

163 case 
	gCUTEST_COLOR_RED_INTENSIVE__
: 
col_str
 = "\e[1;30m"; break;

164 case 
	gCUTEST_COLOR_DEFAULT_INTENSIVE__
: 
col_str
 = "\e[1m"; break;

165 default: 
col_str
 = "\e[0m"; break;

167 
printf
("%s", 
col_str
);

168 
	gn
 = 
printf
("%s", 
buffer
);

169 
printf
("\e[0m");

170 return 
	gn
;

171 #elif 
defined
 
CUTEST_WIN__


172 
HANDLE
 
	gh
;

173 
CONSOLE_SCREEN_BUFFER_INFO
 
	ginfo
;

174 
WORD
 
	gattr
;

176 
	gh
 = 
GetStdHandle
(
STD_OUTPUT_HANDLE
);

177 
GetConsoleScreenBufferInfo
(
h
, &
info
);

179 switch(
	gcolor
) {

180 case 
	gCUTEST_COLOR_GREEN__
: 
attr
 = 
FOREGROUND_GREEN
; break;

181 case 
	gCUTEST_COLOR_RED__
: 
attr
 = 
FOREGROUND_RED
; break;

182 case 
	gCUTEST_COLOR_GREEN_INTENSIVE__
: 
attr
 = 
FOREGROUND_GREEN
 | 
FOREGROUND_INTENSITY
; break;

183 case 
	gCUTEST_COLOR_RED_INTENSIVE__
: 
attr
 = 
FOREGROUND_RED
 | 
FOREGROUND_INTENSITY
; break;

184 case 
	gCUTEST_COLOR_DEFAULT_INTENSIVE__
: 
attr
 = 
FOREGROUND_BLUE
 | 
FOREGROUND_GREEN
 | 
FOREGROUND_RED
 | 
FOREGROUND_INTENSITY
; break;

185 default: 
attr
 = 0; break;

187 if(
	gattr
 != 0)

188 
SetConsoleTextAttribute
(
h
, 
attr
);

189 
	gn
 = 
printf
("%s", 
buffer
);

190 
SetConsoleTextAttribute
(
h
, 
info
.
wAttributes
);

191 return 
	gn
;

193 
	gn
 = 
printf
("%s", 
buffer
);

194 return 
	gn
;

199 
test_check__
(int 
cond
, const char* 
file
, int 
line
, const char* 
fmt
, ...)

201 const char *
	gresult_str
;

202 int 
	gresult_color
;

203 int 
	gverbose_level
;

205 if(
	gcond
) {

206 
	gresult_str
 = "ok";

207 
	gresult_color
 = 
CUTEST_COLOR_GREEN__
;

208 
	gverbose_level
 = 3;

210 if(!
	gtest_current_already_logged__
 && 
	gtest_current_unit__
 != 
NULL
) {

211 
printf
("[ ");

212 
test_print_in_color
(
CUTEST_COLOR_RED_INTENSIVE__
, "FAILED");

213 
printf
(" ]\n");

215 
	gresult_str
 = "failed";

216 
	gresult_color
 = 
CUTEST_COLOR_RED__
;

217 
	gverbose_level
 = 2;

218 
	gtest_current_failures__
++;

219 
	gtest_current_already_logged__
++;

222 if(
	gtest_verbose_level__
 >= 
verbose_level
) {

223 
size_t
 
n
 = 0;

224 
va_list
 
	gargs
;

226 
printf
(" ");

228 if(
	gfile
 != 
NULL
)

229 
n
 += 
printf
("%s:%d: Check ", 
file
, 
line
);

231 
va_start
(
args
, 
fmt
);

232 
	gn
 += 
vprintf
(
fmt
, 
args
);

233 
va_end
(
args
);

235 
printf
("... ");

236 
test_print_in_color
(
result_color
, 
result_str
);

237 
printf
("\n");

238 
	gtest_current_already_logged__
++;

241 return (
	gcond
 != 0);

245 #ifndef 
TEST_NO_MAIN


247 static char* 
	gtest_argv0__
 = 
NULL
;

248 static int 
	gtest_count__
 = 0;

249 static int 
	gtest_no_exec__
 = 0;

250 static int 
	gtest_no_summary__
 = 0;

251 static int 
	gtest_skip_mode__
 = 0;

253 static int 
	gtest_stat_failed_units__
 = 0;

254 static int 
	gtest_stat_run_units__
 = 0;

256 const struct 
test__
* 
	gtest_current_unit__
 = 
NULL
;

257 int 
	gtest_current_already_logged__
 = 0;

258 int 
	gtest_verbose_level__
 = 2;

259 int 
	gtest_current_failures__
 = 0;

260 int 
	gtest_colorize__
 = 0;

264 
test_list_names__
(void)

266 const struct 
test__
* 
	gtest
;

268 
printf
("Unit tests:\n");

269 for(
	gtest
 = &
test_list__
[0]; test->
	gfunc
 != 
NULL
; test++)

270 
printf
(" %s\n", 
test
->
name
);

273 static const struct 
test__
*

274 
test_by_name__
(const char* 
name
)

276 const struct 
test__
* 
	gtest
;

278 for(
	gtest
 = &
test_list__
[0]; test->
	gfunc
 != 
NULL
; test++) {

279 if(
strcmp
(
test
->
name
, name) == 0)

280 return 
test
;

283 return 
	gNULL
;

287 
test_do_run__
(const struct 
test__
* 
test
)

289 
	gtest_current_unit__
 = 
test
;

290 
	gtest_current_failures__
 = 0;

291 
	gtest_current_already_logged__
 = 0;

293 if(
	gtest_verbose_level__
 >= 3) {

294 
test_print_in_color
(
CUTEST_COLOR_DEFAULT_INTENSIVE__
, "Test %s:\n", 
test
->
name
);

295 
	gtest_current_already_logged__
++;

296 } else if(
	gtest_verbose_level__
 >= 1) {

297 
size_t
 
n
;

298 char 
	gspaces
[32];

300 
	gn
 = 
test_print_in_color
(
CUTEST_COLOR_DEFAULT_INTENSIVE__
, "Test %s... ", 
test
->
name
);

301 
memset
(
spaces
, ' ', sizeof(spaces));

302 if(
	gn
 < sizeof(
	gspaces
))

303 
printf
("%.*s", (int) (sizeof(
spaces
) - 
n
), spaces);

305 
	gtest_current_already_logged__
 = 1;

308 #ifdef 
__cplusplus


309 
	gtry
 {

312 
	gtest
->
func
();

314 #ifdef 
__cplusplus


315 } 
catch
(
std
::
exception
& 
e
) {

316 const char* 
what
 = 
e
.what();

317 if(
	gwhat
 != 
NULL
)

318 
test_check__
(0, 
NULL
, 0, "Threw std::exception: %s", 
what
);

320 
test_check__
(0, 
NULL
, 0, "Threw std::exception");

321 } 
catch
(...) {

322 
test_check__
(0, 
NULL
, 0, "Threw an exception");

326 if(
	gtest_verbose_level__
 >= 3) {

327 switch(
test_current_failures__
) {

328 case 0: 
test_print_in_color
(
CUTEST_COLOR_GREEN_INTENSIVE__
, " All conditions have passed.\n\n"); break;

329 case 1: 
test_print_in_color
(
CUTEST_COLOR_RED_INTENSIVE__
, " One condition has FAILED.\n\n"); break;

330 default: 
test_print_in_color
(
CUTEST_COLOR_RED_INTENSIVE__
, " %d conditions have FAILED.\n\n", 
test_current_failures__
); break;

332 } else if(
	gtest_verbose_level__
 >= 1 && 
test_current_failures__
 == 0) {

333 
printf
("[ ");

334 
test_print_in_color
(
CUTEST_COLOR_GREEN_INTENSIVE__
, "OK");

335 
printf
(" ]\n");

338 
	gtest_current_unit__
 = 
NULL
;

339 return (
	gtest_current_failures__
 == 0) ? 0 : -1;

343 
test_error__
(const char* 
fmt
, ...)

345 
va_list
 
	gargs
;

347 if(!
	gtest_current_already_logged__
 && 
	gtest_current_unit__
 != 
NULL
) {

348 
printf
("[ ");

349 
test_print_in_color
(
CUTEST_COLOR_RED_INTENSIVE__
, "FAILED");

350 
printf
(" ]\n");

353 if(
	gtest_verbose_level__
 < 2)

356 
test_print_in_color
(
CUTEST_COLOR_RED_INTENSIVE__
, " Error: ");

357 
va_start
(
args
, 
fmt
);

358 
vprintf
(
fmt
, 
args
);

359 
va_end
(
args
);

360 
printf
("\n");

364 
test_run__
(const struct 
test__
* 
test
)

366 int 
	gfailed
 = 1;

368 
	gtest_current_unit__
 = 
test
;

369 
	gtest_current_already_logged__
 = 0;

371 if(!
	gtest_no_exec__
) {

373 #if 
defined
(
CUTEST_UNIX__
)

375 
pid_t
 
	gpid
;

376 int 
	gexit_code
;

378 
	gpid
 = 
fork
();

379 if(
	gpid
 == (
pid_t
)-1) {

380 
test_error__
("Cannot fork. %s [%d]", 
strerror
(
errno
), errno);

381 
	gfailed
 = 1;

382 } else if(
	gpid
 == 0) {

383 
failed
 = (
test_do_run__
(
test
) != 0);

384 
exit
(
failed
 ? 1 : 0);

386 
waitpid
(
pid
, &
exit_code
, 0);

387 if(
WIFEXITED
(
exit_code
)) {

388 switch(
WEXITSTATUS
(
exit_code
)) {

389 case 0: 
failed
 = 0; break;

391 default: 
test_error__
("Unexpected exit code [%d]", 
WEXITSTATUS
(
exit_code
));

393 } else if(
WIFSIGNALED
(
exit_code
)) {

394 char 
	gtmp
[32];

395 const char* 
	gsigname
;

396 switch(
WTERMSIG
(
exit_code
)) {

397 case 
	gSIGINT
: 
signame
 = "SIGINT"; break;

398 case 
	gSIGHUP
: 
signame
 = "SIGHUP"; break;

399 case 
	gSIGQUIT
: 
signame
 = "SIGQUIT"; break;

400 case 
	gSIGABRT
: 
signame
 = "SIGABRT"; break;

401 case 
	gSIGKILL
: 
signame
 = "SIGKILL"; break;

402 case 
	gSIGSEGV
: 
signame
 = "SIGSEGV"; break;

403 case 
	gSIGILL
: 
signame
 = "SIGILL"; break;

404 case 
	gSIGTERM
: 
signame
 = "SIGTERM"; break;

405 default: 
sprintf
(
tmp
, "signal %d", 
WTERMSIG
(
exit_code
)); 
	gsigname
 = tmp; break;

407 
test_error__
("Test interrupted by %s", 
signame
);

409 
test_error__
("Test ended in an unexpected way [%d]", 
exit_code
);

413 #elif 
defined
(
CUTEST_WIN__
)

415 char 
	gbuffer
[512] = {0};

416 
STARTUPINFOA
 
	gstartupInfo
 = {0};

417 
PROCESS_INFORMATION
 
	gprocessInfo
;

418 
DWORD
 
	gexitCode
;

420 
_snprintf
(
buffer
, sizeof(buffer)-1,

422 
test_argv0__
, 
test_verbose_level__
,

423 
test_colorize__
 ? "always" : "never", 
test
->
name
);

424 
	gstartupInfo
.
	gcb
 = sizeof(
STARTUPINFO
);

425 if(
CreateProcessA
(
NULL
, 
buffer
, NULL, NULL, 
FALSE
, 0, NULL, NULL, &
startupInfo
, &
processInfo
)) {

426 
WaitForSingleObject
(
processInfo
.
hProcess
, 
INFINITE
);

427 
GetExitCodeProcess
(
processInfo
.
hProcess
, &
exitCode
);

428 
CloseHandle
(
processInfo
.
hThread
);

429 
CloseHandle
(
processInfo
.
hProcess
);

430 
	gfailed
 = (
exitCode
 != 0);

432 
test_error__
("Cannot create unit test subprocess [%ld].", 
GetLastError
());

433 
	gfailed
 = 1;

438 
	gfailed
 = (
test_do_run__
(
test
) != 0);

443 
	gfailed
 = (
test_do_run__
(
test
) != 0);

446 
	gtest_current_unit__
 = 
NULL
;

448 
	gtest_stat_run_units__
++;

449 if(
	gfailed
)

450 
	gtest_stat_failed_units__
++;

453 #if 
defined
(
CUTEST_WIN__
)

454 static 
LONG
 
CALLBACK


455 
test_exception_filter__
(
EXCEPTION_POINTERS
 *
ptrs
)

457 
test_error__
("Unhandled SEH exception %08lx at %p.",

458 
ptrs
->
ExceptionRecord
->
ExceptionCode
,

459 
ptrs
->
ExceptionRecord
->
ExceptionAddress
);

460 
fflush
(
stdout
);

461 
fflush
(
stderr
);

462 return 
	gEXCEPTION_EXECUTE_HANDLER
;

467 
test_help__
(void)

469 
printf
("Usage: %s [options] [test...]\n", 
test_argv0__
);

470 
printf
("Run the specified unit tests; or if the option '--skip' is used, run all\n");

471 
printf
("tests in the suite but those listed. By default, if no tests are specified\n");

472 
printf
("on the command line, all unit tests in the suite are run.\n");

473 
printf
("\n");

474 
printf
("Options:\n");

475 
printf
(" -s, --skip Execute all unit tests but the listed ones\n");

476 
printf
(" --no-exec Do not execute unit tests as child processes\n");

477 
printf
(" --no-summary Suppress printing of test results summary\n");

478 
printf
(" -l, --list List unit tests in the suite and exit\n");

479 
printf
(" -v, --verbose Enable more verbose output\n");

480 
printf
(" --verbose=LEVEL Set verbose level to LEVEL (small integer)\n");

481 
printf
(" --color=WHEN Enable colorized output (WHEN is one of 'auto', 'always', 'never')\n");

482 
printf
(" -h, --help Display this help and exit\n");

483 
printf
("\n");

484 
test_list_names__
();

488 
main
(int 
argc
, char** 
argv
)

490 const struct 
test__
** 
	gtests
 = 
NULL
;

491 int 
	gi
, 
	gj
, 
	gn
 = 0;

492 int 
	gseen_double_dash
 = 0;

494 
	gtest_argv0__
 = 
argv
[0];

496 #if 
defined
 
CUTEST_UNIX__


497 
	gtest_colorize__
 = 
isatty
(
fileno
(
stdout
));

498 #elif 
defined
 
CUTEST_WIN__


499 
	gtest_colorize__
 = 
_isatty
(
_fileno
(
stdout
));

501 
	gtest_colorize__
 = 0;

505 for(
	gi
 = 1; i < 
	gargc
; i++) {

506 if(
	gseen_double_dash
 || 
	gargv
[
i
][0] != '-') {

507 
tests
 = (const struct 
test__
**) 
realloc
(tests, (
n
+1) * sizeof(const struct test__*));

508 if(
	gtests
 == 
NULL
) {

509 
fprintf
(
stderr
, "Out of memory.\n");

510 
exit
(2);

512 
	gtests
[
n
] = 
test_by_name__
(
argv
[
i
]);

513 if(
	gtests
[
n
] == 
NULL
) {

514 
fprintf
(
stderr
, "%s: Unrecognized unit test '%s'\n", 
argv
[0], argv[
i
]);

515 
fprintf
(
stderr
, "Try '%s --list' for list of unit tests.\n", 
argv
[0]);

516 
exit
(2);

518 
	gn
++;

519 } else if(
strcmp
(
argv
[
i
], "--") == 0) {

520 
seen_double_dash
 = 1;

521 } else if(
strcmp
(
argv
[
i
], "--help") == 0 || strcmp(argv[i], "-h") == 0) {

522 
test_help__
();

523 
exit
(0);

524 } else if(
strcmp
(
argv
[
i
], "--verbose") == 0 || strcmp(argv[i], "-v") == 0) {

525 
test_verbose_level__
++;

526 } else if(
strncmp
(
argv
[
i
], "--verbose=", 10) == 0) {

527 
test_verbose_level__
 = 
atoi
(
argv
[
i
] + 10);

528 } else if(
strcmp
(
argv
[
i
], "--color=auto") == 0) {

530 } else if(
strcmp
(
argv
[
i
], "--color=always") == 0 || strcmp(argv[i], "--color") == 0) {

531 
test_colorize__
 = 1;

532 } else if(
strcmp
(
argv
[
i
], "--color=never") == 0) {

533 
test_colorize__
 = 0;

534 } else if(
strcmp
(
argv
[
i
], "--skip") == 0 || strcmp(argv[i], "-s") == 0) {

535 
test_skip_mode__
 = 1;

536 } else if(
strcmp
(
argv
[
i
], "--no-exec") == 0) {

537 
test_no_exec__
 = 1;

538 } else if(
strcmp
(
argv
[
i
], "--no-summary") == 0) {

539 
test_no_summary__
 = 1;

540 } else if(
strcmp
(
argv
[
i
], "--list") == 0 || strcmp(argv[i], "-l") == 0) {

541 
test_list_names__
();

542 
exit
(0);

544 
fprintf
(
stderr
, "%s: Unrecognized option '%s'\n", 
argv
[0], argv[
i
]);

545 
fprintf
(
stderr
, "Try '%s --help' for more information.\n", 
argv
[0]);

546 
exit
(2);

550 #if 
defined
(
CUTEST_WIN__
)

551 
SetUnhandledExceptionFilter
(
test_exception_filter__
);

555 
	gtest_count__
 = 0;

556 for(
	gi
 = 0; 
	gtest_list__
[
i
].
	gfunc
 != 
NULL
; i++)

557 
	gtest_count__
++;

560 if(
	gn
 == 0) {

562 for(
i
 = 0; 
	gtest_list__
[i].
	gfunc
 != 
NULL
; 
	gi
++)

563 
test_run__
(&
test_list__
[
i
]);

564 } else if(!
	gtest_skip_mode__
) {

566 for(
	gi
 = 0; i < 
	gn
; i++)

567 
test_run__
(
tests
[
i
]);

570 int 
	gis_skipped
;

572 for(
	gi
 = 0; 
	gtest_list__
[
i
].
	gfunc
 != 
NULL
; i++) {

573 
	gis_skipped
 = 0;

574 for(
	gj
 = 0; j < 
	gn
; j++) {

575 if(
	gtests
[
j
] == &
test_list__
[
i
]) {

576 
is_skipped
 = 1;

580 if(!
	gis_skipped
)

581 
test_run__
(&
test_list__
[
i
]);

586 if(!
	gtest_no_summary__
 && 
	gtest_verbose_level__
 >= 1) {

587 
test_print_in_color
(
CUTEST_COLOR_DEFAULT_INTENSIVE__
, "\nSummary:\n");

589 if(
	gtest_verbose_level__
 >= 3) {

590 
printf
(" Count of all unit tests: %4d\n", 
test_count__
);

591 
printf
(" Count of run unit tests: %4d\n", 
test_stat_run_units__
);

592 
printf
(" Count of failed unit tests: %4d\n", 
test_stat_failed_units__
);

593 
printf
(" Count of skipped unit tests: %4d\n", 
test_count__
 - 
test_stat_run_units__
);

596 if(
	gtest_stat_failed_units__
 == 0) {

597 
test_print_in_color
(
CUTEST_COLOR_GREEN_INTENSIVE__
,

600 
test_print_in_color
(
CUTEST_COLOR_RED_INTENSIVE__
,

602 
test_stat_failed_units__
, 
test_stat_run_units__
);

606 if(
	gtests
 != 
NULL
)

607 
free
(
tests
);

609 return (
	gtest_stat_failed_units__
 == 0) ? 0 : 1;

615 #ifdef 
__cplusplus


	@deps/picotls/deps/cifra/src/ext/handy.h

1 #ifndef 
HANDY_H


2 #define 
	#HANDY_H


	)

4 #include 
	~<stddef.h
>

5 #include 
	~<stdint.h
>

6 #include 
	~<string.h
>

13 #define 
	#ARRAYCOUNT
(
arr
) (sizeof arr / sizeof arr[0])

	)

15 #ifndef 
MIN


16 #define 
	#MIN
(
x
, 
y
) ((x) < (y) ? (x) : (y))

	)

20 #define 
	#STRINGIFY
(
x
) 
	`STRINGIFY_
(x)

	)

21 #define 
	#STRINGIFY_
(
x
) #x

	)

31 #define 
	#ER
(
expr
) do { 
	`typeof
 (expr) 
err_
 = (expr); if (err_) return err_; } while (0)

	)

37 #define 
	#EG
(
expr
) do { 
err
 = (expr); if (err) goto 
x_err
; } while (0)

	)

41 static 
inline
 void 
	$mem_clean
(volatile void *
v
, 
size_t
 
len
)

43 if (
len
)

45 
	`memset
((void *) 
v
, 0, 
len
);

46 (void) *((volatile 
uint8_t
 *) 
v
);

48 
	}
}

52 static 
inline
 unsigned 
	$mem_eq
(const void *
va
, const void *
vb
, 
size_t
 
len
)

54 const volatile 
uint8_t
 *
a
 = 
va
;

55 const volatile 
uint8_t
 *
b
 = 
vb
;

56 
uint8_t
 
diff
 = 0;

58 while (
len
--)

60 
diff
 |= *
a
++ ^ *
b
++;

63 return !
diff
;

64 
	}
}

	@deps/picotls/deps/cifra/src/gcm.c

15 #include 
	~"handy.h
"

16 #include 
	~"prp.h
"

17 #include 
	~"modes.h
"

18 #include 
	~"blockwise.h
"

19 #include 
	~"bitops.h
"

20 #include 
	~"gf128.h
"

21 #include 
	~"tassert.h
"

23 #include 
	~<string.h
>

25 #define 
	#STATE_INVALID
 0

	)

26 #define 
	#STATE_AAD
 1

	)

27 #define 
	#STATE_CIPHER
 2

	)

29 static void 
	$ghash_init
(
ghash_ctx
 *
ctx
, 
uint8_t
 
H
[16])

31 
	`memset
(
ctx
, 0, sizeof *ctx);

32 
	`cf_gf128_frombytes_be
(
H
, 
ctx
->H);

33 
ctx
->
state
 = 
STATE_AAD
;

34 
	}
}

36 static void 
	$ghash_block
(void *
vctx
, const 
uint8_t
 *
data
)

38 
ghash_ctx
 *
ctx
 = 
vctx
;

39 
cf_gf128
 
gfdata
;

40 
	`cf_gf128_frombytes_be
(
data
, 
gfdata
);

41 
	`cf_gf128_add
(
gfdata
, 
ctx
->
Y
, ctx->Y);

42 
	`cf_gf128_mul
(
ctx
->
Y
, ctx->
H
, ctx->Y);

43 
	}
}

45 static void 
	$ghash_add
(
ghash_ctx
 *
ctx
, const 
uint8_t
 *
buf
, 
size_t
 
n
)

47 
	`cf_blockwise_accumulate
(
ctx
->
buffer
, &ctx->
buffer_used
,

48 sizeof 
ctx
->
buffer
,

49 
buf
, 
n
,

50 
ghash_block
,

51 
ctx
);

52 
	}
}

54 static void 
	$ghash_add_pad
(
ghash_ctx
 *
ctx
)

56 if (
ctx
->
buffer_used
 == 0)

59 
	`memset
(
ctx
->
buffer
 + ctx->
buffer_used
, 0, sizeof(ctx->buffer) - ctx->buffer_used);

60 
	`ghash_block
(
ctx
, ctx->
buffer
);

61 
ctx
->
buffer_used
 = 0;

62 
	}
}

64 static void 
	$ghash_add_aad
(
ghash_ctx
 *
ctx
, const 
uint8_t
 *
buf
, 
size_t
 
n
)

66 
	`assert
(
ctx
->
state
 == 
STATE_AAD
);

67 
ctx
->
len_aad
 += 
n
;

68 
	`ghash_add
(
ctx
, 
buf
, 
n
);

69 
	}
}

71 static void 
	$ghash_add_cipher
(
ghash_ctx
 *
ctx
, const 
uint8_t
 *
buf
, 
size_t
 
n
)

73 if (
ctx
->
state
 == 
STATE_AAD
)

75 
	`ghash_add_pad
(
ctx
);

76 
ctx
->
state
 = 
STATE_CIPHER
;

79 
	`assert
(
ctx
->
state
 == 
STATE_CIPHER
);

80 
ctx
->
len_cipher
 += 
n
;

81 
	`ghash_add
(
ctx
, 
buf
, 
n
);

82 
	}
}

84 static void 
	$ghash_final
(
ghash_ctx
 *
ctx
, 
uint8_t
 
out
[16])

86 
uint8_t
 
lenbuf
[8];

88 if (
ctx
->
state
 == 
STATE_AAD
 || ctx->state == 
STATE_CIPHER
)

90 
	`ghash_add_pad
(
ctx
);

91 
ctx
->
state
 = 
STATE_INVALID
;

95 
	`write64_be
(
ctx
->
len_aad
 * 8, 
lenbuf
);

96 
	`ghash_add
(
ctx
, 
lenbuf
, sizeof lenbuf);

98 
	`write64_be
(
ctx
->
len_cipher
 * 8, 
lenbuf
);

99 
	`ghash_add
(
ctx
, 
lenbuf
, sizeof lenbuf);

101 
	`assert
(
ctx
->
buffer_used
 == 0);

102 
	`cf_gf128_tobytes_be
(
ctx
->
Y
, 
out
);

103 
	}
}

105 void 
	$cf_gcm_encrypt_init
(const 
cf_prp
 *
prp
, void *
prpctx
, 
cf_gcm_ctx
 *
gcmctx
,

106 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

107 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
)

109 
uint8_t
 
H
[16] = { 0 };

112 
prp
->
	`encrypt
(
prpctx
, 
H
, H);

122 if (
nnonce
 == 12)

124 
	`memcpy
(
gcmctx
->
Y0
, 
nonce
, 
nnonce
);

125 
gcmctx
->
Y0
[12] = gcmctx->Y0[13] = gcmctx->Y0[14] = 0x00;

126 
gcmctx
->
Y0
[15] = 0x01;

128 
	`ghash_init
(&
gcmctx
->
gh
, 
H
);

129 
	`ghash_add_cipher
(&
gcmctx
->
gh
, 
nonce
, 
nnonce
);

130 
	`ghash_final
(&
gcmctx
->
gh
, gcmctx->
Y0
);

134 
	`ghash_init
(&
gcmctx
->
gh
, 
H
);

135 
	`ghash_add_aad
(&
gcmctx
->
gh
, 
header
, 
nheader
);

138 
	`memset
(
gcmctx
->
e_Y0
, 0, sizeof(gcmctx->e_Y0));

139 
	`cf_ctr_init
(&
gcmctx
->
ctr
, 
prp
, 
prpctx
, gcmctx->
Y0
);

140 
	`cf_ctr_custom_counter
(&
gcmctx
->
ctr
, 12, 4);

141 
	`cf_ctr_cipher
(&
gcmctx
->
ctr
, gcmctx->
e_Y0
, gcmctx->e_Y0, sizeof gcmctx->e_Y0);

143 
	`mem_clean
(
H
, sizeof H);

144 
	}
}

146 void 
	$cf_gcm_encrypt_update
(
cf_gcm_ctx
 *
gcmctx
, const 
uint8_t
 *
plain
, 
size_t
 
nplain
, uint8_t *
cipher
)

148 
	`cf_ctr_cipher
(&
gcmctx
->
ctr
, 
plain
, 
cipher
, 
nplain
);

149 
	`ghash_add_cipher
(&
gcmctx
->
gh
, 
cipher
, 
nplain
);

150 
	}
}

152 void 
	$cf_gcm_encrypt_final
(
cf_gcm_ctx
 *
gcmctx
, 
uint8_t
 *
tag
, 
size_t
 
ntag
)

155 
uint8_t
 
full_tag
[16] = { 0 };

156 
	`ghash_final
(&
gcmctx
->
gh
, 
full_tag
);

158 
	`assert
(
ntag
 > 1 && ntag <= 16);

159 
	`xor_bb
(
tag
, 
full_tag
, 
gcmctx
->
e_Y0
, 
ntag
);

161 
	`mem_clean
(
full_tag
, sizeof full_tag);

162 
	`mem_clean
(
gcmctx
, sizeof *gcmctx);

163 
	}
}

165 void 
	$cf_gcm_encrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

166 const 
uint8_t
 *
plain
, 
size_t
 
nplain
,

167 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

168 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

169 
uint8_t
 *
cipher
,

170 
uint8_t
 *
tag
, 
size_t
 
ntag
)

172 
cf_gcm_ctx
 
gcmctx
;

174 
	`cf_gcm_encrypt_init
(
prp
, 
prpctx
, &
gcmctx
, 
header
, 
nheader
, 
nonce
, 
nnonce
);

175 
	`cf_gcm_encrypt_update
(&
gcmctx
, 
plain
, 
nplain
, 
cipher
);

176 
	`cf_gcm_encrypt_final
(&
gcmctx
, 
tag
, 
ntag
);

177 
	}
}

179 int 
	$cf_gcm_decrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

180 const 
uint8_t
 *
cipher
, 
size_t
 
ncipher
,

181 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

182 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

183 const 
uint8_t
 *
tag
, 
size_t
 
ntag
,

184 
uint8_t
 *
plain
)

186 
uint8_t
 
H
[16] = { 0 };

187 
uint8_t
 
Y0
[16];

190 
prp
->
	`encrypt
(
prpctx
, 
H
, H);

200 if (
nnonce
 == 12)

202 
	`memcpy
(
Y0
, 
nonce
, 
nnonce
);

203 
Y0
[12] = Y0[13] = Y0[14] = 0x00;

204 
Y0
[15] = 0x01;

206 
ghash_ctx
 
gh
;

207 
	`ghash_init
(&
gh
, 
H
);

208 
	`ghash_add_cipher
(&
gh
, 
nonce
, 
nnonce
);

209 
	`ghash_final
(&
gh
, 
Y0
);

213 
ghash_ctx
 
gh
;

214 
	`ghash_init
(&
gh
, 
H
);

215 
	`ghash_add_aad
(&
gh
, 
header
, 
nheader
);

218 
uint8_t
 
e_Y0
[16] = { 0 };

219 
cf_ctr
 
ctr
;

220 
	`cf_ctr_init
(&
ctr
, 
prp
, 
prpctx
, 
Y0
);

221 
	`cf_ctr_custom_counter
(&
ctr
, 12, 4);

222 
	`cf_ctr_cipher
(&
ctr
, 
e_Y0
, e_Y0, sizeof e_Y0);

225 
	`ghash_add_cipher
(&
gh
, 
cipher
, 
ncipher
);

228 
uint8_t
 
full_tag
[16];

229 
	`ghash_final
(&
gh
, 
full_tag
);

230 
	`assert
(
ntag
 > 1 && ntag <= 16);

231 
	`xor_bb
(
full_tag
, full_tag, 
e_Y0
, 
ntag
);

233 int 
err
 = 1;

234 if (!
	`mem_eq
(
full_tag
, 
tag
, 
ntag
))

235 goto 
x_err
;

238 
	`cf_ctr_cipher
(&
ctr
, 
cipher
, 
plain
, 
ncipher
);

239 
err
 = 0;

241 
x_err
:

242 
	`mem_clean
(
H
, sizeof H);

243 
	`mem_clean
(
Y0
, sizeof Y0);

244 
	`mem_clean
(
e_Y0
, sizeof e_Y0);

245 
	`mem_clean
(
full_tag
, sizeof full_tag);

246 
	`mem_clean
(&
gh
, sizeof gh);

247 
	`mem_clean
(&
ctr
, sizeof ctr);

248 return 
err
;

249 
	}
}

	@deps/picotls/deps/cifra/src/gf128.c

15 #include 
	~"cf_config.h
"

16 #include 
	~"gf128.h
"

17 #include 
	~"bitops.h
"

19 #include 
	~<string.h
>

21 void 
	$cf_gf128_tobytes_be
(const 
cf_gf128
 
in
, 
uint8_t
 
out
[16])

23 
	`write32_be
(
in
[0], 
out
 + 0);

24 
	`write32_be
(
in
[1], 
out
 + 4);

25 
	`write32_be
(
in
[2], 
out
 + 8);

26 
	`write32_be
(
in
[3], 
out
 + 12);

27 
	}
}

29 void 
	$cf_gf128_frombytes_be
(const 
uint8_t
 
in
[16], 
cf_gf128
 
out
)

31 
out
[0] = 
	`read32_be
(
in
 + 0);

32 
out
[1] = 
	`read32_be
(
in
 + 4);

33 
out
[2] = 
	`read32_be
(
in
 + 8);

34 
out
[3] = 
	`read32_be
(
in
 + 12);

35 
	}
}

38 void 
	$cf_gf128_double
(const 
cf_gf128
 
in
, cf_gf128 
out
)

40 
uint8_t
 
table
[2] = { 0x00, 0x87 };

41 
uint32_t
 
borrow
 = 0;

42 
uint32_t
 
inword
;

44 
inword
 = 
in
[3]; 
out
[3] = (inword << 1) | 
borrow
; borrow = inword >> 31;

45 
inword
 = 
in
[2]; 
out
[2] = (inword << 1) | 
borrow
; borrow = inword >> 31;

46 
inword
 = 
in
[1]; 
out
[1] = (inword << 1) | 
borrow
; borrow = inword >> 31;

47 
inword
 = 
in
[0]; 
out
[0] = (inword << 1) | 
borrow
; borrow = inword >> 31;

49 #if 
CF_CACHE_SIDE_CHANNEL_PROTECTION


50 
out
[3] ^= 
	`select_u8
(
borrow
, 
table
, 2);

52 
out
[3] ^= 
table
[
borrow
];

54 
	}
}

57 void 
	$cf_gf128_double_le
(const 
cf_gf128
 
in
, cf_gf128 
out
)

59 
uint8_t
 
table
[2] = { 0x00, 0xe1 };

60 
uint32_t
 
borrow
 = 0;

61 
uint32_t
 
inword
;

63 
inword
 = 
in
[0]; 
out
[0] = (inword >> 1) | (
borrow
 << 31); borrow = inword & 1;

64 
inword
 = 
in
[1]; 
out
[1] = (inword >> 1) | (
borrow
 << 31); borrow = inword & 1;

65 
inword
 = 
in
[2]; 
out
[2] = (inword >> 1) | (
borrow
 << 31); borrow = inword & 1;

66 
inword
 = 
in
[3]; 
out
[3] = (inword >> 1) | (
borrow
 << 31); borrow = inword & 1;

68 #if 
CF_CACHE_SIDE_CHANNEL_PROTECTION


69 
out
[0] ^= 
	`select_u8
(
borrow
, 
table
, 2) << 24;

71 
out
[0] ^= 
table
[
borrow
] << 24;

73 
	}
}

76 void 
	$cf_gf128_add
(const 
cf_gf128
 
x
, const cf_gf128 
y
, cf_gf128 
out
)

78 
out
[0] = 
x
[0] ^ 
y
[0];

79 
out
[1] = 
x
[1] ^ 
y
[1];

80 
out
[2] = 
x
[2] ^ 
y
[2];

81 
out
[3] = 
x
[3] ^ 
y
[3];

82 
	}
}

85 void 
	$cf_gf128_mul
(const 
cf_gf128
 
x
, const cf_gf128 
y
, cf_gf128 
out
)

87 #if 
CF_TIME_SIDE_CHANNEL_PROTECTION


88 
cf_gf128
 
zero
 = { 0 };

93 
cf_gf128
 
Z
, 
V
;

94 
	`memset
(
Z
, 0, sizeof Z);

95 
	`memcpy
(
V
, 
y
, sizeof V);

97 int 
i
;

98 for (
i
 = 0; i < 128; i++)

100 
uint32_t
 
word
 = 
x
[
i
 >> 5];

101 
uint8_t
 
bit
 = (
word
 >> (31 - (
i
 & 31))) & 1;

103 #if 
CF_TIME_SIDE_CHANNEL_PROTECTION


104 
	`select_xor128
(
Z
, 
zero
, 
V
, 
bit
);

106 if (
bit
)

107 
	`xor_words
(
Z
, 
V
, 4);

110 
	`cf_gf128_double_le
(
V
, V);

113 
	`memcpy
(
out
, 
Z
, sizeof Z);

114 
	}
}

	@deps/picotls/deps/cifra/src/gf128.h

15 #ifndef 
GF128_H


16 #define 
	#GF128_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

27 typedef 
uint32_t
 
	tcf_gf128
[4];

30 void 
cf_gf128_frombytes_be
(const 
uint8_t
 
in
[16], 
cf_gf128
 
out
);

33 void 
cf_gf128_tobytes_be
(const 
cf_gf128
 
in
, 
uint8_t
 
out
[16]);

36 void 
cf_gf128_double
(const 
cf_gf128
 
in
, cf_gf128 
out
);

44 void 
cf_gf128_double_le
(const 
cf_gf128
 
in
, cf_gf128 
out
);

47 void 
cf_gf128_add
(const 
cf_gf128
 
x
, const cf_gf128 
y
, cf_gf128 
out
);

53 void 
cf_gf128_mul
(const 
cf_gf128
 
x
, const cf_gf128 
y
, cf_gf128 
out
);

	@deps/picotls/deps/cifra/src/hmac.c

15 #include 
	~"hmac.h
"

16 #include 
	~"chash.h
"

17 #include 
	~"bitops.h
"

18 #include 
	~"handy.h
"

19 #include 
	~"tassert.h
"

21 #include 
	~<string.h
>

23 void 
	$cf_hmac_init
(
cf_hmac_ctx
 *
ctx
,

24 const 
cf_chash
 *
hash
,

25 const 
uint8_t
 *
key
, 
size_t
 
nkey
)

27 
	`assert
(
ctx
);

28 
	`assert
(
hash
);

30 
	`mem_clean
(
ctx
, sizeof *ctx);

31 
ctx
->
hash
 = hash;

34 
uint8_t
 
k
[
CF_CHASH_MAXBLK
];

37 if (
nkey
 > 
hash
->
blocksz
)

42 
	`assert
(
hash
->
hashsz
 <= hash->
blocksz
);

44 
	`cf_hash
(
hash
, 
key
, 
nkey
, 
k
);

45 
key
 = 
k
;

46 
nkey
 = 
hash
->
hashsz
;

50 if (
k
 != 
key
)

51 
	`memcpy
(
k
, 
key
, 
nkey
);

52 if (
hash
->
blocksz
 > 
nkey
)

53 
	`memset
(
k
 + 
nkey
, 0, 
hash
->
blocksz
 - nkey);

56 
uint8_t
 
blk
[
CF_CHASH_MAXBLK
];

58 
	`xor_b8
(
blk
, 
k
, 0x36, 
hash
->
blocksz
);

59 
hash
->
	`init
(&
ctx
->
inner
);

60 
hash
->
	`update
(&
ctx
->
inner
, 
blk
, hash->
blocksz
);

63 
	`xor_b8
(
blk
, 
k
, 0x5c, 
hash
->
blocksz
);

64 
hash
->
	`init
(&
ctx
->
outer
);

65 
hash
->
	`update
(&
ctx
->
outer
, 
blk
, hash->
blocksz
);

67 
	`mem_clean
(
blk
, sizeof blk);

68 
	`mem_clean
(
k
, sizeof k);

69 
	}
}

71 void 
	$cf_hmac_update
(
cf_hmac_ctx
 *
ctx
, const void *
data
, 
size_t
 
ndata
)

73 
	`assert
(
ctx
 && ctx->
hash
);

75 
ctx
->
hash
->
	`update
(&ctx->
inner
, 
data
, 
ndata
);

76 
	}
}

78 void 
	$cf_hmac_finish
(
cf_hmac_ctx
 *
ctx
, 
uint8_t
 *
out
)

80 
	`assert
(
ctx
 && ctx->
hash
);

81 
	`assert
(
out
);

83 
uint8_t
 
innerh
[
CF_MAXHASH
];

84 
ctx
->
hash
->
	`digest
(&ctx->
inner
, 
innerh
);

86 
ctx
->
hash
->
	`update
(&ctx->
outer
, 
innerh
, ctx->hash->
hashsz
);

87 
ctx
->
hash
->
	`digest
(&ctx->
outer
, 
out
);

89 
	`mem_clean
(
ctx
, sizeof *ctx);

90 
	}
}

92 void 
	$cf_hmac
(const 
uint8_t
 *
key
, 
size_t
 
nkey
,

93 const 
uint8_t
 *
msg
, 
size_t
 
nmsg
,

94 
uint8_t
 *
out
,

95 const 
cf_chash
 *
hash
)

97 
cf_hmac_ctx
 
ctx
;

99 
	`assert
(
out
);

100 
	`assert
(
hash
);

102 
	`cf_hmac_init
(&
ctx
, 
hash
, 
key
, 
nkey
);

103 
	`cf_hmac_update
(&
ctx
, 
msg
, 
nmsg
);

104 
	`cf_hmac_finish
(&
ctx
, 
out
);

105 
	}
}

	@deps/picotls/deps/cifra/src/hmac.h

15 #ifndef 
HMAC_H


16 #define 
	#HMAC_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

21 #include 
	~"chash.h
"

47 const 
cf_chash
 *
	mhash
;

48 
cf_chash_ctx
 
	minner
;

49 
cf_chash_ctx
 
	mouter
;

50 } 
	tcf_hmac_ctx
;

54 void 
cf_hmac_init
(
cf_hmac_ctx
 *
ctx
,

55 const 
cf_chash
 *
hash
,

56 const 
uint8_t
 *
key
, 
size_t
 
nkey
);

60 void 
cf_hmac_update
(
cf_hmac_ctx
 *
ctx
,

61 const void *
data
, 
size_t
 
ndata
);

66 void 
cf_hmac_finish
(
cf_hmac_ctx
 *
ctx
, 
uint8_t
 *
out
);

73 void 
cf_hmac
(const 
uint8_t
 *
key
, 
size_t
 
nkey
,

74 const 
uint8_t
 *
msg
, 
size_t
 
nmsg
,

75 
uint8_t
 *
out
,

76 const 
cf_chash
 *
hash
);

	@deps/picotls/deps/cifra/src/modes.c

15 #include 
	~"prp.h
"

16 #include 
	~"modes.h
"

17 #include 
	~"bitops.h
"

18 #include 
	~"blockwise.h
"

20 #include 
	~<string.h
>

21 #include 
	~"tassert.h
"

24 void 
	$cf_cbc_init
(
cf_cbc
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
, const 
uint8_t
 
iv
[
CF_MAXBLOCK
])

26 
ctx
->
prp
 = prp;

27 
ctx
->
prpctx
 = prpctx;

28 
	`memcpy
(
ctx
->
block
, 
iv
, 
prp
->
blocksz
);

29 
	}
}

31 void 
	$cf_cbc_encrypt
(
cf_cbc
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
blocks
)

33 
uint8_t
 
buf
[
CF_MAXBLOCK
];

34 
size_t
 
nblk
 = 
ctx
->
prp
->
blocksz
;

36 while (
blocks
--)

38 
	`xor_bb
(
buf
, 
input
, 
ctx
->
block
, 
nblk
);

39 
ctx
->
prp
->
	`encrypt
(ctx->
prpctx
, 
buf
, ctx->
block
);

40 
	`memcpy
(
output
, 
ctx
->
block
, 
nblk
);

41 
input
 += 
nblk
;

42 
output
 += 
nblk
;

44 
	}
}

46 void 
	$cf_cbc_decrypt
(
cf_cbc
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
blocks
)

48 
uint8_t
 
buf
[
CF_MAXBLOCK
];

49 
size_t
 
nblk
 = 
ctx
->
prp
->
blocksz
;

51 while (
blocks
--)

53 
ctx
->
prp
->
	`decrypt
(ctx->
prpctx
, 
input
, 
buf
);

54 
	`xor_bb
(
output
, 
buf
, 
ctx
->
block
, 
nblk
);

55 
	`memcpy
(
ctx
->
block
, 
input
, 
nblk
);

56 
input
 += 
nblk
;

57 
output
 += 
nblk
;

59 
	}
}

62 void 
	$cf_ctr_init
(
cf_ctr
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
, const 
uint8_t
 
nonce
[
CF_MAXBLOCK
])

64 
	`memset
(
ctx
, 0, sizeof *ctx);

65 
ctx
->
counter_offset
 = 0;

66 
ctx
->
counter_width
 = 
prp
->
blocksz
;

67 
ctx
->
prp
 = prp;

68 
ctx
->
prpctx
 = prpctx;

69 
ctx
->
nkeymat
 = 0;

70 
	`memcpy
(
ctx
->
nonce
, nonce, 
prp
->
blocksz
);

71 
	}
}

73 void 
	$cf_ctr_custom_counter
(
cf_ctr
 *
ctx
, 
size_t
 
offset
, size_t 
width
)

75 
	`assert
(
ctx
->
prp
->
blocksz
 <= 
offset
 + 
width
);

76 
ctx
->
counter_offset
 = 
offset
;

77 
ctx
->
counter_width
 = 
width
;

78 
	}
}

80 static void 
	$ctr_next_block
(void *
vctx
, 
uint8_t
 *
out
)

82 
cf_ctr
 *
ctx
 = 
vctx
;

83 
ctx
->
prp
->
	`encrypt
(ctx->
prpctx
, ctx->
nonce
, 
out
);

84 
	`incr_be
(
ctx
->
nonce
 + ctx->
counter_offset
, ctx->
counter_width
);

85 
	}
}

87 void 
	$cf_ctr_cipher
(
cf_ctr
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
bytes
)

89 
	`cf_blockwise_xor
(
ctx
->
keymat
, &ctx->
nkeymat
,

90 
ctx
->
prp
->
blocksz
,

91 
input
, 
output
, 
bytes
,

92 
ctr_next_block
,

93 
ctx
);

94 
	}
}

96 void 
	$cf_ctr_discard_block
(
cf_ctr
 *
ctx
)

98 
ctx
->
nkeymat
 = 0;

99 
	}
}

	@deps/picotls/deps/cifra/src/modes.h

15 #ifndef 
MODES_H


16 #define 
	#MODES_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

21 #include 
	~"gf128.h
"

22 #include 
	~"prp.h
"

56 const 
cf_prp
 *
	mprp
;

57 void *
	mprpctx
;

58 
uint8_t
 
	mblock
[
CF_MAXBLOCK
];

59 } 
	tcf_cbc
;

63 void 
cf_cbc_init
(
cf_cbc
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
, const 
uint8_t
 
iv
[
CF_MAXBLOCK
]);

68 void 
cf_cbc_encrypt
(
cf_cbc
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
blocks
);

73 void 
cf_cbc_decrypt
(
cf_cbc
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
blocks
);

116 const 
cf_prp
 *
	mprp
;

117 void *
	mprpctx
;

118 
uint8_t
 
	mnonce
[
CF_MAXBLOCK
];

119 
uint8_t
 
	mkeymat
[
CF_MAXBLOCK
];

120 
size_t
 
	mnkeymat
;

121 
size_t
 
	mcounter_offset
;

122 
size_t
 
	mcounter_width
;

123 } 
	tcf_ctr
;

128 void 
cf_ctr_init
(
cf_ctr
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
, const 
uint8_t
 
nonce
[
CF_MAXBLOCK
]);

135 void 
cf_ctr_custom_counter
(
cf_ctr
 *
ctx
, 
size_t
 
offset
, size_t 
width
);

140 void 
cf_ctr_cipher
(
cf_ctr
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
bytes
);

144 void 
cf_ctr_discard_block
(
cf_ctr
 *
ctx
);

179 const 
cf_prp
 *
	mprp
;

180 void *
	mprpctx
;

181 
cf_cbc
 
	mcbc
;

182 
uint8_t
 
	mbuffer
[
CF_MAXBLOCK
];

183 
size_t
 
	mused
;

184 } 
	tcf_cbcmac_stream
;

188 void 
cf_cbcmac_stream_init
(
cf_cbcmac_stream
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
);

192 void 
cf_cbcmac_stream_reset
(
cf_cbcmac_stream
 *
ctx
);

196 void 
cf_cbcmac_stream_update
(
cf_cbcmac_stream
 *
ctx
, const 
uint8_t
 *
data
, 
size_t
 
ndata
);

201 void 
cf_cbcmac_stream_finish_block_zero
(
cf_cbcmac_stream
 *
ctx
);

207 void 
cf_cbcmac_stream_nopad_final
(
cf_cbcmac_stream
 *
ctx
, 
uint8_t
 
out
[
CF_MAXBLOCK
]);

213 void 
cf_cbcmac_stream_pad_final
(
cf_cbcmac_stream
 *
ctx
, 
uint8_t
 
out
[
CF_MAXBLOCK
]);

248 const 
cf_prp
 *
	mprp
;

249 void *
	mprpctx
;

250 
uint8_t
 
	mB
[
CF_MAXBLOCK
];

251 
uint8_t
 
	mP
[
CF_MAXBLOCK
];

252 } 
	tcf_cmac
;

256 void 
cf_cmac_init
(
cf_cmac
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
);

261 void 
cf_cmac_sign
(
cf_cmac
 *
ctx
, const 
uint8_t
 *
data
, 
size_t
 
bytes
,

262 
uint8_t
 
out
[
CF_MAXBLOCK
]);

294 
cf_cmac
 
	mcmac
;

295 
cf_cbc
 
	mcbc
;

296 
uint8_t
 
	mbuffer
[
CF_MAXBLOCK
];

297 
size_t
 
	mused
;

298 
size_t
 
	mprocessed
;

299 int 
	mfinalised
;

300 } 
	tcf_cmac_stream
;

304 void 
cf_cmac_stream_init
(
cf_cmac_stream
 *
ctx
, const 
cf_prp
 *
prp
, void *
prpctx
);

308 void 
cf_cmac_stream_reset
(
cf_cmac_stream
 *
ctx
);

313 void 
cf_cmac_stream_update
(
cf_cmac_stream
 *
ctx
, const 
uint8_t
 *
data
, 
size_t
 
ndata
,

314 int 
isfinal
);

320 void 
cf_cmac_stream_final
(
cf_cmac_stream
 *
ctx
, 
uint8_t
 
out
[
CF_MAXBLOCK
]);

348 void 
cf_eax_encrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

349 const 
uint8_t
 *
plain
, 
size_t
 
nplain
,

350 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

351 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

352 
uint8_t
 *
cipher
,

353 
uint8_t
 *
tag
, 
size_t
 
ntag
);

371 int 
cf_eax_decrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

372 const 
uint8_t
 *
cipher
, 
size_t
 
ncipher
,

373 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

374 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

375 const 
uint8_t
 *
tag
, 
size_t
 
ntag
,

376 
uint8_t
 *
plain
);

407 void 
cf_gcm_encrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

408 const 
uint8_t
 *
plain
, 
size_t
 
nplain
,

409 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

410 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

411 
uint8_t
 *
cipher
,

412 
uint8_t
 *
tag
, 
size_t
 
ntag
);

417 
cf_gf128
 
	mH
;

418 
cf_gf128
 
	mY
;

419 
uint8_t
 
	mbuffer
[16];

420 
size_t
 
	mbuffer_used
;

421 
uint64_t
 
	mlen_aad
;

422 
uint64_t
 
	mlen_cipher
;

423 unsigned 
	mstate
;

424 } 
	tghash_ctx
;

428 
cf_ctr
 
	mctr
;

429 
ghash_ctx
 
	mgh
;

430 
uint8_t
 
	mY0
[16];

431 
uint8_t
 
	me_Y0
[16];

432 } 
	tcf_gcm_ctx
;

434 void 
cf_gcm_encrypt_init
(const 
cf_prp
 *
prp
, void *
prpctx
, 
cf_gcm_ctx
 *
gcmctx
,

435 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

436 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
);

437 void 
cf_gcm_encrypt_update
(
cf_gcm_ctx
 *
gcmctx
, const 
uint8_t
 *
plain
, 
size_t
 
nplain
, uint8_t *
cipher
);

438 void 
cf_gcm_encrypt_final
(
cf_gcm_ctx
 *
gcmctx
, 
uint8_t
 *
tag
, 
size_t
 
ntag
);

457 int 
cf_gcm_decrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

458 const 
uint8_t
 *
cipher
, 
size_t
 
ncipher
,

459 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

460 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

461 const 
uint8_t
 *
tag
, 
size_t
 
ntag
,

462 
uint8_t
 *
plain
);

497 void 
cf_ccm_encrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

498 const 
uint8_t
 *
plain
, 
size_t
 
nplain
, size_t 
L
,

499 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

500 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

501 
uint8_t
 *
cipher
,

502 
uint8_t
 *
tag
, 
size_t
 
ntag
);

522 int 
cf_ccm_decrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

523 const 
uint8_t
 *
cipher
, 
size_t
 
ncipher
, size_t 
L
,

524 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

525 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

526 const 
uint8_t
 *
tag
, 
size_t
 
ntag
,

527 
uint8_t
 *
plain
);

557 void 
cf_ocb_encrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

558 const 
uint8_t
 *
plain
, 
size_t
 
nplain
,

559 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

560 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

561 
uint8_t
 *
cipher
,

562 
uint8_t
 *
tag
, 
size_t
 
ntag
);

581 int 
cf_ocb_decrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

582 const 
uint8_t
 *
cipher
, 
size_t
 
ncipher
,

583 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

584 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

585 const 
uint8_t
 *
tag
, 
size_t
 
ntag
,

586 
uint8_t
 *
plain
);

	@deps/picotls/deps/cifra/src/norx.c

16 #include 
	~"norx.h
"

17 #include 
	~"bitops.h
"

18 #include 
	~"handy.h
"

19 #include 
	~"blockwise.h
"

20 #include 
	~"tassert.h
"

22 #include 
	~<string.h
>

26 
uint32_t
 
	ms
[16];

27 } 
	tnorx32_ctx
;

30 #define 
	#DOMAIN_HEADER
 0x01

	)

31 #define 
	#DOMAIN_PAYLOAD
 0x02

	)

32 #define 
	#DOMAIN_TRAILER
 0x04

	)

33 #define 
	#DOMAIN_TAG
 0x08

	)

35 #define 
	#WORD_BYTES
 4

	)

36 #define 
	#WORD_BITS
 32

	)

37 #define 
	#ROUNDS
 4

	)

38 #define 
	#DEGREE
 1

	)

39 #define 
	#TAG_BITS
 128

	)

40 #define 
	#RATE_BYTES
 48

	)

41 #define 
	#RATE_WORDS
 12

	)

43 static void 
	$permute
(
norx32_ctx
 *
ctx
)

45 #ifdef 
CORTEX_M0


49 #define 
	#in
(
xx
) "%[" #xx "]"

	)

52 #define 
	#LOAD
(
u
, 
v
, 
w
, 
x
) \

53 " ldr r2, [%[S], " 
	`in
(
u
) "]\n" \

54 " ldr r3, [%[S], " 
	`in
(
v
) "]\n" \

55 " ldr r4, [%[S], " 
	`in
(
w
) "]\n" \

56 " ldr r5, [%[S], " 
	`in
(
x
) "]\n"

	)

59 #define 
	#STORE
(
u
, 
v
, 
w
, 
x
) \

60 " str r2, [%[S], " 
	`in
(
u
) "]\n" \

61 " str r3, [%[S], " 
	`in
(
v
) "]\n" \

62 " str r4, [%[S], " 
	`in
(
w
) "]\n" \

63 " str r5, [%[S], " 
	`in
(
x
) "]\n"

	)

70 #define 
	#P
(
rx
, 
ry
, 
rw
, 
rot
) \

78 " ror " #rw ", r6\n"

	)

82 #define 
	#G
(
s
, 
a
, 
b
, 
c
, 
d
) \

83 
	`__asm__
 ( \

84 
	`LOAD
(
A
, 
B
, 
C
, 
D
) \

85 
	`P
(
r2
, 
r3
, 
r5
, 8) \

86 
	`P
(
r4
, 
r5
, 
r3
, 11) \

87 
	`P
(
r2
, 
r3
, 
r5
, 16) \

88 
	`P
(
r4
, 
r5
, 
r3
, 31) \

89 
	`STORE
(
A
, 
B
, 
C
, 
D
) \

91 : [
S
] "r" (
s
), \

92 [
A
] "i" (
a
 << 2), \

93 [
B
] "i" (
b
 << 2), \

94 [
C
] "i" (
c
 << 2), \

95 [
D
] "i" (
d
 << 2) \

96 : "memory", "cc", "r2", "r3", "r4", "r5", "r6");

	)

100 #define 
	#P
(
u
, 
v
, 
w
, 
rr
) \

101 (
u
) = ((u) ^ (
v
)) ^ (((u) & (v)) << 1); \

102 (
w
) = 
	`rotr32
((
u
) ^ (w), 
rr
);

	)

104 #define 
	#G
(
s
, 
a
, 
b
, 
c
, 
d
) \

105 
	`P
(
s
[
a
], s[
b
], s[
d
], 8) \

106 
	`P
(
s
[
c
], s[
d
], s[
b
], 11) \

107 
	`P
(
s
[
a
], s[
b
], s[
d
], 16) \

108 
	`P
(
s
[
c
], s[
d
], s[
b
], 31)

	)

111 for (int 
i
 = 0; i < 
ROUNDS
; i++)

114 
	`G
(
ctx
->
s
, 0, 4, 8, 12);

115 
	`G
(
ctx
->
s
, 1, 5, 9, 13);

116 
	`G
(
ctx
->
s
, 2, 6, 10, 14);

117 
	`G
(
ctx
->
s
, 3, 7, 11, 15);

120 
	`G
(
ctx
->
s
, 0, 5, 10, 15);

121 
	`G
(
ctx
->
s
, 1, 6, 11, 12);

122 
	`G
(
ctx
->
s
, 2, 7, 8, 13);

123 
	`G
(
ctx
->
s
, 3, 4, 9, 14);

126 #undef 
G


127 #undef 
P


128 
	}
}

130 static void 
	$init
(
norx32_ctx
 *
ctx
,

131 const 
uint8_t
 
key
[16],

132 const 
uint8_t
 
nonce
[8])

135 
ctx
->
s
[0] = 
	`read32_le
(
nonce
 + 0);

136 
ctx
->
s
[1] = 
	`read32_le
(
nonce
 + 4);

137 
ctx
->
s
[2] = 0xb707322f;

138 
ctx
->
s
[3] = 0xa0c7c90d;

140 
ctx
->
s
[4] = 
	`read32_le
(
key
 + 0);

141 
ctx
->
s
[5] = 
	`read32_le
(
key
 + 4);

142 
ctx
->
s
[6] = 
	`read32_le
(
key
 + 8);

143 
ctx
->
s
[7] = 
	`read32_le
(
key
 + 12);

145 
ctx
->
s
[8] = 0xa3d8d930;

146 
ctx
->
s
[9] = 0x3fa8b72c;

147 
ctx
->
s
[10] = 0xed84eb49;

148 
ctx
->
s
[11] = 0xedca4787;

150 
ctx
->
s
[12] = 0x335463eb;

151 
ctx
->
s
[13] = 0xf994220b;

152 
ctx
->
s
[14] = 0xbe0bf5c9;

153 
ctx
->
s
[15] = 0xd7c49104;

161 
ctx
->
s
[12] ^= 
WORD_BITS
;

162 
ctx
->
s
[13] ^= 
ROUNDS
;

163 
ctx
->
s
[14] ^= 
DEGREE
;

164 
ctx
->
s
[15] ^= 
TAG_BITS
;

166 
	`permute
(
ctx
);

167 
	}
}

171 static void 
	$switch_domain
(
norx32_ctx
 *
ctx
, 
uint32_t
 
constant
)

173 
ctx
->
s
[15] ^= 
constant
;

174 
	`permute
(
ctx
);

175 
	}
}

179 
norx32_ctx
 *
	mctx
;

180 
uint32_t
 
	mtype
;

181 } 
	tblockctx
;

183 static void 
	$input_block_final
(void *
vctx
, const 
uint8_t
 *
data
)

185 
blockctx
 *
bctx
 = 
vctx
;

186 
norx32_ctx
 *
ctx
 = 
bctx
->ctx;

189 for (int 
i
 = 0; i < 
RATE_WORDS
; i++)

191 
ctx
->
s
[
i
] ^= 
	`read32_le
(
data
);

192 
data
 += 
WORD_BYTES
;

194 
	}
}

196 static void 
	$input_block
(void *
vctx
, const 
uint8_t
 *
data
)

199 
blockctx
 *
bctx
 = 
vctx
;

200 
	`input_block_final
(
vctx
, 
data
);

201 
	`switch_domain
(
bctx
->
ctx
, bctx->
type
);

202 
	}
}

204 static void 
	$input
(
norx32_ctx
 *
ctx
, 
uint32_t
 
type
,

205 const 
uint8_t
 *
buf
, 
size_t
 
nbuf
)

207 
uint8_t
 
partial
[
RATE_BYTES
];

208 
size_t
 
npartial
 = 0;

209 
blockctx
 
bctx
 = { 
ctx
, 
type
 };

212 
	`cf_blockwise_accumulate
(
partial
, &
npartial
, sizeof partial,

213 
buf
, 
nbuf
,

214 
input_block
,

215 &
bctx
);

218 
	`memset
(
partial
 + 
npartial
, 0, sizeof(partial) - npartial);

219 
partial
[
npartial
] = 0x01;

220 
partial
[sizeof(partial) - 1] ^= 0x80;

222 
	`input_block_final
(&
bctx
, 
partial
);

223 
	}
}

225 static void 
	$do_header
(
norx32_ctx
 *
ctx
, const 
uint8_t
 *
buf
, 
size_t
 
nbuf
)

227 if (
nbuf
)

229 
	`switch_domain
(
ctx
, 
DOMAIN_HEADER
);

230 
	`input
(
ctx
, 
DOMAIN_HEADER
, 
buf
, 
nbuf
);

232 
	}
}

234 static void 
	$do_trailer
(
norx32_ctx
 *
ctx
, const 
uint8_t
 *
buf
, 
size_t
 
nbuf
)

236 if (
nbuf
)

238 
	`switch_domain
(
ctx
, 
DOMAIN_TRAILER
);

239 
	`input
(
ctx
, 
DOMAIN_TRAILER
, 
buf
, 
nbuf
);

241 
	}
}

243 static void 
	$body_block_encrypt
(
norx32_ctx
 *
ctx
,

244 const 
uint8_t
 
plain
[
RATE_BYTES
],

245 
uint8_t
 
cipher
[
RATE_BYTES
])

247 for (int 
i
 = 0; i < 
RATE_WORDS
; i++)

249 
ctx
->
s
[
i
] ^= 
	`read32_le
(
plain
);

250 
	`write32_le
(
ctx
->
s
[
i
], 
cipher
);

251 
plain
 += 
WORD_BYTES
;

252 
cipher
 += 
WORD_BYTES
;

254 
	}
}

256 static void 
	$encrypt_body
(
norx32_ctx
 *
ctx
,

257 const 
uint8_t
 *
plain
, uint8_t *
cipher
, 
size_t
 
nbytes
)

259 if (
nbytes
 == 0)

263 while (
nbytes
 >= 
RATE_BYTES
)

265 
	`switch_domain
(
ctx
, 
DOMAIN_PAYLOAD
);

266 
	`body_block_encrypt
(
ctx
, 
plain
, 
cipher
);

267 
plain
 += 
RATE_BYTES
;

268 
cipher
 += 
RATE_BYTES
;

269 
nbytes
 -= 
RATE_BYTES
;

273 
uint8_t
 
partial
[
RATE_BYTES
];

274 
	`memset
(
partial
, 0, sizeof partial);

275 
	`memcpy
(
partial
, 
plain
, 
nbytes
);

276 
partial
[
nbytes
] ^= 0x01;

277 
partial
[sizeof(partial) - 1] ^= 0x80;

279 
	`switch_domain
(
ctx
, 
DOMAIN_PAYLOAD
);

280 
	`body_block_encrypt
(
ctx
, 
partial
, partial);

282 
	`memcpy
(
cipher
, 
partial
, 
nbytes
);

283 
	}
}

285 static void 
	$body_block_decrypt
(
norx32_ctx
 *
ctx
,

286 const 
uint8_t
 
cipher
[
RATE_BYTES
],

287 
uint8_t
 
plain
[
RATE_BYTES
],

288 
size_t
 
start
, size_t 
end
)

290 for (
size_t
 
i
 = 
start
; i < 
end
; i++)

292 
uint32_t
 
ct
 = 
	`read32_le
(
cipher
);

293 
	`write32_le
(
ctx
->
s
[
i
] ^ 
ct
, 
plain
);

294 
ctx
->
s
[
i
] = 
ct
;

295 
plain
 += 
WORD_BYTES
;

296 
cipher
 += 
WORD_BYTES
;

298 
	}
}

300 static void 
	$undo_padding
(
norx32_ctx
 *
ctx
, 
size_t
 
bytes
)

302 
	`assert
(
bytes
 < 
RATE_BYTES
);

303 
ctx
->
s
[
bytes
 / 
WORD_BYTES
] ^= 0x01 << ((bytes % WORD_BYTES) * 8);

304 
ctx
->
s
[
RATE_WORDS
 - 1] ^= 0x80000000;

305 
	}
}

307 static void 
	$decrypt_body
(
norx32_ctx
 *
ctx
,

308 const 
uint8_t
 *
cipher
, uint8_t *
plain
, 
size_t
 
nbytes
)

310 if (
nbytes
 == 0)

314 while (
nbytes
 >= 
RATE_BYTES
)

316 
	`switch_domain
(
ctx
, 
DOMAIN_PAYLOAD
);

317 
	`body_block_decrypt
(
ctx
, 
cipher
, 
plain
, 0, 
RATE_WORDS
);

318 
plain
 += 
RATE_BYTES
;

319 
cipher
 += 
RATE_BYTES
;

320 
nbytes
 -= 
RATE_BYTES
;

324 
size_t
 
offset
 = 0;

325 
	`switch_domain
(
ctx
, 
DOMAIN_PAYLOAD
);

327 
	`undo_padding
(
ctx
, 
nbytes
);

330 while (
nbytes
 >= 
WORD_BYTES
)

332 
	`body_block_decrypt
(
ctx
, 
cipher
, 
plain
, 
offset
, offset + 1);

333 
plain
 += 
WORD_BYTES
;

334 
cipher
 += 
WORD_BYTES
;

335 
nbytes
 -= 
WORD_BYTES
;

336 
offset
 += 1;

340 
uint8_t
 
tmp
[
WORD_BYTES
];

341 
	`write32_le
(
ctx
->
s
[
offset
], 
tmp
);

343 for (
size_t
 
i
 = 0; i < 
nbytes
; i++)

345 
uint8_t
 
c
 = 
cipher
[
i
];

346 
plain
[
i
] = 
tmp
[i] ^ 
c
;

347 
tmp
[
i
] = 
c
;

350 
ctx
->
s
[
offset
] = 
	`read32_le
(
tmp
);

351 
	}
}

353 static void 
	$get_tag
(
norx32_ctx
 *
ctx
, 
uint8_t
 
tag
[16])

355 
	`switch_domain
(
ctx
, 
DOMAIN_TAG
);

356 
	`permute
(
ctx
);

357 
	`write32_le
(
ctx
->
s
[0], 
tag
 + 0);

358 
	`write32_le
(
ctx
->
s
[1], 
tag
 + 4);

359 
	`write32_le
(
ctx
->
s
[2], 
tag
 + 8);

360 
	`write32_le
(
ctx
->
s
[3], 
tag
 + 12);

361 
	}
}

363 void 
	$cf_norx32_encrypt
(const 
uint8_t
 
key
[16],

364 const 
uint8_t
 
nonce
[8],

365 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

366 const 
uint8_t
 *
plaintext
, 
size_t
 
nbytes
,

367 const 
uint8_t
 *
trailer
, 
size_t
 
ntrailer
,

368 
uint8_t
 *
ciphertext
,

369 
uint8_t
 
tag
[16])

371 
norx32_ctx
 
ctx
;

373 
	`init
(&
ctx
, 
key
, 
nonce
);

374 
	`do_header
(&
ctx
, 
header
, 
nheader
);

375 
	`encrypt_body
(&
ctx
, 
plaintext
, 
ciphertext
, 
nbytes
);

376 
	`do_trailer
(&
ctx
, 
trailer
, 
ntrailer
);

377 
	`get_tag
(&
ctx
, 
tag
);

379 
	`mem_clean
(&
ctx
, sizeof ctx);

380 
	}
}

382 int 
	$cf_norx32_decrypt
(const 
uint8_t
 
key
[16],

383 const 
uint8_t
 
nonce
[8],

384 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

385 const 
uint8_t
 *
ciphertext
, 
size_t
 
nbytes
,

386 const 
uint8_t
 *
trailer
, 
size_t
 
ntrailer
,

387 const 
uint8_t
 
tag
[16],

388 
uint8_t
 *
plaintext
)

390 
norx32_ctx
 
ctx
;

391 
uint8_t
 
ourtag
[16];

393 
	`init
(&
ctx
, 
key
, 
nonce
);

394 
	`do_header
(&
ctx
, 
header
, 
nheader
);

395 
	`decrypt_body
(&
ctx
, 
ciphertext
, 
plaintext
, 
nbytes
);

396 
	`do_trailer
(&
ctx
, 
trailer
, 
ntrailer
);

397 
	`get_tag
(&
ctx
, 
ourtag
);

399 int 
err
 = 0;

401 if (!
	`mem_eq
(
ourtag
, 
tag
, sizeof ourtag))

403 
err
 = 1;

404 
	`mem_clean
(
plaintext
, 
nbytes
);

405 
	`mem_clean
(
ourtag
, sizeof ourtag);

408 
	`mem_clean
(&
ctx
, sizeof ctx);

409 return 
err
;

410 
	}
}

	@deps/picotls/deps/cifra/src/norx.h

15 #ifndef 
NORX_H


16 #define 
	#NORX_H


	)

18 #include 
	~<stdint.h
>

19 #include 
	~<stddef.h
>

53 void 
cf_norx32_encrypt
(const 
uint8_t
 
key
[16],

54 const 
uint8_t
 
nonce
[8],

55 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

56 const 
uint8_t
 *
plaintext
, 
size_t
 
nbytes
,

57 const 
uint8_t
 *
trailer
, 
size_t
 
ntrailer
,

58 
uint8_t
 *
ciphertext
,

59 
uint8_t
 
tag
[16]);

76 int 
cf_norx32_decrypt
(const 
uint8_t
 
key
[16],

77 const 
uint8_t
 
nonce
[8],

78 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

79 const 
uint8_t
 *
ciphertext
, 
size_t
 
nbytes
,

80 const 
uint8_t
 *
trailer
, 
size_t
 
ntrailer
,

81 const 
uint8_t
 
tag
[16],

82 
uint8_t
 *
plaintext
);

	@deps/picotls/deps/cifra/src/ocb.c

15 #include 
	~"handy.h
"

16 #include 
	~"prp.h
"

17 #include 
	~"modes.h
"

18 #include 
	~"blockwise.h
"

19 #include 
	~"bitops.h
"

20 #include 
	~"gf128.h
"

21 #include 
	~"tassert.h
"

23 #include 
	~<string.h
>

26 #define 
	#MAX_L
 4

	)

29 #define 
	#BLOCK
 16

	)

33 const 
cf_prp
 *
	mprp
;

34 void *
	mprpctx
;

35 
uint8_t
 *
	mout
;

36 
cf_gf128
 
	mL_star
;

37 
cf_gf128
 
	mL_dollar
;

38 
cf_gf128
 
	mL
[
MAX_L
];

39 
cf_gf128
 
	moffset
;

40 
cf_gf128
 
	mchecksum
;

41 
uint32_t
 
	mi
;

42 } 
	tocb
;

46 
ocb
 *
	mo
;

47 
cf_gf128
 
	msum
;

48 
cf_gf128
 
	moffset
;

49 
uint32_t
 
	mi
;

50 } 
	tocb_hash
;

52 static void 
	$ocb_init
(
ocb
 *
o
, const 
cf_prp
 *
prp
, void *
prpctx
,

53 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

54 
size_t
 
ntag
)

56 
o
->
prp
 = prp;

57 
o
->
prpctx
 = prpctx;

59 
	`assert
(
o
->
prp
->
blocksz
 == 
BLOCK
);

62 
uint8_t
 
L_star_bytes
[
BLOCK
] = { 0 };

63 
prp
->
	`encrypt
(
prpctx
, 
L_star_bytes
, L_star_bytes);

64 
	`cf_gf128_frombytes_be
(
L_star_bytes
, 
o
->
L_star
);

67 
	`cf_gf128_double
(
o
->
L_star
, o->
L_dollar
);

70 
	`cf_gf128_double
(
o
->
L_dollar
, o->
L
[0]);

72 for (int 
i
 = 1; i < 
MAX_L
; i++)

73 
	`cf_gf128_double
(
o
->
L
[
i
 - 1], o->L[i]);

76 
	`assert
(
nnonce
 > 0 && nnonce < 
BLOCK
);

77 
uint8_t
 
full_nonce
[
BLOCK
] = { 0 };

78 
full_nonce
[0] = ((
ntag
 * 8) & 0x7f) << 1;

79 
full_nonce
[
BLOCK
 - 1 - 
nnonce
] |= 0x01;

80 
	`memcpy
(
full_nonce
 + 
BLOCK
 - 
nnonce
, 
nonce
, nnonce);

81 
uint8_t
 
bottom
 = 
full_nonce
[
BLOCK
 - 1] & 0x3f;

84 
full_nonce
[
BLOCK
 - 1] &= 0xc0;

85 
uint8_t
 
Ktop
[
BLOCK
 + 8];

86 
prp
->
	`encrypt
(
prpctx
, 
full_nonce
, 
Ktop
);

89 for (int 
i
 = 0; i < 8; i++)

90 
Ktop
[
i
 + 
BLOCK
] = Ktop[i] ^ Ktop[i + 1];

93 
uint8_t
 
offset
[
BLOCK
];

94 
	`copy_bytes_unaligned
(
offset
, 
Ktop
, 
BLOCK
, 
bottom
);

95 
	`cf_gf128_frombytes_be
(
offset
, 
o
->offset);

96 
	`memset
(
o
->
checksum
, 0, sizeof o->checksum);

97 
	}
}

99 static void 
	$ocb_start_cipher
(
ocb
 *
o
, 
uint8_t
 *
output
)

101 
o
->
i
 = 1;

102 
o
->
out
 = 
output
;

103 
	}
}

105 static void 
	$ocb_add_Ln
(
ocb
 *
o
, 
uint32_t
 
n
, 
cf_gf128
 
out
)

108 if (
n
 < 
MAX_L
)

110 
	`cf_gf128_add
(
o
->
L
[
n
], 
out
, out);

115 
cf_gf128
 
accum
;

116 
	`memcpy
(
accum
, 
o
->
L
[
MAX_L
 - 1], sizeof accum);

118 for (
uint32_t
 
i
 = 
MAX_L
 - 1; i < 
n
; i++)

120 
cf_gf128
 
next
;

121 
	`cf_gf128_double
(
accum
, 
next
);

122 
	`memcpy
(
accum
, 
next
, sizeof accum);

125 
	`cf_gf128_add
(
accum
, 
out
, out);

126 
	}
}

128 static void 
	$ocb_hash_init
(
ocb_hash
 *
h
)

130 
	`memset
(
h
->
offset
, 0, sizeof h->offset);

131 
	`memset
(
h
->
sum
, 0, sizeof h->sum);

132 
h
->
i
 = 1;

133 
	}
}

135 static void 
	$ocb_hash_sum
(
ocb
 *
o
, const 
uint8_t
 *
block
,

136 
cf_gf128
 
sum
, const cf_gf128 
offset
)

138 
uint8_t
 
offset_bytes
[
BLOCK
];

139 
	`cf_gf128_tobytes_be
(
offset
, 
offset_bytes
);

141 
uint8_t
 
block_tmp
[
BLOCK
];

142 
	`xor_bb
(
block_tmp
, 
block
, 
offset_bytes
, sizeof block_tmp);

143 
o
->
prp
->
	`encrypt
(o->
prpctx
, 
block_tmp
, block_tmp);

145 
cf_gf128
 
tmp
;

146 
	`cf_gf128_frombytes_be
(
block_tmp
, 
tmp
);

147 
	`cf_gf128_add
(
sum
, 
tmp
, sum);

148 
	}
}

150 static void 
	$ocb_hash_block
(void *
vctx
, const 
uint8_t
 *
block
)

152 
ocb_hash
 *
h
 = 
vctx
;

155 
	`ocb_add_Ln
(
h
->
o
, 
	`count_trailing_zeroes
(h->
i
), h->
offset
);

158 
	`ocb_hash_sum
(
h
->
o
, 
block
, h->
sum
, h->
offset
);

160 
h
->
i
++;

161 
	}
}

163 static void 
	$ocb_process_header
(
ocb
 *
o
, const 
uint8_t
 *
header
, 
size_t
 
nheader
,

164 
uint8_t
 
out
[
BLOCK
])

166 
ocb_hash
 
ctx
 = { 
o
 };

167 
	`ocb_hash_init
(&
ctx
);

169 
uint8_t
 
partial
[
BLOCK
];

170 
size_t
 
npartial
 = 0;

172 
	`cf_blockwise_accumulate
(
partial
, &
npartial
,

173 
o
->
prp
->
blocksz
,

174 
header
, 
nheader
,

175 
ocb_hash_block
,

176 &
ctx
);

178 if (
npartial
)

181 
	`cf_gf128_add
(
ctx
.
offset
, 
o
->
L_star
, ctx.offset);

184 
	`memset
(
partial
 + 
npartial
, 0, sizeof(partial) - npartial);

185 
partial
[
npartial
] = 0x80;

188 
	`ocb_hash_sum
(
ctx
.
o
, 
partial
, ctx.
sum
, ctx.
offset
);

191 
	`cf_gf128_tobytes_be
(
ctx
.
sum
, 
out
);

192 
	`mem_clean
(&
ctx
, sizeof ctx);

193 
	}
}

195 static void 
	$ocb_encrypt_block
(void *
vctx
, const 
uint8_t
 *
block
)

197 
ocb
 *
o
 = 
vctx
;

200 
	`ocb_add_Ln
(
o
, 
	`count_trailing_zeroes
(o->
i
), o->
offset
);

203 
uint8_t
 
offset_bytes
[
BLOCK
];

204 
	`cf_gf128_tobytes_be
(
o
->
offset
, 
offset_bytes
);

206 
uint8_t
 
block_tmp
[
BLOCK
];

207 
	`xor_bb
(
block_tmp
, 
block
, 
offset_bytes
, sizeof block_tmp);

208 
o
->
prp
->
	`encrypt
(o->
prpctx
, 
block_tmp
, block_tmp);

209 
	`xor_bb
(
o
->
out
, 
block_tmp
, 
offset_bytes
, sizeof block_tmp);

210 
o
->
out
 += sizeof 
block_tmp
;

213 
cf_gf128
 
P
;

214 
	`cf_gf128_frombytes_be
(
block
, 
P
);

215 
	`cf_gf128_add
(
o
->
checksum
, 
P
, o->checksum);

217 
o
->
i
++;

218 
	}
}

220 void 
	$cf_ocb_encrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

221 const 
uint8_t
 *
plain
, 
size_t
 
nplain
,

222 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

223 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

224 
uint8_t
 *
cipher
,

225 
uint8_t
 *
tag
, 
size_t
 
ntag
)

227 
ocb
 
o
;

228 
	`ocb_init
(&
o
, 
prp
, 
prpctx
, 
nonce
, 
nnonce
, 
ntag
);

233 
uint8_t
 
partial
[
BLOCK
];

234 
size_t
 
npartial
 = 0;

236 
	`ocb_start_cipher
(&
o
, 
cipher
);

237 
	`cf_blockwise_accumulate
(
partial
, &
npartial
,

238 
prp
->
blocksz
,

239 
plain
, 
nplain
,

240 
ocb_encrypt_block
,

241 &
o
);

244 
plain
 += (
o
.
out
 - 
cipher
);

245 
cipher
 = 
o
.
out
;

249 if (
npartial
)

252 
	`cf_gf128_add
(
o
.
offset
, o.
L_star
, o.offset);

255 
uint8_t
 
pad
[
BLOCK
];

256 
	`cf_gf128_tobytes_be
(
o
.
offset
, 
pad
);

257 
o
.
prp
->
	`encrypt
(o.
prpctx
, 
pad
, pad);

260 
	`xor_bb
(
cipher
, 
partial
, 
pad
, 
npartial
);

261 
	`mem_clean
(
pad
, sizeof pad);

264 
	`memset
(
partial
 + 
npartial
, 0, sizeof(partial) - npartial);

265 
partial
[
npartial
] = 0x80;

267 
cf_gf128
 
last_block
;

268 
	`cf_gf128_frombytes_be
(
partial
, 
last_block
);

269 
	`cf_gf128_add
(
o
.
checksum
, 
last_block
, o.checksum);

270 
	`mem_clean
(
last_block
, sizeof last_block);

274 
cf_gf128
 
full_tag
;

275 for (
size_t
 
i
 = 0; i < 4; i++)

276 
full_tag
[
i
] = 
o
.
checksum
[i] ^ o.
offset
[i] ^ o.
L_dollar
[i];

279 
uint8_t
 
tag_bytes
[
BLOCK
];

280 
	`cf_gf128_tobytes_be
(
full_tag
, 
tag_bytes
);

283 
o
.
prp
->
	`encrypt
(o.
prpctx
, 
tag_bytes
, tag_bytes);

286 
uint8_t
 
hash_a
[
BLOCK
];

287 
	`ocb_process_header
(&
o
, 
header
, 
nheader
, 
hash_a
);

290 
	`xor_bb
(
tag_bytes
, tag_bytes, 
hash_a
, sizeof tag_bytes);

293 
	`memcpy
(
tag
, 
tag_bytes
, 
ntag
);

295 
	`mem_clean
(&
o
, sizeof o);

296 
	}
}

298 static void 
	$ocb_decrypt_block
(void *
vctx
, const 
uint8_t
 *
block
)

300 
ocb
 *
o
 = 
vctx
;

303 
	`ocb_add_Ln
(
o
, 
	`count_trailing_zeroes
(o->
i
), o->
offset
);

306 
uint8_t
 
offset_bytes
[
BLOCK
];

307 
	`cf_gf128_tobytes_be
(
o
->
offset
, 
offset_bytes
);

309 
uint8_t
 
block_tmp
[
BLOCK
];

310 
	`xor_bb
(
block_tmp
, 
block
, 
offset_bytes
, sizeof block_tmp);

311 
o
->
prp
->
	`decrypt
(o->
prpctx
, 
block_tmp
, block_tmp);

312 
	`xor_bb
(
o
->
out
, 
block_tmp
, 
offset_bytes
, sizeof block_tmp);

315 
cf_gf128
 
P
;

316 
	`cf_gf128_frombytes_be
(
o
->
out
, 
P
);

317 
o
->
out
 += sizeof 
block_tmp
;

318 
	`cf_gf128_add
(
o
->
checksum
, 
P
, o->checksum);

320 
o
->
i
++;

321 
	}
}

323 int 
	$cf_ocb_decrypt
(const 
cf_prp
 *
prp
, void *
prpctx
,

324 const 
uint8_t
 *
cipher
, 
size_t
 
ncipher
,

325 const 
uint8_t
 *
header
, 
size_t
 
nheader
,

326 const 
uint8_t
 *
nonce
, 
size_t
 
nnonce
,

327 const 
uint8_t
 *
tag
, 
size_t
 
ntag
,

328 
uint8_t
 *
plain
)

330 
ocb
 
o
;

331 
	`ocb_init
(&
o
, 
prp
, 
prpctx
, 
nonce
, 
nnonce
, 
ntag
);

334 
uint8_t
 
partial
[
BLOCK
];

335 
size_t
 
npartial
 = 0;

337 
	`ocb_start_cipher
(&
o
, 
plain
);

338 
	`cf_blockwise_accumulate
(
partial
, &
npartial
,

339 
prp
->
blocksz
,

340 
cipher
, 
ncipher
,

341 
ocb_decrypt_block
,

342 &
o
);

344 if (
npartial
)

347 
	`cf_gf128_add
(
o
.
offset
, o.
L_star
, o.offset);

350 
uint8_t
 
pad
[
BLOCK
];

351 
	`cf_gf128_tobytes_be
(
o
.
offset
, 
pad
);

352 
o
.
prp
->
	`encrypt
(o.
prpctx
, 
pad
, pad);

355 
	`xor_bb
(
partial
, partial, 
pad
, 
npartial
);

356 
	`mem_clean
(
pad
, sizeof pad);

358 
	`memcpy
(
o
.
out
, 
partial
, 
npartial
);

361 
	`memset
(
partial
 + 
npartial
, 0, sizeof(partial) - npartial);

362 
partial
[
npartial
] = 0x80;

364 
cf_gf128
 
last_block
;

365 
	`cf_gf128_frombytes_be
(
partial
, 
last_block
);

366 
	`cf_gf128_add
(
o
.
checksum
, 
last_block
, o.checksum);

367 
	`mem_clean
(
last_block
, sizeof last_block);

371 
cf_gf128
 
full_tag
;

372 for (
size_t
 
i
 = 0; i < 4; i++)

373 
full_tag
[
i
] = 
o
.
checksum
[i] ^ o.
offset
[i] ^ o.
L_dollar
[i];

376 
uint8_t
 
tag_bytes
[
BLOCK
];

377 
	`cf_gf128_tobytes_be
(
full_tag
, 
tag_bytes
);

380 
o
.
prp
->
	`encrypt
(o.
prpctx
, 
tag_bytes
, tag_bytes);

383 
uint8_t
 
hash_a
[
BLOCK
];

384 
	`ocb_process_header
(&
o
, 
header
, 
nheader
, 
hash_a
);

387 
	`xor_bb
(
tag_bytes
, tag_bytes, 
hash_a
, sizeof tag_bytes);

390 int 
err
;

392 if (
	`mem_eq
(
tag
, 
tag_bytes
, 
ntag
))

394 
err
 = 0;

396 
err
 = 1;

397 
	`mem_clean
(
plain
, 
ncipher
);

400 
	`mem_clean
(&
o
, sizeof o);

401 
	`mem_clean
(
tag_bytes
, sizeof tag_bytes);

402 
	`mem_clean
(
full_tag
, sizeof full_tag);

403 return 
err
;

404 
	}
}

	@deps/picotls/deps/cifra/src/pbkdf2.c

15 #include 
	~"pbkdf2.h
"

16 #include 
	~"hmac.h
"

17 #include 
	~"bitops.h
"

18 #include 
	~"handy.h
"

19 #include 
	~"tassert.h
"

21 #include 
	~<string.h
>

23 static void 
	$F
(const 
cf_hmac_ctx
 *
startctx
,

24 
uint32_t
 
counter
,

25 const 
uint8_t
 *
salt
, 
size_t
 
nsalt
,

26 
uint32_t
 
iterations
,

27 
uint8_t
 *
out
)

29 
uint8_t
 
U
[
CF_MAXHASH
];

30 
size_t
 
hashsz
 = 
startctx
->
hash
->hashsz;

32 
uint8_t
 
countbuf
[4];

33 
	`write32_be
(
counter
, 
countbuf
);

38 
cf_hmac_ctx
 
ctx
 = *
startctx
;

39 
	`cf_hmac_update
(&
ctx
, 
salt
, 
nsalt
);

40 
	`cf_hmac_update
(&
ctx
, 
countbuf
, sizeof countbuf);

41 
	`cf_hmac_finish
(&
ctx
, 
U
);

42 
	`memcpy
(
out
, 
U
, 
hashsz
);

47 for (
uint32_t
 
i
 = 1; i < 
iterations
; i++)

49 
ctx
 = *
startctx
;

50 
	`cf_hmac_update
(&
ctx
, 
U
, 
hashsz
);

51 
	`cf_hmac_finish
(&
ctx
, 
U
);

52 
	`xor_bb
(
out
, out, 
U
, 
hashsz
);

54 
	}
}

56 void 
	$cf_pbkdf2_hmac
(const 
uint8_t
 *
pw
, 
size_t
 
npw
,

57 const 
uint8_t
 *
salt
, 
size_t
 
nsalt
,

58 
uint32_t
 
iterations
,

59 
uint8_t
 *
out
, 
size_t
 
nout
,

60 const 
cf_chash
 *
hash
)

62 
uint32_t
 
counter
 = 1;

63 
uint8_t
 
block
[
CF_MAXHASH
];

65 
	`assert
(
iterations
);

66 
	`assert
(
out
 && 
nout
);

67 
	`assert
(
hash
);

70 
cf_hmac_ctx
 
ctx
;

71 
	`cf_hmac_init
(&
ctx
, 
hash
, 
pw
, 
npw
);

73 while (
nout
)

75 
	`F
(&
ctx
, 
counter
, 
salt
, 
nsalt
, 
iterations
, 
block
);

77 
size_t
 
taken
 = 
	`MIN
(
nout
, 
hash
->
hashsz
);

78 
	`memcpy
(
out
, 
block
, 
taken
);

79 
out
 += 
taken
;

80 
nout
 -= 
taken
;

81 
counter
++;

83 
	}
}

	@deps/picotls/deps/cifra/src/pbkdf2.h

15 #ifndef 
PBKDF2_H


16 #define 
	#PBKDF2_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

21 #include 
	~"chash.h
"

41 void 
cf_pbkdf2_hmac
(const 
uint8_t
 *
pw
, 
size_t
 
npw
,

42 const 
uint8_t
 *
salt
, 
size_t
 
nsalt
,

43 
uint32_t
 
iterations
,

44 
uint8_t
 *
out
, 
size_t
 
nout
,

45 const 
cf_chash
 *
hash
);

	@deps/picotls/deps/cifra/src/poly1305.c

15 #include 
	~"poly1305.h
"

16 #include 
	~"bitops.h
"

17 #include 
	~"handy.h
"

18 #include 
	~"blockwise.h
"

20 #include 
	~<string.h
>

21 #include 
	~<stdio.h
>

23 void 
	$cf_poly1305_init
(
cf_poly1305
 *
ctx
,

24 const 
uint8_t
 
r
[16],

25 const 
uint8_t
 
s
[16])

27 
	`memset
(
ctx
, 0, sizeof *ctx);

29 
ctx
->
r
[0] = r[0];

30 
ctx
->
r
[1] = r[1];

31 
ctx
->
r
[2] = r[2];

32 
ctx
->
r
[3] = r[3] & 0x0f;

33 
ctx
->
r
[4] = r[4] & 0xfc;

34 
ctx
->
r
[5] = r[5];

35 
ctx
->
r
[6] = r[6];

36 
ctx
->
r
[7] = r[7] & 0x0f;

37 
ctx
->
r
[8] = r[8] & 0xfc;

38 
ctx
->
r
[9] = r[9];

39 
ctx
->
r
[10] = r[10];

40 
ctx
->
r
[11] = r[11] & 0x0f;

41 
ctx
->
r
[12] = r[12] & 0xfc;

42 
ctx
->
r
[13] = r[13];

43 
ctx
->
r
[14] = r[14];

44 
ctx
->
r
[15] = r[15] & 0x0f;

45 
ctx
->
r
[16] = 0;

47 
	`memcpy
(
ctx
->
s
, s, 16);

48 
	}
}

50 static void 
	$poly1305_add
(
uint32_t
 
h
[17],

51 const 
uint32_t
 
x
[17])

53 
uint32_t
 
carry
 = 0;

54 int 
i
;

56 for (
i
 = 0; i < 17; i++)

58 
carry
 += 
h
[
i
] + 
x
[i];

59 
h
[
i
] = 
carry
 & 0xff;

60 
carry
 >>= 8;

62 
	}
}

65 static void 
	$poly1305_min_reduce
(
uint32_t
 
x
[17])

67 
uint32_t
 
carry
 = 0;

68 int 
i
;

69 for (
i
 = 0; i < 16; i++)

71 
carry
 += 
x
[
i
];

72 
x
[
i
] = 
carry
 & 0xff;

73 
carry
 >>= 8;

81 
carry
 += 
x
[16];

82 
x
[16] = 
carry
 & 0x03;

83 
carry
 = 5 * (carry >> 2);

85 for (
i
 = 0; i < 16; i++)

87 
carry
 += 
x
[
i
];

88 
x
[
i
] = 
carry
 & 0xff;

89 
carry
 >>= 8;

92 
x
[16] += 
carry
;

93 
	}
}

96 static const 
uint32_t
 
	gnegative_1305
[17] = {

101 static void 
	$poly1305_full_reduce
(
uint32_t
 
x
[17])

103 
uint32_t
 
xsub
[17];

104 
size_t
 
i
;

106 for (
i
 = 0; i < 17; i++)

107 
xsub
[
i
] = 
x
[i];

109 
	`poly1305_add
(
xsub
, 
negative_1305
);

114 
uint32_t
 
negative_mask
 = 
	`mask_u32
(
xsub
[16] & 0x80, 0x80);

115 
uint32_t
 
positive_mask
 = 
negative_mask
 ^ 0xffffffff;

117 for (
i
 = 0; i < 17; i++)

118 
x
[
i
] = (x[i] & 
negative_mask
) | (
xsub
[i] & 
positive_mask
);

119 
	}
}

121 static void 
	$poly1305_mul
(
uint32_t
 
x
[17],

122 const 
uint32_t
 
y
[17])

124 
uint32_t
 
r
[17];

125 int 
i
;

127 for (
i
 = 0; i < 17; i++)

129 
uint32_t
 
accum
 = 0;

130 int 
j
;

132 for (
j
 = 0; j <= 
i
; j++)

133 
accum
 += 
x
[
j
] * 
y
[
i
 - j];

145 for (
j
 = 
i
 + 1; j < 17; j++)

146 
accum
 += (5 << 6) * 
x
[
j
] * 
y
[
i
 + 17 - j];

148 
r
[
i
] = 
accum
;

151 
	`poly1305_min_reduce
(
r
);

153 for (
i
 = 0; i < 17; i++)

154 
x
[
i
] = 
r
[i];

155 
	}
}

157 static void 
	$poly1305_block
(
cf_poly1305
 *
ctx
,

158 const 
uint32_t
 
c
[17])

160 
	`poly1305_add
(
ctx
->
h
, 
c
);

161 
	`poly1305_mul
(
ctx
->
h
, ctx->
r
);

162 
	}
}

164 static void 
	$poly1305_whole_block
(void *
vctx
,

165 const 
uint8_t
 *
buf
)

167 
cf_poly1305
 *
ctx
 = 
vctx
;

168 
uint32_t
 
c
[17];

169 int 
i
;

171 for (
i
 = 0; i < 16; i++)

172 
c
[
i
] = 
buf
[i];

174 
c
[16] = 1;

175 
	`poly1305_block
(
ctx
, 
c
);

176 
	}
}

178 static void 
	$poly1305_last_block
(
cf_poly1305
 *
ctx
)

180 
uint32_t
 
c
[17] = { 0 };

181 
size_t
 
i
;

183 for (
i
 = 0; i < 
ctx
->
npartial
; i++)

184 
c
[
i
] = 
ctx
->
partial
[i];

186 
c
[
ctx
->
npartial
] = 1;

187 
	`poly1305_block
(
ctx
, 
c
);

188 
	}
}

190 void 
	$cf_poly1305_update
(
cf_poly1305
 *
ctx
,

191 const 
uint8_t
 *
buf
,

192 
size_t
 
nbytes
)

194 
	`cf_blockwise_accumulate
(
ctx
->
partial
, &ctx->
npartial
,

195 sizeof 
ctx
->
partial
,

196 
buf
, 
nbytes
,

197 
poly1305_whole_block
,

198 
ctx
);

199 
	}
}

201 void 
	$cf_poly1305_finish
(
cf_poly1305
 *
ctx
,

202 
uint8_t
 
out
[16])

204 if (
ctx
->
npartial
)

205 
	`poly1305_last_block
(
ctx
);

207 
uint32_t
 
s
[17];

208 
size_t
 
i
;

209 for (
i
 = 0; i < 16; i++)

210 
s
[
i
] = 
ctx
->s[i];

211 
s
[16] = 0;

213 
	`poly1305_full_reduce
(
ctx
->
h
);

214 
	`poly1305_add
(
ctx
->
h
, 
s
);

216 for (
i
 = 0; i < 16; i++)

217 
out
[
i
] = 
ctx
->
h
[i];

219 
	`mem_clean
(
ctx
, sizeof *ctx);

220 
	}
}

	@deps/picotls/deps/cifra/src/poly1305.h

15 #ifndef 
POLY1305_H


16 #define 
	#POLY1305_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

53 
uint32_t
 
	mh
[17];

54 
uint32_t
 
	mr
[17];

55 
uint8_t
 
	ms
[16];

56 
uint8_t
 
	mpartial
[16];

57 
size_t
 
	mnpartial
;

58 } 
	tcf_poly1305
;

71 void 
cf_poly1305_init
(
cf_poly1305
 *
ctx
,

72 const 
uint8_t
 
r
[16],

73 const 
uint8_t
 
s
[16]);

79 void 
cf_poly1305_update
(
cf_poly1305
 *
ctx
,

80 const 
uint8_t
 *
data
,

81 
size_t
 
nbytes
);

88 void 
cf_poly1305_finish
(
cf_poly1305
 *
ctx
,

89 
uint8_t
 
out
[16]);

	@deps/picotls/deps/cifra/src/prp.h

15 #ifndef 
PRP_H


16 #define 
	#PRP_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

38 typedef void (*
	tcf_prp_block
)(void *
	tctx
, const 
	tuint8_t
 *
	tin
, uint8_t *
	tout
);

54 
size_t
 
blocksz
;

55 
cf_prp_block
 
encrypt
;

56 
cf_prp_block
 
decrypt
;

57 } 
	tcf_prp
;

62 #define 
	#CF_MAXBLOCK
 16

	)

	@deps/picotls/deps/cifra/src/salsa20.c

15 #include 
	~"salsa20.h
"

16 #include 
	~"bitops.h
"

17 #include 
	~"blockwise.h
"

19 #include 
	~<string.h
>

20 #include 
	~<stdlib.h
>

22 void 
	$cf_salsa20_core
(const 
uint8_t
 
key0
[16],

23 const 
uint8_t
 
key1
[16],

24 const 
uint8_t
 
nonce
[16],

25 const 
uint8_t
 
constant
[16],

26 
uint8_t
 
out
[64])

41 
uint32_t
 
z0
, 
z1
, 
z2
, 
z3
, 
z4
, 
z5
, 
z6
, 
z7
,

42 
z8
, 
z9
, 
za
, 
zb
, 
zc
, 
zd
, 
ze
, 
zf
;

44 
uint32_t
 
x0
 = 
z0
 = 
	`read32_le
(
constant
 + 0),

45 
x1
 = 
z1
 = 
	`read32_le
(
key0
 + 0),

46 
x2
 = 
z2
 = 
	`read32_le
(
key0
 + 4),

47 
x3
 = 
z3
 = 
	`read32_le
(
key0
 + 8),

48 
x4
 = 
z4
 = 
	`read32_le
(
key0
 + 12),

49 
x5
 = 
z5
 = 
	`read32_le
(
constant
 + 4),

50 
x6
 = 
z6
 = 
	`read32_le
(
nonce
 + 0),

51 
x7
 = 
z7
 = 
	`read32_le
(
nonce
 + 4),

52 
x8
 = 
z8
 = 
	`read32_le
(
nonce
 + 8),

53 
x9
 = 
z9
 = 
	`read32_le
(
nonce
 + 12),

54 
xa
 = 
za
 = 
	`read32_le
(
constant
 + 8),

55 
xb
 = 
zb
 = 
	`read32_le
(
key1
 + 0),

56 
xc
 = 
zc
 = 
	`read32_le
(
key1
 + 4),

57 
xd
 = 
zd
 = 
	`read32_le
(
key1
 + 8),

58 
xe
 = 
ze
 = 
	`read32_le
(
key1
 + 12),

59 
xf
 = 
zf
 = 
	`read32_le
(
constant
 + 12);

61 #define 
	#QUARTER
(
v0
, 
v1
, 
v2
, 
v3
) \

62 
v1
 ^= 
	`rotl32
(
v0
 + 
v3
, 7); \

63 
v2
 ^= 
	`rotl32
(
v1
 + 
v0
, 9); \

64 
v3
 ^= 
	`rotl32
(
v2
 + 
v1
, 13);\

65 
v0
 ^= 
	`rotl32
(
v3
 + 
v2
, 18)

	)

67 #define 
	#ROW
 \

68 
	`QUARTER
(
z0
, 
z1
, 
z2
, 
z3
); \

69 
	`QUARTER
(
z5
, 
z6
, 
z7
, 
z4
); \

70 
	`QUARTER
(
za
, 
zb
, 
z8
, 
z9
); \

71 
	`QUARTER
(
zf
, 
zc
, 
zd
, 
ze
)

	)

73 #define 
	#COLUMN
\

74 
	`QUARTER
(
z0
, 
z4
, 
z8
, 
zc
); \

75 
	`QUARTER
(
z5
, 
z9
, 
zd
, 
z1
); \

76 
	`QUARTER
(
za
, 
ze
, 
z2
, 
z6
); \

77 
	`QUARTER
(
zf
, 
z3
, 
z7
, 
zb
)

	)

79 for (int 
i
 = 0; i < 10; i++)

81 
COLUMN
;

82 
ROW
;

85 
x0
 += 
z0
;

86 
x1
 += 
z1
;

87 
x2
 += 
z2
;

88 
x3
 += 
z3
;

89 
x4
 += 
z4
;

90 
x5
 += 
z5
;

91 
x6
 += 
z6
;

92 
x7
 += 
z7
;

93 
x8
 += 
z8
;

94 
x9
 += 
z9
;

95 
xa
 += 
za
;

96 
xb
 += 
zb
;

97 
xc
 += 
zc
;

98 
xd
 += 
zd
;

99 
xe
 += 
ze
;

100 
xf
 += 
zf
;

102 
	`write32_le
(
x0
, 
out
 + 0);

103 
	`write32_le
(
x1
, 
out
 + 4);

104 
	`write32_le
(
x2
, 
out
 + 8);

105 
	`write32_le
(
x3
, 
out
 + 12);

106 
	`write32_le
(
x4
, 
out
 + 16);

107 
	`write32_le
(
x5
, 
out
 + 20);

108 
	`write32_le
(
x6
, 
out
 + 24);

109 
	`write32_le
(
x7
, 
out
 + 28);

110 
	`write32_le
(
x8
, 
out
 + 32);

111 
	`write32_le
(
x9
, 
out
 + 36);

112 
	`write32_le
(
xa
, 
out
 + 40);

113 
	`write32_le
(
xb
, 
out
 + 44);

114 
	`write32_le
(
xc
, 
out
 + 48);

115 
	`write32_le
(
xd
, 
out
 + 52);

116 
	`write32_le
(
xe
, 
out
 + 56);

117 
	`write32_le
(
xf
, 
out
 + 60);

118 
	}
}

120 static const 
uint8_t
 *
	gsalsa20_tau
 = (const uint8_t *) "expand 16-byte k";

121 static const 
uint8_t
 *
	gsalsa20_sigma
 = (const uint8_t *) "expand 32-byte k";

123 void 
	$cf_salsa20_init
(
cf_salsa20_ctx
 *
ctx
, const 
uint8_t
 *
key
, 
size_t
 
nkey
, const uint8_t 
nonce
[8])

125 switch (
nkey
)

128 
	`memcpy
(
ctx
->
key0
, 
key
, 16);

129 
	`memcpy
(
ctx
->
key1
, 
key
, 16);

130 
ctx
->
constant
 = 
salsa20_tau
;

133 
	`memcpy
(
ctx
->
key0
, 
key
, 16);

134 
	`memcpy
(
ctx
->
key1
, 
key
 + 16, 16);

135 
ctx
->
constant
 = 
salsa20_sigma
;

138 
	`abort
();

141 
	`memset
(
ctx
->
nonce
, 0, sizeof ctx->nonce);

142 
	`memcpy
(
ctx
->
nonce
 + 8, nonce, 8);

143 
ctx
->
nblock
 = 0;

144 
ctx
->
ncounter
 = 8;

145 
	}
}

147 static void 
	$cf_salsa20_next_block
(void *
vctx
, 
uint8_t
 *
out
)

149 
cf_salsa20_ctx
 *
ctx
 = 
vctx
;

150 
	`cf_salsa20_core
(
ctx
->
key0
,

151 
ctx
->
key1
,

152 
ctx
->
nonce
,

153 
ctx
->
constant
,

154 
out
);

155 
	`incr_le
(
ctx
->
nonce
, ctx->
ncounter
);

156 
	}
}

158 void 
	$cf_salsa20_cipher
(
cf_salsa20_ctx
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
bytes
)

160 
	`cf_blockwise_xor
(
ctx
->
block
, &ctx->
nblock
, 64,

161 
input
, 
output
, 
bytes
,

162 
cf_salsa20_next_block
,

163 
ctx
);

164 
	}
}

	@deps/picotls/deps/cifra/src/salsa20.h

15 #ifndef 
SALSA20_H


16 #define 
	#SALSA20_H


	)

18 #include 
	~<stdint.h
>

19 #include 
	~<stddef.h
>

38 void 
cf_salsa20_core
(const 
uint8_t
 
key0
[16],

39 const 
uint8_t
 
key1
[16],

40 const 
uint8_t
 
nonce
[16],

41 const 
uint8_t
 
constant
[16],

42 
uint8_t
 
out
[64]);

45 void 
cf_chacha20_core
(const 
uint8_t
 
key0
[16],

46 const 
uint8_t
 
key1
[16],

47 const 
uint8_t
 
nonce
[16],

48 const 
uint8_t
 
constant
[16],

49 
uint8_t
 
out
[64]);

75 
uint8_t
 
	mkey0
[16], 
	mkey1
[16];

76 
uint8_t
 
	mnonce
[16];

77 const 
uint8_t
 *
	mconstant
;

78 
uint8_t
 
	mblock
[64];

79 
size_t
 
	mnblock
;

80 
size_t
 
	mncounter
;

81 } 
	tcf_salsa20_ctx
, 
	tcf_chacha20_ctx
;

96 void 
cf_salsa20_init
(
cf_salsa20_ctx
 *
ctx
, const 
uint8_t
 *
key
, 
size_t
 
nkey
, const uint8_t 
nonce
[8]);

106 void 
cf_chacha20_init
(
cf_chacha20_ctx
 *
ctx
, const 
uint8_t
 *
key
, 
size_t
 
nkey
, const uint8_t 
nonce
[8]);

119 void 
cf_chacha20_init_custom
(
cf_chacha20_ctx
 *
ctx
, const 
uint8_t
 *
key
, 
size_t
 
nkey
,

120 const 
uint8_t
 
nonce
[16], 
size_t
 
ncounter
);

129 void 
cf_salsa20_cipher
(
cf_salsa20_ctx
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
count
);

138 void 
cf_chacha20_cipher
(
cf_chacha20_ctx
 *
ctx
, const 
uint8_t
 *
input
, uint8_t *
output
, 
size_t
 
count
);

	@deps/picotls/deps/cifra/src/sha1.c

15 #include 
	~<string.h
>

17 #include 
	~"sha1.h
"

18 #include 
	~"blockwise.h
"

19 #include 
	~"bitops.h
"

20 #include 
	~"handy.h
"

21 #include 
	~"tassert.h
"

23 void 
	$cf_sha1_init
(
cf_sha1_context
 *
ctx
)

25 
	`memset
(
ctx
, 0, sizeof *ctx);

26 
ctx
->
H
[0] = 0x67452301;

27 
ctx
->
H
[1] = 0xefcdab89;

28 
ctx
->
H
[2] = 0x98badcfe;

29 
ctx
->
H
[3] = 0x10325476;

30 
ctx
->
H
[4] = 0xc3d2e1f0;

31 
	}
}

33 static void 
	$sha1_update_block
(void *
vctx
, const 
uint8_t
 *
inp
)

35 
cf_sha1_context
 *
ctx
 = 
vctx
;

38 
uint32_t
 
W
[16];

40 
uint32_t
 
a
 = 
ctx
->
H
[0],

41 
b
 = 
ctx
->
H
[1],

42 
c
 = 
ctx
->
H
[2],

43 
d
 = 
ctx
->
H
[3],

44 
e
 = 
ctx
->
H
[4],

45 
Wt
;

47 for (
size_t
 
t
 = 0; t < 80; t++)

56 if (
t
 < 16)

58 
W
[
t
] = 
Wt
 = 
	`read32_be
(
inp
);

59 
inp
 += 4;

61 
Wt
 = 
W
[(
t
 - 3) % 16] ^ W[(t - 8) % 16] ^ W[(t - 14) % 16] ^ W[(t - 16) % 16];

62 
Wt
 = 
	`rotl32
(Wt, 1);

63 
W
[
t
 % 16] = 
Wt
;

66 
uint32_t
 
f
, 
k
;

68 if (
t
 <= 19)

70 
f
 = (
b
 & 
c
) | (~b & 
d
);

71 
k
 = 0x5a827999;

72 } else if (
t
 <= 39) {

73 
f
 = 
b
 ^ 
c
 ^ 
d
;

74 
k
 = 0x6ed9eba1;

75 } else if (
t
 <= 59) {

76 
f
 = (
b
 & 
c
) | (b & 
d
) | (c & d);

77 
k
 = 0x8f1bbcdc;

79 
f
 = 
b
 ^ 
c
 ^ 
d
;

80 
k
 = 0xca62c1d6;

83 
uint32_t
 
temp
 = 
	`rotl32
(
a
, 5) + 
f
 + 
e
 + 
k
 + 
Wt
;

84 
e
 = 
d
;

85 
d
 = 
c
;

86 
c
 = 
	`rotl32
(
b
, 30);

87 
b
 = 
a
;

88 
a
 = 
temp
;

91 
ctx
->
H
[0] += 
a
;

92 
ctx
->
H
[1] += 
b
;

93 
ctx
->
H
[2] += 
c
;

94 
ctx
->
H
[3] += 
d
;

95 
ctx
->
H
[4] += 
e
;

97 
ctx
->
blocks
++;

98 
	}
}

100 void 
	$cf_sha1_update
(
cf_sha1_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

102 
	`cf_blockwise_accumulate
(
ctx
->
partial
, &ctx->
npartial
, sizeof ctx->partial,

103 
data
, 
nbytes
,

104 
sha1_update_block
, 
ctx
);

105 
	}
}

107 void 
	$cf_sha1_digest
(const 
cf_sha1_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA1_HASHSZ
])

109 
cf_sha1_context
 
ours
 = *
ctx
;

110 
	`cf_sha1_digest_final
(&
ours
, 
hash
);

111 
	}
}

113 void 
	$cf_sha1_digest_final
(
cf_sha1_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA1_HASHSZ
])

115 
uint64_t
 
digested_bytes
 = 
ctx
->
blocks
;

116 
digested_bytes
 = digested_bytes * 
CF_SHA1_BLOCKSZ
 + 
ctx
->
npartial
;

117 
uint64_t
 
digested_bits
 = 
digested_bytes
 * 8;

119 
size_t
 
padbytes
 = 
CF_SHA1_BLOCKSZ
 - ((
digested_bytes
 + 8) % CF_SHA1_BLOCKSZ);

122 
	`cf_blockwise_acc_pad
(
ctx
->
partial
, &ctx->
npartial
, sizeof ctx->partial,

123 0x80, 0x00, 0x00, 
padbytes
,

124 
sha1_update_block
, 
ctx
);

127 
uint8_t
 
buf
[8];

128 
	`write64_be
(
digested_bits
, 
buf
);

129 
	`cf_sha1_update
(
ctx
, 
buf
, 8);

132 
	`assert
(
ctx
->
npartial
 == 0);

134 
	`write32_be
(
ctx
->
H
[0], 
hash
 + 0);

135 
	`write32_be
(
ctx
->
H
[1], 
hash
 + 4);

136 
	`write32_be
(
ctx
->
H
[2], 
hash
 + 8);

137 
	`write32_be
(
ctx
->
H
[3], 
hash
 + 12);

138 
	`write32_be
(
ctx
->
H
[4], 
hash
 + 16);

140 
	`memset
(
ctx
, 0, sizeof *ctx);

141 
	}
}

143 const 
cf_chash
 
	gcf_sha1
 = {

144 .
hashsz
 = 
CF_SHA1_HASHSZ
,

145 .
	gblocksz
 = 
CF_SHA1_BLOCKSZ
,

146 .
	ginit
 = (
cf_chash_init
) 
cf_sha1_init
,

147 .
	gupdate
 = (
cf_chash_update
) 
cf_sha1_update
,

148 .
	gdigest
 = (
cf_chash_digest
) 
cf_sha1_digest


	@deps/picotls/deps/cifra/src/sha1.h

15 #ifndef 
SHA1_H


16 #define 
	#SHA1_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

21 #include 
	~"chash.h
"

32 #define 
	#CF_SHA1_HASHSZ
 20

	)

36 #define 
	#CF_SHA1_BLOCKSZ
 64

	)

55 
uint32_t
 
	mH
[5];

56 
uint8_t
 
	mpartial
[
CF_SHA1_BLOCKSZ
];

57 
uint32_t
 
	mblocks
;

58 
size_t
 
	mnpartial
;

59 } 
	tcf_sha1_context
;

64 extern void 
cf_sha1_init
(
cf_sha1_context
 *
ctx
);

70 extern void 
cf_sha1_update
(
cf_sha1_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
);

77 extern void 
cf_sha1_digest
(const 
cf_sha1_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA1_HASHSZ
]);

84 extern void 
cf_sha1_digest_final
(
cf_sha1_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA1_HASHSZ
]);

89 extern const 
cf_chash
 
cf_sha1
;

	@deps/picotls/deps/cifra/src/sha2.h

15 #ifndef 
SHA2_H


16 #define 
	#SHA2_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

21 #include 
	~"chash.h
"

30 #define 
	#CF_SHA224_HASHSZ
 28

	)

34 #define 
	#CF_SHA224_BLOCKSZ
 64

	)

38 #define 
	#CF_SHA256_HASHSZ
 32

	)

42 #define 
	#CF_SHA256_BLOCKSZ
 64

	)

61 
uint32_t
 
	mH
[8];

62 
uint8_t
 
	mpartial
[
CF_SHA256_BLOCKSZ
];

63 
uint32_t
 
	mblocks
;

64 
size_t
 
	mnpartial
;

65 } 
	tcf_sha256_context
;

70 extern void 
cf_sha256_init
(
cf_sha256_context
 *
ctx
);

76 extern void 
cf_sha256_update
(
cf_sha256_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
);

83 extern void 
cf_sha256_digest
(const 
cf_sha256_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA256_HASHSZ
]);

90 extern void 
cf_sha256_digest_final
(
cf_sha256_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA256_HASHSZ
]);

97 extern void 
cf_sha224_init
(
cf_sha256_context
 *
ctx
);

103 extern void 
cf_sha224_update
(
cf_sha256_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
);

110 extern void 
cf_sha224_digest
(const 
cf_sha256_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA224_HASHSZ
]);

117 extern void 
cf_sha224_digest_final
(
cf_sha256_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA224_HASHSZ
]);

122 extern const 
cf_chash
 
cf_sha224
;

127 extern const 
cf_chash
 
cf_sha256
;

136 #define 
	#CF_SHA384_HASHSZ
 48

	)

140 #define 
	#CF_SHA384_BLOCKSZ
 128

	)

144 #define 
	#CF_SHA512_HASHSZ
 64

	)

148 #define 
	#CF_SHA512_BLOCKSZ
 128

	)

167 
uint64_t
 
	mH
[8];

168 
uint8_t
 
	mpartial
[
CF_SHA512_BLOCKSZ
];

169 
uint32_t
 
	mblocks
;

170 
size_t
 
	mnpartial
;

171 } 
	tcf_sha512_context
;

176 extern void 
cf_sha512_init
(
cf_sha512_context
 *
ctx
);

182 extern void 
cf_sha512_update
(
cf_sha512_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
);

189 extern void 
cf_sha512_digest
(const 
cf_sha512_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA512_HASHSZ
]);

196 extern void 
cf_sha512_digest_final
(
cf_sha512_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA512_HASHSZ
]);

203 extern void 
cf_sha384_init
(
cf_sha512_context
 *
ctx
);

209 extern void 
cf_sha384_update
(
cf_sha512_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
);

216 extern void 
cf_sha384_digest
(const 
cf_sha512_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA384_HASHSZ
]);

223 extern void 
cf_sha384_digest_final
(
cf_sha512_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA384_HASHSZ
]);

228 extern const 
cf_chash
 
cf_sha384
;

233 extern const 
cf_chash
 
cf_sha512
;

	@deps/picotls/deps/cifra/src/sha256.c

15 #include 
	~<string.h
>

17 #include 
	~"sha2.h
"

18 #include 
	~"blockwise.h
"

19 #include 
	~"bitops.h
"

20 #include 
	~"handy.h
"

21 #include 
	~"tassert.h
"

23 static const 
uint32_t
 
	gK
[64] = {

42 #define 
	#CH
(
x
, 
y
, 
z
) (((x) & (y)) ^ (~(x) & (z)))

	)

43 #define 
	#MAJ
(
x
, 
y
, 
z
) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

	)

44 #define 
	#BSIG0
(
x
) (
	`rotr32
((x), 2) ^ rotr32((x), 13) ^ rotr32((x), 22))

	)

45 #define 
	#BSIG1
(
x
) (
	`rotr32
((x), 6) ^ rotr32((x), 11) ^ rotr32((x), 25))

	)

46 #define 
	#SSIG0
(
x
) (
	`rotr32
((x), 7) ^ rotr32((x), 18) ^ ((x) >> 3))

	)

47 #define 
	#SSIG1
(
x
) (
	`rotr32
((x), 17) ^ rotr32((x), 19) ^ ((x) >> 10))

	)

49 void 
	$cf_sha256_init
(
cf_sha256_context
 *
ctx
)

51 
	`memset
(
ctx
, 0, sizeof *ctx);

52 
ctx
->
H
[0] = 0x6a09e667;

53 
ctx
->
H
[1] = 0xbb67ae85;

54 
ctx
->
H
[2] = 0x3c6ef372;

55 
ctx
->
H
[3] = 0xa54ff53a;

56 
ctx
->
H
[4] = 0x510e527f;

57 
ctx
->
H
[5] = 0x9b05688c;

58 
ctx
->
H
[6] = 0x1f83d9ab;

59 
ctx
->
H
[7] = 0x5be0cd19;

60 
	}
}

62 void 
	$cf_sha224_init
(
cf_sha256_context
 *
ctx
)

64 
	`memset
(
ctx
, 0, sizeof *ctx);

65 
ctx
->
H
[0] = 0xc1059ed8;

66 
ctx
->
H
[1] = 0x367cd507;

67 
ctx
->
H
[2] = 0x3070dd17;

68 
ctx
->
H
[3] = 0xf70e5939;

69 
ctx
->
H
[4] = 0xffc00b31;

70 
ctx
->
H
[5] = 0x68581511;

71 
ctx
->
H
[6] = 0x64f98fa7;

72 
ctx
->
H
[7] = 0xbefa4fa4;

73 
	}
}

75 static void 
	$sha256_update_block
(void *
vctx
, const 
uint8_t
 *
inp
)

77 
cf_sha256_context
 *
ctx
 = 
vctx
;

80 
uint32_t
 
W
[16];

82 
uint32_t
 
a
 = 
ctx
->
H
[0],

83 
b
 = 
ctx
->
H
[1],

84 
c
 = 
ctx
->
H
[2],

85 
d
 = 
ctx
->
H
[3],

86 
e
 = 
ctx
->
H
[4],

87 
f
 = 
ctx
->
H
[5],

88 
g
 = 
ctx
->
H
[6],

89 
h
 = 
ctx
->
H
[7],

90 
Wt
;

92 
size_t
 
t
;

93 for (
t
 = 0; t < 64; t++)

102 if (
t
 < 16)

104 
W
[
t
] = 
Wt
 = 
	`read32_be
(
inp
);

105 
inp
 += 4;

107 
Wt
 = 
	`SSIG1
(
W
[(
t
 - 2) % 16]) +

108 
W
[(
t
 - 7) % 16] +

109 
	`SSIG0
(
W
[(
t
 - 15) % 16]) +

110 
W
[(
t
 - 16) % 16];

111 
W
[
t
 % 16] = 
Wt
;

114 
uint32_t
 
T1
 = 
h
 + 
	`BSIG1
(
e
) + 
	`CH
(e, 
f
, 
g
) + 
K
[
t
] + 
Wt
;

115 
uint32_t
 
T2
 = 
	`BSIG0
(
a
) + 
	`MAJ
(a, 
b
, 
c
);

116 
h
 = 
g
;

117 
g
 = 
f
;

118 
f
 = 
e
;

119 
e
 = 
d
 + 
T1
;

120 
d
 = 
c
;

121 
c
 = 
b
;

122 
b
 = 
a
;

123 
a
 = 
T1
 + 
T2
;

126 
ctx
->
H
[0] += 
a
;

127 
ctx
->
H
[1] += 
b
;

128 
ctx
->
H
[2] += 
c
;

129 
ctx
->
H
[3] += 
d
;

130 
ctx
->
H
[4] += 
e
;

131 
ctx
->
H
[5] += 
f
;

132 
ctx
->
H
[6] += 
g
;

133 
ctx
->
H
[7] += 
h
;

135 
ctx
->
blocks
++;

136 
	}
}

138 void 
	$cf_sha256_update
(
cf_sha256_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

140 
	`cf_blockwise_accumulate
(
ctx
->
partial
, &ctx->
npartial
, sizeof ctx->partial,

141 
data
, 
nbytes
,

142 
sha256_update_block
, 
ctx
);

143 
	}
}

145 void 
	$cf_sha224_update
(
cf_sha256_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

147 
	`cf_sha256_update
(
ctx
, 
data
, 
nbytes
);

148 
	}
}

150 void 
	$cf_sha256_digest
(const 
cf_sha256_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA256_HASHSZ
])

166 
cf_sha256_context
 
ours
 = *
ctx
;

167 
	`cf_sha256_digest_final
(&
ours
, 
hash
);

168 
	}
}

170 void 
	$cf_sha256_digest_final
(
cf_sha256_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA256_HASHSZ
])

172 
uint64_t
 
digested_bytes
 = 
ctx
->
blocks
;

173 
digested_bytes
 = digested_bytes * 
CF_SHA256_BLOCKSZ
 + 
ctx
->
npartial
;

174 
uint64_t
 
digested_bits
 = 
digested_bytes
 * 8;

176 
size_t
 
padbytes
 = 
CF_SHA256_BLOCKSZ
 - ((
digested_bytes
 + 8) % CF_SHA256_BLOCKSZ);

179 
	`cf_blockwise_acc_pad
(
ctx
->
partial
, &ctx->
npartial
, sizeof ctx->partial,

180 0x80, 0x00, 0x00, 
padbytes
,

181 
sha256_update_block
, 
ctx
);

184 
uint8_t
 
buf
[8];

185 
	`write64_be
(
digested_bits
, 
buf
);

186 
	`cf_sha256_update
(
ctx
, 
buf
, 8);

189 
	`assert
(
ctx
->
npartial
 == 0);

191 
	`write32_be
(
ctx
->
H
[0], 
hash
 + 0);

192 
	`write32_be
(
ctx
->
H
[1], 
hash
 + 4);

193 
	`write32_be
(
ctx
->
H
[2], 
hash
 + 8);

194 
	`write32_be
(
ctx
->
H
[3], 
hash
 + 12);

195 
	`write32_be
(
ctx
->
H
[4], 
hash
 + 16);

196 
	`write32_be
(
ctx
->
H
[5], 
hash
 + 20);

197 
	`write32_be
(
ctx
->
H
[6], 
hash
 + 24);

198 
	`write32_be
(
ctx
->
H
[7], 
hash
 + 28);

200 
	`memset
(
ctx
, 0, sizeof *ctx);

201 
	}
}

203 void 
	$cf_sha224_digest
(const 
cf_sha256_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA224_HASHSZ
])

205 
uint8_t
 
full
[
CF_SHA256_HASHSZ
];

206 
	`cf_sha256_digest
(
ctx
, 
full
);

207 
	`memcpy
(
hash
, 
full
, 
CF_SHA224_HASHSZ
);

208 
	}
}

210 void 
	$cf_sha224_digest_final
(
cf_sha256_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA224_HASHSZ
])

212 
uint8_t
 
full
[
CF_SHA256_HASHSZ
];

213 
	`cf_sha256_digest_final
(
ctx
, 
full
);

214 
	`memcpy
(
hash
, 
full
, 
CF_SHA224_HASHSZ
);

215 
	}
}

217 const 
cf_chash
 
	gcf_sha224
 = {

218 .
hashsz
 = 
CF_SHA224_HASHSZ
,

219 .
	gblocksz
 = 
CF_SHA256_BLOCKSZ
,

220 .
	ginit
 = (
cf_chash_init
) 
cf_sha224_init
,

221 .
	gupdate
 = (
cf_chash_update
) 
cf_sha224_update
,

222 .
	gdigest
 = (
cf_chash_digest
) 
cf_sha224_digest


225 const 
cf_chash
 
	gcf_sha256
 = {

226 .
hashsz
 = 
CF_SHA256_HASHSZ
,

227 .
	gblocksz
 = 
CF_SHA256_BLOCKSZ
,

228 .
	ginit
 = (
cf_chash_init
) 
cf_sha256_init
,

229 .
	gupdate
 = (
cf_chash_update
) 
cf_sha256_update
,

230 .
	gdigest
 = (
cf_chash_digest
) 
cf_sha256_digest


	@deps/picotls/deps/cifra/src/sha3.c

15 #include 
	~<string.h
>

17 #include 
	~"sha3.h
"

18 #include 
	~"blockwise.h
"

19 #include 
	~"handy.h
"

20 #include 
	~"bitops.h
"

21 #include 
	~"tassert.h
"

24 static const 
cf_sha3_bi
 
	ground_constants
[24] = {

39 static const 
uint8_t
 
	grotation_constants
[5][5] = {

60 static 
inline
 
uint32_t
 
	$shuffle_out
(
uint32_t
 
x
)

62 
uint32_t
 
t
;

63 
t
 = (
x
 ^ (x >> 1)) & 0x22222222; x = x ^ t ^ (t << 1);

64 
t
 = (
x
 ^ (x >> 2)) & 0x0c0c0c0c; x = x ^ t ^ (t << 2);

65 
t
 = (
x
 ^ (x >> 4)) & 0x00f000f0; x = x ^ t ^ (t << 4);

66 
t
 = (
x
 ^ (x >> 8)) & 0x0000ff00; x = x ^ t ^ (t << 8);

67 return 
x
;

68 
	}
}

71 static 
inline
 
uint32_t
 
	$shuffle_in
(
uint32_t
 
x
)

73 
uint32_t
 
t
;

74 
t
 = (
x
 ^ (x >> 8)) & 0x0000ff00; x = x ^ t ^ (t << 8);

75 
t
 = (
x
 ^ (x >> 4)) & 0x00f000f0; x = x ^ t ^ (t << 4);

76 
t
 = (
x
 ^ (x >> 2)) & 0x0c0c0c0c; x = x ^ t ^ (t << 2);

77 
t
 = (
x
 ^ (x >> 1)) & 0x22222222; x = x ^ t ^ (t << 1);

78 return 
x
;

79 
	}
}

81 static 
inline
 void 
	$read64_bi
(
cf_sha3_bi
 *
out
, const 
uint8_t
 
data
[8])

83 
uint32_t
 
lo
 = 
	`read32_le
(
data
 + 0),

84 
hi
 = 
	`read32_le
(
data
 + 4);

86 
lo
 = 
	`shuffle_out
(lo);

87 
hi
 = 
	`shuffle_out
(hi);

89 
out
->
odd
 = (
lo
 & 0x0000ffff) | (
hi
 << 16);

90 
out
->
evn
 = (
lo
 >> 16) | (
hi
 & 0xffff0000);

91 
	}
}

93 static 
inline
 void 
	$write64_bi
(const 
cf_sha3_bi
 *
bi
, 
uint8_t
 
data
[8])

95 
uint32_t
 
lo
 = (
bi
->
odd
 & 0x0000ffff) | (bi->
evn
 << 16),

96 
hi
 = (
bi
->
odd
 >> 16) | (bi->
evn
 & 0xffff0000);

98 
lo
 = 
	`shuffle_in
(lo);

99 
hi
 = 
	`shuffle_in
(hi);

101 
	`write32_le
(
lo
, 
data
 + 0);

102 
	`write32_le
(
hi
, 
data
 + 4);

103 
	}
}

105 static 
inline
 void 
	$rotl_bi_1
(
cf_sha3_bi
 *
out
, const cf_sha3_bi *
in
)

109 
out
->
odd
 = 
	`rotl32
(
in
->
evn
, 1);

110 
out
->
evn
 = 
in
->
odd
;

111 
	}
}

113 static 
inline
 void 
	$rotl_bi_n
(
cf_sha3_bi
 *
out
, const cf_sha3_bi *
in
, 
uint8_t
 
rot
)

115 
uint8_t
 
half
 = 
rot
 >> 1;

118 if (
rot
 & 1)

120 
out
->
odd
 = 
	`rotl32
(
in
->
evn
, 
half
 + 1);

121 
out
->
evn
 = 
	`rotl32
(
in
->
odd
, 
half
);

123 
out
->
evn
 = 
	`rotl32
(
in
->evn, 
half
);

124 
out
->
odd
 = 
	`rotl32
(
in
->odd, 
half
);

126 
	}
}

130 static void 
	$sha3_init
(
cf_sha3_context
 *
ctx
, 
uint16_t
 
rate_bits
, uint16_t 
capacity_bits
)

132 
	`mem_clean
(
ctx
, sizeof *ctx);

133 
ctx
->
rate
 = 
rate_bits
 / 8;

134 
ctx
->
capacity
 = 
capacity_bits
 / 8;

135 
	}
}

137 static void 
	$absorb
(
cf_sha3_context
 *
ctx
, const 
uint8_t
 *
data
, 
uint16_t
 
sz
)

139 
uint16_t
 
lanes
 = 
sz
 / 8;

141 for (
uint16_t
 
x
 = 0, 
y
 = 0, 
i
 = 0; i < 
lanes
; i++)

143 
cf_sha3_bi
 
bi
;

144 
	`read64_bi
(&
bi
, 
data
);

145 
ctx
->
A
[
x
][
y
].
odd
 ^= 
bi
.odd;

146 
ctx
->
A
[
x
][
y
].
evn
 ^= 
bi
.evn;

147 
data
 += 8;

149 
x
++;

150 if (
x
 == 5)

152 
y
++;

153 
x
 = 0;

156 
	}
}

160 static const 
uint8_t
 
	gmod5_table
[] = {

167 #define 
	#MOD5
(
x
) (
mod5_table
[(x) + 1])

	)

169 static void 
	$theta
(
cf_sha3_context
 *
ctx
)

171 
cf_sha3_bi
 
C
[5], 
D
[5];

173 for (int 
x
 = 0; x < 5; x++)

175 
C
[
x
].
odd
 = 
ctx
->
A
[x][0].odd ^ ctx->A[x][1].odd ^ ctx->A[x][2].odd ^ ctx->A[x][3].odd ^ ctx->A[x][4].odd;

176 
C
[
x
].
evn
 = 
ctx
->
A
[x][0].evn ^ ctx->A[x][1].evn ^ ctx->A[x][2].evn ^ ctx->A[x][3].evn ^ ctx->A[x][4].evn;

179 for (int 
x
 = 0; x < 5; x++)

181 
cf_sha3_bi
 
r
;

182 
	`rotl_bi_1
(&
r
, &
C
[
	`MOD5
(
x
 + 1)]);

183 
D
[
x
].
odd
 = 
C
[
	`MOD5
(x - 1)].odd ^ 
r
.odd;

184 
D
[
x
].
evn
 = 
C
[
	`MOD5
(x - 1)].evn ^ 
r
.evn;

186 for (int 
y
 = 0; y < 5; y++)

188 
ctx
->
A
[
x
][
y
].
odd
 ^= 
D
[x].odd;

189 
ctx
->
A
[
x
][
y
].
evn
 ^= 
D
[x].evn;

192 
	}
}

194 static void 
	$rho_pi_chi
(
cf_sha3_context
 *
ctx
)

196 
cf_sha3_bi
 
B
[5][5] = { { { 0 } } };

198 for (int 
x
 = 0; x < 5; x++)

199 for (int 
y
 = 0; y < 5; y++)

200 
	`rotl_bi_n
(&
B
[
y
][
	`MOD5
(2 * 
x
 + 3 * y)], &
ctx
->
A
[x][y], 
rotation_constants
[y][x]);

202 for (int 
x
 = 0; x < 5; x++)

204 unsigned 
x1
 = 
	`MOD5
(
x
 + 1);

205 unsigned 
x2
 = 
	`MOD5
(
x
 + 2);

207 for (int 
y
 = 0; y < 5; y++)

209 
ctx
->
A
[
x
][
y
].
odd
 = 
B
[x][y].odd ^ ((~ B[
x1
][y].odd) & B[
x2
][y].odd);

210 
ctx
->
A
[
x
][
y
].
evn
 = 
B
[x][y].evn ^ ((~ B[
x1
][y].evn) & B[
x2
][y].evn);

213 
	}
}

215 static void 
	$permute
(
cf_sha3_context
 *
ctx
)

217 for (int 
r
 = 0; r < 24; r++)

219 
	`theta
(
ctx
);

220 
	`rho_pi_chi
(
ctx
);

223 
ctx
->
A
[0][0].
odd
 ^= 
round_constants
[
r
].odd;

224 
ctx
->
A
[0][0].
evn
 ^= 
round_constants
[
r
].evn;

226 
	}
}

228 static void 
	$extract
(
cf_sha3_context
 *
ctx
, 
uint8_t
 *
out
, 
size_t
 
nbytes
)

230 
uint16_t
 
lanes
 = (
nbytes
 + 7) / 8;

232 for (
uint16_t
 
x
 = 0, 
y
 = 0, 
i
 = 0; i < 
lanes
; i++)

234 if (
nbytes
 >= 8)

236 
	`write64_bi
(&
ctx
->
A
[
x
][
y
], 
out
);

237 
out
 += 8;

238 
nbytes
 -= 8;

240 
uint8_t
 
buf
[8];

241 
	`write64_bi
(&
ctx
->
A
[
x
][
y
], 
buf
);

242 
	`memcpy
(
out
, 
buf
, 
nbytes
);

243 
out
 += 
nbytes
;

244 
nbytes
 = 0;

247 
x
++;

248 if (
x
 == 5)

250 
y
++;

251 
x
 = 0;

254 
	}
}

256 static void 
	$squeeze
(
cf_sha3_context
 *
ctx
, 
uint8_t
 *
out
, 
size_t
 
nbytes
)

258 while (
nbytes
)

260 
size_t
 
take
 = 
	`MIN
(
nbytes
, 
ctx
->
rate
);

261 
	`extract
(
ctx
, 
out
, 
take
);

262 
out
 += 
take
;

263 
nbytes
 -= 
take
;

265 
	`assert
(
nbytes
 == 0);

271 if (
nbytes
)

272 
	`permute
(
ctx
);

275 
	}
}

277 static void 
	$sha3_block
(void *
vctx
, const 
uint8_t
 *
data
)

279 
cf_sha3_context
 *
ctx
 = 
vctx
;

281 
	`absorb
(
ctx
, 
data
, ctx->
rate
);

282 
	`permute
(
ctx
);

283 
	}
}

285 static void 
	$sha3_update
(
cf_sha3_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

287 
	`cf_blockwise_accumulate
(
ctx
->
partial
, &ctx->
npartial
, ctx->
rate
,

288 
data
, 
nbytes
,

289 
sha3_block
, 
ctx
);

290 
	}
}

304 #define 
	#DOMAIN_HASH_PAD
 0x06

	)

305 #define 
	#DOMAIN_SHAKE_PAD
 0x1f

	)

307 static void 
	$pad
(
cf_sha3_context
 *
ctx
, 
uint8_t
 
domain
, 
size_t
 
npad
)

309 
	`assert
(
npad
 >= 1);

311 
	`cf_blockwise_acc_pad
(
ctx
->
partial
, &ctx->
npartial
, ctx->
rate
,

312 
domain
, 0x00, 0x80,

313 
npad
,

314 
sha3_block
, 
ctx
);

315 
	}
}

317 static void 
	$pad_and_squeeze
(
cf_sha3_context
 *
ctx
, 
uint8_t
 *
out
, 
size_t
 
nout
)

319 
	`pad
(
ctx
, 
DOMAIN_HASH_PAD
, ctx->
rate
 - ctx->
npartial
);

320 
	`assert
(
ctx
->
npartial
 == 0);

322 
	`squeeze
(
ctx
, 
out
, 
nout
);

323 
	`mem_clean
(
ctx
, sizeof *ctx);

324 
	}
}

327 void 
	$cf_sha3_224_init
(
cf_sha3_context
 *
ctx
)

329 
	`sha3_init
(
ctx
, 1152, 448);

330 
	}
}

332 void 
	$cf_sha3_224_update
(
cf_sha3_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

334 
	`sha3_update
(
ctx
, 
data
, 
nbytes
);

335 
	}
}

337 void 
	$cf_sha3_224_digest
(const 
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_224_HASHSZ
])

339 
cf_sha3_context
 
ours
 = *
ctx
;

340 
	`cf_sha3_224_digest_final
(&
ours
, 
hash
);

341 
	}
}

343 void 
	$cf_sha3_224_digest_final
(
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_224_HASHSZ
])

345 
	`pad_and_squeeze
(
ctx
, 
hash
, 
CF_SHA3_224_HASHSZ
);

346 
	}
}

348 const 
cf_chash
 
	gcf_sha3_224
 = {

349 .
hashsz
 = 
CF_SHA3_224_HASHSZ
,

350 .
	gblocksz
 = 
CF_SHA3_224_BLOCKSZ
,

351 .
	ginit
 = (
cf_chash_init
) 
cf_sha3_224_init
,

352 .
	gupdate
 = (
cf_chash_update
) 
cf_sha3_224_update
,

353 .
	gdigest
 = (
cf_chash_digest
) 
cf_sha3_224_digest


357 void 
	$cf_sha3_256_init
(
cf_sha3_context
 *
ctx
)

359 
	`sha3_init
(
ctx
, 1088, 512);

360 
	}
}

362 void 
	$cf_sha3_256_update
(
cf_sha3_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

364 
	`sha3_update
(
ctx
, 
data
, 
nbytes
);

365 
	}
}

367 void 
	$cf_sha3_256_digest
(const 
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_256_HASHSZ
])

369 
cf_sha3_context
 
ours
 = *
ctx
;

370 
	`cf_sha3_256_digest_final
(&
ours
, 
hash
);

371 
	}
}

373 void 
	$cf_sha3_256_digest_final
(
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_256_HASHSZ
])

375 
	`pad_and_squeeze
(
ctx
, 
hash
, 
CF_SHA3_256_HASHSZ
);

376 
	}
}

378 const 
cf_chash
 
	gcf_sha3_256
 = {

379 .
hashsz
 = 
CF_SHA3_256_HASHSZ
,

380 .
	gblocksz
 = 
CF_SHA3_256_BLOCKSZ
,

381 .
	ginit
 = (
cf_chash_init
) 
cf_sha3_256_init
,

382 .
	gupdate
 = (
cf_chash_update
) 
cf_sha3_256_update
,

383 .
	gdigest
 = (
cf_chash_digest
) 
cf_sha3_256_digest


387 void 
	$cf_sha3_384_init
(
cf_sha3_context
 *
ctx
)

389 
	`sha3_init
(
ctx
, 832, 768);

390 
	}
}

392 void 
	$cf_sha3_384_update
(
cf_sha3_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

394 
	`sha3_update
(
ctx
, 
data
, 
nbytes
);

395 
	}
}

397 void 
	$cf_sha3_384_digest
(const 
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_384_HASHSZ
])

399 
cf_sha3_context
 
ours
 = *
ctx
;

400 
	`cf_sha3_384_digest_final
(&
ours
, 
hash
);

401 
	}
}

403 void 
	$cf_sha3_384_digest_final
(
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_384_HASHSZ
])

405 
	`pad_and_squeeze
(
ctx
, 
hash
, 
CF_SHA3_384_HASHSZ
);

406 
	}
}

408 const 
cf_chash
 
	gcf_sha3_384
 = {

409 .
hashsz
 = 
CF_SHA3_384_HASHSZ
,

410 .
	gblocksz
 = 
CF_SHA3_384_BLOCKSZ
,

411 .
	ginit
 = (
cf_chash_init
) 
cf_sha3_384_init
,

412 .
	gupdate
 = (
cf_chash_update
) 
cf_sha3_384_update
,

413 .
	gdigest
 = (
cf_chash_digest
) 
cf_sha3_384_digest


417 void 
	$cf_sha3_512_init
(
cf_sha3_context
 *
ctx
)

419 
	`sha3_init
(
ctx
, 576, 1024);

420 
	}
}

422 void 
	$cf_sha3_512_update
(
cf_sha3_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

424 
	`sha3_update
(
ctx
, 
data
, 
nbytes
);

425 
	}
}

427 void 
	$cf_sha3_512_digest
(const 
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_512_HASHSZ
])

429 
cf_sha3_context
 
ours
 = *
ctx
;

430 
	`cf_sha3_512_digest_final
(&
ours
, 
hash
);

431 
	}
}

433 void 
	$cf_sha3_512_digest_final
(
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_512_HASHSZ
])

435 
	`pad_and_squeeze
(
ctx
, 
hash
, 
CF_SHA3_512_HASHSZ
);

436 
	}
}

438 const 
cf_chash
 
	gcf_sha3_512
 = {

439 .
hashsz
 = 
CF_SHA3_512_HASHSZ
,

440 .
	gblocksz
 = 
CF_SHA3_512_BLOCKSZ
,

441 .
	ginit
 = (
cf_chash_init
) 
cf_sha3_512_init
,

442 .
	gupdate
 = (
cf_chash_update
) 
cf_sha3_512_update
,

443 .
	gdigest
 = (
cf_chash_digest
) 
cf_sha3_512_digest


	@deps/picotls/deps/cifra/src/sha3.h

15 #ifndef 
SHA3_H


16 #define 
	#SHA3_H


	)

18 #include 
	~<stddef.h
>

19 #include 
	~<stdint.h
>

21 #include 
	~"chash.h
"

33 #define 
	#CF_SHA3_224_HASHSZ
 28

	)

37 #define 
	#CF_SHA3_256_HASHSZ
 32

	)

41 #define 
	#CF_SHA3_384_HASHSZ
 48

	)

45 #define 
	#CF_SHA3_512_HASHSZ
 64

	)

49 #define 
	#CF_SHA3_224_BLOCKSZ
 144

	)

53 #define 
	#CF_SHA3_256_BLOCKSZ
 136

	)

57 #define 
	#CF_SHA3_384_BLOCKSZ
 104

	)

61 #define 
	#CF_SHA3_512_BLOCKSZ
 72

	)

69 
uint32_t
 
	modd
, 
	mevn
;

70 } 
	tcf_sha3_bi
;

93 
cf_sha3_bi
 
	mA
[5][5];

94 
uint8_t
 
	mpartial
[
CF_SHA3_224_BLOCKSZ
];

95 
size_t
 
	mnpartial
;

96 
uint16_t
 
	mrate
, 
	mcapacity
;

97 } 
	tcf_sha3_context
;

103 extern void 
cf_sha3_224_init
(
cf_sha3_context
 *
ctx
);

106 extern void 
cf_sha3_256_init
(
cf_sha3_context
 *
ctx
);

109 extern void 
cf_sha3_384_init
(
cf_sha3_context
 *
ctx
);

114 extern void 
cf_sha3_512_init
(
cf_sha3_context
 *
ctx
);

119 extern void 
cf_sha3_224_update
(
cf_sha3_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
);

122 extern void 
cf_sha3_256_update
(
cf_sha3_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
);

125 extern void 
cf_sha3_384_update
(
cf_sha3_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
);

131 extern void 
cf_sha3_512_update
(
cf_sha3_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
);

136 extern void 
cf_sha3_224_digest
(const 
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_224_HASHSZ
]);

139 extern void 
cf_sha3_256_digest
(const 
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_256_HASHSZ
]);

142 extern void 
cf_sha3_384_digest
(const 
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_384_HASHSZ
]);

149 extern void 
cf_sha3_512_digest
(const 
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_512_HASHSZ
]);

154 extern void 
cf_sha3_224_digest_final
(
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_224_HASHSZ
]);

157 extern void 
cf_sha3_256_digest_final
(
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_256_HASHSZ
]);

160 extern void 
cf_sha3_384_digest_final
(
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_384_HASHSZ
]);

167 extern void 
cf_sha3_512_digest_final
(
cf_sha3_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA3_512_HASHSZ
]);

175 extern const 
cf_chash
 
cf_sha3_224
;

176 extern const 
cf_chash
 
cf_sha3_256
;

177 extern const 
cf_chash
 
cf_sha3_384
;

178 extern const 
cf_chash
 
cf_sha3_512
;

	@deps/picotls/deps/cifra/src/sha512.c

15 #include 
	~<string.h
>

17 #include 
	~"sha2.h
"

18 #include 
	~"blockwise.h
"

19 #include 
	~"bitops.h
"

20 #include 
	~"handy.h
"

21 #include 
	~"tassert.h
"

23 static const 
uint64_t
 
	gK
[80] = {

24 
UINT64_C
(0x428a2f98d728ae22), UINT64_C(0x7137449123ef65cd),

25 
UINT64_C
(0xb5c0fbcfec4d3b2f), UINT64_C(0xe9b5dba58189dbbc),

26 
UINT64_C
(0x3956c25bf348b538), UINT64_C(0x59f111f1b605d019),

27 
UINT64_C
(0x923f82a4af194f9b), UINT64_C(0xab1c5ed5da6d8118),

28 
UINT64_C
(0xd807aa98a3030242), UINT64_C(0x12835b0145706fbe),

29 
UINT64_C
(0x243185be4ee4b28c), UINT64_C(0x550c7dc3d5ffb4e2),

30 
UINT64_C
(0x72be5d74f27b896f), UINT64_C(0x80deb1fe3b1696b1),

31 
UINT64_C
(0x9bdc06a725c71235), UINT64_C(0xc19bf174cf692694),

32 
UINT64_C
(0xe49b69c19ef14ad2), UINT64_C(0xefbe4786384f25e3),

33 
UINT64_C
(0x0fc19dc68b8cd5b5), UINT64_C(0x240ca1cc77ac9c65),

34 
UINT64_C
(0x2de92c6f592b0275), UINT64_C(0x4a7484aa6ea6e483),

35 
UINT64_C
(0x5cb0a9dcbd41fbd4), UINT64_C(0x76f988da831153b5),

36 
UINT64_C
(0x983e5152ee66dfab), UINT64_C(0xa831c66d2db43210),

37 
UINT64_C
(0xb00327c898fb213f), UINT64_C(0xbf597fc7beef0ee4),

38 
UINT64_C
(0xc6e00bf33da88fc2), UINT64_C(0xd5a79147930aa725),

39 
UINT64_C
(0x06ca6351e003826f), UINT64_C(0x142929670a0e6e70),

40 
UINT64_C
(0x27b70a8546d22ffc), UINT64_C(0x2e1b21385c26c926),

41 
UINT64_C
(0x4d2c6dfc5ac42aed), UINT64_C(0x53380d139d95b3df),

42 
UINT64_C
(0x650a73548baf63de), UINT64_C(0x766a0abb3c77b2a8),

43 
UINT64_C
(0x81c2c92e47edaee6), UINT64_C(0x92722c851482353b),

44 
UINT64_C
(0xa2bfe8a14cf10364), UINT64_C(0xa81a664bbc423001),

45 
UINT64_C
(0xc24b8b70d0f89791), UINT64_C(0xc76c51a30654be30),

46 
UINT64_C
(0xd192e819d6ef5218), UINT64_C(0xd69906245565a910),

47 
UINT64_C
(0xf40e35855771202a), UINT64_C(0x106aa07032bbd1b8),

48 
UINT64_C
(0x19a4c116b8d2d0c8), UINT64_C(0x1e376c085141ab53),

49 
UINT64_C
(0x2748774cdf8eeb99), UINT64_C(0x34b0bcb5e19b48a8),

50 
UINT64_C
(0x391c0cb3c5c95a63), UINT64_C(0x4ed8aa4ae3418acb),

51 
UINT64_C
(0x5b9cca4f7763e373), UINT64_C(0x682e6ff3d6b2b8a3),

52 
UINT64_C
(0x748f82ee5defb2fc), UINT64_C(0x78a5636f43172f60),

53 
UINT64_C
(0x84c87814a1f0ab72), UINT64_C(0x8cc702081a6439ec),

54 
UINT64_C
(0x90befffa23631e28), UINT64_C(0xa4506cebde82bde9),

55 
UINT64_C
(0xbef9a3f7b2c67915), UINT64_C(0xc67178f2e372532b),

56 
UINT64_C
(0xca273eceea26619c), UINT64_C(0xd186b8c721c0c207),

57 
UINT64_C
(0xeada7dd6cde0eb1e), UINT64_C(0xf57d4f7fee6ed178),

58 
UINT64_C
(0x06f067aa72176fba), UINT64_C(0x0a637dc5a2c898a6),

59 
UINT64_C
(0x113f9804bef90dae), UINT64_C(0x1b710b35131c471b),

60 
UINT64_C
(0x28db77f523047d84), UINT64_C(0x32caab7b40c72493),

61 
UINT64_C
(0x3c9ebe0a15c9bebc), UINT64_C(0x431d67c49c100d4c),

62 
UINT64_C
(0x4cc5d4becb3e42b6), UINT64_C(0x597f299cfc657e2a),

63 
UINT64_C
(0x5fcb6fab3ad6faec), UINT64_C(0x6c44198c4a475817)

66 #define 
	#CH
(
x
, 
y
, 
z
) (((x) & (y)) ^ (~(x) & (z)))

	)

67 #define 
	#MAJ
(
x
, 
y
, 
z
) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

	)

68 #define 
	#BSIG0
(
x
) (
	`rotr64
((x), 28) ^ rotr64((x), 34) ^ rotr64((x), 39))

	)

69 #define 
	#BSIG1
(
x
) (
	`rotr64
((x), 14) ^ rotr64((x), 18) ^ rotr64((x), 41))

	)

70 #define 
	#SSIG0
(
x
) (
	`rotr64
((x), 1) ^ rotr64((x), 8) ^ ((x) >> 7))

	)

71 #define 
	#SSIG1
(
x
) (
	`rotr64
((x), 19) ^ rotr64((x), 61) ^ ((x) >> 6))

	)

73 void 
	$cf_sha512_init
(
cf_sha512_context
 *
ctx
)

75 
	`memset
(
ctx
, 0, sizeof *ctx);

76 
ctx
->
H
[0] = 
	`UINT64_C
(0x6a09e667f3bcc908);

77 
ctx
->
H
[1] = 
	`UINT64_C
(0xbb67ae8584caa73b);

78 
ctx
->
H
[2] = 
	`UINT64_C
(0x3c6ef372fe94f82b);

79 
ctx
->
H
[3] = 
	`UINT64_C
(0xa54ff53a5f1d36f1);

80 
ctx
->
H
[4] = 
	`UINT64_C
(0x510e527fade682d1);

81 
ctx
->
H
[5] = 
	`UINT64_C
(0x9b05688c2b3e6c1f);

82 
ctx
->
H
[6] = 
	`UINT64_C
(0x1f83d9abfb41bd6b);

83 
ctx
->
H
[7] = 
	`UINT64_C
(0x5be0cd19137e2179);

84 
	}
}

86 void 
	$cf_sha384_init
(
cf_sha512_context
 *
ctx
)

88 
	`memset
(
ctx
, 0, sizeof *ctx);

89 
ctx
->
H
[0] = 
	`UINT64_C
(0xcbbb9d5dc1059ed8);

90 
ctx
->
H
[1] = 
	`UINT64_C
(0x629a292a367cd507);

91 
ctx
->
H
[2] = 
	`UINT64_C
(0x9159015a3070dd17);

92 
ctx
->
H
[3] = 
	`UINT64_C
(0x152fecd8f70e5939);

93 
ctx
->
H
[4] = 
	`UINT64_C
(0x67332667ffc00b31);

94 
ctx
->
H
[5] = 
	`UINT64_C
(0x8eb44a8768581511);

95 
ctx
->
H
[6] = 
	`UINT64_C
(0xdb0c2e0d64f98fa7);

96 
ctx
->
H
[7] = 
	`UINT64_C
(0x47b5481dbefa4fa4);

97 
	}
}

99 static void 
	$sha512_update_block
(void *
vctx
, const 
uint8_t
 *
inp
)

101 
cf_sha512_context
 *
ctx
 = 
vctx
;

103 
uint64_t
 
W
[16];

105 
uint64_t
 
a
 = 
ctx
->
H
[0],

106 
b
 = 
ctx
->
H
[1],

107 
c
 = 
ctx
->
H
[2],

108 
d
 = 
ctx
->
H
[3],

109 
e
 = 
ctx
->
H
[4],

110 
f
 = 
ctx
->
H
[5],

111 
g
 = 
ctx
->
H
[6],

112 
h
 = 
ctx
->
H
[7],

113 
Wt
;

115 
size_t
 
t
;

116 for (
t
 = 0; t < 80; t++)

118 if (
t
 < 16)

120 
W
[
t
] = 
Wt
 = 
	`read64_be
(
inp
);

121 
inp
 += 8;

123 
Wt
 = 
	`SSIG1
(
W
[(
t
 - 2) % 16]) +

124 
W
[(
t
 - 7) % 16] +

125 
	`SSIG0
(
W
[(
t
 - 15) % 16]) +

126 
W
[(
t
 - 16) % 16];

127 
W
[
t
 % 16] = 
Wt
;

130 
uint64_t
 
T1
 = 
h
 + 
	`BSIG1
(
e
) + 
	`CH
(e, 
f
, 
g
) + 
K
[
t
] + 
Wt
;

131 
uint64_t
 
T2
 = 
	`BSIG0
(
a
) + 
	`MAJ
(a, 
b
, 
c
);

132 
h
 = 
g
;

133 
g
 = 
f
;

134 
f
 = 
e
;

135 
e
 = 
d
 + 
T1
;

136 
d
 = 
c
;

137 
c
 = 
b
;

138 
b
 = 
a
;

139 
a
 = 
T1
 + 
T2
;

142 
ctx
->
H
[0] += 
a
;

143 
ctx
->
H
[1] += 
b
;

144 
ctx
->
H
[2] += 
c
;

145 
ctx
->
H
[3] += 
d
;

146 
ctx
->
H
[4] += 
e
;

147 
ctx
->
H
[5] += 
f
;

148 
ctx
->
H
[6] += 
g
;

149 
ctx
->
H
[7] += 
h
;

151 
ctx
->
blocks
++;

152 
	}
}

154 void 
	$cf_sha512_update
(
cf_sha512_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

156 
	`cf_blockwise_accumulate
(
ctx
->
partial
, &ctx->
npartial
, sizeof ctx->partial,

157 
data
, 
nbytes
,

158 
sha512_update_block
, 
ctx
);

159 
	}
}

161 void 
	$cf_sha384_update
(
cf_sha512_context
 *
ctx
, const void *
data
, 
size_t
 
nbytes
)

163 
	`cf_sha512_update
(
ctx
, 
data
, 
nbytes
);

164 
	}
}

166 void 
	$cf_sha512_digest
(const 
cf_sha512_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA512_HASHSZ
])

182 
cf_sha512_context
 
ours
 = *
ctx
;

183 
	`cf_sha512_digest_final
(&
ours
, 
hash
);

184 
	}
}

186 void 
	$cf_sha512_digest_final
(
cf_sha512_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA512_HASHSZ
])

188 
uint64_t
 
digested_bytes
 = 
ctx
->
blocks
;

189 
digested_bytes
 = digested_bytes * 
CF_SHA512_BLOCKSZ
 + 
ctx
->
npartial
;

190 
uint64_t
 
digested_bits
 = 
digested_bytes
 * 8;

192 
size_t
 
padbytes
 = 
CF_SHA512_BLOCKSZ
 - ((
digested_bytes
 + 16) % CF_SHA512_BLOCKSZ);

195 
	`cf_blockwise_acc_pad
(
ctx
->
partial
, &ctx->
npartial
, sizeof ctx->partial,

196 0x80, 0x00, 0x00, 
padbytes
,

197 
sha512_update_block
, 
ctx
);

200 
uint8_t
 
buf
[8];

201 
	`write64_be
(0, 
buf
);

202 
	`cf_sha512_update
(
ctx
, 
buf
, 8);

203 
	`write64_be
(
digested_bits
, 
buf
);

204 
	`cf_sha512_update
(
ctx
, 
buf
, 8);

207 
	`assert
(
ctx
->
npartial
 == 0);

209 
	`write64_be
(
ctx
->
H
[0], 
hash
 + 0);

210 
	`write64_be
(
ctx
->
H
[1], 
hash
 + 8);

211 
	`write64_be
(
ctx
->
H
[2], 
hash
 + 16);

212 
	`write64_be
(
ctx
->
H
[3], 
hash
 + 24);

213 
	`write64_be
(
ctx
->
H
[4], 
hash
 + 32);

214 
	`write64_be
(
ctx
->
H
[5], 
hash
 + 40);

215 
	`write64_be
(
ctx
->
H
[6], 
hash
 + 48);

216 
	`write64_be
(
ctx
->
H
[7], 
hash
 + 56);

217 
	`memset
(
ctx
, 0, sizeof *ctx);

218 
	}
}

220 void 
	$cf_sha384_digest
(const 
cf_sha512_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA384_HASHSZ
])

222 
uint8_t
 
full
[
CF_SHA512_HASHSZ
];

223 
	`cf_sha512_digest
(
ctx
, 
full
);

224 
	`memcpy
(
hash
, 
full
, 
CF_SHA384_HASHSZ
);

225 
	}
}

227 void 
	$cf_sha384_digest_final
(
cf_sha512_context
 *
ctx
, 
uint8_t
 
hash
[
CF_SHA384_HASHSZ
])

229 
uint8_t
 
full
[
CF_SHA512_HASHSZ
];

230 
	`cf_sha512_digest_final
(
ctx
, 
full
);

231 
	`memcpy
(
hash
, 
full
, 
CF_SHA384_HASHSZ
);

232 
	}
}

234 const 
cf_chash
 
	gcf_sha384
 = {

235 .
hashsz
 = 
CF_SHA384_HASHSZ
,

236 .
	gblocksz
 = 
CF_SHA384_BLOCKSZ
,

237 .
	ginit
 = (
cf_chash_init
) 
cf_sha384_init
,

238 .
	gupdate
 = (
cf_chash_update
) 
cf_sha384_update
,

239 .
	gdigest
 = (
cf_chash_digest
) 
cf_sha384_digest


242 const 
cf_chash
 
	gcf_sha512
 = {

243 .
hashsz
 = 
CF_SHA512_HASHSZ
,

244 .
	gblocksz
 = 
CF_SHA512_BLOCKSZ
,

245 .
	ginit
 = (
cf_chash_init
) 
cf_sha512_init
,

246 .
	gupdate
 = (
cf_chash_update
) 
cf_sha512_update
,

247 .
	gdigest
 = (
cf_chash_digest
) 
cf_sha512_digest


	@deps/picotls/deps/cifra/src/tassert.h

15 #ifndef 
TASSERT_H


16 #define 
	#TASSERT_H


	)

25 #ifndef 
FULL_FAT_ASSERT


26 #include 
	~<stdlib.h
>

27 #define 
	#assert
(
expr
) do { if (!(expr)) 
	`abort
(); } while (0)

	)

29 #include 
	~<assert.h
>

	@deps/picotls/deps/cifra/src/testaes.c

15 #include 
	~"aes.h
"

16 #include 
	~"modes.h
"

17 #include 
	~"bitops.h
"

18 #include 
	~"gf128.h
"

20 #include 
	~"handy.h
"

21 #include 
	~"cutest.h
"

22 #include 
	~"testutil.h
"

24 static void 
	$test_memclean
(void)

26 
uint8_t
 
buf
[32], 
buf2
[32];

27 
	`memset
(
buf
, 0xff, sizeof buf);

28 
	`mem_clean
(
buf
 + 1, sizeof buf - 2);

29 
	`TEST_CHECK
(
buf
[0] == 0xff);

30 
	`TEST_CHECK
(
buf
[1] == 0x00);

31 
	`TEST_CHECK
(
buf
[16] == 0x00);

32 
	`TEST_CHECK
(
buf
[30] == 0x00);

33 
	`TEST_CHECK
(
buf
[31] == 0xff);

35 
	`memcpy
(
buf2
, 
buf
, sizeof buf);

36 
	`TEST_CHECK
(
buf2
[0] == 0xff);

37 
	`TEST_CHECK
(
buf2
[1] == 0x00);

38 
	`TEST_CHECK
(
buf2
[16] == 0x00);

39 
	`TEST_CHECK
(
buf2
[30] == 0x00);

40 
	`TEST_CHECK
(
buf2
[31] == 0xff);

42 
	`memset
(
buf2
, 0xee, sizeof 
buf
);

43 
	`TEST_CHECK
(
buf2
[0] == 0xee);

44 
	`TEST_CHECK
(
buf2
[1] == 0xee);

45 
	`TEST_CHECK
(
buf2
[2] == 0xee);

46 
	`TEST_CHECK
(
buf2
[3] == 0xee);

47 
	`TEST_CHECK
(
buf2
[30] == 0xee);

48 
	`TEST_CHECK
(
buf2
[31] == 0xee);

49 
	}
}

51 static void 
	$test_bitops_select
(void)

53 
uint8_t
 
tab8
[8];

54 
uint32_t
 
tab32
[32];

56 for (
size_t
 
i
 = 0; i < 8; i++)

57 
tab8
[
i
] = 1 << i;

58 for (
size_t
 
i
 = 0; i < 32; i++)

59 
tab32
[
i
] = 1 << i;

61 for (
size_t
 
i
 = 0; i < 8; i++)

63 
	`TEST_CHECK
(
	`select_u8
(
i
, 
tab8
, 8) == tab8[i]);

66 for (
size_t
 
i
 = 0; i < 32; i++)

68 
	`TEST_CHECK
(
	`select_u32
(
i
, 
tab32
, 32) == tab32[i]);

70 
	}
}

72 static void 
	$test_bitops_incr
(void)

74 
uint8_t
 
buf
[4];

76 #define 
	#CHECK_BE
(
start
, 
add
, 
end
) \

78 
	`write32_be
((
start
), 
buf
); \

79 for (
size_t
 
i
 = 0; i < (
add
); i++) \

80 
	`incr_be
(
buf
, sizeof buf); \

81 
	`TEST_CHECK
(
	`read32_be
(
buf
) == (
end
)); \

82 }

	)

84 #define 
	#CHECK_LE
(
start
, 
add
, 
end
) \

86 
	`write32_le
((
start
), 
buf
); \

87 for (
size_t
 
i
 = 0; i < (
add
); i++) \

88 
	`incr_le
(
buf
, sizeof buf); \

89 
	`TEST_CHECK
(
	`read32_le
(
buf
) == (
end
)); \

90 }

	)

92 
	`CHECK_BE
(0, 1, 1);

93 
	`CHECK_BE
(0, 256, 256);

94 
	`CHECK_BE
(256, 256, 512);

95 
	`CHECK_BE
(0xffffffff, 1, 0);

97 
	`CHECK_LE
(0, 1, 1);

98 
	`CHECK_LE
(0, 256, 256);

99 
	`CHECK_LE
(0x7fffffff, 1, 0x80000000);

100 
	`CHECK_LE
(0xffffffff, 1, 0);

102 #undef 
CHECK_BE


103 #undef 
CHECK_LE


104 
	}
}

106 static void 
	$test_bitops_unaligned
(void)

108 
uint8_t
 
in
[4], 
out
[4];

110 #define 
	#CHECK
(
outw
, 
len
, 
offs
) \

112 
	`memset
(
out
, 0, sizeof out); \

113 
	`copy_bytes_unaligned
(
out
, 
in
, 
len
, 
offs
); \

114 
	`TEST_CHECK
(
	`read32_be
(
out
) == (
outw
)); \

115 }

	)

117 
	`write32_be
(0x11223344, 
in
);

119 
	`CHECK
(0x11223344, 4, 0);

120 
	`CHECK
(0x22446600, 3, 1);

121 
	`CHECK
(0x4488cd00, 3, 2);

122 
	`CHECK
(0x89119a00, 3, 3);

123 
	`CHECK
(0x12233400, 3, 4);

124 
	`CHECK
(0x24466800, 3, 5);

125 
	`CHECK
(0x488cd100, 3, 6);

126 
	`CHECK
(0x9119a200, 3, 7);

127 
	`CHECK
(0x22334400, 3, 8);

128 
	`CHECK
(0x44660000, 2, 9);

129 
	`CHECK
(0x33440000, 2, 16);

131 #undef 
CHECK


132 
	}
}

134 static void 
	$test_expand
(const 
uint8_t
 *
key
, 
size_t
 
nkey
,

135 const 
uint32_t
 *
answer
, 
size_t
 
roundkeys
)

137 
cf_aes_context
 
ctx
;

139 
	`cf_aes_init
(&
ctx
, 
key
, 
nkey
);

141 for (
size_t
 
i
 = 0; i < 
roundkeys
; i++)

143 
	`TEST_CHECK
(
ctx
.
ks
[
i
] == 
answer
[i]);

145 
	}
}

147 static void 
	$test_expand_128
(void)

150 const 
uint8_t
 
key
[] = {

155 const 
uint32_t
 
answer
[] = {

166 
	`test_expand
(
key
, sizeof key, 
answer
, 
	`ARRAYCOUNT
(answer));

167 
	}
}

169 static void 
	$test_expand_192
(void)

172 const 
uint8_t
 
key
[] = {

177 const 
uint32_t
 
answer
[] = {

189 
	`test_expand
(
key
, sizeof key, 
answer
, 
	`ARRAYCOUNT
(answer));

190 
	}
}

192 static void 
	$test_expand_256
(void)

195 const 
uint8_t
 
key
[] = {

201 const 
uint32_t
 
answer
[] = {

214 
	`test_expand
(
key
, sizeof key, 
answer
, 
	`ARRAYCOUNT
(answer));

215 
	}
}

217 static void 
	$vector
(const char *
input
, const char *
output
,

218 const char *
key
)

220 
uint8_t
 
keybuf
[32], 
inbuf
[16], 
outbuf
[16], 
tmp
[16];

221 
size_t
 
nkey
 = sizeof 
keybuf
;

222 
cf_aes_context
 
ctx
;

224 
nkey
 = 
	`unhex
(
keybuf
, 32, 
key
);

225 
	`unhex
(
inbuf
, 16, 
input
);

226 
	`unhex
(
outbuf
, 16, 
output
);

228 
	`cf_aes_init
(&
ctx
, 
keybuf
, 
nkey
);

229 
	`cf_aes_encrypt
(&
ctx
, 
inbuf
, 
tmp
);

230 
	`TEST_CHECK
(
	`memcmp
(
tmp
, 
outbuf
, 16) == 0);

232 
	`cf_aes_decrypt
(&
ctx
, 
outbuf
, 
tmp
);

233 
	`TEST_CHECK
(
	`memcmp
(
tmp
, 
inbuf
, 16) == 0);

234 
	`cf_aes_finish
(&
ctx
);

235 
	}
}

237 static void 
	$test_vectors
(void)

239 
	`vector
("00112233445566778899aabbccddeeff", "69c4e0d86a7b0430d8cdb78070b4c55a",

241 
	`vector
("00112233445566778899aabbccddeeff", "dda97ca4864cdfe06eaf70a0ec0d7191",

243 
	`vector
("00112233445566778899aabbccddeeff", "8ea2b7ca516745bfeafc49904b496089",

245 
	}
}

247 
	gTEST_LIST
 = {

248 { "handy-memclean", 
test_memclean
 },

249 { "bitops-select", 
test_bitops_select
 },

250 { "bitops-incr", 
test_bitops_incr
 },

251 { "bitops-unaligned", 
test_bitops_unaligned
 },

252 { "key-expansion-128", 
test_expand_128
 },

253 { "key-expansion-192", 
test_expand_192
 },

254 { "key-expansion-256", 
test_expand_256
 },

255 { "vectors", 
test_vectors
 },

	@deps/picotls/deps/cifra/src/testchacha20poly1305.c

15 #include 
	~"chacha20poly1305.h
"

16 #include 
	~"handy.h
"

17 #include 
	~"cutest.h
"

18 #include 
	~"testutil.h
"

20 static void 
	$vector
(const char *
keystr
,

21 const char *
noncestr
,

22 const char *
headerstr
,

23 const char *
plainstr
,

24 const char *
cipherstr
,

25 const char *
tagstr
)

28 
uint8_t
 
K
[32], 
N
[12], 
H
[12], 
A
[16];

29 
uint8_t
 
C
[265], 
P
[265];

31 
	`unhex
(
K
, sizeof K, 
keystr
);

32 
	`unhex
(
N
, sizeof N, 
noncestr
);

33 
size_t
 
headerlen
 = 
	`unhex
(
H
, sizeof H, 
headerstr
);

34 
size_t
 
plainlen
 = 
	`unhex
(
P
, sizeof P, 
plainstr
);

35 
size_t
 
cipherlen
 = 
	`unhex
(
C
, sizeof C, 
cipherstr
);

36 
	`unhex
(
A
, sizeof A, 
tagstr
);

38 
	`assert
(
cipherlen
 == 
plainlen
);

41 
uint8_t
 
out
[265], 
ourtag
[16];

44 
	`cf_chacha20poly1305_encrypt
(
K
, 
N
,

45 
H
, 
headerlen
,

46 
P
, 
plainlen
,

47 
out
, 
ourtag
);

49 
	`TEST_CHECK
(
	`memcmp
(
out
, 
C
, 
cipherlen
) == 0);

50 
	`TEST_CHECK
(
	`memcmp
(
ourtag
, 
A
, sizeof A) == 0);

53 
	`TEST_CHECK
(0 == 
	`cf_chacha20poly1305_decrypt
(
K
, 
N
,

54 
H
, 
headerlen
,

55 
C
, 
cipherlen
,

56 
A
, 
out
));

57 
	`TEST_CHECK
(0 == 
	`memcmp
(
out
, 
P
, 
plainlen
));

60 
C
[0] ^= 0xff;

62 
	`TEST_CHECK
(1 == 
	`cf_chacha20poly1305_decrypt
(
K
, 
N
,

63 
H
, 
headerlen
,

64 
C
, 
cipherlen
,

65 
A
, 
out
));

66 
	}
}

68 static void 
	$test_vectors
(void)

71 
	`vector
("808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f",

79 
	`vector
("1c9240a5eb55d38af333888604f6b5f0473917c1402b80099dca5cbc207075c0",

85 
	}
}

87 
	gTEST_LIST
 = {

88 { "vectors", 
test_vectors
 },

	@deps/picotls/deps/cifra/src/testcurve25519.c

15 #include 
	~"curve25519.h
"

16 #include 
	~"handy.h
"

17 #include 
	~"cutest.h
"

18 #include 
	~"testutil.h
"

20 static void 
	$test_base_mul
(void)

22 
uint8_t
 
secret
[32];

23 
uint8_t
 
public
[32];

24 
uint8_t
 
expect
[32];

26 
	`unhex
(
secret
, 32, "77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a");

27 
	`unhex
(
expect
, 32, "8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a");

28 
	`cf_curve25519_mul_base
(
public
, 
secret
);

29 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
public
, 32) == 0);

31 
	`unhex
(
secret
, 32, "5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb");

32 
	`unhex
(
expect
, 32, "de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f");

33 
	`cf_curve25519_mul_base
(
public
, 
secret
);

34 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
public
, 32) == 0);

35 
	}
}

37 static void 
	$test_mul
(void)

39 
uint8_t
 
scalar
[32];

40 
uint8_t
 
public
[32];

41 
uint8_t
 
shared
[32];

42 
uint8_t
 
expect
[32];

44 
	`unhex
(
scalar
, 32, "77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a");

45 
	`unhex
(
public
, 32, "de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f");

46 
	`unhex
(
expect
, 32, "4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742");

47 
	`cf_curve25519_mul
(
shared
, 
scalar
, 
public
);

48 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
shared
, 32) == 0);

49 
	}
}

51 
	gTEST_LIST
 = {

52 { "base-mul", 
test_base_mul
 },

53 { "mul", 
test_mul
 },

	@deps/picotls/deps/cifra/src/testdrbg.c

15 #include 
	~"drbg.h
"

16 #include 
	~"sha1.h
"

17 #include 
	~"sha2.h
"

19 #include 
	~"handy.h
"

20 #include 
	~"cutest.h
"

21 #include 
	~"testutil.h
"

23 static void 
	$test_hashdrbg_sha256_vector
(void)

25 
uint8_t
 
entropy
[32], 
nonce
[16], 
persn
[32], 
reseed
[32], 
got
[128], 
expect
[128];

29 
	`unhex
(
entropy
, sizeof entropy, "b87bb4de5c148d964fc0cb612d69295671780b4270fe32bf389b6f49488efe13");

30 
	`unhex
(
nonce
, sizeof nonce, "27eb37a0c695c4ee3c9b70b7f6b33492");

31 
	`unhex
(
persn
, sizeof persn, "52321406ac8a9c266b1f8d811bb871269e5824b59a0234f01d358193523bbb7c");

32 
	`unhex
(
reseed
, sizeof reseed, "7638267f534c4e6ee22cc6ca6ed824fd5d3d387c00b89dd791eb5ac9766385b8");

34 
	`unhex
(
expect
, sizeof expect, "de01c061651bab3cef2fc4ea89a56b6e86e74b2e9fd11ed671c97c813778a06a2c1f41b41e754a5257750c6bde9601da9d67d8d9564f4a8538b92516a2dacc496dee257b85393f2a01ad59aa3257f1b6da9566e3706d2d6d4a26e511b0c64d7dc223acb24827178afa43ca8d5a66f983d6929dc61564c4c14fc32d85765a23f7");

36 
cf_hash_drbg_sha256
 
ctx
;

37 
	`cf_hash_drbg_sha256_init
(&
ctx
, 
entropy
, sizeof entropy, 
nonce
, sizeof nonce, 
persn
, sizeof persn);

38 
	`cf_hash_drbg_sha256_reseed
(&
ctx
, 
reseed
, sizeof reseed, 
NULL
, 0);

39 
	`cf_hash_drbg_sha256_gen
(&
ctx
, 
got
, sizeof got);

40 
	`cf_hash_drbg_sha256_gen
(&
ctx
, 
got
, sizeof got);

41 
	`TEST_CHECK
(
	`memcmp
(
got
, 
expect
, sizeof got) == 0);

44 
	`unhex
(
entropy
, sizeof entropy, "63363377e41e86468deb0ab4a8ed683f6a134e47e014c700454e81e95358a569");

45 
	`unhex
(
nonce
, sizeof nonce, "808aa38f2a72a62359915a9f8a04ca68");

47 
	`unhex
(
reseed
, sizeof reseed, "e62b8a8ee8f141b6980566e3bfe3c04903dad4ac2cdf9f2280010a6739bc83d3");

48 
	`unhex
(
expect
, sizeof expect, "04eec63bb231df2c630a1afbe724949d005a587851e1aa795e477347c8b056621c18bddcdd8d99fc5fc2b92053d8cfacfb0bb8831205fad1ddd6c071318a6018f03b73f5ede4d4d071f9de03fd7aea105d9299b8af99aa075bdb4db9aa28c18d174b56ee2a014d098896ff2282c955a81969e069fa8ce007a180183a07dfae17");

50 
	`cf_hash_drbg_sha256_init
(&
ctx
, 
entropy
, sizeof entropy, 
nonce
, sizeof nonce, 
NULL
, 0);

51 
	`cf_hash_drbg_sha256_reseed
(&
ctx
, 
reseed
, sizeof reseed, 
NULL
, 0);

52 
	`cf_hash_drbg_sha256_gen
(&
ctx
, 
got
, sizeof got);

53 
	`cf_hash_drbg_sha256_gen
(&
ctx
, 
got
, sizeof got);

54 
	`TEST_CHECK
(
	`memcmp
(
got
, 
expect
, sizeof got) == 0);

55 
	}
}

57 static void 
	$test_hashdrbg_sha256_vector_addnl
(void)

59 
uint8_t
 
entropy
[32], 
nonce
[16], 
reseed
[32], 
got
[128], 
expect
[128], 
addnl
[32];

62 
	`unhex
(
entropy
, sizeof entropy, "9cfb7ad03be487a3b42be06e9ae44f283c2b1458cec801da2ae6532fcb56cc4c");

63 
	`unhex
(
nonce
, sizeof nonce, "a20765538e8db31295747ec922c13a69");

64 
	`unhex
(
reseed
, sizeof reseed, "96bc8014f90ebdf690db0e171b59cc46c75e2e9b8e1dc699c65c03ceb2f4d7dc");

65 
	`unhex
(
expect
, sizeof expect, "71c1154a2a7a3552413970bf698aa02f14f8ea95e861f801f463be27868b1b14b1b4babd9eba5915a6414ab1104c8979b1918f3094925aeab0d07d2037e613b63cbd4f79d9f95c84b47ed9b77230a57515c211f48f4af6f5edb2c308b33905db308cf88f552c8912c49b34e66c026e67b302ca65b187928a1aba9a49edbfe190");

67 
cf_hash_drbg_sha256
 
ctx
;

68 
	`cf_hash_drbg_sha256_init
(&
ctx
, 
entropy
, sizeof entropy, 
nonce
, sizeof nonce, 
NULL
, 0);

69 
	`unhex
(
addnl
, sizeof addnl, "6fea0894052dab3c44d503950c7c72bd7b87de87cb81d3bb51c32a62f742286d");

70 
	`cf_hash_drbg_sha256_reseed
(&
ctx
, 
reseed
, sizeof reseed, 
addnl
, sizeof addnl);

71 
	`unhex
(
addnl
, sizeof addnl, "d3467c78563b74c13db7af36c2a964820f2a9b1b167474906508fdac9b2049a6");

72 
	`cf_hash_drbg_sha256_gen_additional
(&
ctx
, 
addnl
, sizeof addnl, 
got
, sizeof got);

73 
	`unhex
(
addnl
, sizeof addnl, "5840a11cc9ebf77b963854726a826370ffdb2fc2b3d8479e1df5dcfa3dddd10b");

74 
	`cf_hash_drbg_sha256_gen_additional
(&
ctx
, 
addnl
, sizeof addnl, 
got
, sizeof got);

75 
	`TEST_CHECK
(
	`memcmp
(
got
, 
expect
, sizeof got) == 0);

76 
	}
}

78 static void 
	$test_hmacdrbg_sha1_vector
(void)

80 
uint8_t
 
entropy
[16], 
nonce
[8], 
reseed
[16], 
got
[80], 
expect
[80];

83 
	`unhex
(
entropy
, sizeof entropy, "79349bbf7cdda5799557866621c91383");

84 
	`unhex
(
nonce
, sizeof nonce, "1146733abf8c35c8");

85 
	`unhex
(
reseed
, sizeof reseed, "c7215b5b96c48e9b338c74e3e99dfedf");

86 
	`unhex
(
expect
, sizeof expect, "c6a16ab8d420706f0f34ab7fec5adca9d8ca3a133e159ca6ac43c6f8a2be22834a4c0a0affb10d7194f1c1a5cf7322ec1ae0964ed4bf122746e087fdb5b3e91b3493d5bb98faed49e85f130fc8a459b7");

88 
cf_hmac_drbg
 
ctx
;

89 
	`cf_hmac_drbg_init
(&
ctx
, &
cf_sha1
, 
entropy
, sizeof entropy, 
nonce
, sizeof nonce, 
NULL
, 0);

90 
	`cf_hmac_drbg_reseed
(&
ctx
, 
reseed
, sizeof reseed, 
NULL
, 0);

91 
	`cf_hmac_drbg_gen
(&
ctx
, 
got
, sizeof got);

92 
	`cf_hmac_drbg_gen
(&
ctx
, 
got
, sizeof got);

93 
	`TEST_CHECK
(
	`memcmp
(
got
, 
expect
, sizeof got) == 0);

94 
	}
}

96 static void 
	$test_hmacdrbg_sha1_vector_addnl
(void)

98 
uint8_t
 
entropy
[16], 
nonce
[8], 
reseed
[16], 
got
[80], 
expect
[80], 
addnl
[16];

101 
	`unhex
(
entropy
, sizeof entropy, "7d7052a776fd2fb3d7191f733304ee8b");

102 
	`unhex
(
nonce
, sizeof nonce, "be4a0ceedca80207");

103 
	`unhex
(
reseed
, sizeof reseed, "49047e879d610955eed916e4060e00c9");

104 
	`unhex
(
expect
, sizeof expect, "a736343844fc92511391db0addd9064dbee24c8976aa259a9e3b6368aa6de4c9bf3a0effcda9cb0e9dc33652ab58ecb7650ed80467f76a849fb1cfc1ed0a09f7155086064db324b1e124f3fc9e614fcb");

106 
cf_hmac_drbg
 
ctx
;

107 
	`cf_hmac_drbg_init
(&
ctx
, &
cf_sha1
, 
entropy
, sizeof entropy, 
nonce
, sizeof nonce, 
NULL
, 0);

108 
	`unhex
(
addnl
, sizeof addnl, "fd8bb33aab2f6cdfbc541811861d518d");

109 
	`cf_hmac_drbg_reseed
(&
ctx
, 
reseed
, sizeof reseed, 
addnl
, sizeof addnl);

110 
	`unhex
(
addnl
, sizeof addnl, "99afe347540461ddf6abeb491e0715b4");

111 
	`cf_hmac_drbg_gen_additional
(&
ctx
, 
addnl
, sizeof addnl, 
got
, sizeof got);

112 
	`unhex
(
addnl
, sizeof addnl, "02f773482dd7ae66f76e381598a64ef0");

113 
	`cf_hmac_drbg_gen_additional
(&
ctx
, 
addnl
, sizeof addnl, 
got
, sizeof got);

114 
	`TEST_CHECK
(
	`memcmp
(
got
, 
expect
, sizeof got) == 0);

115 
	}
}

117 static void 
	$test_hmacdrbg_sha256_vector
(void)

119 
uint8_t
 
entropy
[32], 
nonce
[16], 
reseed
[32], 
got
[128], 
expect
[128];

122 
	`unhex
(
entropy
, sizeof entropy, "06032cd5eed33f39265f49ecb142c511da9aff2af71203bffaf34a9ca5bd9c0d");

123 
	`unhex
(
nonce
, sizeof nonce, "0e66f71edc43e42a45ad3c6fc6cdc4df");

124 
	`unhex
(
reseed
, sizeof reseed, "01920a4e669ed3a85ae8a33b35a74ad7fb2a6bb4cf395ce00334a9c9a5a5d552");

125 
	`unhex
(
expect
, sizeof expect, "76fc79fe9b50beccc991a11b5635783a83536add03c157fb30645e611c2898bb2b1bc215000209208cd506cb28da2a51bdb03826aaf2bd2335d576d519160842e7158ad0949d1a9ec3e66ea1b1a064b005de914eac2e9d4f2d72a8616a80225422918250ff66a41bd2f864a6a38cc5b6499dc43f7f2bd09e1e0f8f5885935124");

127 
cf_hmac_drbg
 
ctx
;

128 
	`cf_hmac_drbg_init
(&
ctx
, &
cf_sha256
, 
entropy
, sizeof entropy, 
nonce
, sizeof nonce, 
NULL
, 0);

129 
	`cf_hmac_drbg_reseed
(&
ctx
, 
reseed
, sizeof reseed, 
NULL
, 0);

130 
	`cf_hmac_drbg_gen
(&
ctx
, 
got
, sizeof got);

131 
	`cf_hmac_drbg_gen
(&
ctx
, 
got
, sizeof got);

132 
	`TEST_CHECK
(
	`memcmp
(
got
, 
expect
, sizeof got) == 0);

133 
	}
}

135 static void 
	$test_hmacdrbg_sha256_vector_addnl
(void)

137 
uint8_t
 
entropy
[32], 
nonce
[16], 
reseed
[32], 
got
[128], 
expect
[128], 
addnl
[32];

140 
	`unhex
(
entropy
, sizeof entropy, "05ac9fc4c62a02e3f90840da5616218c6de5743d66b8e0fbf833759c5928b53d");

141 
	`unhex
(
nonce
, sizeof nonce, "2b89a17904922ed8f017a63044848545");

142 
	`unhex
(
reseed
, sizeof reseed, "2791126b8b52ee1fd9392a0a13e0083bed4186dc649b739607ac70ec8dcecf9b");

143 
	`unhex
(
expect
, sizeof expect, "02ddff5173da2fcffa10215b030d660d61179e61ecc22609b1151a75f1cbcbb4363c3a89299b4b63aca5e581e73c860491010aa35de3337cc6c09ebec8c91a6287586f3a74d9694b462d2720ea2e11bbd02af33adefb4a16e6b370fa0effd57d607547bdcfbb7831f54de7073ad2a7da987a0016a82fa958779a168674b56524");

145 
cf_hmac_drbg
 
ctx
;

146 
	`cf_hmac_drbg_init
(&
ctx
, &
cf_sha256
, 
entropy
, sizeof entropy, 
nonce
, sizeof nonce, 
NULL
, 0);

147 
	`unhex
(
addnl
, sizeof addnl, "43bac13bae715092cf7eb280a2e10a962faf7233c41412f69bc74a35a584e54c");

148 
	`cf_hmac_drbg_reseed
(&
ctx
, 
reseed
, sizeof reseed, 
addnl
, sizeof addnl);

149 
	`unhex
(
addnl
, sizeof addnl, "3f2fed4b68d506ecefa21f3f5bb907beb0f17dbc30f6ffbba5e5861408c53a1e");

150 
	`cf_hmac_drbg_gen_additional
(&
ctx
, 
addnl
, sizeof addnl, 
got
, sizeof got);

151 
	`unhex
(
addnl
, sizeof addnl, "529030df50f410985fde068df82b935ec23d839cb4b269414c0ede6cffea5b68");

152 
	`cf_hmac_drbg_gen_additional
(&
ctx
, 
addnl
, sizeof addnl, 
got
, sizeof got);

153 
	`TEST_CHECK
(
	`memcmp
(
got
, 
expect
, sizeof got) == 0);

154 
	}
}

156 static void 
	$test_hmacdrbg_sha512_vector
(void)

158 
uint8_t
 
entropy
[32], 
nonce
[16], 
reseed
[32], 
got
[256], 
expect
[256];

161 
	`unhex
(
entropy
, sizeof entropy, "48c121b18733af15c27e1dd9ba66a9a81a5579cdba0f5b657ec53c2b9e90bbf6");

162 
	`unhex
(
nonce
, sizeof nonce, "bbb7c777428068fad9970891f879b1af");

163 
	`unhex
(
reseed
, sizeof reseed, "e0ffefdadb9ccf990504d568bdb4d862cbe17ccce6e22dfcab8b4804fd21421a");

164 
	`unhex
(
expect
, sizeof expect, "05da6aac7d980da038f65f392841476d37fe70fbd3e369d1f80196e66e54b8fadb1d60e1a0f3d4dc173769d75fc3410549d7a843270a54a068b4fe767d7d9a59604510a875ad1e9731c8afd0fd50b825e2c50d062576175106a9981be37e02ec7c5cd0a69aa0ca65bddaee1b0de532e10cfa1f5bf6a026e47379736a099d6750ab121dbe3622b841baf8bdcbe875c85ba4b586b8b5b57b0fecbec08c12ff2a9453c47c6e32a52103d972c62ab9affb8e728a31fcefbbccc556c0f0a35f4b10ace2d96b906e36cbb72233201e536d3e13b045187b417d2449cad1edd192e061f12d22147b0a176ea8d9c4c35404395b6502ef333a813b6586037479e0fa3c6a23");

166 
cf_hmac_drbg
 
ctx
;

167 
	`cf_hmac_drbg_init
(&
ctx
, &
cf_sha512
, 
entropy
, sizeof entropy, 
nonce
, sizeof nonce, 
NULL
, 0);

168 
	`cf_hmac_drbg_reseed
(&
ctx
, 
reseed
, sizeof reseed, 
NULL
, 0);

169 
	`cf_hmac_drbg_gen
(&
ctx
, 
got
, sizeof got);

170 
	`cf_hmac_drbg_gen
(&
ctx
, 
got
, sizeof got);

171 
	`TEST_CHECK
(
	`memcmp
(
got
, 
expect
, sizeof got) == 0);

172 
	}
}

174 static void 
	$test_hmacdrbg_sha512_vector_addnl
(void)

176 
uint8_t
 
entropy
[32], 
nonce
[16], 
reseed
[32], 
got
[256], 
expect
[256], 
addnl
[32];

179 
	`unhex
(
entropy
, sizeof entropy, "4686a959e17dfb96c294b09c0f7a60efb386416cfb4c8972bcc55e44a151607a");

180 
	`unhex
(
nonce
, sizeof nonce, "5226543b4c89321bbfb0f11f18ee3462");

181 
	`unhex
(
reseed
, sizeof reseed, "5ef50daaf29929047870235c17762f5df5d9ab1af656e0e215fcc6fd9fc0d85d");

182 
	`unhex
(
expect
, sizeof expect, "b60d8803531b2b8583d17bdf3ac7c01f3c65cf9b069862b2d39b9024b34c172b712db0704acb078a1ab1aec0390dbaee2dec9be7b234e63da481fd469a92c77bc7bb2cfca586855520e0f9e9d47dcb9bdf2a2fdfa9f2b4342ef0ea582616b55477717cfd516d46d6383257743656f7cf8b38402ba795a8c9d35a4aa88bec623313dad6ead689d152b54074f183b2fee556f554db343626cea853718f18d386bc8bebb0c07b3c5e96ceb391ffceece88864dbd3be83a613562c5c417a24807d5f9332974f045e79a9ade36994af6cf9bbeeb71d0025fcb4ad50f121cbc2df7cd12ff5a50cddfd9a4bbc6d942d743c8b8fbebe00eeccea3d14e07ff8454fa715da");

184 
cf_hmac_drbg
 
ctx
;

185 
	`cf_hmac_drbg_init
(&
ctx
, &
cf_sha512
, 
entropy
, sizeof entropy, 
nonce
, sizeof nonce, 
NULL
, 0);

186 
	`unhex
(
addnl
, sizeof addnl, "d2383c3e528492269e6c3b3aaa2b54fbf48731f5aa52150ce7fc644679a5e7c6");

187 
	`cf_hmac_drbg_reseed
(&
ctx
, 
reseed
, sizeof reseed, 
addnl
, sizeof addnl);

188 
	`unhex
(
addnl
, sizeof addnl, "c841e7a2d9d13bdb8644cd7f5d91d241a369e12dc6c9c2be50d1ed29484bff98");

189 
	`cf_hmac_drbg_gen_additional
(&
ctx
, 
addnl
, sizeof addnl, 
got
, sizeof got);

190 
	`unhex
(
addnl
, sizeof addnl, "9054cf9216af66a788d3bf6757b8987e42d4e49b325e728dc645d5e107048245");

191 
	`cf_hmac_drbg_gen_additional
(&
ctx
, 
addnl
, sizeof addnl, 
got
, sizeof got);

192 
	`TEST_CHECK
(
	`memcmp
(
got
, 
expect
, sizeof got) == 0);

193 
	}
}

195 
	gTEST_LIST
 = {

196 { "hashdrbg-sha256", 
test_hashdrbg_sha256_vector
 },

197 { "hashdrbg-sha256-addnl", 
test_hashdrbg_sha256_vector_addnl
 },

198 { "hmacdrbg-sha1", 
test_hmacdrbg_sha1_vector
 },

199 { "hmacdrbg-sha1-addnl", 
test_hmacdrbg_sha1_vector_addnl
 },

200 { "hmacdrbg-sha256", 
test_hmacdrbg_sha256_vector
 },

201 { "hmacdrbg-sha256-addnl", 
test_hmacdrbg_sha256_vector_addnl
 },

202 { "hmacdrbg-sha512", 
test_hmacdrbg_sha512_vector
 },

203 { "hmacdrbg-sha512-addnl", 
test_hmacdrbg_sha512_vector_addnl
 },

	@deps/picotls/deps/cifra/src/testmodes.c

15 #include 
	~"aes.h
"

16 #include 
	~"modes.h
"

17 #include 
	~"bitops.h
"

18 #include 
	~"gf128.h
"

20 #include 
	~"handy.h
"

21 #include 
	~"cutest.h
"

22 #include 
	~"testutil.h
"

25 #if 
defined
(
CORTEX_M0
) || defined(
CORTEX_M3
) || defined(
CORTEX_M4
)

26 #define 
	#MCU_TARGET
 1

	)

28 #define 
	#MCU_TARGET
 0

	)

31 static void 
	$test_cbc
(void)

33 
uint8_t
 
out
[16];

35 const void *
iv
 = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f";

36 const void *
key
 = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";

37 const void *
inp
 = "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96\xe9\x3d\x7e\x11\x73\x93\x17\x2a";

38 const void *
expect
 = "\x76\x49\xab\xac\x81\x19\xb2\x46\xce\xe9\x8e\x9b\x12\xe9\x19\x7d";

40 
cf_aes_context
 
aes
;

41 
	`cf_aes_init
(&
aes
, 
key
, 16);

43 
cf_cbc
 
cbc
;

44 
	`cf_cbc_init
(&
cbc
, &
cf_aes
, &
aes
, 
iv
);

45 
	`cf_cbc_encrypt
(&
cbc
, 
inp
, 
out
, 1);

46 
	`TEST_CHECK
(
	`memcmp
(
out
, 
expect
, 16) == 0);

48 
uint8_t
 
decrypt
[16];

49 
	`cf_cbc_init
(&
cbc
, &
cf_aes
, &
aes
, 
iv
);

50 
	`cf_cbc_decrypt
(&
cbc
, 
out
, 
decrypt
, 1);

51 
	`TEST_CHECK
(
	`memcmp
(
decrypt
, 
inp
, 16) == 0);

52 
	}
}

54 static void 
	$cbcmac_vector
(const void *
tag_expect
, 
size_t
 
ntag
,

55 const void *
key
, 
size_t
 
nkey
,

56 const void *
msg
, 
size_t
 
nmsg
)

58 
uint8_t
 
tag
[16];

60 
cf_aes_context
 
aes
;

61 
	`cf_aes_init
(&
aes
, 
key
, 
nkey
);

63 
cf_cbcmac_stream
 
cm
;

64 
	`cf_cbcmac_stream_init
(&
cm
, &
cf_aes
, &
aes
);

65 
	`cf_cbcmac_stream_update
(&
cm
, 
msg
, 
nmsg
);

66 
	`cf_cbcmac_stream_pad_final
(&
cm
, 
tag
);

68 
	`TEST_CHECK
(sizeof 
tag
 == 
ntag
);

69 
	`TEST_CHECK
(
	`memcmp
(
tag
, 
tag_expect
, sizeof tag) == 0);

70 
	}
}

72 static void 
	$test_cbcmac
(void)

74 
	`cbcmac_vector
("\xf0\xf1\x89\x75\xa0\x85\x9d\x13\xa4\x9d\x3d\xbf\xc6\xcd\x65\xd9", 16, "\x04\xf7\xf7\x78\x62\x1d\x1e\x2c\x86\x47\x82\x2a\x50\xd9\x8a\x83", 16, "\x83\x1b\xe7\x4b\x9b\xe6\x85\xc8\x38\xe2\x2a\x25\xa3\x11\xcb\x14\x79\x62\x35\xf5\x28\x98\xd0", 23);

75 
	`cbcmac_vector
("\x0d\x6a\x13\x8f\x75\xb7\x56\x94\xd5\x15\xc5\x55\x5e\xee\xdd\x92", 16, "\xff\x84\x5a\xfc\x51\xf2\x06\x35\xa4\x8f\x6c\xec\x9f\x78\x1f\x2e", 16, "\xc5\x85\x3e\x6b\x3f\x7e\xf5\x10\x93\x6e\x30\xd5\x54\x13\x5f\x0d\x55\x43\x92\x8c\x53\xfc\x2f\x81\xa3", 25);

76 
	`cbcmac_vector
("\x96\x81\x3d\xb1\x7e\xac\x06\xb9\x79\x42\xa7\x3a\x7c\x5a\x0a\xad", 16, "\x10\x77\x16\x47\x23\x2e\xda\x40\x23\xd7\xc5\xc9\xbb\x51\x2e\x93", 16, "\x06\x53\x5f\x70\xd9\x6c\x80\x50\x85\x6b\x02\x4f\x67\xae\x87\xde\xc8\xd2\x9d\xab\xb7\x1f\x55\x93\x51\x00\x0a\x3c\x8f\xfc\x63\x60", 32);

77 
	`cbcmac_vector
("\x20\xdd\xa5\xb1\xc1\x14\x00\x90\x97\x41\xef\x3b\xc6\xac\xe8\xec", 16, "\x5b\x39\xdb\x4b\xa4\x53\x1f\x97\xf9\xca\x4b\xdd\xed\x9b\x28\x53", 16, "\x49\x91\xb3\x35\x40\xda\x4d\x8a\xdf\xe9\x37\x4b\xb4\xe1\xc5", 15);

78 
	`cbcmac_vector
("\xc0\x2f\x8f\x0a\xba\x13\x4b\x6b\x16\x69\xfb\x58\x2f\xc1\xc8\x76", 16, "\xd0\x22\xc7\xe7\x85\xd2\xfc\xa4\xd6\x7f\xaa\x18\xb1\xa9\xfd\x9d\x7a\x47\x37\x09\x33\x43\x06\x32", 24, "\x2b\xa2\x8e\xa5\x62\xdd\x9c\x5e\x80\xcc\xaf\x80\x16\x77", 14);

79 
	`cbcmac_vector
("\x05\x79\x4b\x5f\xc8\xf2\xee\x87\x74\xcd\x88\x9f\x7c\x29\xeb\xa0", 16, "\xe4\x51\xdb\x26\x8e\x2a\x26\xd1\xbf\x78\x3e\xab\x5d\xc6\xf9\x3f\xb2\xc5\xe2\x5c\xe8\x61\x28\x3c", 24, "\xea\x14\xfa\xaa\x95\x48\x12\xcb", 8);

80 
	`cbcmac_vector
("\x6a\x14\x4b\xaa\x39\xf6\x19\x71\x62\x65\xd3\x4e\x53\xb4\xc6\x7c", 16, "\xff\x46\x38\x0f\x62\xa9\x37\x7f\xb2\x41\x88\x44\x39\x2a\x97\xf5\xb9\x9a\xc0\x37\xf9\xc6\x75\x3f", 24, "\x64\x04\x53\x4c\xa8\x0a\x60\xf6\x5e\x22\xb6\xc4\xd7\xf3\xa9\x33\xf9\x3e", 18);

81 
	`cbcmac_vector
("\xf7\x1d\x16\x5c\xba\xac\x0f\xf0\x1a\x12\x75\xf8\x5b\x6a\x8e\x15", 16, "\x67\xce\x47\x6c\x11\x0e\xa1\xbc\xf0\x81\x30\x2b\x5f\xe2\x3b\xbc\x34\xc5\x4d\x46\x01\xed\x49\x04", 24, "\x94\xb1\x25\x63\x49\x49\x46\x7e\x7a\xa0\x0e\xa1\x10\x25\x21\x9a\xc9\x1f\x0d\xed\xa1\x10\x30\x7e\x08\x84\xee\x09\xe8\x31\x53\x81", 32);

82 
	`cbcmac_vector
("\x22\xfb\x7e\x4c\x77\x12\x7c\xed\x2c\xaa\xf9\x8d\x9f\x35\x15\x60", 16, "\x1c\x50\xc0\x79\x7c\xd6\x7f\x89\x26\xd1\xc9\xb9\x85\xf9\xee\xaf\x18\x3f\x07\x0b\x3a\xd2\x5f\x7e\xfa\x08\x95\xfe\x98\xe3\x43\x91", 32, "\x7d\x1e\x7e\x19\x9a\xd4\xf4\x3f\xcf\xff\x55\xf7\xc9\x81\xe6\x13\xc0\x22\xab\x7f\x83\x92\x21\x72\x65\x79\x78\xcd\xf0\x8b\x36", 31);

83 
	`cbcmac_vector
("\x40\xc1\xef\xf3\xf4\x71\x54\x58\x77\x3c\xd3\x07\x96\xdf\xfd\x54", 16, "\x3c\x1e\xae\xa7\x4a\xf6\xee\x43\x9b\xd7\xa3\x76\x38\xd6\x08\x21\x60\xe6\x1b\x23\x2b\xf8\xa4\x5d\x05\xd5\xf4\x89\x04\x3e\x2d\x19", 32, "\xd2\xa3\x38\x1a\x82\xd6\xb6\xc2\x52\x93\x43\x1d\xdc\x1d\x73\xb5\x14\x82\x40\xfe\x00\xc3\x24\x52\x8d\x69\xc6\x11\x4e\x4c\xa9\x40\xcd\xfb\x29\x17", 36);

84 
	`cbcmac_vector
("\x69\x7c\x65\x95\xa2\x1f\xa2\xfa\x3a\xd3\x60\x68\x7a\xed\x68\x37", 16, "\xc2\xda\x01\xb4\x12\xa5\xcd\x1c\x75\xb5\x08\x5f\xd2\xee\x79\xc3\x47\xd9\xf9\x12\x86\x3d\x81\xd0\x42\x89\x75\x96\x58\x70\x47\x05", 32, "\x65\x22\x9b\x77\x15\xe5\x02\x54\x04\x90\xfb\xe2\xbf\x5a\x8e\xb0\xbf\x64\xff\x7f\xb7\xab\x7f\x18\x69\x7b", 26);

85 
	`cbcmac_vector
("\xf5\x2d\x65\x16\x84\x43\x0d\xe8\x1f\x29\x51\x06\xec\xf0\xa5\xd2", 16, "\x76\xff\xb3\x38\x5b\xca\x7c\x93\xc0\x12\xd7\xbc\xb3\xa3\xd0\xf2\x87\xa7\x0a\x91\x36\x76\xa7\x8d\x28\x47\x05\x8e\x75\xae\x5e\x3c", 32, "\x12\x90\x91\x65\x32\x37\xd0\x35\xf6\x40\x42\xa7\x4f\x61\xa9\x9c\x8f\xd6\x84\x9a\x86\x0e\x57\xe7\xe4", 25);

86 
	}
}

88 static void 
	$test_ctr
(void)

90 
uint8_t
 
out
[16];

92 const void *
nonce
 = "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff";

93 const void *
key
 = "\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c";

94 const void *
inp
 = "\x6b\xc1\xbe\xe2\x2e\x40\x9f\x96\xe9\x3d\x7e\x11\x73\x93\x17\x2a";

95 const void *
expect
 = "\x87\x4d\x61\x91\xb6\x20\xe3\x26\x1b\xef\x68\x64\x99\x0d\xb6\xce";

97 
cf_aes_context
 
aes
;

98 
	`cf_aes_init
(&
aes
, 
key
, 16);

100 
cf_ctr
 
ctr
;

101 
	`cf_ctr_init
(&
ctr
, &
cf_aes
, &
aes
, 
nonce
);

102 
	`cf_ctr_cipher
(&
ctr
, 
inp
, 
out
, 16);

103 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 16) == 0);

105 
	`cf_ctr_init
(&
ctr
, &
cf_aes
, &
aes
, 
nonce
);

106 
	`cf_ctr_cipher
(&
ctr
, 
inp
, 
out
, 1);

107 
	`cf_ctr_cipher
(&
ctr
, 
inp
, 
out
, 16);

108 
	`cf_ctr_cipher
(&
ctr
, 
inp
, 
out
, 16);

110 
	`cf_ctr_init
(&
ctr
, &
cf_aes
, &
aes
, 
nonce
);

111 
	`cf_ctr_cipher
(&
ctr
, 
inp
, 
out
, 1);

112 
	`cf_ctr_cipher
(&
ctr
, ((
uint8_t
 *)
inp
) + 1, 
out
 + 1, 15);

113 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 16) == 0);

115 
uint8_t
 
decrypt
[16];

116 
	`cf_ctr_init
(&
ctr
, &
cf_aes
, &
aes
, 
nonce
);

117 
	`cf_ctr_cipher
(&
ctr
, 
out
, 
decrypt
, 16);

118 
	`TEST_CHECK
(
	`memcmp
(
decrypt
, 
inp
, 16) == 0);

121 
uint8_t
 
test_nonce
[16], 
test_inp
[16];

122 
	`memset
(
test_nonce
, 0xff, 16);

123 
	`memset
(
test_inp
, 0x00, 16);

124 
	`cf_ctr_init
(&
ctr
, &
cf_aes
, &
aes
, 
test_nonce
);

127 for (int 
i
 = 0; i < 1024; i++)

129 
	`cf_ctr_cipher
(&
ctr
, 
test_inp
, 
out
, 
i
 % 16);

136 
	`memset
(
test_nonce
, 0, sizeof test_nonce);

137 
test_nonce
[15] = 0xdf;

138 
test_nonce
[14] = 0x01;

140 
	`TEST_CHECK
(
	`memcmp
(
test_nonce
, 
ctr
.
nonce
, 16) == 0);

141 
	}
}

143 static void 
	$check_eax
(const void *
key
, 
size_t
 
nkey
,

144 const void *
msg
, 
size_t
 
nmsg
,

145 const void *
nonce
, 
size_t
 
nnonce
,

146 const void *
header
, 
size_t
 
nheader
,

147 const void *
expect_cipher
,

148 const void *
expect_tag
, 
size_t
 
ntag
)

150 
uint8_t
 
cipher
[32];

151 
uint8_t
 
tag
[16];

153 
	`assert
(
nmsg
 <= sizeof 
cipher
);

154 
	`assert
(
ntag
 <= ntag);

156 
cf_aes_context
 
aes
;

157 
	`cf_aes_init
(&
aes
, 
key
, 
nkey
);

159 
	`cf_eax_encrypt
(&
cf_aes
, &
aes
,

160 
msg
, 
nmsg
,

161 
header
, 
nheader
,

162 
nonce
, 
nnonce
,

163 
cipher
,

164 
tag
, 
ntag
);

166 
	`TEST_CHECK
(
	`memcmp
(
expect_cipher
, 
cipher
, 
nmsg
) == 0);

167 
	`TEST_CHECK
(
	`memcmp
(
expect_tag
, 
tag
, 
ntag
) == 0);

169 int 
rc
;

170 
uint8_t
 
tmp
[sizeof 
cipher
];

171 
rc
 = 
	`cf_eax_decrypt
(&
cf_aes
, &
aes
,

172 
cipher
, 
nmsg
,

173 
header
, 
nheader
,

174 
nonce
, 
nnonce
,

175 
tag
, 
ntag
,

176 
tmp
);

177 
	`TEST_CHECK
(
rc
 == 0);

178 
	`TEST_CHECK
(
	`memcmp
(
tmp
, 
msg
, 
nmsg
) == 0);

180 
tag
[0] ^= 0xff;

181 
rc
 = 
	`cf_eax_decrypt
(&
cf_aes
, &
aes
,

182 
cipher
, 
nmsg
,

183 
header
, 
nheader
,

184 
nonce
, 
nnonce
,

185 
tag
, 
ntag
,

186 
tmp
);

187 
	`TEST_CHECK
(
rc
 == 1);

188 
	}
}

190 static void 
	$test_eax
(void)

193 
	`check_eax
("\x23\x39\x52\xDE\xE4\xD5\xED\x5F\x9B\x9C\x6D\x6F\xF8\x0F\xF4\x78", 16,

200 
	`check_eax
("\x91\x94\x5D\x3F\x4D\xCB\xEE\x0B\xF4\x5E\xF5\x22\x55\xF0\x95\xA4", 16,

207 
	`check_eax
("\x01\xF7\x4A\xD6\x40\x77\xF2\xE7\x04\xC0\xF6\x0A\xDA\x3D\xD5\x23", 16,

214 
	`check_eax
("\xD0\x7C\xF6\xCB\xB7\xF3\x13\xBD\xDE\x66\xB7\x27\xAF\xD3\xC5\xE8", 16,

221 
	`check_eax
("\x35\xB6\xD0\x58\x00\x05\xBB\xC1\x2B\x05\x87\x12\x45\x57\xD2\xC2", 16,

228 
	`check_eax
("\xBD\x8E\x6E\x11\x47\x5E\x60\xB2\x68\x78\x4C\x38\xC6\x2F\xEB\x22", 16,

235 
	`check_eax
("\x7C\x77\xD6\xE8\x13\xBE\xD5\xAC\x98\xBA\xA4\x17\x47\x7A\x2E\x7D", 16,

242 
	`check_eax
("\x5F\xFF\x20\xCA\xFA\xB1\x19\xCA\x2F\xC7\x35\x49\xE2\x0F\x5B\x0D", 16,

249 
	`check_eax
("\xA4\xA4\x78\x2B\xCF\xFD\x3E\xC5\xE7\xEF\x6D\x8C\x34\xA5\x61\x23", 16,

256 
	`check_eax
("\x83\x95\xFC\xF1\xE9\x5B\xEB\xD6\x97\xBD\x01\x0B\xC7\x66\xAA\xC3", 16,

264 
	`check_eax
("\x58\x94\x17\xB0\x32\x4B\x1B\x71\xD7\xA6\x75\x18\x52\x86\x7A\xE8", 16,

271 
	}
}

273 static void 
	$check_cmac
(const void *
key
, 
size_t
 
nkey
,

274 const void *
msg
, 
size_t
 
nmsg
,

275 const void *
wanttag
, 
size_t
 
ntag
)

277 
uint8_t
 
gottag
[16];

279 
	`TEST_CHECK
(
cf_aes
.
blocksz
 == 
ntag
);

281 
cf_aes_context
 
aes
;

282 
	`cf_aes_init
(&
aes
, 
key
, 
nkey
);

284 
cf_cmac
 
cmac
;

285 
	`cf_cmac_init
(&
cmac
, &
cf_aes
, &
aes
);

286 
	`cf_cmac_sign
(&
cmac
, 
msg
, 
nmsg
, 
gottag
);

288 
	`TEST_CHECK
(
	`memcmp
(
gottag
, 
wanttag
, 
cf_aes
.
blocksz
) == 0);

289 
	}
}

291 static void 
	$test_cmac
(void)

294 
	`check_cmac
("\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c", 16,

297 
	`check_cmac
("\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c", 16,

300 
	`check_cmac
("\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c", 16,

303 
	`check_cmac
("\x2b\x7e\x15\x16\x28\xae\xd2\xa6\xab\xf7\x15\x88\x09\xcf\x4f\x3c", 16,

307 
	`check_cmac
("\x8e\x73\xb0\xf7\xda\x0e\x64\x52\xc8\x10\xf3\x2b\x80\x90\x79\xe5\x62\xf8\xea\xd2\x52\x2c\x6b\x7b", 24,

310 
	`check_cmac
("\x8e\x73\xb0\xf7\xda\x0e\x64\x52\xc8\x10\xf3\x2b\x80\x90\x79\xe5\x62\xf8\xea\xd2\x52\x2c\x6b\x7b", 24,

313 
	`check_cmac
("\x8e\x73\xb0\xf7\xda\x0e\x64\x52\xc8\x10\xf3\x2b\x80\x90\x79\xe5\x62\xf8\xea\xd2\x52\x2c\x6b\x7b", 24,

316 
	`check_cmac
("\x8e\x73\xb0\xf7\xda\x0e\x64\x52\xc8\x10\xf3\x2b\x80\x90\x79\xe5\x62\xf8\xea\xd2\x52\x2c\x6b\x7b", 24,

320 
	`check_cmac
("\x60\x3d\xeb\x10\x15\xca\x71\xbe\x2b\x73\xae\xf0\x85\x7d\x77\x81\x1f\x35\x2c\x07\x3b\x61\x08\xd7\x2d\x98\x10\xa3\x09\x14\xdf\xf4", 32,

323 
	`check_cmac
("\x60\x3d\xeb\x10\x15\xca\x71\xbe\x2b\x73\xae\xf0\x85\x7d\x77\x81\x1f\x35\x2c\x07\x3b\x61\x08\xd7\x2d\x98\x10\xa3\x09\x14\xdf\xf4", 32,

326 
	`check_cmac
("\x60\x3d\xeb\x10\x15\xca\x71\xbe\x2b\x73\xae\xf0\x85\x7d\x77\x81\x1f\x35\x2c\x07\x3b\x61\x08\xd7\x2d\x98\x10\xa3\x09\x14\xdf\xf4", 32,

329 
	`check_cmac
("\x60\x3d\xeb\x10\x15\xca\x71\xbe\x2b\x73\xae\xf0\x85\x7d\x77\x81\x1f\x35\x2c\x07\x3b\x61\x08\xd7\x2d\x98\x10\xa3\x09\x14\xdf\xf4", 32,

332 
	}
}

334 static void 
	$test_gf128_mul
(void)

336 
uint8_t
 
bout
[16];

338 const void *
bx
 = "\x03\x88\xda\xce\x60\xb6\xa3\x92\xf3\x28\xc2\xb9\x71\xb2\xfe\x78";

339 const void *
by
 = "\x66\xe9\x4b\xd4\xef\x8a\x2c\x3b\x88\x4c\xfa\x59\xca\x34\x2b\x2e";

340 const void *
bexpect
 = "\x5e\x2e\xc7\x46\x91\x70\x62\x88\x2c\x85\xb0\x68\x53\x53\xde\xb7";

342 
cf_gf128
 
x
, 
y
, 
out
;

343 
	`cf_gf128_frombytes_be
(
bx
, 
x
);

344 
	`cf_gf128_frombytes_be
(
by
, 
y
);

345 
	`cf_gf128_mul
(
x
, 
y
, 
out
);

346 
	`cf_gf128_tobytes_be
(
out
, 
bout
);

347 
	`TEST_CHECK
(
	`memcmp
(
bexpect
, 
bout
, 16) == 0);

348 
	}
}

350 static void 
	$check_gcm
(const void *
key
, 
size_t
 
nkey
,

351 const void *
plain
, 
size_t
 
nplain
,

352 const void *
aad
, 
size_t
 
naad
,

353 const void *
iv
, 
size_t
 
niv
,

354 const void *
cipher_expect
, 
size_t
 
ncipher
,

355 const void *
tag_expect
, 
size_t
 
ntag
)

357 
uint8_t
 
plain_decrypt
[64],

358 
cipher
[64],

359 
tag
[16];

361 
	`assert
(
ncipher
 == 
nplain
);

363 
cf_aes_context
 
ctx
;

364 
	`cf_aes_init
(&
ctx
, 
key
, 
nkey
);

366 
	`cf_gcm_encrypt
(&
cf_aes
, &
ctx
,

367 
plain
, 
nplain
,

368 
aad
, 
naad
,

369 
iv
, 
niv
,

370 
cipher
,

371 
tag
, 
ntag
);

373 
	`TEST_CHECK
(
	`memcmp
(
tag
, 
tag_expect
, 
ntag
) == 0);

374 
	`TEST_CHECK
(
	`memcmp
(
cipher
, 
cipher_expect
, 
ncipher
) == 0);

376 int 
err
 = 
	`cf_gcm_decrypt
(&
cf_aes
, &
ctx
,

377 
cipher
, 
ncipher
,

378 
aad
, 
naad
,

379 
iv
, 
niv
,

380 
tag
, 
ntag
,

381 
plain_decrypt
);

382 
	`TEST_CHECK
(
err
 == 0);

383 
	`TEST_CHECK
(
	`memcmp
(
plain_decrypt
, 
plain
, 
ncipher
) == 0);

385 
tag
[0] ^= 0xff;

386 
err
 = 
	`cf_gcm_decrypt
(&
cf_aes
, &
ctx
,

387 
cipher
, 
ncipher
,

388 
aad
, 
naad
,

389 
iv
, 
niv
,

390 
tag
, 
ntag
,

391 
plain_decrypt
);

392 
	`TEST_CHECK
(
err
 == 1);

393 
	}
}

395 static void 
	$test_gcm
(void)

397 
	`check_gcm
("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16,

403 
	`check_gcm
("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 16,

409 
	`check_gcm
("\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08", 16,

421 
	`check_gcm
("\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08", 16,

434 
	`check_gcm
("\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08", 16,

447 
	`check_gcm
("\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08", 16,

464 
	`check_gcm
("\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08", 16,

480 
	`check_gcm
("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 24,

486 
	`check_gcm
("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 24,

492 
	`check_gcm
("\xfe\xff\xe9\x92\x86\x65\x73\x1c\x6d\x6a\x8f\x94\x67\x30\x83\x08"

505 
	}
}

507 static void 
	$check_ccm
(const void *
key
, 
size_t
 
nkey
,

508 const void *
header
, 
size_t
 
nheader
,

509 const void *
plain
, 
size_t
 
nplain
,

510 const void *
nonce
, 
size_t
 
nnonce
,

511 const void *
expect_cipher
, 
size_t
 
ncipher
,

512 const void *
expect_tag
, 
size_t
 
ntag
)

514 
uint8_t
 
cipher
[32], 
tag
[16], 
decrypted
[32];

516 
	`assert
(
ncipher
 == 
nplain
);

518 
cf_aes_context
 
ctx
;

519 
	`cf_aes_init
(&
ctx
, 
key
, 
nkey
);

521 
	`cf_ccm_encrypt
(&
cf_aes
, &
ctx
,

522 
plain
, 
nplain
, 15 - 
nnonce
,

523 
header
, 
nheader
,

524 
nonce
, 
nnonce
,

525 
cipher
,

526 
tag
, 
ntag
);

528 
	`TEST_CHECK
(
	`memcmp
(
tag
, 
expect_tag
, 
ntag
) == 0);

529 
	`TEST_CHECK
(
	`memcmp
(
cipher
, 
expect_cipher
, 
ncipher
) == 0);

531 int 
err
;

532 
err
 = 
	`cf_ccm_decrypt
(&
cf_aes
, &
ctx
,

533 
expect_cipher
, 
ncipher
, 15 - 
nnonce
,

534 
header
, 
nheader
,

535 
nonce
, 
nnonce
,

536 
tag
, 
ntag
,

537 
decrypted
);

538 
	`TEST_CHECK
(
err
 == 0);

539 
	`TEST_CHECK
(
	`memcmp
(
decrypted
, 
plain
, 
nplain
) == 0);

541 
tag
[0] ^= 0xff;

543 
err
 = 
	`cf_ccm_decrypt
(&
cf_aes
, &
ctx
,

544 
expect_cipher
, 
ncipher
, 15 - 
nnonce
,

545 
header
, 
nheader
,

546 
nonce
, 
nnonce
,

547 
tag
, 
ntag
,

548 
decrypted
);

549 
	`TEST_CHECK
(
err
 == 1);

550 
	}
}

552 #if !
MCU_TARGET


553 static void 
	$fill
(
uint8_t
 *
buf
, 
size_t
 
len
, uint8_t 
b
)

555 for (
size_t
 
i
 = 0; i < 
len
; i++)

556 
buf
[
i
] = 
b
++;

557 
	}
}

559 static void 
	$test_ccm_long
(void)

562 
uint8_t
 
header
[0x10000];

563 
uint8_t
 
key
[16];

564 
uint8_t
 
tag
[14];

565 
uint8_t
 
nonce
[13];

566 
uint8_t
 
plain
[32], 
cipher
[32];

568 
	`fill
(
header
, sizeof header, 0x00);

569 
	`fill
(
key
, sizeof key, 0x40);

570 
	`fill
(
nonce
, sizeof nonce, 0x10);

571 
	`fill
(
plain
, sizeof plain, 0x20);

573 const void *
expect_tag
 = "\xb4\xac\x6b\xec\x93\xe8\x59\x8e\x7f\x0d\xad\xbc\xea\x5b";

574 const void *
expect_cipher
 = "\x69\x91\x5d\xad\x1e\x84\xc6\x37\x6a\x68\xc2\x96\x7e\x4d\xab\x61\x5a\xe0\xfd\x1f\xae\xc4\x4c\xc4\x84\x82\x85\x29\x46\x3c\xcf\x72";

576 
cf_aes_context
 
ctx
;

577 
	`cf_aes_init
(&
ctx
, 
key
, sizeof key);

579 
	`cf_ccm_encrypt
(&
cf_aes
, &
ctx
,

580 
plain
, sizeof plain, 15 - sizeof 
nonce
,

581 
header
, sizeof header,

582 
nonce
, sizeof nonce,

583 
cipher
,

584 
tag
, sizeof tag);

586 
	`TEST_CHECK
(
	`memcmp
(
expect_tag
, 
tag
, sizeof tag) == 0);

587 
	`TEST_CHECK
(
	`memcmp
(
expect_cipher
, 
cipher
, sizeof cipher) == 0);

588 
	}
}

591 static void 
	$test_ccm
(void)

593 
	`check_ccm
("\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf", 16,

600 
	`check_ccm
("\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f", 16,

607 
	`check_ccm
("\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f", 16,

613 
	}
}

615 static void 
	$check_ocb
(const void *
key
, 
size_t
 
nkey
,

616 const void *
header
, 
size_t
 
nheader
,

617 const void *
plain
, 
size_t
 
nplain
,

618 const void *
nonce
, 
size_t
 
nnonce
,

619 const void *
expect_cipher
, 
size_t
 
ncipher
,

620 const void *
expect_tag
, 
size_t
 
ntag
)

622 
uint8_t
 
cipher
[40], 
tag
[16];

624 
	`assert
(
ncipher
 == 
nplain
);

625 
	`assert
(
ncipher
 <= sizeof 
cipher
);

626 
	`assert
(
ntag
 <= sizeof 
tag
);

628 
cf_aes_context
 
ctx
;

629 
	`cf_aes_init
(&
ctx
, 
key
, 
nkey
);

631 
	`cf_ocb_encrypt
(&
cf_aes
, &
ctx
,

632 
plain
, 
nplain
,

633 
header
, 
nheader
,

634 
nonce
, 
nnonce
,

635 
cipher
,

636 
tag
, 
ntag
);

638 
	`TEST_CHECK
(
	`memcmp
(
tag
, 
expect_tag
, 
ntag
) == 0);

639 
	`TEST_CHECK
(
	`memcmp
(
cipher
, 
expect_cipher
, 
ncipher
) == 0);

641 
uint8_t
 
decrypted
[40];

642 int 
err
;

643 
err
 = 
	`cf_ocb_decrypt
(&
cf_aes
, &
ctx
,

644 
expect_cipher
, 
ncipher
,

645 
header
, 
nheader
,

646 
nonce
, 
nnonce
,

647 
tag
, 
ntag
,

648 
decrypted
);

649 
	`TEST_CHECK
(
err
 == 0);

650 
	`TEST_CHECK
(
	`memcmp
(
decrypted
, 
plain
, 
nplain
) == 0);

652 
tag
[0] ^= 0xff;

654 
err
 = 
	`cf_ocb_decrypt
(&
cf_aes
, &
ctx
,

655 
expect_cipher
, 
ncipher
,

656 
header
, 
nheader
,

657 
nonce
, 
nnonce
,

658 
tag
, 
ntag
,

659 
decrypted
);

660 
	`TEST_CHECK
(
err
 == 1);

661 
	}
}

663 static void 
	$test_ocb
(void)

665 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

672 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

679 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

686 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

693 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

700 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

707 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

714 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

721 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

728 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

735 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

742 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

749 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

756 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

763 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

770 
	`check_ocb
("\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F", 16,

777 
	`check_ocb
("\x0F\x0E\x0D\x0C\x0B\x0A\x09\x08\x07\x06\x05\x04\x03\x02\x01\x00", 16,

783 
	}
}

785 #if !
MCU_TARGET


786 static void 
	$check_ocb_long
(
size_t
 
nkey
, const void *
expect_tag
, size_t 
ntag
)

788 
uint8_t
 
C
[22400];

789 
uint8_t
 
K
[32];

790 
uint8_t
 
S
[128] = { 0 };

791 
uint8_t
 
N
[12] = { 0 };

792 
size_t
 
nC
 = 0;

794 
	`memset
(
K
, 0, sizeof K);

795 
K
[
nkey
 - 1] = 
ntag
 * 8;

797 
cf_aes_context
 
aes
;

798 
	`cf_aes_init
(&
aes
, 
K
, 
nkey
);

800 for (
size_t
 
i
 = 0; i < 128; i++)

803 
	`memset
(
N
, 0, sizeof N);

804 
	`write32_be
(3 * 
i
 + 1, 
N
 + 8);

808 
	`cf_ocb_encrypt
(&
cf_aes
, &
aes
,

809 
S
, 
i
,

810 
S
, 
i
,

811 
N
, sizeof N,

812 
C
 + 
nC
,

813 
C
 + 
nC
 + 
i
,

814 
ntag
);

815 
nC
 += 
i
 + 
ntag
;

818 
	`write32_be
(3 * 
i
 + 2, 
N
 + 8);

821 
	`cf_ocb_encrypt
(&
cf_aes
, &
aes
,

822 
S
, 
i
,

823 
NULL
, 0,

824 
N
, sizeof N,

825 
C
 + 
nC
,

826 
C
 + 
nC
 + 
i
,

827 
ntag
);

828 
nC
 += 
i
 + 
ntag
;

831 
	`write32_be
(3 * 
i
 + 3, 
N
 + 8);

834 
	`cf_ocb_encrypt
(&
cf_aes
, &
aes
,

835 
NULL
, 0,

836 
S
, 
i
,

837 
N
, sizeof N,

838 
NULL
,

839 
C
 + 
nC
,

840 
ntag
);

841 
nC
 += 
ntag
;

845 
	`write32_be
(385, 
N
 + 8);

848 
uint8_t
 
result
[16];

849 
	`cf_ocb_encrypt
(&
cf_aes
, &
aes
,

850 
NULL
, 0,

851 
C
, 
nC
,

852 
N
, sizeof N,

853 
NULL
,

854 
result
, 
ntag
);

856 
	`TEST_CHECK
(
	`memcmp
(
result
, 
expect_tag
, 
ntag
) == 0);

857 
	}
}

859 static void 
	$test_ocb_long
(void)

861 
	`check_ocb_long
(16, "\x67\xE9\x44\xD2\x32\x56\xC5\xE0\xB6\xC6\x1F\xA2\x2F\xDF\x1E\xA2", 16);

862 
	`check_ocb_long
(24, "\xF6\x73\xF2\xC3\xE7\x17\x4A\xAE\x7B\xAE\x98\x6C\xA9\xF2\x9E\x17", 16);

863 
	`check_ocb_long
(32, "\xD9\x0E\xB8\xE9\xC9\x77\xC8\x8B\x79\xDD\x79\x3D\x7F\xFA\x16\x1C", 16);

864 
	`check_ocb_long
(16, "\x77\xA3\xD8\xE7\x35\x89\x15\x8D\x25\xD0\x12\x09", 12);

865 
	`check_ocb_long
(24, "\x05\xD5\x6E\xAD\x27\x52\xC8\x6B\xE6\x93\x2C\x5E", 12);

866 
	`check_ocb_long
(32, "\x54\x58\x35\x9A\xC2\x3B\x0C\xBA\x9E\x63\x30\xDD", 12);

867 
	`check_ocb_long
(16, "\x19\x2C\x9B\x7B\xD9\x0B\xA0\x6A", 8);

868 
	`check_ocb_long
(24, "\x00\x66\xBC\x6E\x0E\xF3\x4E\x24", 8);

869 
	`check_ocb_long
(32, "\x7D\x4E\xA5\xD4\x45\x50\x1C\xBE", 8);

870 
	}
}

873 
	gTEST_LIST
 = {

874 { "cbc", 
test_cbc
 },

875 { "cbcmac", 
test_cbcmac
 },

876 { "ctr", 
test_ctr
 },

877 { "eax", 
test_eax
 },

878 { "cmac", 
test_cmac
 },

879 { "gf128-mul", 
test_gf128_mul
 },

880 { "gcm", 
test_gcm
 },

881 { "ccm", 
test_ccm
 },

882 { "ocb", 
test_ocb
 },

884 #if !
MCU_TARGET


885 { "ccm-long", 
test_ccm_long
 },

886 { "ocb-long", 
test_ocb_long
 },

	@deps/picotls/deps/cifra/src/testnorx.c

15 #include 
	~"norx.h
"

16 #include 
	~"handy.h
"

17 #include 
	~"cutest.h
"

18 #include 
	~"testutil.h
"

20 static void 
	$test_vector
(void)

22 
uint8_t
 
K
[16], 
N
[8], 
A
[128], 
M
[128], 
Z
[128], 
C
[128], 
T
[16];

26 
	`unhex
(
K
, sizeof K, "000102030405060708090a0b0c0d0e0f");

27 
	`unhex
(
N
, sizeof N, "f0e0d0c0b0a09080");

29 for (unsigned 
i
 = 0; i < 128; i++)

31 
A
[
i
] = 
M
[i] = 
Z
[i] = i;

34 
	`cf_norx32_encrypt
(
K
, 
N
,

35 
A
, sizeof A,

36 
M
, sizeof M,

37 
Z
, sizeof Z,

38 
C
, 
T
);

40 
uint8_t
 
expect_C
[128], 
expect_T
[16];

42 
	`unhex
(
expect_C
, sizeof expect_C, "f4afc8e66d2d80de0a7f719c899624c9ad896ec7c61739d5376d0648c7bcb204e57db05c6f83b3ff4315e8a4ef2f2c855f21ea4c51ac6de575773ba548f36e636a13b979d953bb91298ea4a6e2aa27402991e0da541997825407b2f12441de3ae6c5dbfe41b12f1480d234832765111e4c09deef9fe3971618d2217c4b77921e");

43 
	`unhex
(
expect_T
, sizeof expect_T, "7810131eea2eab1e5da05d23d4e3cb99");

45 
	`TEST_CHECK
(
	`memcmp
(
C
, 
expect_C
, sizeof C) == 0);

46 
	`TEST_CHECK
(
	`memcmp
(
T
, 
expect_T
, sizeof T) == 0);

48 
uint8_t
 
M2
[128];

49 
	`TEST_CHECK
(0 ==

50 
	`cf_norx32_decrypt
(
K
, 
N
,

51 
A
, sizeof A,

52 
C
, sizeof C,

53 
Z
, sizeof Z,

54 
T
,

55 
M2
));

57 
	`TEST_CHECK
(
	`memcmp
(
M
, 
M2
, sizeof M) == 0);

58 
T
[0] ^= 0xff;

60 
	`TEST_CHECK
(
	`cf_norx32_decrypt
(
K
, 
N
,

61 
A
, sizeof A,

62 
C
, sizeof C,

63 
Z
, sizeof Z,

64 
T
,

65 
M2
));

66 
	}
}

68 #include 
	~"testnorx.katdata.inc
"

70 static void 
	$test_kat
(void)

72 
uint8_t
 
K
[16], 
N
[16], 
H
[256], 
W
[256];

73 const 
uint8_t
 *
kats
 = 
kat_data
;

75 #define 
	#FILL
(
arr
, 
c
) \

77 for (
size_t
 
i
 = 0; i < sizeof 
arr
; i++) \

78 
arr
[
i
] = (i * 
c
 + 123) & 0xff; \

79 } while (0)

	)

80 
	`FILL
(
N
, 181);

81 
	`FILL
(
K
, 191);

82 
	`FILL
(
H
, 193);

83 
	`FILL
(
W
, 197);

84 #undef 
FILL


86 for (
size_t
 
i
 = 0; i < sizeof 
W
; i++)

88 
uint8_t
 
C
[256];

89 
uint8_t
 
A
[16];

91 
	`cf_norx32_encrypt
(
K
, 
N
,

92 
H
, 
i
,

93 
W
, 
i
,

94 
NULL
, 0,

95 
C
, 
A
);

97 
	`TEST_CHECK
(
	`memcmp
(
kats
, 
C
, 
i
) == 0);

98 
kats
 += 
i
;

99 
	`TEST_CHECK
(
	`memcmp
(
kats
, 
A
, sizeof A) == 0);

100 
kats
 += sizeof 
A
;

102 
uint8_t
 
M
[256] = { 0 };

103 
	`TEST_CHECK
(0 == 
	`cf_norx32_decrypt
(
K
, 
N
,

104 
H
, 
i
,

105 
C
, 
i
,

106 
NULL
, 0,

107 
A
, 
M
));

109 
	`TEST_CHECK
(0 == 
	`memcmp
(
M
, 
W
, 
i
));

111 
	}
}

113 
	gTEST_LIST
 = {

114 { "vector", 
test_vector
 },

115 { "kat", 
test_kat
 },

	@deps/picotls/deps/cifra/src/testpoly1305.c

16 #include 
	~"poly1305.h
"

18 #include 
	~"testutil.h
"

19 #include 
	~"handy.h
"

20 #include 
	~"cutest.h
"

22 static void 
	$check
(const char *
rstr
, const char *
sstr
,

23 const char *
msgstr
, const char *
tagstr
)

25 
uint8_t
 
r
[16], 
s
[16], 
tag
[16];

26 
uint8_t
 
msg
[132], 
out
[16];

28 
	`unhex
(
r
, sizeof r, 
rstr
);

29 
	`unhex
(
s
, sizeof s, 
sstr
);

30 
size_t
 
nmsg
 = 
	`unhex
(
msg
, sizeof msg, 
msgstr
);

31 
	`unhex
(
tag
, sizeof tag, 
tagstr
);

33 
cf_poly1305
 
ctx
;

34 
	`cf_poly1305_init
(&
ctx
, 
r
, 
s
);

35 
	`cf_poly1305_update
(&
ctx
, 
msg
, 
nmsg
);

36 
	`cf_poly1305_finish
(&
ctx
, 
out
);

38 
	`TEST_CHECK
(
	`memcmp
(
out
, 
tag
, 16) == 0);

39 
	}
}

41 static void 
	$test_poly1305
(void)

43 
	`check
("eea6a7251c1e72916d11c2cb214d3c25",

48 
	`check
("851fc40c3467ac0be05cc20404f3f700",

53 
	`check
("a0f3080000f46400d0c7e9076c834403",

58 
	`check
("48443d0bb0d21109c89a100b5ce2c208",

63 
	`check
("12976a08c4426d0ce8a82407c4f48207",

69 
	`check
("02000000000000000000000000000000",

73 
	`check
("02000000000000000000000000000000",

77 
	`check
("01000000000000000000000000000000",

81 
	`check
("01000000000000000000000000000000",

85 
	`check
("02000000000000000000000000000000",

89 
	`check
("01000000000000000400000000000000",

93 
	`check
("01000000000000000400000000000000",

97 
	}
}

99 
	gTEST_LIST
 = {

100 { "poly1305", 
test_poly1305
 },

	@deps/picotls/deps/cifra/src/testsalsa20.c

15 #include 
	~"salsa20.h
"

17 #include 
	~"testutil.h
"

18 #include 
	~"handy.h
"

19 #include 
	~"cutest.h
"

21 static void 
	$test_salsa20_core
(void)

23 
uint8_t
 
k0
[16], 
k1
[16], 
nonce
[16], 
sigma
[16], 
out
[64], 
expect
[64];

26 
	`memset
(
k0
, 0, sizeof k0);

27 
	`memset
(
k1
, 0, sizeof k1);

28 
	`memset
(
nonce
, 0, sizeof nonce);

29 
	`memset
(
sigma
, 0, sizeof sigma);

31 
	`cf_salsa20_core
(
k0
, 
k1
, 
nonce
, 
sigma
, 
out
);

33 
	`unhex
(
expect
, 64, "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

34 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

45 
	`unhex
(
k0
, 16, "4c3752b70375de25bfbbea8831edb330");

46 
	`unhex
(
k1
, 16, "ee37cc244fc9eb4f03519c2fcb1af4f3");

47 
	`unhex
(
nonce
, 16, "afc7a6305610b3cf1ff0203f0f535da1");

48 
	`unhex
(
sigma
, 16, "d39f0d73016ab2db7493307158766836");

50 
	`cf_salsa20_core
(
k0
, 
k1
, 
nonce
, 
sigma
, 
out
);

52 
	`unhex
(
expect
, 64, "6d2ab2a89cf0f8eea8c4becb1a6eaa9a1d1d961a961eebf9bea3fb30459033397628989db4391b5e6b2aec231b6f7272dbece8876f9b6e1218e85f9eb31330ca");

53 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

64 
	`unhex
(
k0
, 16, "4fc9eb4f03519c2fcb1af4f3bfbbea88");

65 
	`unhex
(
k1
, 16, "afc7a630ee37cc241ff0203f0f535da1");

66 
	`unhex
(
nonce
, 16, "4c3752b70375de255610b3cf31edb330");

67 
	`unhex
(
sigma
, 16, "58766836d39f0d73016ab2db74933071");

69 
	`cf_salsa20_core
(
k0
, 
k1
, 
nonce
, 
sigma
, 
out
);

71 
	`unhex
(
expect
, 64, "b31330cadbece8876f9b6e1218e85f9e1a6eaa9a6d2ab2a89cf0f8eea8c4becb459033391d1d961a961eebf9bea3fb301b6f72727628989db4391b5e6b2aec23");

72 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

75 for (
size_t
 
i
 = 0; i < 16; i++)

77 
k0
[
i
] = 1 + i;

78 
k1
[
i
] = 201 + i;

79 
nonce
[
i
] = 101 + i;

82 
	`cf_salsa20_core
(
k0
, 
k1
, 
nonce
, (const 
uint8_t
 *) "expand 32-byte k", 
out
);

84 
	`unhex
(
expect
, 64, "45254427290f6bc1ff8b7a06aae9d9625990b66a1533c841ef31de22d772287e68c507e1c5991f02664e4cb054f5f6b8b1a0858206489577c0c384ecea67f64a");

85 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

87 
	`cf_salsa20_core
(
k0
, k0, 
nonce
, (const 
uint8_t
 *) "expand 16-byte k", 
out
);

89 
	`unhex
(
expect
, 64, "27ad2ef81ec852113043feef25120df7f1c83d900a3732b9062ff6fd8f56bbe186556ef6a1a32bebe75eab3391d6701d0ee80510978cb78dab097ab568b6b1c1");

90 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

91 
	}
}

93 static void 
	$test_salsa20
(void)

95 
cf_salsa20_ctx
 
ctx
;

96 
uint8_t
 
key
[32], 
nonce
[8], 
cipher
[64], 
expect
[64];

98 
	`unhex
(
key
, 32, "0102030405060708090a0b0c0d0e0f10c9cacbcccdcecfd0d1d2d3d4d5d6d7d8");

99 
	`memset
(
nonce
, 0, 8);

101 
	`cf_salsa20_init
(&
ctx
, 
key
, sizeof key, 
nonce
);

102 
	`unhex
(
ctx
.
nonce
, 16, "65666768696a6b6c6d6e6f7071727374");

103 
	`memset
(
cipher
, 0, 64);

104 
	`cf_salsa20_cipher
(&
ctx
, 
cipher
, cipher, 64);

106 
	`unhex
(
expect
, 64, "45254427290f6bc1ff8b7a06aae9d9625990b66a1533c841ef31de22d772287e68c507e1c5991f02664e4cb054f5f6b8b1a0858206489577c0c384ecea67f64a");

107 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
cipher
, 64) == 0);

109 
	`cf_salsa20_init
(&
ctx
, 
key
, 16, 
nonce
);

110 
	`unhex
(
ctx
.
nonce
, 16, "65666768696a6b6c6d6e6f7071727374");

111 
	`memset
(
cipher
, 0, 64);

112 
	`cf_salsa20_cipher
(&
ctx
, 
cipher
, cipher, 64);

114 
	`unhex
(
expect
, 64, "27ad2ef81ec852113043feef25120df7f1c83d900a3732b9062ff6fd8f56bbe186556ef6a1a32bebe75eab3391d6701d0ee80510978cb78dab097ab568b6b1c1");

115 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
cipher
, 64) == 0);

116 
	}
}

118 static void 
	$test_chacha20_core
(void)

120 
uint8_t
 
k0
[16], 
k1
[16], 
nonce
[16], 
out
[64], 
expect
[64];

124 
	`memset
(
k0
, 0, sizeof k0);

125 
	`memset
(
k1
, 0, sizeof k1);

126 
	`memset
(
nonce
, 0, sizeof nonce);

128 
	`cf_chacha20_core
(
k0
, 
k1
, 
nonce
, (const 
uint8_t
 *) "expand 32-byte k", 
out
);

130 
	`unhex
(
expect
, 60, "76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669");

131 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 60) == 0);

133 
k1
[15] = 0x01;

134 
	`cf_chacha20_core
(
k0
, 
k1
, 
nonce
, (const 
uint8_t
 *) "expand 32-byte k", 
out
);

136 
	`unhex
(
expect
, 60, "4540f05a9f1fb296d7736e7b208e3c96eb4fe1834688d2604f450952ed432d41bbe2a0b6ea7566d2a5d1e7e20d42af2c53d792b1c43fea817e9ad275");

137 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 60) == 0);

139 
	`memset
(
k1
, 0, sizeof k1);

140 
nonce
[15] = 0x01;

142 
	`cf_chacha20_core
(
k0
, 
k1
, 
nonce
, (const 
uint8_t
 *) "expand 32-byte k", 
out
);

144 
	`unhex
(
expect
, 60, "de9cba7bf3d69ef5e786dc63973f653a0b49e015adbff7134fcb7df137821031e85a050278a7084527214f73efc7fa5b5277062eb7a0433e445f41e3");

145 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 60) == 0);

147 
	`memset
(
nonce
, 0, sizeof nonce);

148 
nonce
[8] = 0x01;

150 
	`cf_chacha20_core
(
k0
, 
k1
, 
nonce
, (const 
uint8_t
 *) "expand 32-byte k", 
out
);

152 
	`unhex
(
expect
, 64, "ef3fdfd6c61578fbf5cf35bd3dd33b8009631634d21e42ac33960bd138e50d32111e4caf237ee53ca8ad6426194a88545ddc497a0b466e7d6bbdb0041b2f586b");

153 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

155 
	`unhex
(
k0
, 16, "000102030405060708090a0b0c0d0e0f");

156 
	`unhex
(
k1
, 16, "101112131415161718191a1b1c1d1e1f");

157 
	`unhex
(
nonce
, 16, "00000000000000000001020304050607");

159 
	`cf_chacha20_core
(
k0
, 
k1
, 
nonce
, (const 
uint8_t
 *) "expand 32-byte k", 
out
);

161 
	`unhex
(
expect
, 64, "f798a189f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a");

162 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

164 
nonce
[0]++;

165 
	`cf_chacha20_core
(
k0
, 
k1
, 
nonce
, (const 
uint8_t
 *) "expand 32-byte k", 
out
);

167 
	`unhex
(
expect
, 64, "38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c7");

168 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

170 
nonce
[0]++;

171 
	`cf_chacha20_core
(
k0
, 
k1
, 
nonce
, (const 
uint8_t
 *) "expand 32-byte k", 
out
);

173 
	`unhex
(
expect
, 64, "9db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d7");

174 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

176 
nonce
[0]++;

177 
	`cf_chacha20_core
(
k0
, 
k1
, 
nonce
, (const 
uint8_t
 *) "expand 32-byte k", 
out
);

179 
	`unhex
(
expect
, 64, "0eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9");

180 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
out
, 64) == 0);

181 
	}
}

183 static void 
	$test_chacha20
(void)

185 
uint8_t
 
key
[32], 
nonce
[8], 
block
[256], 
expect
[256];

187 
	`unhex
(
key
, 32, "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f");

188 
	`unhex
(
nonce
, 8, "0001020304050607");

189 
	`unhex
(
expect
, 256, "f798a189f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9");

190 
	`memset
(
block
, 0, 256);

192 
cf_chacha20_ctx
 
ctx
;

193 
	`cf_chacha20_init
(&
ctx
, 
key
, sizeof key, 
nonce
);

194 
	`cf_chacha20_cipher
(&
ctx
, 
block
, block, sizeof block);

196 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
block
, sizeof expect) == 0);

199 
	`cf_chacha20_init
(&
ctx
, 
key
, 16, 
nonce
);

200 
	`cf_chacha20_cipher
(&
ctx
, 
block
, block, sizeof block);

201 
	}
}

203 
	gTEST_LIST
 = {

204 { "salsa20-core", 
test_salsa20_core
 },

205 { "chacha20-core", 
test_chacha20_core
 },

206 { "salsa20", 
test_salsa20
 },

207 { "chacha20", 
test_chacha20
 },

	@deps/picotls/deps/cifra/src/testsha.h

15 #ifndef 
TESTSHA_H


16 #define 
	#TESTSHA_H


	)

18 #include 
	~"hmac.h
"

23 static void 
	$vector
(const 
cf_chash
 *
hash
,

24 const void *
vmsg
, 
size_t
 
nmsg
,

25 const char *
expect
, 
size_t
 
nexpect
)

27 
uint8_t
 
digest
[
CF_MAXHASH
];

28 const 
uint8_t
 *
msg
 = 
vmsg
;

29 
size_t
 
orig_nmsg
 = 
nmsg
;

31 
cf_chash_ctx
 
ctx
;

32 
hash
->
	`init
(&
ctx
);

35 if (
nmsg
)

37 
hash
->
	`update
(&
ctx
, 
msg
, 1);

38 
nmsg
--;

39 
msg
++;

42 
hash
->
	`update
(&
ctx
, 
msg
, 
nmsg
);

43 
hash
->
	`digest
(&
ctx
, 
digest
);

44 
	`TEST_CHECK
(
nexpect
 == 
hash
->
hashsz
);

45 
	`TEST_CHECK
(
	`memcmp
(
digest
, 
expect
, 
nexpect
) == 0);

48 
msg
 = 
vmsg
;

49 
nmsg
 = 
orig_nmsg
;

51 
hash
->
	`init
(&
ctx
);

52 if (
nmsg
 >= 
hash
->
blocksz
)

54 
hash
->
	`update
(&
ctx
, 
msg
, hash->
blocksz
 - 1);

55 
nmsg
 -= 
hash
->
blocksz
 - 1;

56 
msg
 += 
hash
->
blocksz
 - 1;

59 
hash
->
	`update
(&
ctx
, 
msg
, 
nmsg
);

60 
hash
->
	`digest
(&
ctx
, 
digest
);

61 
	`TEST_CHECK
(
	`memcmp
(
digest
, 
expect
, 
nexpect
) == 0);

62 
	}
}

65 static 
inline
 void 
	$hmac_test
(const 
cf_chash
 *
hash
,

66 const void *
hi_there
,

67 const void *
jefe
,

68 const void *
aa_dd
,

69 const void *
counter_key
)

71 
uint8_t
 
sig
[
CF_MAXHASH
];

72 
uint8_t
 
key
[25], 
message
[50];

77 
	`memset
(
key
, 0x0b, 20);

78 
	`memcpy
(
message
, "Hi There", 8);

79 
	`cf_hmac
(
key
, 20, 
message
, 8, 
sig
, 
hash
);

81 
	`TEST_CHECK
(
	`memcmp
(
sig
, 
hi_there
, 
hash
->
hashsz
) == 0);

86 
	`memcpy
(
key
, "Jefe", 4);

87 
	`memcpy
(
message
, "what do ya want for nothing?", 28);

88 
	`cf_hmac
(
key
, 4, 
message
, 28, 
sig
, 
hash
);

89 
	`TEST_CHECK
(
	`memcmp
(
sig
, 
jefe
, 
hash
->
hashsz
) == 0);

94 
	`memset
(
key
, 0xaa, 20);

95 
	`memset
(
message
, 0xdd, 50);

96 
	`cf_hmac
(
key
, 20, 
message
, 50, 
sig
, 
hash
);

97 
	`TEST_CHECK
(
	`memcmp
(
sig
, 
aa_dd
, 
hash
->
hashsz
) == 0);

102 for (
uint8_t
 
i
 = 1; i < 26; i++)

103 
key
[
i
 - 1] = i;

104 
	`memset
(
message
, 0xcd, 50);

105 
	`cf_hmac
(
key
, 25, 
message
, 50, 
sig
, 
hash
);

106 
	`TEST_CHECK
(
	`memcmp
(
sig
, 
counter_key
, 
hash
->
hashsz
) == 0);

107 
	}
}

110 static 
inline
 void 
	$hmac_test_sha2
(const 
cf_chash
 *
hash
,

111 const char *
long_key
,

112 const char *
long_message
)

114 
uint8_t
 
sig
[
CF_MAXHASH
];

115 
uint8_t
 
key
[131], 
message
[152];

120 
	`memset
(
key
, 0xaa, 131);

121 
	`memcpy
(
message
, "Test Using Larger Than Block-Size Key - Hash Key First", 54);

122 
	`cf_hmac
(
key
, 131, 
message
, 54, 
sig
, 
hash
);

123 
	`TEST_CHECK
(
	`memcmp
(
sig
, 
long_key
, 
hash
->
hashsz
) == 0);

128 
	`memset
(
key
, 0xaa, 131);

129 
	`memcpy
(
message
, "This is a test using a larger than block-size key and a larger than block-size data. The key needs to be hashed before being used by the HMAC algorithm.", 152);

130 
	`cf_hmac
(
key
, 131, 
message
, 152, 
sig
, 
hash
);

131 
	`TEST_CHECK
(
	`memcmp
(
sig
, 
long_message
, 
hash
->
hashsz
) == 0);

132 
	}
}

136 static 
inline
 void 
	$hmac_test_sha1
(const 
cf_chash
 *
hash
,

137 const char *
long_key
,

138 const char *
long_message
)

140 
uint8_t
 
sig
[
CF_MAXHASH
];

141 
uint8_t
 
key
[80], 
message
[73];

146 
	`memset
(
key
, 0xaa, 80);

147 
	`memcpy
(
message
, "Test Using Larger Than Block-Size Key - Hash Key First", 54);

148 
	`cf_hmac
(
key
, 80, 
message
, 54, 
sig
, 
hash
);

149 
	`TEST_CHECK
(
	`memcmp
(
sig
, 
long_key
, 
hash
->
hashsz
) == 0);

154 
	`memset
(
key
, 0xaa, 80);

155 
	`memcpy
(
message
, "Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data", 73);

156 
	`cf_hmac
(
key
, 80, 
message
, 73, 
sig
, 
hash
);

157 
	`TEST_CHECK
(
	`memcmp
(
sig
, 
long_message
, 
hash
->
hashsz
) == 0);

158 
	}
}

160 typedef void (*
	tfinal_fn
)(void *
	tctx
, 
	tuint8_t
 *
	tout
);

163 static void 
	$vector_abc_final
(const 
cf_chash
 *
hash
, const void *
vfinal_fn
,

164 const void *
expect
, 
size_t
 
nexpect
)

166 
uint8_t
 
digest
[
CF_MAXHASH
];

168 
final_fn
 
final
 = 
vfinal_fn
;

169 
cf_chash_ctx
 
ctx
;

170 
hash
->
	`init
(&
ctx
);

171 
hash
->
	`update
(&
ctx
, "a", 1);

172 
hash
->
	`digest
(&
ctx
, 
digest
);

173 
hash
->
	`update
(&
ctx
, "b", 1);

174 
hash
->
	`digest
(&
ctx
, 
digest
);

175 
hash
->
	`update
(&
ctx
, "c", 1);

176 
	`final
(&
ctx
, 
digest
);

178 
	`TEST_CHECK
(
hash
->
hashsz
 == 
nexpect
);

179 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
digest
, 
nexpect
) == 0);

180 
	}
}

183 static 
inline
 void 
	$vector_length
(const 
cf_chash
 *
h
,

184 
size_t
 
max
,

185 const void *
expect
, 
size_t
 
nexpect
)

187 
cf_chash_ctx
 
outer
, 
inner
;

188 
uint8_t
 
digest
[
CF_MAXHASH
];

190 
h
->
	`init
(&
outer
);

192 for (
size_t
 
n
 = 0; n < 
max
; n++)

194 
h
->
	`init
(&
inner
);

196 for (
size_t
 
i
 = 0; i < 
n
; i++)

198 
uint8_t
 
byte
 = (uint8_t) 
n
 & 0xff;

199 
h
->
	`update
(&
inner
, &
byte
, 1);

202 
h
->
	`digest
(&
inner
, 
digest
);

204 
h
->
	`update
(&
outer
, 
digest
, h->
hashsz
);

207 
h
->
	`digest
(&
outer
, 
digest
);

209 
	`TEST_CHECK
(
h
->
hashsz
 == 
nexpect
);

210 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
digest
, 
nexpect
) == 0);

211 
	}
}

	@deps/picotls/deps/cifra/src/testsha1.c

15 #include 
	~"sha1.h
"

16 #include 
	~"hmac.h
"

17 #include 
	~"handy.h
"

18 #include 
	~"cutest.h
"

19 #include 
	~"testutil.h
"

21 #include 
	~"testsha.h
"

23 static void 
	$test_sha1
(void)

25 const 
cf_chash
 *
h
 = &
cf_sha1
;

26 
	`vector
(
h
, "", 0, "\xda\x39\xa3\xee\x5e\x6b\x4b\x0d\x32\x55\xbf\xef\x95\x60\x18\x90\xaf\xd8\x07\x09", 20);

27 
	`vector
(
h
, "abc", 3, "\xa9\x99\x3e\x36\x47\x06\x81\x6a\xba\x3e\x25\x71\x78\x50\xc2\x6c\x9c\xd0\xd8\x9d", 20);

28 
	`vector
(
h
, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56,

30 
	`vector
(
h
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112,

33 
	`vector_abc_final
(
h
, 
cf_sha1_digest_final
, "\xa9\x99\x3e\x36\x47\x06\x81\x6a\xba\x3e\x25\x71\x78\x50\xc2\x6c\x9c\xd0\xd8\x9d", 20);

35 
	`vector_length
(
h
, 1024, "\x15\x53\x65\xcf\x77\xee\xd4\x8f\x46\xe2\x55\xc7\xdd\xdf\xfd\x0a\xf6\x99\x88\xbe", 20);

36 
	}
}

38 static void 
	$test_hmac_sha1
(void)

40 
	`hmac_test
(&
cf_sha1
,

45 
	`hmac_test_sha1
(&
cf_sha1
,

48 
	}
}

50 
	gTEST_LIST
 = {

51 { "sha1", 
test_sha1
},

52 { "hmac-sha1", 
test_hmac_sha1
},

	@deps/picotls/deps/cifra/src/testsha2.c

15 #include 
	~"sha2.h
"

16 #include 
	~"hmac.h
"

17 #include 
	~"pbkdf2.h
"

18 #include 
	~"handy.h
"

19 #include 
	~"cutest.h
"

20 #include 
	~"testutil.h
"

22 #include 
	~"testsha.h
"

24 #undef 
REALLY_SLOW_TEST


26 static void 
	$test_sha224
(void)

28 const 
cf_chash
 *
h
 = &
cf_sha224
;

29 
	`vector
(
h
, "", 0, "\xd1\x4a\x02\x8c\x2a\x3a\x2b\xc9\x47\x61\x02\xbb\x28\x82\x34\xc4\x15\xa2\xb0\x1f\x82\x8e\xa6\x2a\xc5\xb3\xe4\x2f", 28);

30 
	`vector
(
h
, "abc", 3, "\x23\x09\x7d\x22\x34\x05\xd8\x22\x86\x42\xa4\x77\xbd\xa2\x55\xb3\x2a\xad\xbc\xe4\xbd\xa0\xb3\xf7\xe3\x6c\x9d\xa7", 28);

31 
	`vector
(
h
, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56,

33 
	`vector
(
h
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112,

37 
	`vector_abc_final
(
h
, 
cf_sha224_digest_final
, "\x23\x09\x7d\x22\x34\x05\xd8\x22\x86\x42\xa4\x77\xbd\xa2\x55\xb3\x2a\xad\xbc\xe4\xbd\xa0\xb3\xf7\xe3\x6c\x9d\xa7", 28);

39 
	`vector_length
(
h
, 1024, "\x08\x2c\x80\x5b\x6f\x85\xde\x0e\xdf\xa8\x51\xa0\x1f\xe6\x4f\x64\x85\x16\x48\xae\xfc\xc1\xd4\x52\x4e\xf8\x36\xe7", 28);

40 
	}
}

42 static void 
	$test_hmac_sha224
(void)

44 
	`hmac_test
(&
cf_sha224
,

49 
	`hmac_test_sha2
(&
cf_sha224
,

52 
	}
}

54 static void 
	$test_sha256
(void)

56 const 
cf_chash
 *
h
 = &
cf_sha256
;

57 
	`vector
(
h
, "", 0, "\xe3\xb0\xc4\x42\x98\xfc\x1c\x14\x9a\xfb\xf4\xc8\x99\x6f\xb9\x24\x27\xae\x41\xe4\x64\x9b\x93\x4c\xa4\x95\x99\x1b\x78\x52\xb8\x55", 32);

58 
	`vector
(
h
, "abc", 3, "\xba\x78\x16\xbf\x8f\x01\xcf\xea\x41\x41\x40\xde\x5d\xae\x22\x23\xb0\x03\x61\xa3\x96\x17\x7a\x9c\xb4\x10\xff\x61\xf2\x00\x15\xad", 32);

59 
	`vector
(
h
, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56,

61 
	`vector
(
h
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112,

64 
	`vector_abc_final
(
h
, 
cf_sha256_digest_final
, "\xba\x78\x16\xbf\x8f\x01\xcf\xea\x41\x41\x40\xde\x5d\xae\x22\x23\xb0\x03\x61\xa3\x96\x17\x7a\x9c\xb4\x10\xff\x61\xf2\x00\x15\xad", 32);

66 
	`vector_length
(
h
, 1024, "\x55\x7b\xfd\xd5\xef\xda\xfd\x63\x06\x5e\xb7\x98\x87\xde\x86\xdb\x54\xc3\xfe\xdf\x7b\xcc\xcb\x97\x08\xfa\x87\xf0\x11\x87\x61\xdc", 32);

67 
	}
}

69 static void 
	$test_hmac_sha256
(void)

71 
	`hmac_test
(&
cf_sha256
,

76 
	`hmac_test_sha2
(&
cf_sha256
,

79 
	}
}

81 static void 
	$test_sha384
(void)

83 const 
cf_chash
 *
h
 = &
cf_sha384
;

84 
	`vector
(
h
, "", 0, "\x38\xb0\x60\xa7\x51\xac\x96\x38\x4c\xd9\x32\x7e\xb1\xb1\xe3\x6a\x21\xfd\xb7\x11\x14\xbe\x07\x43\x4c\x0c\xc7\xbf\x63\xf6\xe1\xda\x27\x4e\xde\xbf\xe7\x6f\x65\xfb\xd5\x1a\xd2\xf1\x48\x98\xb9\x5b", 48);

85 
	`vector
(
h
, "abc", 3, "\xcb\x00\x75\x3f\x45\xa3\x5e\x8b\xb5\xa0\x3d\x69\x9a\xc6\x50\x07\x27\x2c\x32\xab\x0e\xde\xd1\x63\x1a\x8b\x60\x5a\x43\xff\x5b\xed\x80\x86\x07\x2b\xa1\xe7\xcc\x23\x58\xba\xec\xa1\x34\xc8\x25\xa7", 48);

86 
	`vector
(
h
, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56,

88 
	`vector
(
h
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112,

91 
	`vector_abc_final
(
h
, 
cf_sha384_digest_final
, "\xcb\x00\x75\x3f\x45\xa3\x5e\x8b\xb5\xa0\x3d\x69\x9a\xc6\x50\x07\x27\x2c\x32\xab\x0e\xde\xd1\x63\x1a\x8b\x60\x5a\x43\xff\x5b\xed\x80\x86\x07\x2b\xa1\xe7\xcc\x23\x58\xba\xec\xa1\x34\xc8\x25\xa7", 48);

93 
	`vector_length
(
h
, 1024, "\xae\xe7\xf1\x43\xef\x69\x7b\xa2\xe1\xfd\x39\x9f\xd7\xe6\x28\x9c\x19\xaf\x3c\xc1\xbd\xda\xbd\x3f\x07\xae\xc2\xea\x40\x55\x37\x27\x5f\x41\x49\x50\x3f\xcc\xaf\xa0\xc5\x95\xf7\x62\x9b\xff\x50\x32", 48);

94 
	}
}

96 static void 
	$test_hmac_sha384
(void)

98 
	`hmac_test
(&
cf_sha384
,

103 
	`hmac_test_sha2
(&
cf_sha384
,

106 
	}
}

108 static void 
	$test_sha512
(void)

110 const 
cf_chash
 *
h
 = &
cf_sha512
;

111 
	`vector
(
h
, "", 0, "\xcf\x83\xe1\x35\x7e\xef\xb8\xbd\xf1\x54\x28\x50\xd6\x6d\x80\x07\xd6\x20\xe4\x05\x0b\x57\x15\xdc\x83\xf4\xa9\x21\xd3\x6c\xe9\xce\x47\xd0\xd1\x3c\x5d\x85\xf2\xb0\xff\x83\x18\xd2\x87\x7e\xec\x2f\x63\xb9\x31\xbd\x47\x41\x7a\x81\xa5\x38\x32\x7a\xf9\x27\xda\x3e", 64);

112 
	`vector
(
h
, "abc", 3, "\xdd\xaf\x35\xa1\x93\x61\x7a\xba\xcc\x41\x73\x49\xae\x20\x41\x31\x12\xe6\xfa\x4e\x89\xa9\x7e\xa2\x0a\x9e\xee\xe6\x4b\x55\xd3\x9a\x21\x92\x99\x2a\x27\x4f\xc1\xa8\x36\xba\x3c\x23\xa3\xfe\xeb\xbd\x45\x4d\x44\x23\x64\x3c\xe8\x0e\x2a\x9a\xc9\x4f\xa5\x4c\xa4\x9f", 64);

113 
	`vector
(
h
, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56,

115 
	`vector
(
h
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112,

118 
	`vector_abc_final
(
h
, 
cf_sha512_digest_final
, "\xdd\xaf\x35\xa1\x93\x61\x7a\xba\xcc\x41\x73\x49\xae\x20\x41\x31\x12\xe6\xfa\x4e\x89\xa9\x7e\xa2\x0a\x9e\xee\xe6\x4b\x55\xd3\x9a\x21\x92\x99\x2a\x27\x4f\xc1\xa8\x36\xba\x3c\x23\xa3\xfe\xeb\xbd\x45\x4d\x44\x23\x64\x3c\xe8\x0e\x2a\x9a\xc9\x4f\xa5\x4c\xa4\x9f", 64);

120 
	`vector_length
(
h
, 1024, "\x61\x20\x81\x2e\xd5\x0c\xc3\x11\x67\x04\x3f\x1f\x06\x9d\xcd\x4a\xd8\x83\x23\xd9\x96\x53\xd9\x67\x38\x2c\xc3\x44\x25\x69\x53\x1c\xd0\x3d\xe4\x79\x0a\x71\xde\x88\x45\x44\x66\x80\xb8\xc5\x90\xb3\x07\xc8\xae\x52\x57\x67\xf9\x28\xf8\xda\x9e\x9e\x80\xc9\x35\x5e", 64);

121 
	}
}

123 static void 
	$test_hmac_sha512
(void)

125 
	`hmac_test
(&
cf_sha512
,

130 
	`hmac_test_sha2
(&
cf_sha512
,

133 
	}
}

135 #ifdef 
REALLY_SLOW_TEST


136 static void 
	$test_sha256_long
(void)

138 
uint8_t
 
digest
[32];

139 
cf_sha256_context
 
ctx
;

140 
	`cf_sha256_init
(&
ctx
);

142 for (
size_t
 
i
 = 0; i < 0x1000000; i++)

143 
	`cf_sha256_update
(&
ctx
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno", 64);

144 
	`cf_sha256_digest_final
(&
ctx
, 
digest
);

146 
uint8_t
 
expect
[32];

147 
	`unhex
(
expect
, sizeof expect, "\x50\xe7\x2a\x0e\x26\x44\x2f\xe2\x55\x2d\xc3\x93\x8a\xc5\x86\x58\x22\x8c\x0c\xbf\xb1\xd2\xca\x87\x2a\xe4\x35\x26\x6f\xcd\x05\x5e", 32);

148 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
digest
, sizeof digest) == 0);

149 
	}
}

152 static void 
	$check_pkbdf2_sha256
(const void *
pw
, 
size_t
 
npw
,

153 const void *
salt
, 
size_t
 
nsalt
,

154 
uint32_t
 
iters
,

155 const void *
expect
, 
size_t
 
nexpect
)

157 
uint8_t
 
output
[64];

159 
	`cf_pbkdf2_hmac
((const void *) 
pw
, 
npw
,

160 (const void *) 
salt
, 
nsalt
,

161 
iters
,

162 
output
, 
nexpect
,

163 &
cf_sha256
);

165 
	`TEST_CHECK
(
	`memcmp
(
expect
, 
output
, 
nexpect
) == 0);

166 
	}
}

168 static void 
	$test_pbkdf2_sha256
(void)

170 
	`check_pkbdf2_sha256
("password", 8,

175 
	`check_pkbdf2_sha256
("password", 8,

180 
	`check_pkbdf2_sha256
("password", 8,

185 
	`check_pkbdf2_sha256
("passwordPASSWORDpassword", 24,

190 
	`check_pkbdf2_sha256
("", 0,

195 
	`check_pkbdf2_sha256
("password", 8,

200 
	`check_pkbdf2_sha256
("\x70\x61\x73\x73\x00\x77\x6f\x72\x64", 9,

204 
	}
}

206 
	gTEST_LIST
 = {

207 { "sha224", 
test_sha224
},

208 { "sha256", 
test_sha256
 },

209 { "sha384", 
test_sha384
 },

210 { "sha512", 
test_sha512
 },

212 { "hmac-sha224", 
test_hmac_sha224
 },

213 { "hmac-sha256", 
test_hmac_sha256
 },

214 { "hmac-sha384", 
test_hmac_sha384
 },

215 { "hmac-sha512", 
test_hmac_sha512
 },

217 { "pbkdf2-sha256", 
test_pbkdf2_sha256
 },

219 #ifdef 
REALLY_SLOW_TEST


220 { "sha256-long", 
test_sha256_long
 },

	@deps/picotls/deps/cifra/src/testsha3.c

15 #include 
	~"sha3.h
"

16 #include 
	~"handy.h
"

17 #include 
	~"cutest.h
"

18 #include 
	~"testutil.h
"

19 #include 
	~"testsha.h
"

21 static void 
	$test_sha3_224
(void)

23 const 
cf_chash
 *
H
 = &
cf_sha3_224
;

24 
	`vector
(
H
, "", 0,

26 
	`vector
(
H
, "abc", 3,

28 
	`vector
(
H
, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56,

30 
	`vector
(
H
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112,

34 
	`vector
(
H
, "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", 143,

37 
	`vector_abc_final
(
H
, 
cf_sha3_224_digest_final
,

40 
	`vector_length
(
H
, 1024, "\xf2\x54\xf3\x67\x6d\xc6\xc0\x0f\x2f\xee\x50\x59\x07\x62\x8b\x0d\x5b\x9e\xdf\xf8\xe8\xc2\x9e\x9b\xa7\xd6\x05\xdd", 28);

41 
	}
}

43 static void 
	$test_sha3_256
(void)

45 const 
cf_chash
 *
H
 = &
cf_sha3_256
;

46 
	`vector
(
H
, "", 0,

48 
	`vector
(
H
, "abc", 3,

50 
	`vector
(
H
, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56,

52 
	`vector
(
H
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112,

55 
	`vector_abc_final
(
H
, 
cf_sha3_256_digest_final
,

58 
	`vector_length
(
H
, 1024, "\xf7\xed\xf7\x2b\x34\x8c\xb4\xab\x5e\xe7\x4f\x6c\xae\xaf\x11\xad\xe2\x2f\x04\x65\x84\x8e\x5c\xaa\x14\x38\x7f\xd4\xeb\xdb\x9d\x70", 32);

59 
	}
}

61 static void 
	$test_sha3_384
(void)

63 const 
cf_chash
 *
H
 = &
cf_sha3_384
;

64 
	`vector
(
H
, "", 0,

66 
	`vector
(
H
, "abc", 3,

68 
	`vector
(
H
, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56,

70 
	`vector
(
H
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112,

73 
	`vector_abc_final
(
H
, 
cf_sha3_384_digest_final
,

76 
	`vector_length
(
H
, 1024, "\xc2\x16\x48\x6a\x00\x32\xb1\xe1\x98\xf8\x72\x52\x01\x87\xba\xd4\xcf\x39\x13\x9c\x54\x21\x6d\x78\x86\x93\x88\xf9\x75\x03\xc1\x11\xcc\x7f\x5a\xc3\x21\x00\x3f\xc8\xa1\xf7\xfa\x10\x75\x60\xdb\xb1", 48);

77 
	}
}

79 static void 
	$test_sha3_512
(void)

81 const 
cf_chash
 *
H
 = &
cf_sha3_512
;

82 
	`vector
(
H
, "", 0,

84 
	`vector
(
H
, "abc", 3,

86 
	`vector
(
H
, "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq", 56,

88 
	`vector
(
H
, "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu", 112,

91 
	`vector_abc_final
(
H
, 
cf_sha3_512_digest_final
,

94 
	`vector_length
(
H
, 1024, "\x3a\x98\x11\x17\xbc\x2f\xa3\x3b\x00\x51\x71\xf8\x80\x86\x33\x7f\x4f\x6c\xe9\xd1\x5c\xb7\x38\xc0\x9b\xe2\x8a\xb6\xd5\x38\xba\xbf\x7b\xc5\x4e\xbf\x3d\xdb\x53\x4a\x9c\x3c\x10\x85\xe7\x18\x3d\x46\xa5\x8c\xbc\xb0\x15\xb0\xdf\x50\x7a\xad\x0e\xdf\xf3\x54\x8e\xfd", 64);

95 
	}
}

97 
	gTEST_LIST
 = {

98 { "sha3-224", 
test_sha3_224
 },

99 { "sha3-256", 
test_sha3_256
 },

100 { "sha3-384", 
test_sha3_384
 },

101 { "sha3-512", 
test_sha3_512
 },

	@deps/picotls/deps/cifra/src/testutil.h

15 #ifndef 
TESTUTIL_H


16 #define 
	#TESTUTIL_H


	)

18 #include 
	~<assert.h
>

19 #include 
	~<string.h
>

20 #include 
	~<stdio.h
>

22 static 
inline
 
uint8_t
 
	$unhex_chr
(char 
a
)

24 if (
a
 >= '0' && a <= '9')

25 return 
a
 - '0';

26 else if (
a
 >= 'a' && a <= 'f')

27 return 
a
 - 'a' + 10;

28 else if (
a
 >= 'A' && a <= 'F')

29 return 
a
 - 'A' + 10;

31 
	}
}

33 static 
inline
 
size_t
 
	$unhex
(
uint8_t
 *
buf
, 
size_t
 
len
, const char *
str
)

35 
size_t
 
used
 = 0;

37 
	`assert
(
	`strlen
(
str
) % 2 == 0);

38 
	`assert
(
	`strlen
(
str
) / 2 <= 
len
);

40 while (*
str
)

42 
	`assert
(
len
);

43 *
buf
 = 
	`unhex_chr
(
str
[0]) << 4 | unhex_chr(str[1]);

44 
buf
++;

45 
used
++;

46 
str
 += 2;

47 
len
--;

50 return 
used
;

51 
	}
}

53 static 
inline
 void 
	$dump
(const char *
label
, const 
uint8_t
 *
buf
, 
size_t
 
len
)

55 
	`printf
("%s: ", 
label
);

56 for (
size_t
 
i
 = 0; i < 
len
; i++)

57 
	`printf
("%02x", 
buf
[
i
]);

58 
	`printf
("\n");

59 
	}
}

	@deps/picotls/deps/micro-ecc/test/test_compress.c

3 #include 
	~"uECC.h
"

5 #include 
	~<stdio.h
>

6 #include 
	~<string.h
>

8 #ifndef 
uECC_TEST_NUMBER_OF_ITERATIONS


9 #define 
	#uECC_TEST_NUMBER_OF_ITERATIONS
 256

	)

12 void 
	$vli_print
(char *
str
, 
uint8_t
 *
vli
, unsigned int 
size
) {

13 
	`printf
("%s ", 
str
);

14 for(unsigned 
i
=0; i<
size
; ++i) {

15 
	`printf
("%02X ", (unsigned)
vli
[
i
]);

17 
	`printf
("\n");

18 
	}
}

20 int 
	$main
() {

21 
uint8_t
 
public
[64];

22 
uint8_t
 
private
[32];

23 
uint8_t
 
compressed_point
[33];

24 
uint8_t
 
decompressed_point
[64];

26 int 
i
;

27 int 
c
;

29 const struct 
uECC_Curve_t
 * 
curves
[5];

30 int 
num_curves
 = 0;

31 #if 
uECC_SUPPORTS_secp160r1


32 
curves
[
num_curves
++] = 
	`uECC_secp160r1
();

34 #if 
uECC_SUPPORTS_secp192r1


35 
curves
[
num_curves
++] = 
	`uECC_secp192r1
();

37 #if 
uECC_SUPPORTS_secp224r1


38 
curves
[
num_curves
++] = 
	`uECC_secp224r1
();

40 #if 
uECC_SUPPORTS_secp256r1


41 
curves
[
num_curves
++] = 
	`uECC_secp256r1
();

43 #if 
uECC_SUPPORTS_secp256k1


44 
curves
[
num_curves
++] = 
	`uECC_secp256k1
();

47 
	`printf
("Testing compression and decompression of %d random EC points\n",

48 
uECC_TEST_NUMBER_OF_ITERATIONS
);

50 for (
c
 = 0; c < 
num_curves
; ++c) {

51 for (
i
 = 0; i < 
uECC_TEST_NUMBER_OF_ITERATIONS
; ++i) {

52 
	`printf
(".");

53 
	`fflush
(
stdout
);

55 
	`memset
(
public
, 0, sizeof(public));

56 
	`memset
(
decompressed_point
, 0, sizeof(decompressed_point));

59 if (!
	`uECC_make_key
(
public
, 
private
, 
curves
[
c
])) {

60 
	`printf
("uECC_make_key() failed\n");

65 
	`uECC_compress
(
public
, 
compressed_point
, 
curves
[
c
]);

66 
	`uECC_decompress
(
compressed_point
, 
decompressed_point
, 
curves
[
c
]);

68 if (
	`memcmp
(
public
, 
decompressed_point
, sizeof(public)) != 0) {

69 
	`printf
("Original and decompressed points are not identical!\n");

70 
	`vli_print
("Original point = ", 
public
, sizeof(public));

71 
	`vli_print
("Compressed point = ", 
compressed_point
, sizeof(compressed_point));

72 
	`vli_print
("Decompressed point = ", 
decompressed_point
, sizeof(decompressed_point));

75 
	`printf
("\n");

79 
	}
}

	@deps/picotls/deps/micro-ecc/test/test_compute.c

3 #include 
	~"uECC.h
"

5 #include 
	~<stdio.h
>

6 #include 
	~<string.h
>

8 void 
	$vli_print
(char *
str
, 
uint8_t
 *
vli
, unsigned int 
size
) {

9 
	`printf
("%s ", 
str
);

10 for(unsigned 
i
=0; i<
size
; ++i) {

11 
	`printf
("%02X ", (unsigned)
vli
[
i
]);

13 
	`printf
("\n");

14 
	}
}

16 int 
	$main
() {

17 int 
i
;

18 int 
success
;

19 
uint8_t
 
private
[32];

20 
uint8_t
 
public
[64];

21 
uint8_t
 
public_computed
[64];

23 int 
c
;

25 const struct 
uECC_Curve_t
 * 
curves
[5];

26 int 
num_curves
 = 0;

27 #if 
uECC_SUPPORTS_secp160r1


28 
curves
[
num_curves
++] = 
	`uECC_secp160r1
();

30 #if 
uECC_SUPPORTS_secp192r1


31 
curves
[
num_curves
++] = 
	`uECC_secp192r1
();

33 #if 
uECC_SUPPORTS_secp224r1


34 
curves
[
num_curves
++] = 
	`uECC_secp224r1
();

36 #if 
uECC_SUPPORTS_secp256r1


37 
curves
[
num_curves
++] = 
	`uECC_secp256r1
();

39 #if 
uECC_SUPPORTS_secp256k1


40 
curves
[
num_curves
++] = 
	`uECC_secp256k1
();

43 
	`printf
("Testing 256 random private key pairs\n");

44 for (
c
 = 0; c < 
num_curves
; ++c) {

45 for (
i
 = 0; i < 256; ++i) {

46 
	`printf
(".");

47 
	`fflush
(
stdout
);

49 
	`memset
(
public
, 0, sizeof(public));

50 
	`memset
(
public_computed
, 0, sizeof(public_computed));

52 if (!
	`uECC_make_key
(
public
, 
private
, 
curves
[
c
])) {

53 
	`printf
("uECC_make_key() failed\n");

57 if (!
	`uECC_compute_public_key
(
private
, 
public_computed
, 
curves
[
c
])) {

58 
	`printf
("uECC_compute_public_key() failed\n");

61 if (
	`memcmp
(
public
, 
public_computed
, sizeof(public)) != 0) {

62 
	`printf
("Computed and provided public keys are not identical!\n");

63 
	`vli_print
("Computed public key = ", 
public_computed
, sizeof(public_computed));

64 
	`vli_print
("Provided public key = ", 
public
, sizeof(public));

65 
	`vli_print
("Private key = ", 
private
, sizeof(private));

69 
	`printf
("\n");

70 
	`printf
("Testing private key = 0\n");

72 
	`memset
(
private
, 0, sizeof(private));

73 
success
 = 
	`uECC_compute_public_key
(
private
, 
public_computed
, 
curves
[
c
]);

74 if (
success
) {

75 
	`printf
("uECC_compute_public_key() should have failed\n");

77 
	`printf
("\n");

81 
	}
}

	@deps/picotls/deps/micro-ecc/test/test_ecdh.c

3 #include 
	~"uECC.h
"

5 #include 
	~<stdio.h
>

6 #include 
	~<string.h
>

8 void 
	$vli_print
(
uint8_t
 *
vli
, unsigned int 
size
) {

9 for(unsigned 
i
=0; i<
size
; ++i) {

10 
	`printf
("%02X ", (unsigned)
vli
[
i
]);

12 
	}
}

14 int 
	$main
() {

15 int 
i
, 
c
;

16 
uint8_t
 
private1
[32] = {0};

17 
uint8_t
 
private2
[32] = {0};

18 
uint8_t
 
public1
[64] = {0};

19 
uint8_t
 
public2
[64] = {0};

20 
uint8_t
 
secret1
[32] = {0};

21 
uint8_t
 
secret2
[32] = {0};

23 const struct 
uECC_Curve_t
 * 
curves
[5];

24 int 
num_curves
 = 0;

25 #if 
uECC_SUPPORTS_secp160r1


26 
curves
[
num_curves
++] = 
	`uECC_secp160r1
();

28 #if 
uECC_SUPPORTS_secp192r1


29 
curves
[
num_curves
++] = 
	`uECC_secp192r1
();

31 #if 
uECC_SUPPORTS_secp224r1


32 
curves
[
num_curves
++] = 
	`uECC_secp224r1
();

34 #if 
uECC_SUPPORTS_secp256r1


35 
curves
[
num_curves
++] = 
	`uECC_secp256r1
();

37 #if 
uECC_SUPPORTS_secp256k1


38 
curves
[
num_curves
++] = 
	`uECC_secp256k1
();

41 
	`printf
("Testing 256 random private key pairs\n");

43 for (
c
 = 0; c < 
num_curves
; ++c) {

44 for (
i
 = 0; i < 256; ++i) {

45 
	`printf
(".");

46 
	`fflush
(
stdout
);

48 if (!
	`uECC_make_key
(
public1
, 
private1
, 
curves
[
c
]) ||

49 !
	`uECC_make_key
(
public2
, 
private2
, 
curves
[
c
])) {

50 
	`printf
("uECC_make_key() failed\n");

54 if (!
	`uECC_shared_secret
(
public2
, 
private1
, 
secret1
, 
curves
[
c
])) {

55 
	`printf
("shared_secret() failed (1)\n");

59 if (!
	`uECC_shared_secret
(
public1
, 
private2
, 
secret2
, 
curves
[
c
])) {

60 
	`printf
("shared_secret() failed (2)\n");

64 if (
	`memcmp
(
secret1
, 
secret2
, sizeof(secret1)) != 0) {

65 
	`printf
("Shared secrets are not identical!\n");

66 
	`printf
("Private key 1 = ");

67 
	`vli_print
(
private1
, 32);

68 
	`printf
("\n");

69 
	`printf
("Private key 2 = ");

70 
	`vli_print
(
private2
, 32);

71 
	`printf
("\n");

72 
	`printf
("Public key 1 = ");

73 
	`vli_print
(
public1
, 64);

74 
	`printf
("\n");

75 
	`printf
("Public key 2 = ");

76 
	`vli_print
(
public2
, 64);

77 
	`printf
("\n");

78 
	`printf
("Shared secret 1 = ");

79 
	`vli_print
(
secret1
, 32);

80 
	`printf
("\n");

81 
	`printf
("Shared secret 2 = ");

82 
	`vli_print
(
secret2
, 32);

83 
	`printf
("\n");

86 
	`printf
("\n");

90 
	}
}

	@deps/picotls/deps/micro-ecc/test/test_ecdsa.c

3 #include 
	~"uECC.h
"

5 #include 
	~<stdio.h
>

6 #include 
	~<string.h
>

8 int 
	$main
() {

9 int 
i
, 
c
;

10 
uint8_t
 
private
[32] = {0};

11 
uint8_t
 
public
[64] = {0};

12 
uint8_t
 
hash
[32] = {0};

13 
uint8_t
 
sig
[64] = {0};

15 const struct 
uECC_Curve_t
 * 
curves
[5];

16 int 
num_curves
 = 0;

17 #if 
uECC_SUPPORTS_secp160r1


18 
curves
[
num_curves
++] = 
	`uECC_secp160r1
();

20 #if 
uECC_SUPPORTS_secp192r1


21 
curves
[
num_curves
++] = 
	`uECC_secp192r1
();

23 #if 
uECC_SUPPORTS_secp224r1


24 
curves
[
num_curves
++] = 
	`uECC_secp224r1
();

26 #if 
uECC_SUPPORTS_secp256r1


27 
curves
[
num_curves
++] = 
	`uECC_secp256r1
();

29 #if 
uECC_SUPPORTS_secp256k1


30 
curves
[
num_curves
++] = 
	`uECC_secp256k1
();

33 
	`printf
("Testing 256 signatures\n");

34 for (
c
 = 0; c < 
num_curves
; ++c) {

35 for (
i
 = 0; i < 256; ++i) {

36 
	`printf
(".");

37 
	`fflush
(
stdout
);

39 if (!
	`uECC_make_key
(
public
, 
private
, 
curves
[
c
])) {

40 
	`printf
("uECC_make_key() failed\n");

43 
	`memcpy
(
hash
, 
public
, sizeof(hash));

45 if (!
	`uECC_sign
(
private
, 
hash
, sizeof(hash), 
sig
, 
curves
[
c
])) {

46 
	`printf
("uECC_sign() failed\n");

50 if (!
	`uECC_verify
(
public
, 
hash
, sizeof(hash), 
sig
, 
curves
[
c
])) {

51 
	`printf
("uECC_verify() failed\n");

55 
	`printf
("\n");

59 
	}
}

	@deps/picotls/deps/micro-ecc/types.h

3 #ifndef 
_UECC_TYPES_H_


4 #define 
	#_UECC_TYPES_H_


	)

6 #ifndef 
uECC_PLATFORM


7 #if 
__AVR__


8 #define 
	#uECC_PLATFORM
 
uECC_avr


	)

9 #elif 
defined
(
__thumb2__
) || defined(
_M_ARMT
)

10 #define 
	#uECC_PLATFORM
 
uECC_arm_thumb2


	)

11 #elif 
defined
(
__thumb__
)

12 #define 
	#uECC_PLATFORM
 
uECC_arm_thumb


	)

13 #elif 
defined
(
__arm__
) || defined(
_M_ARM
)

14 #define 
	#uECC_PLATFORM
 
uECC_arm


	)

15 #elif 
defined
(
__aarch64__
)

16 #define 
	#uECC_PLATFORM
 
uECC_arm64


	)

17 #elif 
defined
(
__i386__
) || defined(
_M_IX86
) || defined(
_X86_
) || defined(
__I86__
)

18 #define 
	#uECC_PLATFORM
 
uECC_x86


	)

19 #elif 
defined
(
__amd64__
) || defined(
_M_X64
)

20 #define 
	#uECC_PLATFORM
 
uECC_x86_64


	)

22 #define 
	#uECC_PLATFORM
 
uECC_arch_other


	)

26 #ifndef 
uECC_ARM_USE_UMAAL


27 #if (
uECC_PLATFORM
 == 
uECC_arm
) && (
__ARM_ARCH
 >= 6)

28 #define 
	#uECC_ARM_USE_UMAAL
 1

	)

29 #elif (
uECC_PLATFORM
 == 
uECC_arm_thumb2
) && (
__ARM_ARCH
 >= 6) && !
__ARM_ARCH_7M__


30 #define 
	#uECC_ARM_USE_UMAAL
 1

	)

32 #define 
	#uECC_ARM_USE_UMAAL
 0

	)

36 #ifndef 
uECC_WORD_SIZE


37 #if 
uECC_PLATFORM
 == 
uECC_avr


38 #define 
	#uECC_WORD_SIZE
 1

	)

39 #elif (
uECC_PLATFORM
 == 
uECC_x86_64
 || uECC_PLATFORM == 
uECC_arm64
)

40 #define 
	#uECC_WORD_SIZE
 8

	)

42 #define 
	#uECC_WORD_SIZE
 4

	)

46 #if (
uECC_WORD_SIZE
 != 1) && (uECC_WORD_SIZE != 4) && (uECC_WORD_SIZE != 8)

50 #if ((
uECC_PLATFORM
 == 
uECC_avr
) && (
uECC_WORD_SIZE
 != 1))

51 #pragma 
message
 ("uECC_WORD_SIZE must be 1 for AVR")

52 #undef 
uECC_WORD_SIZE


53 #define 
	#uECC_WORD_SIZE
 1

	)

56 #if ((
uECC_PLATFORM
 == 
uECC_arm
 || uECC_PLATFORM == 
uECC_arm_thumb
 || \

57 
	guECC_PLATFORM
 == 
uECC_arm_thumb2
) && \

58 (
uECC_WORD_SIZE
 != 4))

59 #pragma 
message
 ("uECC_WORD_SIZE must be 4 for ARM")

60 #undef 
uECC_WORD_SIZE


61 #define 
	#uECC_WORD_SIZE
 4

	)

64 #if 
defined
(
__SIZEOF_INT128__
) || ((
__clang_major__
 * 100 + 
__clang_minor__
) >= 302)

65 #define 
	#SUPPORTS_INT128
 1

	)

67 #define 
	#SUPPORTS_INT128
 0

	)

70 typedef 
int8_t
 
	twordcount_t
;

71 typedef 
int16_t
 
	tbitcount_t
;

72 typedef 
int8_t
 
	tcmpresult_t
;

74 #if (
uECC_WORD_SIZE
 == 1)

76 typedef 
uint8_t
 
	tuECC_word_t
;

77 typedef 
uint16_t
 
	tuECC_dword_t
;

79 #define 
	#HIGH_BIT_SET
 0x80

	)

80 #define 
	#uECC_WORD_BITS
 8

	)

81 #define 
	#uECC_WORD_BITS_SHIFT
 3

	)

82 #define 
	#uECC_WORD_BITS_MASK
 0x07

	)

84 #elif (
uECC_WORD_SIZE
 == 4)

86 typedef 
uint32_t
 
	tuECC_word_t
;

87 typedef 
uint64_t
 
	tuECC_dword_t
;

89 #define 
	#HIGH_BIT_SET
 0x80000000

	)

90 #define 
	#uECC_WORD_BITS
 32

	)

91 #define 
	#uECC_WORD_BITS_SHIFT
 5

	)

92 #define 
	#uECC_WORD_BITS_MASK
 0x01F

	)

94 #elif (
uECC_WORD_SIZE
 == 8)

96 typedef 
uint64_t
 
	tuECC_word_t
;

97 #if 
SUPPORTS_INT128


98 typedef unsigned 
	t__int128
 
	tuECC_dword_t
;

101 #define 
	#HIGH_BIT_SET
 0x8000000000000000ull

	)

102 #define 
	#uECC_WORD_BITS
 64

	)

103 #define 
	#uECC_WORD_BITS_SHIFT
 6

	)

104 #define 
	#uECC_WORD_BITS_MASK
 0x03F

	)

	@deps/picotls/deps/micro-ecc/uECC.c

3 #include 
	~"uECC.h
"

4 #include 
	~"uECC_vli.h
"

6 #ifndef 
uECC_RNG_MAX_TRIES


7 #define 
	#uECC_RNG_MAX_TRIES
 64

	)

10 #if 
uECC_ENABLE_VLI_API


11 #define 
	#uECC_VLI_API


	)

13 #define 
	#uECC_VLI_API
 static

	)

16 #define 
	#CONCATX
(
a
, ...) a ## 
__VA_ARGS__


	)

17 #define 
	#CONCAT
(
a
, ...) 
	`CONCATX
(a, 
__VA_ARGS__
)

	)

19 #define 
	#STRX
(
a
) #a

	)

20 #define 
	#STR
(
a
) 
	`STRX
(a)

	)

22 #define 
	#EVAL
(...) 
	`EVAL1
(EVAL1(EVAL1(EVAL1(
__VA_ARGS__
))))

	)

23 #define 
	#EVAL1
(...) 
	`EVAL2
(EVAL2(EVAL2(EVAL2(
__VA_ARGS__
))))

	)

24 #define 
	#EVAL2
(...) 
	`EVAL3
(EVAL3(EVAL3(EVAL3(
__VA_ARGS__
))))

	)

25 #define 
	#EVAL3
(...) 
	`EVAL4
(EVAL4(EVAL4(EVAL4(
__VA_ARGS__
))))

	)

26 #define 
	#EVAL4
(...) 
__VA_ARGS__


	)

28 #define 
	#DEC_1
 0

	)

29 #define 
	#DEC_2
 1

	)

30 #define 
	#DEC_3
 2

	)

31 #define 
	#DEC_4
 3

	)

32 #define 
	#DEC_5
 4

	)

33 #define 
	#DEC_6
 5

	)

34 #define 
	#DEC_7
 6

	)

35 #define 
	#DEC_8
 7

	)

36 #define 
	#DEC_9
 8

	)

37 #define 
	#DEC_10
 9

	)

38 #define 
	#DEC_11
 10

	)

39 #define 
	#DEC_12
 11

	)

40 #define 
	#DEC_13
 12

	)

41 #define 
	#DEC_14
 13

	)

42 #define 
	#DEC_15
 14

	)

43 #define 
	#DEC_16
 15

	)

44 #define 
	#DEC_17
 16

	)

45 #define 
	#DEC_18
 17

	)

46 #define 
	#DEC_19
 18

	)

47 #define 
	#DEC_20
 19

	)

48 #define 
	#DEC_21
 20

	)

49 #define 
	#DEC_22
 21

	)

50 #define 
	#DEC_23
 22

	)

51 #define 
	#DEC_24
 23

	)

52 #define 
	#DEC_25
 24

	)

53 #define 
	#DEC_26
 25

	)

54 #define 
	#DEC_27
 26

	)

55 #define 
	#DEC_28
 27

	)

56 #define 
	#DEC_29
 28

	)

57 #define 
	#DEC_30
 29

	)

58 #define 
	#DEC_31
 30

	)

59 #define 
	#DEC_32
 31

	)

61 #define 
	#DEC
(
N
) 
	`CONCAT
(
DEC_
, N)

	)

63 #define 
	#SECOND_ARG
(
_
, 
val
, ...) 
	)
val

64 #define 
	#SOME_CHECK_0
 ~, 0

	)

65 #define 
	#GET_SECOND_ARG
(...) 
	`SECOND_ARG
(
__VA_ARGS__
, 
SOME
,)

	)

66 #define 
	#SOME_OR_0
(
N
) 
	`GET_SECOND_ARG
(
	`CONCAT
(
SOME_CHECK_
, N))

	)

68 #define 
	#EMPTY
(...)

	)

69 #define 
	#DEFER
(...) 
__VA_ARGS__
 
	`EMPTY
()

	)

71 #define 
	#REPEAT_NAME_0
() 
REPEAT_0


	)

72 #define 
	#REPEAT_NAME_SOME
() 
REPEAT_SOME


	)

73 #define 
	#REPEAT_0
(...)

	)

74 #define 
	#REPEAT_SOME
(
N
, 
stuff
) 
	`DEFER
(
	`CONCAT
(
REPEAT_NAME_
, 
	`SOME_OR_0
(
	`DEC
(N))))()(DEC(N), stuff) 
	)
stuff

75 #define 
	#REPEAT
(
N
, 
stuff
) 
	`EVAL
(
	`REPEAT_SOME
(N, stuff))

	)

77 #define 
	#REPEATM_NAME_0
() 
REPEATM_0


	)

78 #define 
	#REPEATM_NAME_SOME
() 
REPEATM_SOME


	)

79 #define 
	#REPEATM_0
(...)

	)

80 #define 
	#REPEATM_SOME
(
N
, 
macro
) 
	`macro
(N) \

81 
	`DEFER
(
	`CONCAT
(
REPEATM_NAME_
, 
	`SOME_OR_0
(
	`DEC
(
N
))))()(DEC(N), 
macro
)

	)

82 #define 
	#REPEATM
(
N
, 
macro
) 
	`EVAL
(
	`REPEATM_SOME
(N, macro))

	)

84 #include 
	~"platform-specific.inc
"

86 #if (
uECC_WORD_SIZE
 == 1)

87 #if 
uECC_SUPPORTS_secp160r1


88 #define 
	#uECC_MAX_WORDS
 21

	)

90 #if 
uECC_SUPPORTS_secp192r1


91 #undef 
uECC_MAX_WORDS


92 #define 
	#uECC_MAX_WORDS
 24

	)

94 #if 
uECC_SUPPORTS_secp224r1


95 #undef 
uECC_MAX_WORDS


96 #define 
	#uECC_MAX_WORDS
 28

	)

98 #if (
uECC_SUPPORTS_secp256r1
 || 
uECC_SUPPORTS_secp256k1
)

99 #undef 
uECC_MAX_WORDS


100 #define 
	#uECC_MAX_WORDS
 32

	)

102 #elif (
uECC_WORD_SIZE
 == 4)

103 #if 
uECC_SUPPORTS_secp160r1


104 #define 
	#uECC_MAX_WORDS
 6

	)

106 #if 
uECC_SUPPORTS_secp192r1


107 #undef 
uECC_MAX_WORDS


108 #define 
	#uECC_MAX_WORDS
 6

	)

110 #if 
uECC_SUPPORTS_secp224r1


111 #undef 
uECC_MAX_WORDS


112 #define 
	#uECC_MAX_WORDS
 7

	)

114 #if (
uECC_SUPPORTS_secp256r1
 || 
uECC_SUPPORTS_secp256k1
)

115 #undef 
uECC_MAX_WORDS


116 #define 
	#uECC_MAX_WORDS
 8

	)

118 #elif (
uECC_WORD_SIZE
 == 8)

119 #if 
uECC_SUPPORTS_secp160r1


120 #define 
	#uECC_MAX_WORDS
 3

	)

122 #if 
uECC_SUPPORTS_secp192r1


123 #undef 
uECC_MAX_WORDS


124 #define 
	#uECC_MAX_WORDS
 3

	)

126 #if 
uECC_SUPPORTS_secp224r1


127 #undef 
uECC_MAX_WORDS


128 #define 
	#uECC_MAX_WORDS
 4

	)

130 #if (
uECC_SUPPORTS_secp256r1
 || 
uECC_SUPPORTS_secp256k1
)

131 #undef 
uECC_MAX_WORDS


132 #define 
	#uECC_MAX_WORDS
 4

	)

136 #define 
	#BITS_TO_WORDS
(
num_bits
) ((num_bits + ((
uECC_WORD_SIZE
 * 8) - 1)) / (uECC_WORD_SIZE * 8))

	)

137 #define 
	#BITS_TO_BYTES
(
num_bits
) ((num_bits + 7) / 8)

	)

139 struct 
	suECC_Curve_t
 {

140 
wordcount_t
 
	mnum_words
;

141 
wordcount_t
 
	mnum_bytes
;

142 
bitcount_t
 
	mnum_n_bits
;

143 
uECC_word_t
 
	mp
[
uECC_MAX_WORDS
];

144 
uECC_word_t
 
	mn
[
uECC_MAX_WORDS
];

145 
uECC_word_t
 
	mG
[
uECC_MAX_WORDS
 * 2];

146 
uECC_word_t
 
	mb
[
uECC_MAX_WORDS
];

147 void (*
	mdouble_jacobian
)(
uECC_word_t
 * 
	mX1
,

148 
uECC_word_t
 * 
	mY1
,

149 
uECC_word_t
 * 
	mZ1
,

150 
uECC_Curve
 
	mcurve
);

151 #if 
uECC_SUPPORT_COMPRESSED_POINT


152 void (*
	mmod_sqrt
)(
uECC_word_t
 *
	ma
, 
uECC_Curve
 
	mcurve
);

154 void (*
	mx_side
)(
uECC_word_t
 *
	mresult
, const uECC_word_t *
	mx
, 
uECC_Curve
 
	mcurve
);

155 #if (
uECC_OPTIMIZATION_LEVEL
 > 0)

156 void (*
	mmmod_fast
)(
uECC_word_t
 *
	mresult
, uECC_word_t *
	mproduct
);

160 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


161 static void 
	$bcopy
(
uint8_t
 *
dst
,

162 const 
uint8_t
 *
src
,

163 unsigned 
num_bytes
) {

164 while (0 != 
num_bytes
) {

165 
num_bytes
--;

166 
dst
[
num_bytes
] = 
src
[num_bytes];

168 
	}
}

171 static 
cmpresult_t
 
uECC_vli_cmp_unsafe
(const 
uECC_word_t
 *
left
,

172 const 
uECC_word_t
 *
right
,

173 
wordcount_t
 
num_words
);

175 #if (
uECC_PLATFORM
 == 
uECC_arm
 || uECC_PLATFORM == 
uECC_arm_thumb
 || \

176 
	guECC_PLATFORM
 == 
uECC_arm_thumb2
)

177 #include 
	~"asm_arm.inc
"

180 #if (
uECC_PLATFORM
 == 
uECC_avr
)

181 #include 
	~"asm_avr.inc
"

184 #if 
default_RNG_defined


185 static 
uECC_RNG_Function
 
g_rng_function
 = &
default_RNG
;

187 static 
uECC_RNG_Function
 
	gg_rng_function
 = 0;

190 void 
	$uECC_set_rng
(
uECC_RNG_Function
 
rng_function
) {

191 
g_rng_function
 = 
rng_function
;

192 
	}
}

194 
uECC_RNG_Function
 
	$uECC_get_rng
(void) {

195 return 
g_rng_function
;

196 
	}
}

198 int 
	$uECC_curve_private_key_size
(
uECC_Curve
 
curve
) {

199 return 
	`BITS_TO_BYTES
(
curve
->
num_n_bits
);

200 
	}
}

202 int 
	$uECC_curve_public_key_size
(
uECC_Curve
 
curve
) {

203 return 2 * 
curve
->
num_bytes
;

204 
	}
}

206 #if !
asm_clear


207 
uECC_VLI_API
 void 
	$uECC_vli_clear
(
uECC_word_t
 *
vli
, 
wordcount_t
 
num_words
) {

208 
wordcount_t
 
i
;

209 for (
i
 = 0; i < 
num_words
; ++i) {

210 
vli
[
i
] = 0;

212 
	}
}

217 
uECC_VLI_API
 
uECC_word_t
 
	$uECC_vli_isZero
(const 
uECC_word_t
 *
vli
, 
wordcount_t
 
num_words
) {

218 
uECC_word_t
 
bits
 = 0;

219 
wordcount_t
 
i
;

220 for (
i
 = 0; i < 
num_words
; ++i) {

221 
bits
 |= 
vli
[
i
];

223 return (
bits
 == 0);

224 
	}
}

227 
uECC_VLI_API
 
uECC_word_t
 
	$uECC_vli_testBit
(const 
uECC_word_t
 *
vli
, 
bitcount_t
 
bit
) {

228 return (
vli
[
bit
 >> 
uECC_WORD_BITS_SHIFT
] & ((
uECC_word_t
)1 << (bit & 
uECC_WORD_BITS_MASK
)));

229 
	}
}

232 static 
wordcount_t
 
	$vli_numDigits
(const 
uECC_word_t
 *
vli
, const 
wordcount_t
 
max_words
) {

233 
wordcount_t
 
i
;

236 for (
i
 = 
max_words
 - 1; i >= 0 && 
vli
[i] == 0; --i) {

239 return (
i
 + 1);

240 
	}
}

243 
uECC_VLI_API
 
bitcount_t
 
	$uECC_vli_numBits
(const 
uECC_word_t
 *
vli
, const 
wordcount_t
 
max_words
) {

244 
uECC_word_t
 
i
;

245 
uECC_word_t
 
digit
;

247 
wordcount_t
 
num_digits
 = 
	`vli_numDigits
(
vli
, 
max_words
);

248 if (
num_digits
 == 0) {

252 
digit
 = 
vli
[
num_digits
 - 1];

253 for (
i
 = 0; 
digit
; ++i) {

254 
digit
 >>= 1;

257 return (((
bitcount_t
)(
num_digits
 - 1) << 
uECC_WORD_BITS_SHIFT
) + 
i
);

258 
	}
}

261 #if !
asm_set


262 
uECC_VLI_API
 void 
	$uECC_vli_set
(
uECC_word_t
 *
dest
, const uECC_word_t *
src
, 
wordcount_t
 
num_words
) {

263 
wordcount_t
 
i
;

264 for (
i
 = 0; i < 
num_words
; ++i) {

265 
dest
[
i
] = 
src
[i];

267 
	}
}

271 static 
cmpresult_t
 
	$uECC_vli_cmp_unsafe
(const 
uECC_word_t
 *
left
,

272 const 
uECC_word_t
 *
right
,

273 
wordcount_t
 
num_words
) {

274 
wordcount_t
 
i
;

275 for (
i
 = 
num_words
 - 1; i >= 0; --i) {

276 if (
left
[
i
] > 
right
[i]) {

278 } else if (
left
[
i
] < 
right
[i]) {

283 
	}
}

287 
uECC_VLI_API
 
uECC_word_t
 
	$uECC_vli_equal
(const 
uECC_word_t
 *
left
,

288 const 
uECC_word_t
 *
right
,

289 
wordcount_t
 
num_words
) {

290 
uECC_word_t
 
diff
 = 0;

291 
wordcount_t
 
i
;

292 for (
i
 = 
num_words
 - 1; i >= 0; --i) {

293 
diff
 |= (
left
[
i
] ^ 
right
[i]);

295 return (
diff
 == 0);

296 
	}
}

298 
uECC_VLI_API
 
uECC_word_t
 
uECC_vli_sub
(uECC_word_t *
result
,

299 const 
uECC_word_t
 *
left
,

300 const 
uECC_word_t
 *
right
,

301 
wordcount_t
 
num_words
);

304 
uECC_VLI_API
 
cmpresult_t
 
	$uECC_vli_cmp
(const 
uECC_word_t
 *
left
,

305 const 
uECC_word_t
 *
right
,

306 
wordcount_t
 
num_words
) {

307 
uECC_word_t
 
tmp
[
uECC_MAX_WORDS
];

308 
uECC_word_t
 
neg
 = !!
	`uECC_vli_sub
(
tmp
, 
left
, 
right
, 
num_words
);

309 
uECC_word_t
 
equal
 = 
	`uECC_vli_isZero
(
tmp
, 
num_words
);

310 return (
cmpresult_t
)(!
equal
 - 2 * 
neg
);

311 
	}
}

314 #if !
asm_rshift1


315 
uECC_VLI_API
 void 
	$uECC_vli_rshift1
(
uECC_word_t
 *
vli
, 
wordcount_t
 
num_words
) {

316 
uECC_word_t
 *
end
 = 
vli
;

317 
uECC_word_t
 
carry
 = 0;

319 
vli
 += 
num_words
;

320 while (
vli
-- > 
end
) {

321 
uECC_word_t
 
temp
 = *
vli
;

322 *
vli
 = (
temp
 >> 1) | 
carry
;

323 
carry
 = 
temp
 << (
uECC_WORD_BITS
 - 1);

325 
	}
}

329 #if !
asm_add


330 
uECC_VLI_API
 
uECC_word_t
 
	$uECC_vli_add
(
uECC_word_t
 *
result
,

331 const 
uECC_word_t
 *
left
,

332 const 
uECC_word_t
 *
right
,

333 
wordcount_t
 
num_words
) {

334 
uECC_word_t
 
carry
 = 0;

335 
wordcount_t
 
i
;

336 for (
i
 = 0; i < 
num_words
; ++i) {

337 
uECC_word_t
 
sum
 = 
left
[
i
] + 
right
[i] + 
carry
;

338 if (
sum
 != 
left
[
i
]) {

339 
carry
 = (
sum
 < 
left
[
i
]);

341 
result
[
i
] = 
sum
;

343 return 
carry
;

344 
	}
}

348 #if !
asm_sub


349 
uECC_VLI_API
 
uECC_word_t
 
	$uECC_vli_sub
(
uECC_word_t
 *
result
,

350 const 
uECC_word_t
 *
left
,

351 const 
uECC_word_t
 *
right
,

352 
wordcount_t
 
num_words
) {

353 
uECC_word_t
 
borrow
 = 0;

354 
wordcount_t
 
i
;

355 for (
i
 = 0; i < 
num_words
; ++i) {

356 
uECC_word_t
 
diff
 = 
left
[
i
] - 
right
[i] - 
borrow
;

357 if (
diff
 != 
left
[
i
]) {

358 
borrow
 = (
diff
 > 
left
[
i
]);

360 
result
[
i
] = 
diff
;

362 return 
borrow
;

363 
	}
}

366 #if !
asm_mult
 || (
uECC_SQUARE_FUNC
 && !
asm_square
) || \

367 (
	guECC_SUPPORTS_secp256k1
 && (
	guECC_OPTIMIZATION_LEVEL
 > 0) && \

368 ((
	guECC_WORD_SIZE
 == 1) || (
uECC_WORD_SIZE
 == 8)))

369 static void 
	$muladd
(
uECC_word_t
 
a
,

370 
uECC_word_t
 
b
,

371 
uECC_word_t
 *
r0
,

372 
uECC_word_t
 *
r1
,

373 
uECC_word_t
 *
r2
) {

374 #if 
uECC_WORD_SIZE
 == 8 && !
SUPPORTS_INT128


375 
uint64_t
 
a0
 = 
a
 & 0xffffffffull;

376 
uint64_t
 
a1
 = 
a
 >> 32;

377 
uint64_t
 
b0
 = 
b
 & 0xffffffffull;

378 
uint64_t
 
b1
 = 
b
 >> 32;

380 
uint64_t
 
i0
 = 
a0
 * 
b0
;

381 
uint64_t
 
i1
 = 
a0
 * 
b1
;

382 
uint64_t
 
i2
 = 
a1
 * 
b0
;

383 
uint64_t
 
i3
 = 
a1
 * 
b1
;

385 
uint64_t
 
p0
, 
p1
;

387 
i2
 += (
i0
 >> 32);

388 
i2
 += 
i1
;

389 if (
i2
 < 
i1
) {

390 
i3
 += 0x100000000ull;

393 
p0
 = (
i0
 & 0xffffffffull) | (
i2
 << 32);

394 
p1
 = 
i3
 + (
i2
 >> 32);

396 *
r0
 += 
p0
;

397 *
r1
 += (
p1
 + (*
r0
 < 
p0
));

398 *
r2
 += ((*
r1
 < 
p1
) || (*r1 == p1 && *
r0
 < 
p0
));

400 
uECC_dword_t
 
p
 = (uECC_dword_t)
a
 * 
b
;

401 
uECC_dword_t
 
r01
 = ((uECC_dword_t)(*
r1
) << 
uECC_WORD_BITS
) | *
r0
;

402 
r01
 += 
p
;

403 *
r2
 += (
r01
 < 
p
);

404 *
r1
 = 
r01
 >> 
uECC_WORD_BITS
;

405 *
r0
 = (
uECC_word_t
)
r01
;

407 
	}
}

410 #if !
asm_mult


411 
uECC_VLI_API
 void 
	$uECC_vli_mult
(
uECC_word_t
 *
result
,

412 const 
uECC_word_t
 *
left
,

413 const 
uECC_word_t
 *
right
,

414 
wordcount_t
 
num_words
) {

415 
uECC_word_t
 
r0
 = 0;

416 
uECC_word_t
 
r1
 = 0;

417 
uECC_word_t
 
r2
 = 0;

418 
wordcount_t
 
i
, 
k
;

421 for (
k
 = 0; k < 
num_words
; ++k) {

422 for (
i
 = 0; i <= 
k
; ++i) {

423 
	`muladd
(
left
[
i
], 
right
[
k
 - i], &
r0
, &
r1
, &
r2
);

425 
result
[
k
] = 
r0
;

426 
r0
 = 
r1
;

427 
r1
 = 
r2
;

428 
r2
 = 0;

430 for (
k
 = 
num_words
; k < num_words * 2 - 1; ++k) {

431 for (
i
 = (
k
 + 1) - 
num_words
; i < num_words; ++i) {

432 
	`muladd
(
left
[
i
], 
right
[
k
 - i], &
r0
, &
r1
, &
r2
);

434 
result
[
k
] = 
r0
;

435 
r0
 = 
r1
;

436 
r1
 = 
r2
;

437 
r2
 = 0;

439 
result
[
num_words
 * 2 - 1] = 
r0
;

440 
	}
}

443 #if 
uECC_SQUARE_FUNC


445 #if !
asm_square


446 static void 
	$mul2add
(
uECC_word_t
 
a
,

447 
uECC_word_t
 
b
,

448 
uECC_word_t
 *
r0
,

449 
uECC_word_t
 *
r1
,

450 
uECC_word_t
 *
r2
) {

451 #if 
uECC_WORD_SIZE
 == 8 && !
SUPPORTS_INT128


452 
uint64_t
 
a0
 = 
a
 & 0xffffffffull;

453 
uint64_t
 
a1
 = 
a
 >> 32;

454 
uint64_t
 
b0
 = 
b
 & 0xffffffffull;

455 
uint64_t
 
b1
 = 
b
 >> 32;

457 
uint64_t
 
i0
 = 
a0
 * 
b0
;

458 
uint64_t
 
i1
 = 
a0
 * 
b1
;

459 
uint64_t
 
i2
 = 
a1
 * 
b0
;

460 
uint64_t
 
i3
 = 
a1
 * 
b1
;

462 
uint64_t
 
p0
, 
p1
;

464 
i2
 += (
i0
 >> 32);

465 
i2
 += 
i1
;

466 if (
i2
 < 
i1
)

468 
i3
 += 0x100000000ull;

471 
p0
 = (
i0
 & 0xffffffffull) | (
i2
 << 32);

472 
p1
 = 
i3
 + (
i2
 >> 32);

474 *
r2
 += (
p1
 >> 63);

475 
p1
 = (p1 << 1) | (
p0
 >> 63);

476 
p0
 <<= 1;

478 *
r0
 += 
p0
;

479 *
r1
 += (
p1
 + (*
r0
 < 
p0
));

480 *
r2
 += ((*
r1
 < 
p1
) || (*r1 == p1 && *
r0
 < 
p0
));

482 
uECC_dword_t
 
p
 = (uECC_dword_t)
a
 * 
b
;

483 
uECC_dword_t
 
r01
 = ((uECC_dword_t)(*
r1
) << 
uECC_WORD_BITS
) | *
r0
;

484 *
r2
 += (
p
 >> (
uECC_WORD_BITS
 * 2 - 1));

485 
p
 *= 2;

486 
r01
 += 
p
;

487 *
r2
 += (
r01
 < 
p
);

488 *
r1
 = 
r01
 >> 
uECC_WORD_BITS
;

489 *
r0
 = (
uECC_word_t
)
r01
;

491 
	}
}

493 
uECC_VLI_API
 void 
	$uECC_vli_square
(
uECC_word_t
 *
result
,

494 const 
uECC_word_t
 *
left
,

495 
wordcount_t
 
num_words
) {

496 
uECC_word_t
 
r0
 = 0;

497 
uECC_word_t
 
r1
 = 0;

498 
uECC_word_t
 
r2
 = 0;

500 
wordcount_t
 
i
, 
k
;

502 for (
k
 = 0; k < 
num_words
 * 2 - 1; ++k) {

503 
uECC_word_t
 
min
 = (
k
 < 
num_words
 ? 0 : (k + 1) - num_words);

504 for (
i
 = 
min
; i <= 
k
 && i <= k - i; ++i) {

505 if (
i
 < 
k
-i) {

506 
	`mul2add
(
left
[
i
], left[
k
 - i], &
r0
, &
r1
, &
r2
);

508 
	`muladd
(
left
[
i
], left[
k
 - i], &
r0
, &
r1
, &
r2
);

511 
result
[
k
] = 
r0
;

512 
r0
 = 
r1
;

513 
r1
 = 
r2
;

514 
r2
 = 0;

517 
result
[
num_words
 * 2 - 1] = 
r0
;

518 
	}
}

523 #if 
uECC_ENABLE_VLI_API


524 
uECC_VLI_API
 void 
	$uECC_vli_square
(
uECC_word_t
 *
result
,

525 const 
uECC_word_t
 *
left
,

526 
wordcount_t
 
num_words
) {

527 
	`uECC_vli_mult
(
result
, 
left
, left, 
num_words
);

528 
	}
}

535 
uECC_VLI_API
 void 
	$uECC_vli_modAdd
(
uECC_word_t
 *
result
,

536 const 
uECC_word_t
 *
left
,

537 const 
uECC_word_t
 *
right
,

538 const 
uECC_word_t
 *
mod
,

539 
wordcount_t
 
num_words
) {

540 
uECC_word_t
 
carry
 = 
	`uECC_vli_add
(
result
, 
left
, 
right
, 
num_words
);

541 if (
carry
 || 
	`uECC_vli_cmp_unsafe
(
mod
, 
result
, 
num_words
) != 1) {

543 
	`uECC_vli_sub
(
result
, result, 
mod
, 
num_words
);

545 
	}
}

549 
uECC_VLI_API
 void 
	$uECC_vli_modSub
(
uECC_word_t
 *
result
,

550 const 
uECC_word_t
 *
left
,

551 const 
uECC_word_t
 *
right
,

552 const 
uECC_word_t
 *
mod
,

553 
wordcount_t
 
num_words
) {

554 
uECC_word_t
 
l_borrow
 = 
	`uECC_vli_sub
(
result
, 
left
, 
right
, 
num_words
);

555 if (
l_borrow
) {

558 
	`uECC_vli_add
(
result
, result, 
mod
, 
num_words
);

560 
	}
}

564 
uECC_VLI_API
 void 
	$uECC_vli_mmod
(
uECC_word_t
 *
result
,

565 
uECC_word_t
 *
product
,

566 const 
uECC_word_t
 *
mod
,

567 
wordcount_t
 
num_words
) {

568 
uECC_word_t
 
mod_multiple
[2 * 
uECC_MAX_WORDS
];

569 
uECC_word_t
 
tmp
[2 * 
uECC_MAX_WORDS
];

570 
uECC_word_t
 *
v
[2] = {
tmp
, 
product
};

571 
uECC_word_t
 
index
;

574 
bitcount_t
 
shift
 = (
num_words
 * 2 * 
uECC_WORD_BITS
) - 
	`uECC_vli_numBits
(
mod
, num_words);

575 
wordcount_t
 
word_shift
 = 
shift
 / 
uECC_WORD_BITS
;

576 
wordcount_t
 
bit_shift
 = 
shift
 % 
uECC_WORD_BITS
;

577 
uECC_word_t
 
carry
 = 0;

578 
	`uECC_vli_clear
(
mod_multiple
, 
word_shift
);

579 if (
bit_shift
 > 0) {

580 for(
index
 = 0; index < (
uECC_word_t
)
num_words
; ++index) {

581 
mod_multiple
[
word_shift
 + 
index
] = (
mod
[index] << 
bit_shift
) | 
carry
;

582 
carry
 = 
mod
[
index
] >> (
uECC_WORD_BITS
 - 
bit_shift
);

585 
	`uECC_vli_set
(
mod_multiple
 + 
word_shift
, 
mod
, 
num_words
);

588 for (
index
 = 1; 
shift
 >= 0; --shift) {

589 
uECC_word_t
 
borrow
 = 0;

590 
wordcount_t
 
i
;

591 for (
i
 = 0; i < 
num_words
 * 2; ++i) {

592 
uECC_word_t
 
diff
 = 
v
[
index
][
i
] - 
mod_multiple
[i] - 
borrow
;

593 if (
diff
 != 
v
[
index
][
i
]) {

594 
borrow
 = (
diff
 > 
v
[
index
][
i
]);

596 
v
[1 - 
index
][
i
] = 
diff
;

598 
index
 = !(index ^ 
borrow
);

599 
	`uECC_vli_rshift1
(
mod_multiple
, 
num_words
);

600 
mod_multiple
[
num_words
 - 1] |= mod_multiple[num_words] << (
uECC_WORD_BITS
 - 1);

601 
	`uECC_vli_rshift1
(
mod_multiple
 + 
num_words
, num_words);

603 
	`uECC_vli_set
(
result
, 
v
[
index
], 
num_words
);

604 
	}
}

607 
uECC_VLI_API
 void 
	$uECC_vli_modMult
(
uECC_word_t
 *
result
,

608 const 
uECC_word_t
 *
left
,

609 const 
uECC_word_t
 *
right
,

610 const 
uECC_word_t
 *
mod
,

611 
wordcount_t
 
num_words
) {

612 
uECC_word_t
 
product
[2 * 
uECC_MAX_WORDS
];

613 
	`uECC_vli_mult
(
product
, 
left
, 
right
, 
num_words
);

614 
	`uECC_vli_mmod
(
result
, 
product
, 
mod
, 
num_words
);

615 
	}
}

617 
uECC_VLI_API
 void 
	$uECC_vli_modMult_fast
(
uECC_word_t
 *
result
,

618 const 
uECC_word_t
 *
left
,

619 const 
uECC_word_t
 *
right
,

620 
uECC_Curve
 
curve
) {

621 
uECC_word_t
 
product
[2 * 
uECC_MAX_WORDS
];

622 
	`uECC_vli_mult
(
product
, 
left
, 
right
, 
curve
->
num_words
);

623 #if (
uECC_OPTIMIZATION_LEVEL
 > 0)

624 
curve
->
	`mmod_fast
(
result
, 
product
);

626 
	`uECC_vli_mmod
(
result
, 
product
, 
curve
->
p
, curve->
num_words
);

628 
	}
}

630 #if 
uECC_SQUARE_FUNC


632 #if 
uECC_ENABLE_VLI_API


634 
uECC_VLI_API
 void 
	$uECC_vli_modSquare
(
uECC_word_t
 *
result
,

635 const 
uECC_word_t
 *
left
,

636 const 
uECC_word_t
 *
mod
,

637 
wordcount_t
 
num_words
) {

638 
uECC_word_t
 
product
[2 * 
uECC_MAX_WORDS
];

639 
	`uECC_vli_square
(
product
, 
left
, 
num_words
);

640 
	`uECC_vli_mmod
(
result
, 
product
, 
mod
, 
num_words
);

641 
	}
}

644 
uECC_VLI_API
 void 
	$uECC_vli_modSquare_fast
(
uECC_word_t
 *
result
,

645 const 
uECC_word_t
 *
left
,

646 
uECC_Curve
 
curve
) {

647 
uECC_word_t
 
product
[2 * 
uECC_MAX_WORDS
];

648 
	`uECC_vli_square
(
product
, 
left
, 
curve
->
num_words
);

649 #if (
uECC_OPTIMIZATION_LEVEL
 > 0)

650 
curve
->
	`mmod_fast
(
result
, 
product
);

652 
	`uECC_vli_mmod
(
result
, 
product
, 
curve
->
p
, curve->
num_words
);

654 
	}
}

658 #if 
uECC_ENABLE_VLI_API


659 
uECC_VLI_API
 void 
	$uECC_vli_modSquare
(
uECC_word_t
 *
result
,

660 const 
uECC_word_t
 *
left
,

661 const 
uECC_word_t
 *
mod
,

662 
wordcount_t
 
num_words
) {

663 
	`uECC_vli_modMult
(
result
, 
left
, left, 
mod
, 
num_words
);

664 
	}
}

667 
uECC_VLI_API
 void 
	$uECC_vli_modSquare_fast
(
uECC_word_t
 *
result
,

668 const 
uECC_word_t
 *
left
,

669 
uECC_Curve
 
curve
) {

670 
	`uECC_vli_modMult_fast
(
result
, 
left
, left, 
curve
);

671 
	}
}

675 #define 
	#EVEN
(
vli
) (!(vli[0] & 1))

	)

676 static void 
	$vli_modInv_update
(
uECC_word_t
 *
uv
,

677 const 
uECC_word_t
 *
mod
,

678 
wordcount_t
 
num_words
) {

679 
uECC_word_t
 
carry
 = 0;

680 if (!
	`EVEN
(
uv
)) {

681 
carry
 = 
	`uECC_vli_add
(
uv
, uv, 
mod
, 
num_words
);

683 
	`uECC_vli_rshift1
(
uv
, 
num_words
);

684 if (
carry
) {

685 
uv
[
num_words
 - 1] |= 
HIGH_BIT_SET
;

687 
	}
}

691 
uECC_VLI_API
 void 
	$uECC_vli_modInv
(
uECC_word_t
 *
result
,

692 const 
uECC_word_t
 *
input
,

693 const 
uECC_word_t
 *
mod
,

694 
wordcount_t
 
num_words
) {

695 
uECC_word_t
 
a
[
uECC_MAX_WORDS
], 
b
[uECC_MAX_WORDS], 
u
[uECC_MAX_WORDS], 
v
[uECC_MAX_WORDS];

696 
cmpresult_t
 
cmpResult
;

698 if (
	`uECC_vli_isZero
(
input
, 
num_words
)) {

699 
	`uECC_vli_clear
(
result
, 
num_words
);

703 
	`uECC_vli_set
(
a
, 
input
, 
num_words
);

704 
	`uECC_vli_set
(
b
, 
mod
, 
num_words
);

705 
	`uECC_vli_clear
(
u
, 
num_words
);

706 
u
[0] = 1;

707 
	`uECC_vli_clear
(
v
, 
num_words
);

708 while ((
cmpResult
 = 
	`uECC_vli_cmp_unsafe
(
a
, 
b
, 
num_words
)) != 0) {

709 if (
	`EVEN
(
a
)) {

710 
	`uECC_vli_rshift1
(
a
, 
num_words
);

711 
	`vli_modInv_update
(
u
, 
mod
, 
num_words
);

712 } else if (
	`EVEN
(
b
)) {

713 
	`uECC_vli_rshift1
(
b
, 
num_words
);

714 
	`vli_modInv_update
(
v
, 
mod
, 
num_words
);

715 } else if (
cmpResult
 > 0) {

716 
	`uECC_vli_sub
(
a
, a, 
b
, 
num_words
);

717 
	`uECC_vli_rshift1
(
a
, 
num_words
);

718 if (
	`uECC_vli_cmp_unsafe
(
u
, 
v
, 
num_words
) < 0) {

719 
	`uECC_vli_add
(
u
, u, 
mod
, 
num_words
);

721 
	`uECC_vli_sub
(
u
, u, 
v
, 
num_words
);

722 
	`vli_modInv_update
(
u
, 
mod
, 
num_words
);

724 
	`uECC_vli_sub
(
b
, b, 
a
, 
num_words
);

725 
	`uECC_vli_rshift1
(
b
, 
num_words
);

726 if (
	`uECC_vli_cmp_unsafe
(
v
, 
u
, 
num_words
) < 0) {

727 
	`uECC_vli_add
(
v
, v, 
mod
, 
num_words
);

729 
	`uECC_vli_sub
(
v
, v, 
u
, 
num_words
);

730 
	`vli_modInv_update
(
v
, 
mod
, 
num_words
);

733 
	`uECC_vli_set
(
result
, 
u
, 
num_words
);

734 
	}
}

738 #include 
	~"curve-specific.inc
"

741 #define 
	#EccPoint_isZero
(
point
, 
curve
) 
	`uECC_vli_isZero
((point), (curve)->
num_words
 * 2)

	)

748 static void 
	$apply_z
(
uECC_word_t
 * 
X1
,

749 
uECC_word_t
 * 
Y1
,

750 const 
uECC_word_t
 * const 
Z
,

751 
uECC_Curve
 
curve
) {

752 
uECC_word_t
 
t1
[
uECC_MAX_WORDS
];

754 
	`uECC_vli_modSquare_fast
(
t1
, 
Z
, 
curve
);

755 
	`uECC_vli_modMult_fast
(
X1
, X1, 
t1
, 
curve
);

756 
	`uECC_vli_modMult_fast
(
t1
, t1, 
Z
, 
curve
);

757 
	`uECC_vli_modMult_fast
(
Y1
, Y1, 
t1
, 
curve
);

758 
	}
}

761 static void 
	$XYcZ_initial_double
(
uECC_word_t
 * 
X1
,

762 
uECC_word_t
 * 
Y1
,

763 
uECC_word_t
 * 
X2
,

764 
uECC_word_t
 * 
Y2
,

765 const 
uECC_word_t
 * const 
initial_Z
,

766 
uECC_Curve
 
curve
) {

767 
uECC_word_t
 
z
[
uECC_MAX_WORDS
];

768 
wordcount_t
 
num_words
 = 
curve
->num_words;

769 if (
initial_Z
) {

770 
	`uECC_vli_set
(
z
, 
initial_Z
, 
num_words
);

772 
	`uECC_vli_clear
(
z
, 
num_words
);

773 
z
[0] = 1;

776 
	`uECC_vli_set
(
X2
, 
X1
, 
num_words
);

777 
	`uECC_vli_set
(
Y2
, 
Y1
, 
num_words
);

779 
	`apply_z
(
X1
, 
Y1
, 
z
, 
curve
);

780 
curve
->
	`double_jacobian
(
X1
, 
Y1
, 
z
, curve);

781 
	`apply_z
(
X2
, 
Y2
, 
z
, 
curve
);

782 
	}
}

788 static void 
	$XYcZ_add
(
uECC_word_t
 * 
X1
,

789 
uECC_word_t
 * 
Y1
,

790 
uECC_word_t
 * 
X2
,

791 
uECC_word_t
 * 
Y2
,

792 
uECC_Curve
 
curve
) {

794 
uECC_word_t
 
t5
[
uECC_MAX_WORDS
];

795 
wordcount_t
 
num_words
 = 
curve
->num_words;

797 
	`uECC_vli_modSub
(
t5
, 
X2
, 
X1
, 
curve
->
p
, 
num_words
);

798 
	`uECC_vli_modSquare_fast
(
t5
, t5, 
curve
);

799 
	`uECC_vli_modMult_fast
(
X1
, X1, 
t5
, 
curve
);

800 
	`uECC_vli_modMult_fast
(
X2
, X2, 
t5
, 
curve
);

801 
	`uECC_vli_modSub
(
Y2
, Y2, 
Y1
, 
curve
->
p
, 
num_words
);

802 
	`uECC_vli_modSquare_fast
(
t5
, 
Y2
, 
curve
);

804 
	`uECC_vli_modSub
(
t5
, t5, 
X1
, 
curve
->
p
, 
num_words
);

805 
	`uECC_vli_modSub
(
t5
, t5, 
X2
, 
curve
->
p
, 
num_words
);

806 
	`uECC_vli_modSub
(
X2
, X2, 
X1
, 
curve
->
p
, 
num_words
);

807 
	`uECC_vli_modMult_fast
(
Y1
, Y1, 
X2
, 
curve
);

808 
	`uECC_vli_modSub
(
X2
, 
X1
, 
t5
, 
curve
->
p
, 
num_words
);

809 
	`uECC_vli_modMult_fast
(
Y2
, Y2, 
X2
, 
curve
);

810 
	`uECC_vli_modSub
(
Y2
, Y2, 
Y1
, 
curve
->
p
, 
num_words
);

812 
	`uECC_vli_set
(
X2
, 
t5
, 
num_words
);

813 
	}
}

819 static void 
	$XYcZ_addC
(
uECC_word_t
 * 
X1
,

820 
uECC_word_t
 * 
Y1
,

821 
uECC_word_t
 * 
X2
,

822 
uECC_word_t
 * 
Y2
,

823 
uECC_Curve
 
curve
) {

825 
uECC_word_t
 
t5
[
uECC_MAX_WORDS
];

826 
uECC_word_t
 
t6
[
uECC_MAX_WORDS
];

827 
uECC_word_t
 
t7
[
uECC_MAX_WORDS
];

828 
wordcount_t
 
num_words
 = 
curve
->num_words;

830 
	`uECC_vli_modSub
(
t5
, 
X2
, 
X1
, 
curve
->
p
, 
num_words
);

831 
	`uECC_vli_modSquare_fast
(
t5
, t5, 
curve
);

832 
	`uECC_vli_modMult_fast
(
X1
, X1, 
t5
, 
curve
);

833 
	`uECC_vli_modMult_fast
(
X2
, X2, 
t5
, 
curve
);

834 
	`uECC_vli_modAdd
(
t5
, 
Y2
, 
Y1
, 
curve
->
p
, 
num_words
);

835 
	`uECC_vli_modSub
(
Y2
, Y2, 
Y1
, 
curve
->
p
, 
num_words
);

837 
	`uECC_vli_modSub
(
t6
, 
X2
, 
X1
, 
curve
->
p
, 
num_words
);

838 
	`uECC_vli_modMult_fast
(
Y1
, Y1, 
t6
, 
curve
);

839 
	`uECC_vli_modAdd
(
t6
, 
X1
, 
X2
, 
curve
->
p
, 
num_words
);

840 
	`uECC_vli_modSquare_fast
(
X2
, 
Y2
, 
curve
);

841 
	`uECC_vli_modSub
(
X2
, X2, 
t6
, 
curve
->
p
, 
num_words
);

843 
	`uECC_vli_modSub
(
t7
, 
X1
, 
X2
, 
curve
->
p
, 
num_words
);

844 
	`uECC_vli_modMult_fast
(
Y2
, Y2, 
t7
, 
curve
);

845 
	`uECC_vli_modSub
(
Y2
, Y2, 
Y1
, 
curve
->
p
, 
num_words
);

847 
	`uECC_vli_modSquare_fast
(
t7
, 
t5
, 
curve
);

848 
	`uECC_vli_modSub
(
t7
, t7, 
t6
, 
curve
->
p
, 
num_words
);

849 
	`uECC_vli_modSub
(
t6
, 
t7
, 
X1
, 
curve
->
p
, 
num_words
);

850 
	`uECC_vli_modMult_fast
(
t6
, t6, 
t5
, 
curve
);

851 
	`uECC_vli_modSub
(
Y1
, 
t6
, Y1, 
curve
->
p
, 
num_words
);

853 
	`uECC_vli_set
(
X1
, 
t7
, 
num_words
);

854 
	}
}

857 static void 
	$EccPoint_mult
(
uECC_word_t
 * 
result
,

858 const 
uECC_word_t
 * 
point
,

859 const 
uECC_word_t
 * 
scalar
,

860 const 
uECC_word_t
 * 
initial_Z
,

861 
bitcount_t
 
num_bits
,

862 
uECC_Curve
 
curve
) {

864 
uECC_word_t
 
Rx
[2][
uECC_MAX_WORDS
];

865 
uECC_word_t
 
Ry
[2][
uECC_MAX_WORDS
];

866 
uECC_word_t
 
z
[
uECC_MAX_WORDS
];

867 
bitcount_t
 
i
;

868 
uECC_word_t
 
nb
;

869 
wordcount_t
 
num_words
 = 
curve
->num_words;

871 
	`uECC_vli_set
(
Rx
[1], 
point
, 
num_words
);

872 
	`uECC_vli_set
(
Ry
[1], 
point
 + 
num_words
, num_words);

874 
	`XYcZ_initial_double
(
Rx
[1], 
Ry
[1], Rx[0], Ry[0], 
initial_Z
, 
curve
);

876 for (
i
 = 
num_bits
 - 2; i > 0; --i) {

877 
nb
 = !
	`uECC_vli_testBit
(
scalar
, 
i
);

878 
	`XYcZ_addC
(
Rx
[1 - 
nb
], 
Ry
[1 - nb], Rx[nb], Ry[nb], 
curve
);

879 
	`XYcZ_add
(
Rx
[
nb
], 
Ry
[nb], Rx[1 - nb], Ry[1 - nb], 
curve
);

882 
nb
 = !
	`uECC_vli_testBit
(
scalar
, 0);

883 
	`XYcZ_addC
(
Rx
[1 - 
nb
], 
Ry
[1 - nb], Rx[nb], Ry[nb], 
curve
);

886 
	`uECC_vli_modSub
(
z
, 
Rx
[1], Rx[0], 
curve
->
p
, 
num_words
);

887 
	`uECC_vli_modMult_fast
(
z
, z, 
Ry
[1 - 
nb
], 
curve
);

888 
	`uECC_vli_modMult_fast
(
z
, z, 
point
, 
curve
);

889 
	`uECC_vli_modInv
(
z
, z, 
curve
->
p
, 
num_words
);

891 
	`uECC_vli_modMult_fast
(
z
, z, 
point
 + 
num_words
, 
curve
);

892 
	`uECC_vli_modMult_fast
(
z
, z, 
Rx
[1 - 
nb
], 
curve
);

895 
	`XYcZ_add
(
Rx
[
nb
], 
Ry
[nb], Rx[1 - nb], Ry[1 - nb], 
curve
);

896 
	`apply_z
(
Rx
[0], 
Ry
[0], 
z
, 
curve
);

898 
	`uECC_vli_set
(
result
, 
Rx
[0], 
num_words
);

899 
	`uECC_vli_set
(
result
 + 
num_words
, 
Ry
[0], num_words);

900 
	}
}

902 static 
uECC_word_t
 
	$regularize_k
(const 
uECC_word_t
 * const 
k
,

903 
uECC_word_t
 *
k0
,

904 
uECC_word_t
 *
k1
,

905 
uECC_Curve
 
curve
) {

906 
wordcount_t
 
num_n_words
 = 
	`BITS_TO_WORDS
(
curve
->
num_n_bits
);

907 
bitcount_t
 
num_n_bits
 = 
curve
->num_n_bits;

908 
uECC_word_t
 
carry
 = 
	`uECC_vli_add
(
k0
, 
k
, 
curve
->
n
, 
num_n_words
) ||

909 (
num_n_bits
 < ((
bitcount_t
)
num_n_words
 * 
uECC_WORD_SIZE
 * 8) &&

910 
	`uECC_vli_testBit
(
k0
, 
num_n_bits
));

911 
	`uECC_vli_add
(
k1
, 
k0
, 
curve
->
n
, 
num_n_words
);

912 return 
carry
;

913 
	}
}

915 static 
uECC_word_t
 
	$EccPoint_compute_public_key
(
uECC_word_t
 *
result
,

916 
uECC_word_t
 *
private_key
,

917 
uECC_Curve
 
curve
) {

918 
uECC_word_t
 
tmp1
[
uECC_MAX_WORDS
];

919 
uECC_word_t
 
tmp2
[
uECC_MAX_WORDS
];

920 
uECC_word_t
 *
p2
[2] = {
tmp1
, 
tmp2
};

921 
uECC_word_t
 
carry
;

925 
carry
 = 
	`regularize_k
(
private_key
, 
tmp1
, 
tmp2
, 
curve
);

927 
	`EccPoint_mult
(
result
, 
curve
->
G
, 
p2
[!
carry
], 0, curve->
num_n_bits
 + 1, curve);

929 if (
	`EccPoint_isZero
(
result
, 
curve
)) {

933 
	}
}

935 #if 
uECC_WORD_SIZE
 == 1

937 
uECC_VLI_API
 void 
	$uECC_vli_nativeToBytes
(
uint8_t
 *
bytes
,

938 int 
num_bytes
,

939 const 
uint8_t
 *
native
) {

940 
wordcount_t
 
i
;

941 for (
i
 = 0; i < 
num_bytes
; ++i) {

942 
bytes
[
i
] = 
native
[(
num_bytes
 - 1) - i];

944 
	}
}

946 
uECC_VLI_API
 void 
	$uECC_vli_bytesToNative
(
uint8_t
 *
native
,

947 const 
uint8_t
 *
bytes
,

948 int 
num_bytes
) {

949 
	`uECC_vli_nativeToBytes
(
native
, 
num_bytes
, 
bytes
);

950 
	}
}

954 
uECC_VLI_API
 void 
	$uECC_vli_nativeToBytes
(
uint8_t
 *
bytes
,

955 int 
num_bytes
,

956 const 
uECC_word_t
 *
native
) {

957 
wordcount_t
 
i
;

958 for (
i
 = 0; i < 
num_bytes
; ++i) {

959 unsigned 
b
 = 
num_bytes
 - 1 - 
i
;

960 
bytes
[
i
] = (
uint8_t
)(
native
[
b
 / 
uECC_WORD_SIZE
] >> (8 * (b % uECC_WORD_SIZE)));

962 
	}
}

964 
uECC_VLI_API
 void 
	$uECC_vli_bytesToNative
(
uECC_word_t
 *
native
,

965 const 
uint8_t
 *
bytes
,

966 int 
num_bytes
) {

967 
wordcount_t
 
i
;

968 
	`uECC_vli_clear
(
native
, (
num_bytes
 + (
uECC_WORD_SIZE
 - 1)) / uECC_WORD_SIZE);

969 for (
i
 = 0; i < 
num_bytes
; ++i) {

970 unsigned 
b
 = 
num_bytes
 - 1 - 
i
;

971 
native
[
b
 / 
uECC_WORD_SIZE
] |=

972 (
uECC_word_t
)
bytes
[
i
] << (8 * (
b
 % 
uECC_WORD_SIZE
));

974 
	}
}

980 
uECC_VLI_API
 int 
	$uECC_generate_random_int
(
uECC_word_t
 *
random
,

981 const 
uECC_word_t
 *
top
,

982 
wordcount_t
 
num_words
) {

983 
uECC_word_t
 
mask
 = (uECC_word_t)-1;

984 
uECC_word_t
 
tries
;

985 
bitcount_t
 
num_bits
 = 
	`uECC_vli_numBits
(
top
, 
num_words
);

987 if (!
g_rng_function
) {

991 for (
tries
 = 0; tries < 
uECC_RNG_MAX_TRIES
; ++tries) {

992 if (!
	`g_rng_function
((
uint8_t
 *)
random
, 
num_words
 * 
uECC_WORD_SIZE
)) {

995 
random
[
num_words
 - 1] &= 
mask
 >> ((
bitcount_t
)(num_words * 
uECC_WORD_SIZE
 * 8 - 
num_bits
));

996 if (!
	`uECC_vli_isZero
(
random
, 
num_words
) &&

997 
	`uECC_vli_cmp
(
top
, 
random
, 
num_words
) == 1) {

1002 
	}
}

1004 int 
	$uECC_make_key
(
uint8_t
 *
public_key
,

1005 
uint8_t
 *
private_key
,

1006 
uECC_Curve
 
curve
) {

1007 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1008 
uECC_word_t
 *
_private
 = (uECC_word_t *)
private_key
;

1009 
uECC_word_t
 *
_public
 = (uECC_word_t *)
public_key
;

1011 
uECC_word_t
 
_private
[
uECC_MAX_WORDS
];

1012 
uECC_word_t
 
_public
[
uECC_MAX_WORDS
 * 2];

1014 
uECC_word_t
 
tries
;

1016 for (
tries
 = 0; tries < 
uECC_RNG_MAX_TRIES
; ++tries) {

1017 if (!
	`uECC_generate_random_int
(
_private
, 
curve
->
n
, 
	`BITS_TO_WORDS
(curve->
num_n_bits
))) {

1021 if (
	`EccPoint_compute_public_key
(
_public
, 
_private
, 
curve
)) {

1022 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN
 == 0

1023 
	`uECC_vli_nativeToBytes
(
private_key
, 
	`BITS_TO_BYTES
(
curve
->
num_n_bits
), 
_private
);

1024 
	`uECC_vli_nativeToBytes
(
public_key
, 
curve
->
num_bytes
, 
_public
);

1025 
	`uECC_vli_nativeToBytes
(

1026 
public_key
 + 
curve
->
num_bytes
, curve->num_bytes, 
_public
 + curve->
num_words
);

1032 
	}
}

1034 int 
	$uECC_shared_secret
(const 
uint8_t
 *
public_key
,

1035 const 
uint8_t
 *
private_key
,

1036 
uint8_t
 *
secret
,

1037 
uECC_Curve
 
curve
) {

1038 
uECC_word_t
 
_public
[
uECC_MAX_WORDS
 * 2];

1039 
uECC_word_t
 
_private
[
uECC_MAX_WORDS
];

1041 
uECC_word_t
 
tmp
[
uECC_MAX_WORDS
];

1042 
uECC_word_t
 *
p2
[2] = {
_private
, 
tmp
};

1043 
uECC_word_t
 *
initial_Z
 = 0;

1044 
uECC_word_t
 
carry
;

1045 
wordcount_t
 
num_words
 = 
curve
->num_words;

1046 
wordcount_t
 
num_bytes
 = 
curve
->num_bytes;

1048 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1049 
	`bcopy
((
uint8_t
 *) 
_private
, 
private_key
, 
num_bytes
);

1050 
	`bcopy
((
uint8_t
 *) 
_public
, 
public_key
, 
num_bytes
*2);

1052 
	`uECC_vli_bytesToNative
(
_private
, 
private_key
, 
	`BITS_TO_BYTES
(
curve
->
num_n_bits
));

1053 
	`uECC_vli_bytesToNative
(
_public
, 
public_key
, 
num_bytes
);

1054 
	`uECC_vli_bytesToNative
(
_public
 + 
num_words
, 
public_key
 + 
num_bytes
, num_bytes);

1059 
carry
 = 
	`regularize_k
(
_private
, _private, 
tmp
, 
curve
);

1063 if (
g_rng_function
) {

1064 if (!
	`uECC_generate_random_int
(
p2
[
carry
], 
curve
->
p
, 
num_words
)) {

1067 
initial_Z
 = 
p2
[
carry
];

1070 
	`EccPoint_mult
(
_public
, _public, 
p2
[!
carry
], 
initial_Z
, 
curve
->
num_n_bits
 + 1, curve);

1071 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1072 
	`bcopy
((
uint8_t
 *) 
secret
, (uint8_t *) 
_public
, 
num_bytes
);

1074 
	`uECC_vli_nativeToBytes
(
secret
, 
num_bytes
, 
_public
);

1076 return !
	`EccPoint_isZero
(
_public
, 
curve
);

1077 
	}
}

1079 #if 
uECC_SUPPORT_COMPRESSED_POINT


1080 void 
	$uECC_compress
(const 
uint8_t
 *
public_key
, uint8_t *
compressed
, 
uECC_Curve
 
curve
) {

1081 
wordcount_t
 
i
;

1082 for (
i
 = 0; i < 
curve
->
num_bytes
; ++i) {

1083 
compressed
[
i
+1] = 
public_key
[i];

1085 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1086 
compressed
[0] = 2 + (
public_key
[
curve
->
num_bytes
] & 0x01);

1088 
compressed
[0] = 2 + (
public_key
[
curve
->
num_bytes
 * 2 - 1] & 0x01);

1090 
	}
}

1092 void 
	$uECC_decompress
(const 
uint8_t
 *
compressed
, uint8_t *
public_key
, 
uECC_Curve
 
curve
) {

1093 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1094 
uECC_word_t
 *
point
 = (uECC_word_t *)
public_key
;

1096 
uECC_word_t
 
point
[
uECC_MAX_WORDS
 * 2];

1098 
uECC_word_t
 *
y
 = 
point
 + 
curve
->
num_words
;

1099 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1100 
	`bcopy
(
public_key
, 
compressed
+1, 
curve
->
num_bytes
);

1102 
	`uECC_vli_bytesToNative
(
point
, 
compressed
 + 1, 
curve
->
num_bytes
);

1104 
curve
->
	`x_side
(
y
, 
point
, curve);

1105 
curve
->
	`mod_sqrt
(
y
, curve);

1107 if ((
y
[0] & 0x01) != (
compressed
[0] & 0x01)) {

1108 
	`uECC_vli_sub
(
y
, 
curve
->
p
, y, curve->
num_words
);

1111 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN
 == 0

1112 
	`uECC_vli_nativeToBytes
(
public_key
, 
curve
->
num_bytes
, 
point
);

1113 
	`uECC_vli_nativeToBytes
(
public_key
 + 
curve
->
num_bytes
, curve->num_bytes, 
y
);

1115 
	}
}

1118 int 
	$uECC_valid_point
(const 
uECC_word_t
 *
point
, 
uECC_Curve
 
curve
) {

1119 
uECC_word_t
 
tmp1
[
uECC_MAX_WORDS
];

1120 
uECC_word_t
 
tmp2
[
uECC_MAX_WORDS
];

1121 
wordcount_t
 
num_words
 = 
curve
->num_words;

1124 if (
	`EccPoint_isZero
(
point
, 
curve
)) {

1129 if (
	`uECC_vli_cmp_unsafe
(
curve
->
p
, 
point
, 
num_words
) != 1 ||

1130 
	`uECC_vli_cmp_unsafe
(
curve
->
p
, 
point
 + 
num_words
, num_words) != 1) {

1134 
	`uECC_vli_modSquare_fast
(
tmp1
, 
point
 + 
num_words
, 
curve
);

1135 
curve
->
	`x_side
(
tmp2
, 
point
, curve);

1138 return (int)(
	`uECC_vli_equal
(
tmp1
, 
tmp2
, 
num_words
));

1139 
	}
}

1141 int 
	$uECC_valid_public_key
(const 
uint8_t
 *
public_key
, 
uECC_Curve
 
curve
) {

1142 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1143 
uECC_word_t
 *
_public
 = (uECC_word_t *)
public_key
;

1145 
uECC_word_t
 
_public
[
uECC_MAX_WORDS
 * 2];

1148 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN
 == 0

1149 
	`uECC_vli_bytesToNative
(
_public
, 
public_key
, 
curve
->
num_bytes
);

1150 
	`uECC_vli_bytesToNative
(

1151 
_public
 + 
curve
->
num_words
, 
public_key
 + curve->
num_bytes
, curve->num_bytes);

1153 return 
	`uECC_valid_point
(
_public
, 
curve
);

1154 
	}
}

1156 int 
	$uECC_compute_public_key
(const 
uint8_t
 *
private_key
, uint8_t *
public_key
, 
uECC_Curve
 
curve
) {

1157 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1158 
uECC_word_t
 *
_private
 = (uECC_word_t *)
private_key
;

1159 
uECC_word_t
 *
_public
 = (uECC_word_t *)
public_key
;

1161 
uECC_word_t
 
_private
[
uECC_MAX_WORDS
];

1162 
uECC_word_t
 
_public
[
uECC_MAX_WORDS
 * 2];

1165 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN
 == 0

1166 
	`uECC_vli_bytesToNative
(
_private
, 
private_key
, 
	`BITS_TO_BYTES
(
curve
->
num_n_bits
));

1170 if (
	`uECC_vli_isZero
(
_private
, 
	`BITS_TO_WORDS
(
curve
->
num_n_bits
))) {

1174 if (
	`uECC_vli_cmp
(
curve
->
n
, 
_private
, 
	`BITS_TO_WORDS
(curve->
num_n_bits
)) != 1) {

1179 if (!
	`EccPoint_compute_public_key
(
_public
, 
_private
, 
curve
)) {

1183 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN
 == 0

1184 
	`uECC_vli_nativeToBytes
(
public_key
, 
curve
->
num_bytes
, 
_public
);

1185 
	`uECC_vli_nativeToBytes
(

1186 
public_key
 + 
curve
->
num_bytes
, curve->num_bytes, 
_public
 + curve->
num_words
);

1189 
	}
}

1194 static void 
	$bits2int
(
uECC_word_t
 *
native
,

1195 const 
uint8_t
 *
bits
,

1196 unsigned 
bits_size
,

1197 
uECC_Curve
 
curve
) {

1198 unsigned 
num_n_bytes
 = 
	`BITS_TO_BYTES
(
curve
->
num_n_bits
);

1199 unsigned 
num_n_words
 = 
	`BITS_TO_WORDS
(
curve
->
num_n_bits
);

1200 int 
shift
;

1201 
uECC_word_t
 
carry
;

1202 
uECC_word_t
 *
ptr
;

1204 if (
bits_size
 > 
num_n_bytes
) {

1205 
bits_size
 = 
num_n_bytes
;

1208 
	`uECC_vli_clear
(
native
, 
num_n_words
);

1209 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1210 
	`bcopy
((
uint8_t
 *) 
native
, 
bits
, 
bits_size
);

1212 
	`uECC_vli_bytesToNative
(
native
, 
bits
, 
bits_size
);

1214 if (
bits_size
 * 8 <= (unsigned)
curve
->
num_n_bits
) {

1217 
shift
 = 
bits_size
 * 8 - 
curve
->
num_n_bits
;

1218 
carry
 = 0;

1219 
ptr
 = 
native
 + 
num_n_words
;

1220 while (
ptr
-- > 
native
) {

1221 
uECC_word_t
 
temp
 = *
ptr
;

1222 *
ptr
 = (
temp
 >> 
shift
) | 
carry
;

1223 
carry
 = 
temp
 << (
uECC_WORD_BITS
 - 
shift
);

1227 if (
	`uECC_vli_cmp_unsafe
(
curve
->
n
, 
native
, 
num_n_words
) != 1) {

1228 
	`uECC_vli_sub
(
native
, native, 
curve
->
n
, 
num_n_words
);

1230 
	}
}

1232 static int 
	$uECC_sign_with_k
(const 
uint8_t
 *
private_key
,

1233 const 
uint8_t
 *
message_hash
,

1234 unsigned 
hash_size
,

1235 
uECC_word_t
 *
k
,

1236 
uint8_t
 *
signature
,

1237 
uECC_Curve
 
curve
) {

1239 
uECC_word_t
 
tmp
[
uECC_MAX_WORDS
];

1240 
uECC_word_t
 
s
[
uECC_MAX_WORDS
];

1241 
uECC_word_t
 *
k2
[2] = {
tmp
, 
s
};

1242 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1243 
uECC_word_t
 *
p
 = (uECC_word_t *)
signature
;

1245 
uECC_word_t
 
p
[
uECC_MAX_WORDS
 * 2];

1247 
uECC_word_t
 
carry
;

1248 
wordcount_t
 
num_words
 = 
curve
->num_words;

1249 
wordcount_t
 
num_n_words
 = 
	`BITS_TO_WORDS
(
curve
->
num_n_bits
);

1250 
bitcount_t
 
num_n_bits
 = 
curve
->num_n_bits;

1253 if (
	`uECC_vli_isZero
(
k
, 
num_words
) || 
	`uECC_vli_cmp
(
curve
->
n
, k, 
num_n_words
) != 1) {

1257 
carry
 = 
	`regularize_k
(
k
, 
tmp
, 
s
, 
curve
);

1258 
	`EccPoint_mult
(
p
, 
curve
->
G
, 
k2
[!
carry
], 0, 
num_n_bits
 + 1, curve);

1259 if (
	`uECC_vli_isZero
(
p
, 
num_words
)) {

1265 if (!
g_rng_function
) {

1266 
	`uECC_vli_clear
(
tmp
, 
num_n_words
);

1267 
tmp
[0] = 1;

1268 } else if (!
	`uECC_generate_random_int
(
tmp
, 
curve
->
n
, 
num_n_words
)) {

1274 
	`uECC_vli_modMult
(
k
, k, 
tmp
, 
curve
->
n
, 
num_n_words
);

1275 
	`uECC_vli_modInv
(
k
, k, 
curve
->
n
, 
num_n_words
);

1276 
	`uECC_vli_modMult
(
k
, k, 
tmp
, 
curve
->
n
, 
num_n_words
);

1278 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN
 == 0

1279 
	`uECC_vli_nativeToBytes
(
signature
, 
curve
->
num_bytes
, 
p
);

1282 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1283 
	`bcopy
((
uint8_t
 *) 
tmp
, 
private_key
, 
	`BITS_TO_BYTES
(
curve
->
num_n_bits
));

1285 
	`uECC_vli_bytesToNative
(
tmp
, 
private_key
, 
	`BITS_TO_BYTES
(
curve
->
num_n_bits
));

1288 
s
[
num_n_words
 - 1] = 0;

1289 
	`uECC_vli_set
(
s
, 
p
, 
num_words
);

1290 
	`uECC_vli_modMult
(
s
, 
tmp
, s, 
curve
->
n
, 
num_n_words
);

1292 
	`bits2int
(
tmp
, 
message_hash
, 
hash_size
, 
curve
);

1293 
	`uECC_vli_modAdd
(
s
, 
tmp
, s, 
curve
->
n
, 
num_n_words
);

1294 
	`uECC_vli_modMult
(
s
, s, 
k
, 
curve
->
n
, 
num_n_words
);

1295 if (
	`uECC_vli_numBits
(
s
, 
num_n_words
) > (
bitcount_t
)
curve
->
num_bytes
 * 8) {

1298 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1299 
	`bcopy
((
uint8_t
 *) 
signature
 + 
curve
->
num_bytes
, (uint8_t *) 
s
, curve->num_bytes);

1301 
	`uECC_vli_nativeToBytes
(
signature
 + 
curve
->
num_bytes
, curve->num_bytes, 
s
);

1304 
	}
}

1306 int 
	$uECC_sign
(const 
uint8_t
 *
private_key
,

1307 const 
uint8_t
 *
message_hash
,

1308 unsigned 
hash_size
,

1309 
uint8_t
 *
signature
,

1310 
uECC_Curve
 
curve
) {

1311 
uECC_word_t
 
k
[
uECC_MAX_WORDS
];

1312 
uECC_word_t
 
tries
;

1314 for (
tries
 = 0; tries < 
uECC_RNG_MAX_TRIES
; ++tries) {

1315 if (!
	`uECC_generate_random_int
(
k
, 
curve
->
n
, 
	`BITS_TO_WORDS
(curve->
num_n_bits
))) {

1319 if (
	`uECC_sign_with_k
(
private_key
, 
message_hash
, 
hash_size
, 
k
, 
signature
, 
curve
)) {

1324 
	}
}

1328 static void 
	$HMAC_init
(const 
uECC_HashContext
 *
hash_context
, const 
uint8_t
 *
K
) {

1329 
uint8_t
 *
pad
 = 
hash_context
->
tmp
 + 2 * hash_context->
result_size
;

1330 unsigned 
i
;

1331 for (
i
 = 0; i < 
hash_context
->
result_size
; ++i)

1332 
pad
[
i
] = 
K
[i] ^ 0x36;

1333 for (; 
i
 < 
hash_context
->
block_size
; ++i)

1334 
pad
[
i
] = 0x36;

1336 
hash_context
->
	`init_hash
(hash_context);

1337 
hash_context
->
	`update_hash
(hash_context, 
pad
, hash_context->
block_size
);

1338 
	}
}

1340 static void 
	$HMAC_update
(const 
uECC_HashContext
 *
hash_context
,

1341 const 
uint8_t
 *
message
,

1342 unsigned 
message_size
) {

1343 
hash_context
->
	`update_hash
(hash_context, 
message
, 
message_size
);

1344 
	}
}

1346 static void 
	$HMAC_finish
(const 
uECC_HashContext
 *
hash_context
,

1347 const 
uint8_t
 *
K
,

1348 
uint8_t
 *
result
) {

1349 
uint8_t
 *
pad
 = 
hash_context
->
tmp
 + 2 * hash_context->
result_size
;

1350 unsigned 
i
;

1351 for (
i
 = 0; i < 
hash_context
->
result_size
; ++i)

1352 
pad
[
i
] = 
K
[i] ^ 0x5c;

1353 for (; 
i
 < 
hash_context
->
block_size
; ++i)

1354 
pad
[
i
] = 0x5c;

1356 
hash_context
->
	`finish_hash
(hash_context, 
result
);

1358 
hash_context
->
	`init_hash
(hash_context);

1359 
hash_context
->
	`update_hash
(hash_context, 
pad
, hash_context->
block_size
);

1360 
hash_context
->
	`update_hash
(hash_context, 
result
, hash_context->
result_size
);

1361 
hash_context
->
	`finish_hash
(hash_context, 
result
);

1362 
	}
}

1365 static void 
	$update_V
(const 
uECC_HashContext
 *
hash_context
, 
uint8_t
 *
K
, uint8_t *
V
) {

1366 
	`HMAC_init
(
hash_context
, 
K
);

1367 
	`HMAC_update
(
hash_context
, 
V
, hash_context->
result_size
);

1368 
	`HMAC_finish
(
hash_context
, 
K
, 
V
);

1369 
	}
}

1377 int 
	$uECC_sign_deterministic
(const 
uint8_t
 *
private_key
,

1378 const 
uint8_t
 *
message_hash
,

1379 unsigned 
hash_size
,

1380 const 
uECC_HashContext
 *
hash_context
,

1381 
uint8_t
 *
signature
,

1382 
uECC_Curve
 
curve
) {

1383 
uint8_t
 *
K
 = 
hash_context
->
tmp
;

1384 
uint8_t
 *
V
 = 
K
 + 
hash_context
->
result_size
;

1385 
wordcount_t
 
num_bytes
 = 
curve
->num_bytes;

1386 
wordcount_t
 
num_n_words
 = 
	`BITS_TO_WORDS
(
curve
->
num_n_bits
);

1387 
bitcount_t
 
num_n_bits
 = 
curve
->num_n_bits;

1388 
uECC_word_t
 
tries
;

1389 unsigned 
i
;

1390 for (
i
 = 0; i < 
hash_context
->
result_size
; ++i) {

1391 
V
[
i
] = 0x01;

1392 
K
[
i
] = 0;

1396 
	`HMAC_init
(
hash_context
, 
K
);

1397 
V
[
hash_context
->
result_size
] = 0x00;

1398 
	`HMAC_update
(
hash_context
, 
V
, hash_context->
result_size
 + 1);

1399 
	`HMAC_update
(
hash_context
, 
private_key
, 
num_bytes
);

1400 
	`HMAC_update
(
hash_context
, 
message_hash
, 
hash_size
);

1401 
	`HMAC_finish
(
hash_context
, 
K
, K);

1403 
	`update_V
(
hash_context
, 
K
, 
V
);

1406 
	`HMAC_init
(
hash_context
, 
K
);

1407 
V
[
hash_context
->
result_size
] = 0x01;

1408 
	`HMAC_update
(
hash_context
, 
V
, hash_context->
result_size
 + 1);

1409 
	`HMAC_update
(
hash_context
, 
private_key
, 
num_bytes
);

1410 
	`HMAC_update
(
hash_context
, 
message_hash
, 
hash_size
);

1411 
	`HMAC_finish
(
hash_context
, 
K
, K);

1413 
	`update_V
(
hash_context
, 
K
, 
V
);

1415 for (
tries
 = 0; tries < 
uECC_RNG_MAX_TRIES
; ++tries) {

1416 
uECC_word_t
 
T
[
uECC_MAX_WORDS
];

1417 
uint8_t
 *
T_ptr
 = (uint8_t *)
T
;

1418 
wordcount_t
 
T_bytes
 = 0;

1420 
	`update_V
(
hash_context
, 
K
, 
V
);

1421 for (
i
 = 0; i < 
hash_context
->
result_size
; ++i) {

1422 
T_ptr
[
T_bytes
++] = 
V
[
i
];

1423 if (
T_bytes
 >= 
num_n_words
 * 
uECC_WORD_SIZE
) {

1424 goto 
filled
;

1428 
filled
:

1429 if ((
bitcount_t
)
num_n_words
 * 
uECC_WORD_SIZE
 * 8 > 
num_n_bits
) {

1430 
uECC_word_t
 
mask
 = (uECC_word_t)-1;

1431 
T
[
num_n_words
 - 1] &=

1432 
mask
 >> ((
bitcount_t
)(
num_n_words
 * 
uECC_WORD_SIZE
 * 8 - 
num_n_bits
));

1435 if (
	`uECC_sign_with_k
(
private_key
, 
message_hash
, 
hash_size
, 
T
, 
signature
, 
curve
)) {

1440 
	`HMAC_init
(
hash_context
, 
K
);

1441 
V
[
hash_context
->
result_size
] = 0x00;

1442 
	`HMAC_update
(
hash_context
, 
V
, hash_context->
result_size
 + 1);

1443 
	`HMAC_finish
(
hash_context
, 
K
, K);

1445 
	`update_V
(
hash_context
, 
K
, 
V
);

1448 
	}
}

1450 static 
bitcount_t
 
	$smax
(
bitcount_t
 
a
, bitcount_t 
b
) {

1451 return (
a
 > 
b
 ? a : b);

1452 
	}
}

1454 int 
	$uECC_verify
(const 
uint8_t
 *
public_key
,

1455 const 
uint8_t
 *
message_hash
,

1456 unsigned 
hash_size
,

1457 const 
uint8_t
 *
signature
,

1458 
uECC_Curve
 
curve
) {

1459 
uECC_word_t
 
u1
[
uECC_MAX_WORDS
], 
u2
[uECC_MAX_WORDS];

1460 
uECC_word_t
 
z
[
uECC_MAX_WORDS
];

1461 
uECC_word_t
 
sum
[
uECC_MAX_WORDS
 * 2];

1462 
uECC_word_t
 
rx
[
uECC_MAX_WORDS
];

1463 
uECC_word_t
 
ry
[
uECC_MAX_WORDS
];

1464 
uECC_word_t
 
tx
[
uECC_MAX_WORDS
];

1465 
uECC_word_t
 
ty
[
uECC_MAX_WORDS
];

1466 
uECC_word_t
 
tz
[
uECC_MAX_WORDS
];

1467 const 
uECC_word_t
 *
points
[4];

1468 const 
uECC_word_t
 *
point
;

1469 
bitcount_t
 
num_bits
;

1470 
bitcount_t
 
i
;

1471 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1472 
uECC_word_t
 *
_public
 = (uECC_word_t *)
public_key
;

1474 
uECC_word_t
 
_public
[
uECC_MAX_WORDS
 * 2];

1476 
uECC_word_t
 
r
[
uECC_MAX_WORDS
], 
s
[uECC_MAX_WORDS];

1477 
wordcount_t
 
num_words
 = 
curve
->num_words;

1478 
wordcount_t
 
num_n_words
 = 
	`BITS_TO_WORDS
(
curve
->
num_n_bits
);

1480 
rx
[
num_n_words
 - 1] = 0;

1481 
r
[
num_n_words
 - 1] = 0;

1482 
s
[
num_n_words
 - 1] = 0;

1484 #if 
uECC_VLI_NATIVE_LITTLE_ENDIAN


1485 
	`bcopy
((
uint8_t
 *) 
r
, 
signature
, 
curve
->
num_bytes
);

1486 
	`bcopy
((
uint8_t
 *) 
s
, 
signature
 + 
curve
->
num_bytes
, curve->num_bytes);

1488 
	`uECC_vli_bytesToNative
(
_public
, 
public_key
, 
curve
->
num_bytes
);

1489 
	`uECC_vli_bytesToNative
(

1490 
_public
 + 
num_words
, 
public_key
 + 
curve
->
num_bytes
, curve->num_bytes);

1491 
	`uECC_vli_bytesToNative
(
r
, 
signature
, 
curve
->
num_bytes
);

1492 
	`uECC_vli_bytesToNative
(
s
, 
signature
 + 
curve
->
num_bytes
, curve->num_bytes);

1496 if (
	`uECC_vli_isZero
(
r
, 
num_words
) || uECC_vli_isZero(
s
, num_words)) {

1501 if (
	`uECC_vli_cmp_unsafe
(
curve
->
n
, 
r
, 
num_n_words
) != 1 ||

1502 
	`uECC_vli_cmp_unsafe
(
curve
->
n
, 
s
, 
num_n_words
) != 1) {

1507 
	`uECC_vli_modInv
(
z
, 
s
, 
curve
->
n
, 
num_n_words
);

1508 
u1
[
num_n_words
 - 1] = 0;

1509 
	`bits2int
(
u1
, 
message_hash
, 
hash_size
, 
curve
);

1510 
	`uECC_vli_modMult
(
u1
, u1, 
z
, 
curve
->
n
, 
num_n_words
);

1511 
	`uECC_vli_modMult
(
u2
, 
r
, 
z
, 
curve
->
n
, 
num_n_words
);

1514 
	`uECC_vli_set
(
sum
, 
_public
, 
num_words
);

1515 
	`uECC_vli_set
(
sum
 + 
num_words
, 
_public
 + num_words, num_words);

1516 
	`uECC_vli_set
(
tx
, 
curve
->
G
, 
num_words
);

1517 
	`uECC_vli_set
(
ty
, 
curve
->
G
 + 
num_words
, num_words);

1518 
	`uECC_vli_modSub
(
z
, 
sum
, 
tx
, 
curve
->
p
, 
num_words
);

1519 
	`XYcZ_add
(
tx
, 
ty
, 
sum
, sum + 
num_words
, 
curve
);

1520 
	`uECC_vli_modInv
(
z
, z, 
curve
->
p
, 
num_words
);

1521 
	`apply_z
(
sum
, sum + 
num_words
, 
z
, 
curve
);

1524 
points
[0] = 0;

1525 
points
[1] = 
curve
->
G
;

1526 
points
[2] = 
_public
;

1527 
points
[3] = 
sum
;

1528 
num_bits
 = 
	`smax
(
	`uECC_vli_numBits
(
u1
, 
num_n_words
),

1529 
	`uECC_vli_numBits
(
u2
, 
num_n_words
));

1531 
point
 = 
points
[(!!
	`uECC_vli_testBit
(
u1
, 
num_bits
 - 1)) |

1532 ((!!
	`uECC_vli_testBit
(
u2
, 
num_bits
 - 1)) << 1)];

1533 
	`uECC_vli_set
(
rx
, 
point
, 
num_words
);

1534 
	`uECC_vli_set
(
ry
, 
point
 + 
num_words
, num_words);

1535 
	`uECC_vli_clear
(
z
, 
num_words
);

1536 
z
[0] = 1;

1538 for (
i
 = 
num_bits
 - 2; i >= 0; --i) {

1539 
uECC_word_t
 
index
;

1540 
curve
->
	`double_jacobian
(
rx
, 
ry
, 
z
, curve);

1542 
index
 = (!!
	`uECC_vli_testBit
(
u1
, 
i
)) | ((!!uECC_vli_testBit(
u2
, i)) << 1);

1543 
point
 = 
points
[
index
];

1544 if (
point
) {

1545 
	`uECC_vli_set
(
tx
, 
point
, 
num_words
);

1546 
	`uECC_vli_set
(
ty
, 
point
 + 
num_words
, num_words);

1547 
	`apply_z
(
tx
, 
ty
, 
z
, 
curve
);

1548 
	`uECC_vli_modSub
(
tz
, 
rx
, 
tx
, 
curve
->
p
, 
num_words
);

1549 
	`XYcZ_add
(
tx
, 
ty
, 
rx
, 
ry
, 
curve
);

1550 
	`uECC_vli_modMult_fast
(
z
, z, 
tz
, 
curve
);

1554 
	`uECC_vli_modInv
(
z
, z, 
curve
->
p
, 
num_words
);

1555 
	`apply_z
(
rx
, 
ry
, 
z
, 
curve
);

1558 if (
	`uECC_vli_cmp_unsafe
(
curve
->
n
, 
rx
, 
num_n_words
) != 1) {

1559 
	`uECC_vli_sub
(
rx
, rx, 
curve
->
n
, 
num_n_words
);

1563 return (int)(
	`uECC_vli_equal
(
rx
, 
r
, 
num_words
));

1564 
	}
}

1566 #if 
uECC_ENABLE_VLI_API


1568 unsigned 
	$uECC_curve_num_words
(
uECC_Curve
 
curve
) {

1569 return 
curve
->
num_words
;

1570 
	}
}

1572 unsigned 
	$uECC_curve_num_bytes
(
uECC_Curve
 
curve
) {

1573 return 
curve
->
num_bytes
;

1574 
	}
}

1576 unsigned 
	$uECC_curve_num_bits
(
uECC_Curve
 
curve
) {

1577 return 
curve
->
num_bytes
 * 8;

1578 
	}
}

1580 unsigned 
	$uECC_curve_num_n_words
(
uECC_Curve
 
curve
) {

1581 return 
	`BITS_TO_WORDS
(
curve
->
num_n_bits
);

1582 
	}
}

1584 unsigned 
	$uECC_curve_num_n_bytes
(
uECC_Curve
 
curve
) {

1585 return 
	`BITS_TO_BYTES
(
curve
->
num_n_bits
);

1586 
	}
}

1588 unsigned 
	$uECC_curve_num_n_bits
(
uECC_Curve
 
curve
) {

1589 return 
curve
->
num_n_bits
;

1590 
	}
}

1592 const 
uECC_word_t
 *
	$uECC_curve_p
(
uECC_Curve
 
curve
) {

1593 return 
curve
->
p
;

1594 
	}
}

1596 const 
uECC_word_t
 *
	$uECC_curve_n
(
uECC_Curve
 
curve
) {

1597 return 
curve
->
n
;

1598 
	}
}

1600 const 
uECC_word_t
 *
	$uECC_curve_G
(
uECC_Curve
 
curve
) {

1601 return 
curve
->
G
;

1602 
	}
}

1604 const 
uECC_word_t
 *
	$uECC_curve_b
(
uECC_Curve
 
curve
) {

1605 return 
curve
->
b
;

1606 
	}
}

1608 #if 
uECC_SUPPORT_COMPRESSED_POINT


1609 void 
	$uECC_vli_mod_sqrt
(
uECC_word_t
 *
a
, 
uECC_Curve
 
curve
) {

1610 
curve
->
	`mod_sqrt
(
a
, curve);

1611 
	}
}

1614 void 
	$uECC_vli_mmod_fast
(
uECC_word_t
 *
result
, uECC_word_t *
product
, 
uECC_Curve
 
curve
) {

1615 #if (
uECC_OPTIMIZATION_LEVEL
 > 0)

1616 
curve
->
	`mmod_fast
(
result
, 
product
);

1618 
	`uECC_vli_mmod
(
result
, 
product
, 
curve
->
p
, curve->
num_words
);

1620 
	}
}

1622 void 
	$uECC_point_mult
(
uECC_word_t
 *
result
,

1623 const 
uECC_word_t
 *
point
,

1624 const 
uECC_word_t
 *
scalar
,

1625 
uECC_Curve
 
curve
) {

1626 
uECC_word_t
 
tmp1
[
uECC_MAX_WORDS
];

1627 
uECC_word_t
 
tmp2
[
uECC_MAX_WORDS
];

1628 
uECC_word_t
 *
p2
[2] = {
tmp1
, 
tmp2
};

1629 
uECC_word_t
 
carry
 = 
	`regularize_k
(
scalar
, 
tmp1
, 
tmp2
, 
curve
);

1631 
	`EccPoint_mult
(
result
, 
point
, 
p2
[!
carry
], 0, 
curve
->
num_n_bits
 + 1, curve);

1632 
	}
}

	@deps/picotls/deps/micro-ecc/uECC.h

3 #ifndef 
_UECC_H_


4 #define 
	#_UECC_H_


	)

6 #include 
	~<stdint.h
>

11 #define 
	#uECC_arch_other
 0

	)

12 #define 
	#uECC_x86
 1

	)

13 #define 
	#uECC_x86_64
 2

	)

14 #define 
	#uECC_arm
 3

	)

15 #define 
	#uECC_arm_thumb
 4

	)

16 #define 
	#uECC_arm_thumb2
 5

	)

17 #define 
	#uECC_arm64
 6

	)

18 #define 
	#uECC_avr
 7

	)

29 #ifndef 
uECC_OPTIMIZATION_LEVEL


30 #define 
	#uECC_OPTIMIZATION_LEVEL
 2

	)

36 #ifndef 
uECC_SQUARE_FUNC


37 #define 
	#uECC_SQUARE_FUNC
 0

	)

48 #ifndef 
uECC_VLI_NATIVE_LITTLE_ENDIAN


49 #define 
	#uECC_VLI_NATIVE_LITTLE_ENDIAN
 0

	)

53 #ifndef 
uECC_SUPPORTS_secp160r1


54 #define 
	#uECC_SUPPORTS_secp160r1
 1

	)

56 #ifndef 
uECC_SUPPORTS_secp192r1


57 #define 
	#uECC_SUPPORTS_secp192r1
 1

	)

59 #ifndef 
uECC_SUPPORTS_secp224r1


60 #define 
	#uECC_SUPPORTS_secp224r1
 1

	)

62 #ifndef 
uECC_SUPPORTS_secp256r1


63 #define 
	#uECC_SUPPORTS_secp256r1
 1

	)

65 #ifndef 
uECC_SUPPORTS_secp256k1


66 #define 
	#uECC_SUPPORTS_secp256k1
 1

	)

71 #ifndef 
uECC_SUPPORT_COMPRESSED_POINT


72 #define 
	#uECC_SUPPORT_COMPRESSED_POINT
 1

	)

75 struct 
	guECC_Curve_t
;

76 typedef const struct 
	tuECC_Curve_t
 * 
	tuECC_Curve
;

78 #ifdef 
__cplusplus


83 #if 
uECC_SUPPORTS_secp160r1


84 
uECC_Curve
 
uECC_secp160r1
(void);

86 #if 
uECC_SUPPORTS_secp192r1


87 
uECC_Curve
 
uECC_secp192r1
(void);

89 #if 
uECC_SUPPORTS_secp224r1


90 
uECC_Curve
 
uECC_secp224r1
(void);

92 #if 
uECC_SUPPORTS_secp256r1


93 
uECC_Curve
 
uECC_secp256r1
(void);

95 #if 
uECC_SUPPORTS_secp256k1


96 
uECC_Curve
 
uECC_secp256k1
(void);

115 typedef int (*
	guECC_RNG_Function
)(
	tuint8_t
 *
	tdest
, unsigned 
	tsize
);

127 void 
uECC_set_rng
(
uECC_RNG_Function
 
rng_function
);

133 
uECC_RNG_Function
 
uECC_get_rng
(void);

139 int 
uECC_curve_private_key_size
(
uECC_Curve
 
curve
);

145 int 
uECC_curve_public_key_size
(
uECC_Curve
 
curve
);

163 int 
uECC_make_key
(
uint8_t
 *
public_key
, uint8_t *
private_key
, 
uECC_Curve
 
curve
);

180 int 
uECC_shared_secret
(const 
uint8_t
 *
public_key
,

181 const 
uint8_t
 *
private_key
,

182 
uint8_t
 *
secret
,

183 
uECC_Curve
 
curve
);

185 #if 
uECC_SUPPORT_COMPRESSED_POINT


197 void 
uECC_compress
(const 
uint8_t
 *
public_key
, uint8_t *
compressed
, 
uECC_Curve
 
curve
);

208 void 
uECC_decompress
(const 
uint8_t
 *
compressed
, uint8_t *
public_key
, 
uECC_Curve
 
curve
);

223 int 
uECC_valid_public_key
(const 
uint8_t
 *
public_key
, 
uECC_Curve
 
curve
);

236 int 
uECC_compute_public_key
(const 
uint8_t
 *
private_key
, uint8_t *
public_key
, 
uECC_Curve
 
curve
);

255 int 
uECC_sign
(const 
uint8_t
 *
private_key
,

256 const 
uint8_t
 *
message_hash
,

257 unsigned 
hash_size
,

258 
uint8_t
 *
signature
,

259 
uECC_Curve
 
curve
);

299 typedef struct 
	suECC_HashContext
 {

300 void (*
	ginit_hash
)(const struct 
uECC_HashContext
 *
	gcontext
);

301 void (*
	gupdate_hash
)(const struct 
uECC_HashContext
 *
	gcontext
,

302 const 
uint8_t
 *
	gmessage
,

303 unsigned 
	gmessage_size
);

304 void (*
	gfinish_hash
)(const struct 
uECC_HashContext
 *
	gcontext
, 
uint8_t
 *
	ghash_result
);

305 unsigned 
	gblock_size
;

306 unsigned 
	gresult_size
;

307 
uint8_t
 *
	gtmp
;

308 } 
	tuECC_HashContext
;

331 int 
uECC_sign_deterministic
(const 
uint8_t
 *
private_key
,

332 const 
uint8_t
 *
message_hash
,

333 unsigned 
hash_size
,

334 const 
uECC_HashContext
 *
hash_context
,

335 
uint8_t
 *
signature
,

336 
uECC_Curve
 
curve
);

352 int 
uECC_verify
(const 
uint8_t
 *
public_key
,

353 const 
uint8_t
 *
message_hash
,

354 unsigned 
hash_size
,

355 const 
uint8_t
 *
signature
,

356 
uECC_Curve
 
curve
);

358 #ifdef 
__cplusplus


	@deps/picotls/deps/micro-ecc/uECC_vli.h

3 #ifndef 
_UECC_VLI_H_


4 #define 
	#_UECC_VLI_H_


	)

6 #include 
	~"uECC.h
"

7 #include 
	~"types.h
"

11 #ifndef 
uECC_ENABLE_VLI_API


12 #define 
	#uECC_ENABLE_VLI_API
 0

	)

15 #ifdef 
__cplusplus


20 #if 
uECC_ENABLE_VLI_API


22 void 
uECC_vli_clear
(
uECC_word_t
 *
vli
, 
wordcount_t
 
num_words
);

26 
uECC_word_t
 
uECC_vli_isZero
(const uECC_word_t *
vli
, 
wordcount_t
 
num_words
);

29 
uECC_word_t
 
uECC_vli_testBit
(const uECC_word_t *
vli
, 
bitcount_t
 
bit
);

32 
bitcount_t
 
uECC_vli_numBits
(const 
uECC_word_t
 *
vli
, const 
wordcount_t
 
max_words
);

35 void 
uECC_vli_set
(
uECC_word_t
 *
dest
, const uECC_word_t *
src
, 
wordcount_t
 
num_words
);

39 
uECC_word_t
 
uECC_vli_equal
(const uECC_word_t *
left
,

40 const 
uECC_word_t
 *
right
,

41 
wordcount_t
 
num_words
);

45 
cmpresult_t
 
uECC_vli_cmp
(const 
uECC_word_t
 *
left
, const uECC_word_t *
right
, 
wordcount_t
 
num_words
);

48 void 
uECC_vli_rshift1
(
uECC_word_t
 *
vli
, 
wordcount_t
 
num_words
);

51 
uECC_word_t
 
uECC_vli_add
(uECC_word_t *
result
,

52 const 
uECC_word_t
 *
left
,

53 const 
uECC_word_t
 *
right
,

54 
wordcount_t
 
num_words
);

57 
uECC_word_t
 
uECC_vli_sub
(uECC_word_t *
result
,

58 const 
uECC_word_t
 *
left
,

59 const 
uECC_word_t
 *
right
,

60 
wordcount_t
 
num_words
);

63 void 
uECC_vli_mult
(
uECC_word_t
 *
result
,

64 const 
uECC_word_t
 *
left
,

65 const 
uECC_word_t
 *
right
,

66 
wordcount_t
 
num_words
);

69 void 
uECC_vli_square
(
uECC_word_t
 *
result
, const uECC_word_t *
left
, 
wordcount_t
 
num_words
);

73 void 
uECC_vli_modAdd
(
uECC_word_t
 *
result
,

74 const 
uECC_word_t
 *
left
,

75 const 
uECC_word_t
 *
right
,

76 const 
uECC_word_t
 *
mod
,

77 
wordcount_t
 
num_words
);

81 void 
uECC_vli_modSub
(
uECC_word_t
 *
result
,

82 const 
uECC_word_t
 *
left
,

83 const 
uECC_word_t
 *
right
,

84 const 
uECC_word_t
 *
mod
,

85 
wordcount_t
 
num_words
);

89 void 
uECC_vli_mmod
(
uECC_word_t
 *
result
,

90 
uECC_word_t
 *
product
,

91 const 
uECC_word_t
 *
mod
,

92 
wordcount_t
 
num_words
);

96 void 
uECC_vli_mmod_fast
(
uECC_word_t
 *
result
, uECC_word_t *
product
, 
uECC_Curve
 
curve
);

100 void 
uECC_vli_modMult
(
uECC_word_t
 *
result
,

101 const 
uECC_word_t
 *
left
,

102 const 
uECC_word_t
 *
right
,

103 const 
uECC_word_t
 *
mod
,

104 
wordcount_t
 
num_words
);

107 void 
uECC_vli_modMult_fast
(
uECC_word_t
 *
result
,

108 const 
uECC_word_t
 *
left
,

109 const 
uECC_word_t
 *
right
,

110 
uECC_Curve
 
curve
);

114 void 
uECC_vli_modSquare
(
uECC_word_t
 *
result
,

115 const 
uECC_word_t
 *
left
,

116 const 
uECC_word_t
 *
mod
,

117 
wordcount_t
 
num_words
);

120 void 
uECC_vli_modSquare_fast
(
uECC_word_t
 *
result
, const uECC_word_t *
left
, 
uECC_Curve
 
curve
);

123 void 
uECC_vli_modInv
(
uECC_word_t
 *
result
,

124 const 
uECC_word_t
 *
input
,

125 const 
uECC_word_t
 *
mod
,

126 
wordcount_t
 
num_words
);

128 #if 
uECC_SUPPORT_COMPRESSED_POINT


130 void 
uECC_vli_mod_sqrt
(
uECC_word_t
 *
a
, 
uECC_Curve
 
curve
);

134 void 
uECC_vli_nativeToBytes
(
uint8_t
 *
bytes
, int 
num_bytes
, const 
uECC_word_t
 *
native
);

136 void 
uECC_vli_bytesToNative
(
uECC_word_t
 *
native
, const 
uint8_t
 *
bytes
, int 
num_bytes
);

138 unsigned 
uECC_curve_num_words
(
uECC_Curve
 
curve
);

139 unsigned 
uECC_curve_num_bytes
(
uECC_Curve
 
curve
);

140 unsigned 
uECC_curve_num_bits
(
uECC_Curve
 
curve
);

141 unsigned 
uECC_curve_num_n_words
(
uECC_Curve
 
curve
);

142 unsigned 
uECC_curve_num_n_bytes
(
uECC_Curve
 
curve
);

143 unsigned 
uECC_curve_num_n_bits
(
uECC_Curve
 
curve
);

145 const 
uECC_word_t
 *
uECC_curve_p
(
uECC_Curve
 
curve
);

146 const 
uECC_word_t
 *
uECC_curve_n
(
uECC_Curve
 
curve
);

147 const 
uECC_word_t
 *
uECC_curve_G
(
uECC_Curve
 
curve
);

148 const 
uECC_word_t
 *
uECC_curve_b
(
uECC_Curve
 
curve
);

150 int 
uECC_valid_point
(const 
uECC_word_t
 *
point
, 
uECC_Curve
 
curve
);

155 void 
uECC_point_mult
(
uECC_word_t
 *
result
,

156 const 
uECC_word_t
 *
point
,

157 const 
uECC_word_t
 *
scalar
,

158 
uECC_Curve
 
curve
);

162 int 
uECC_generate_random_int
(
uECC_word_t
 *
random
,

163 const 
uECC_word_t
 *
top
,

164 
wordcount_t
 
num_words
);

168 #ifdef 
__cplusplus


	@deps/picotls/deps/picotest/picotest.c

22 #ifdef 
_WINDOWS


23 #include 
	~"wincompat.h
"

25 #include 
	~<stdarg.h
>

26 #include 
	~<stdio.h
>

27 #include 
	~<string.h
>

28 #include 
	~"picotest.h
"

30 struct 
	stest_t
 {

31 int 
	mnum_tests
;

32 int 
	mfailed
;

34 struct 
test_t
 
	gmain_tests
, *
	gcur_tests
 = &
main_tests
;

35 static int 
	gtest_level
 = 0;

37 static void 
	$indent
(void)

39 int 
i
;

40 for (
i
 = 0; i != 
test_level
; ++i)

41 
	`printf
(" ");

42 
	}
}

44 
__attribute__
((
	$format
 (
printf
, 1, 2)))

45 void 
	$note
(const char *
fmt
, ...)

47 
va_list
 
arg
;

49 
	`indent
();

50 
	`printf
("# ");

52 
	`va_start
(
arg
, 
fmt
);

53 
	`vprintf
(
fmt
, 
arg
);

54 
	`va_end
(
arg
);

56 
	`printf
("\n");

57 
	`fflush
(
stdout
);

58 
	}
}

60 
__attribute__
((
	$format
 (
printf
, 2, 3)))

61 void 
	$_ok
(int 
cond
, const char *
fmt
, ...)

63 
va_list
 
arg
;

65 if (! 
cond
)

66 
cur_tests
->
failed
 = 1;

67 
	`indent
();

69 
	`printf
("%s %d - ", 
cond
 ? "ok" : "not ok", ++
cur_tests
->
num_tests
);

70 
	`va_start
(
arg
, 
fmt
);

71 
	`vprintf
(
fmt
, 
arg
);

72 
	`va_end
(
arg
);

74 
	`printf
("\n");

75 
	`fflush
(
stdout
);

76 
	}
}

78 int 
	$done_testing
(void)

80 
	`indent
();

81 
	`printf
("1..%d\n", 
cur_tests
->
num_tests
);

82 
	`fflush
(
stdout
);

83 return 
cur_tests
->
failed
;

84 
	}
}

86 void 
	$subtest
(const char *
name
, void (*
cb
)(void))

88 struct 
test_t
 
test
 = {0}, *
parent_tests
;

90 
parent_tests
 = 
cur_tests
;

91 
cur_tests
 = &
test
;

92 ++
test_level
;

94 
	`note
("Subtest: %s", 
name
);

96 
	`cb
();

98 
	`done_testing
();

100 --
test_level
;

101 
cur_tests
 = 
parent_tests
;

102 if (
test
.
failed
)

103 
cur_tests
->
failed
 = 1;

104 
	`_ok
(! 
test
.
failed
, "%s", 
name
);

105 
	}
}

	@deps/picotls/deps/picotest/picotest.h

22 #ifndef 
picotest_h


23 #define 
	#picotest_h


	)

25 #ifdef 
__cplusplus


29 void 
note
(const char *
fmt
, ...) 
__attribute__
((
format
 (
printf
, 1, 2)));

30 void 
_ok
(int 
cond
, const char *
fmt
, ...) 
__attribute__
((
format
 (
printf
, 2, 3)));

31 #define 
	#ok
(
cond
) 
	`_ok
(cond, "%s %d", 
__FILE__
, 
__LINE__
)

	)

32 int 
done_testing
(void);

33 void 
subtest
(const char *
name
, void (*
cb
)(void));

35 #ifdef 
__cplusplus


	@deps/picotls/fuzz/fuzz-asn1.c

1 #include 
	~<stdint.h
>

2 #include 
	~<unistd.h
>

3 #include 
	~<stdlib.h
>

4 #include 
	~<stdio.h
>

5 #include 
	~<stddef.h
>

6 #include 
	~<stdarg.h
>

7 #include 
	~"picotls.h
"

8 #include 
	~"picotls/asn1.h
"

9 #include 
	~"picotls/minicrypto.h
"

11 static struct 
	sfeeder
 {

12 const 
uint8_t
 *
	mdata
;

13 
size_t
 
	msize
;

14 } 
	gfeeder
;

16 static void 
	$feeder_init
(const 
uint8_t
 *
orig_data
, 
size_t
 
orig_size
)

18 
feeder
.
data
 = 
orig_data
;

19 
feeder
.
size
 = 
orig_size
;

20 
	}
}

22 static 
uint8_t
 
	$feeder_next_byte
(void)

24 if (
feeder
.
size
 == 0) {

27 
uint8_t
 
byte
 = *
feeder
.
data
;

28 --
feeder
.
size
;

29 ++
feeder
.
data
;

30 return 
byte
;

31 
	}
}

33 void 
	$count_printf
(void *
ctx
, const char *
format
, ...)

35 int *
c
 = 
ctx
;

36 
c
++;

38 
	}
}

40 int 
	$LLVMFuzzerTestOneInput
(const 
uint8_t
 *
Data
, 
size_t
 
Size
)

42 int 
i
, 
counter
, 
indefinite_length
, 
decode_error
;

43 
ptls_minicrypto_log_ctx_t
 
ctx
 = {&
counter
, 
count_printf
};

44 
uint8_t
 *
bytes
, 
expected_type
;

45 
size_t
 
last_byte
, 
bytes_max
, 
byte_index
;

46 
uint32_t
 
length
;

47 
uint8_t
 
ret
;

49 
	`feeder_init
(
Data
, 
Size
);

51 
bytes_max
 = (
	`feeder_next_byte
() << 8) + feeder_next_byte();

52 if (
bytes_max
 == 0)

56 
bytes
 = 
	`malloc
(
bytes_max
);

57 for (
i
 = 0; i < 
bytes_max
; i++) {

58 
bytes
[
i
] = 
	`feeder_next_byte
();

61 
ret
 = 
	`feeder_next_byte
() % 4;

63 if (
ret
 == 0) {

64 
	`ptls_asn1_validation
(
bytes
, 
bytes_max
, &
ctx
);

65 } else if (
ret
 == 1) {

66 
byte_index
 = (
	`feeder_next_byte
() << 8) + feeder_next_byte();

67 
byte_index
 = byte_index % 
bytes_max
;

68 
expected_type
 = 
	`feeder_next_byte
();

69 
	`ptls_asn1_get_expected_type_and_length
(
bytes
, 
bytes_max
, 
byte_index
, 
expected_type
, &
length
, &
indefinite_length
, &
last_byte
,

70 &
decode_error
, &
ctx
);

71 } else if (
ret
 == 2 || ret == 3) {

72 
ptls_context_t
 
ctx
 = {};

73 char 
fname
[] = "/tmp/XXXXXXXX";

74 int 
fd
, 
ret
;

75 
fd
 = 
	`mkstemp
(
fname
);

76 if (
fd
 < 0) {

77 goto 
out
;

79 
ret
 = 
	`write
(
fd
, 
bytes
, 
bytes_max
);

80 if (
ret
 != 
bytes_max
) {

81 goto 
out2
;

83 
ctx
.
random_bytes
 = 
ptls_minicrypto_random_bytes
;

84 
ctx
.
get_time
 = &
ptls_get_time
;

85 
ctx
.
key_exchanges
 = 
ptls_minicrypto_key_exchanges
;

86 
ctx
.
cipher_suites
 = 
ptls_minicrypto_cipher_suites
;

88 if (
ret
 == 2) {

89 
	`ptls_load_certificates
(&
ctx
, 
fname
);

90 if (
ctx
.
certificates
.
list
) {

91 for (
i
 = 0; i < 
ctx
.
certificates
.
count
; i++) {

92 if (
ctx
.
certificates
.
list
[
i
].
base
)

93 
	`free
(
ctx
.
certificates
.
list
[
i
].
base
);

95 
	`free
(
ctx
.
certificates
.
list
);

99 
	`ptls_minicrypto_load_private_key
(&
ctx
, 
fname
);

101 
out2
:

102 
	`close
(
fd
);

103 
	`unlink
(
fname
);

105 
out
:

106 
	`free
(
bytes
);

108 
	}
}

	@deps/picotls/fuzz/fuzz-client-hello.c

1 #include 
	~<assert.h
>

2 #include 
	~<getopt.h
>

3 #include 
	~<inttypes.h
>

4 #include 
	~<stdio.h
>

5 #include 
	~<string.h
>

6 #include 
	~<strings.h
>

7 #include 
	~<sys/select.h
>

8 #include 
	~<sys/socket.h
>

9 #include 
	~<sys/stat.h
>

10 #include 
	~<sys/time.h
>

11 #include 
	~<sys/types.h
>

12 #include 
	~<unistd.h
>

14 #include 
	~<openssl/err.h
>

15 #include 
	~<openssl/evp.h
>

16 #include 
	~<openssl/engine.h
>

17 #include 
	~<openssl/pem.h
>

19 #include 
	~"picotls.h
"

20 #include 
	~"picotls/openssl.h
"

21 #include 
	~"util.h
"

23 void 
	$deterministic_random_bytes
(void *
buf
, 
size_t
 
len
) {

24 for (int 
i
 = 0; i < 
len
; i++) {

25 ((
uint8_t
 *)
buf
)[
i
] = 0;

27 
	}
}

29 
uint8_t
 
	gfake_ticket
[] = {

38 static int 
	$encrypt_ticket_cb_fake
(
ptls_encrypt_ticket_t
 *
_self
, 
ptls_t
 *
tls
,

39 int 
is_encrypt
, 
ptls_buffer_t
 *
dst
,

40 
ptls_iovec_t
 
src
) {

41 (void)
_self
;

42 int 
ret
;

44 if (
is_encrypt
) {

45 if ((
ret
 = 
	`ptls_buffer_reserve
(
dst
, 32)) != 0) return ret;

46 
	`memcpy
(
dst
->
base
 + dst->
off
, 
fake_ticket
, 32);

47 
dst
->
off
 += 32;

49 if ((
ret
 = 
	`ptls_buffer_reserve
(
dst
, sizeof(
fake_ticket
))) != 0) return ret;

50 
	`memcpy
(
dst
->
base
 + dst->
off
, 
fake_ticket
, sizeof(fake_ticket));

51 
dst
->
off
 += sizeof(
fake_ticket
);

55 
	}
}

57 int 
	$LLVMFuzzerTestOneInput
(const 
uint8_t
 *
data
, 
size_t
 
size
) {

59 
ptls_key_exchange_algorithm_t
 *
key_exchanges
[128] = {
NULL
};

60 
key_exchanges
[0] = &
ptls_openssl_secp256r1
;

62 
ptls_cipher_suite_t
 *
cipher_suites
[] = {&
ptls_openssl_aes128gcmsha256
,

63 &
ptls_openssl_aes256gcmsha384
, 
NULL
};

66 
ptls_context_t
 
ctx_server
 = {
deterministic_random_bytes
, &
ptls_get_time
,

67 
key_exchanges
, 
cipher_suites
};

68 
ctx_server
.
verify_certificate
 = 
NULL
;

71 struct 
st_util_session_cache_t
 
sc
;

72 
sc
.
super
.
cb
 = 
encrypt_ticket_cb_fake
;

73 
ctx_server
.
ticket_lifetime
 = 
UINT_MAX
;

74 
ctx_server
.
max_early_data_size
 = 8192;

75 
ctx_server
.
encrypt_ticket
 = &
sc
.
super
;

78 
ptls_t
 *
tls_server
 = 
	`ptls_new
(&
ctx_server
, 1);

81 
ptls_handshake_properties_t
 
hsprop
 = {{{{
NULL
}}}};

84 
ptls_buffer_t
 
server_response
;

85 
	`ptls_buffer_init
(&
server_response
, "", 0);

88 
size_t
 
consumed
 = 
size
;

89 int 
ret
 =

90 
	`ptls_handshake
(
tls_server
, &
server_response
, 
data
, &
consumed
, &
hsprop
);

93 if (
ret
 == 0 && 
size
 - 
consumed
 > 0) {

94 
size
 = size - 
consumed
;

96 
	`ptls_buffer_dispose
(&
server_response
);

97 
	`ptls_buffer_init
(&
server_response
, "", 0);

99 
	`ptls_receive
(
tls_server
, &
server_response
, 
data
 + 
consumed
, &
size
);

103 
	`ptls_buffer_dispose
(&
server_response
);

104 
	`ptls_free
(
tls_server
);

108 
	}
}

	@deps/picotls/fuzz/fuzz-server-hello.c

1 #include 
	~<assert.h
>

2 #include 
	~<getopt.h
>

3 #include 
	~<inttypes.h
>

4 #include 
	~<stdio.h
>

5 #include 
	~<string.h
>

6 #include 
	~<strings.h
>

7 #include 
	~<sys/select.h
>

8 #include 
	~<sys/socket.h
>

9 #include 
	~<sys/stat.h
>

10 #include 
	~<sys/time.h
>

11 #include 
	~<sys/types.h
>

12 #include 
	~<unistd.h
>

14 #include 
	~<openssl/err.h
>

15 #include 
	~<openssl/evp.h
>

16 #include 
	~<openssl/engine.h
>

17 #include 
	~<openssl/pem.h
>

19 #include 
	~"picotls.h
"

20 #include 
	~"picotls/openssl.h
"

21 #include 
	~"util.h
"

23 void 
	$deterministic_random_bytes
(void *
buf
, 
size_t
 
len
) {

24 for (int 
i
 = 0; i < 
len
; i++) {

25 ((
uint8_t
 *)
buf
)[
i
] = 0;

27 
	}
}

29 static int 
	$fake_ticket_cb
(
ptls_save_ticket_t
 *
_self
, 
ptls_t
 *
tls
,

30 
ptls_iovec_t
 
src
) {

32 
	}
}

34 int 
	$LLVMFuzzerTestOneInput
(const 
uint8_t
 *
data
, 
size_t
 
size
) {

36 
ptls_key_exchange_algorithm_t
 *
key_exchanges
[128] = {
NULL
};

37 
key_exchanges
[0] = &
ptls_openssl_secp256r1
;

38 
ptls_cipher_suite_t
 *
cipher_suites
[] = {&
ptls_openssl_aes128gcmsha256
, 
NULL
};

41 
ptls_context_t
 
ctx_client
 = {
deterministic_random_bytes
, &
ptls_get_time
,

42 
key_exchanges
, 
cipher_suites
};

43 
ctx_client
.
verify_certificate
 = 
NULL
;

46 
ptls_t
 *
tls_client
 = 
	`ptls_new
(&
ctx_client
, 0);

49 static struct 
st_util_save_ticket_t
 
st
;

50 
st
.
super
.
cb
 = 
fake_ticket_cb
;

51 
ctx_client
.
save_ticket
 = &
st
.
super
;

54 
ptls_handshake_properties_t
 
hsprop
 = {{{{
NULL
}}}};

57 
ptls_buffer_t
 
client_encbuf
;

58 
	`ptls_buffer_init
(&
client_encbuf
, "", 0);

61 
	`ptls_handshake
(
tls_client
, &
client_encbuf
, 
NULL
, 0, &
hsprop
);

64 
	`ptls_buffer_dispose
(&
client_encbuf
);

65 
	`ptls_buffer_init
(&
client_encbuf
, "", 0);

68 
size_t
 
consumed
 = 
size
;

69 int 
ret
 =

70 
	`ptls_handshake
(
tls_client
, &
client_encbuf
, 
data
, &
consumed
, &
hsprop
);

73 if (
ret
 == 0 && 
size
 - 
consumed
 > 0) {

74 
size
 = size - 
consumed
;

76 
	`ptls_buffer_dispose
(&
client_encbuf
);

77 
	`ptls_buffer_init
(&
client_encbuf
, "", 0);

79 
	`ptls_receive
(
tls_client
, &
client_encbuf
, 
data
 + 
consumed
, &
size
);

83 
	`ptls_buffer_dispose
(&
client_encbuf
);

84 
	`ptls_free
(
tls_client
);

87 
	}
}

	@deps/picotls/include/picotls.h

22 #ifndef 
picotls_h


23 #define 
	#picotls_h


	)

25 #ifdef 
__cplusplus


29 #ifdef 
_WINDOWS


30 #include 
	~"wincompat.h
"

33 #include 
	~<assert.h
>

34 #include 
	~<inttypes.h
>

35 #include 
	~<string.h
>

36 #include 
	~<sys/types.h
>

38 #if 
__GNUC__
 >= 3

39 #define 
	#PTLS_LIKELY
(
x
) 
	`__builtin_expect
(!!(x), 1)

	)

40 #define 
	#PTLS_UNLIKELY
(
x
) 
	`__builtin_expect
(!!(x), 0)

	)

41 #define 
	#PTLS_BUILD_ASSERT_EXPR
(
cond
) (sizeof(char[2 * !!(!
	`__builtin_constant_p
(cond) || (cond)) - 1]) != 0)

	)

42 #define 
	#PTLS_BUILD_ASSERT
(
cond
) ((void)
	`PTLS_BUILD_ASSERT_EXPR
(cond))

	)

44 #define 
	#PTLS_LIKELY
(
x
) (x)

	)

45 #define 
	#PTLS_UNLIKELY
(
x
) (x)

	)

46 #define 
	#PTLS_BUILD_ASSERT
(
cond
) 1

	)

55 #if ((
defined
(
__clang__
) && 
__clang_major__
 >= 10) || 
__GNUC__
 >= 6) && !defined(
__cplusplus
)

56 #define 
	#PTLS_ASSERT_IS_ARRAY_EXPR
(
a
) 
	`PTLS_BUILD_ASSERT_EXPR
(
	`__builtin_types_compatible_p
(
	`__typeof__
(a[0])[], __typeof__(a)))

	)

58 #define 
	#PTLS_ASSERT_IS_ARRAY_EXPR
(
a
) 1

	)

61 #define 
	#PTLS_ELEMENTSOF
(
x
) (
	`PTLS_ASSERT_IS_ARRAY_EXPR
(x) * sizeof(x) / sizeof((x)[0]))

	)

63 #ifdef 
_WINDOWS


64 #define 
	#PTLS_THREADLOCAL
 
	`__declspec
(
thread
)

	)

66 #define 
	#PTLS_THREADLOCAL
 
__thread


	)

69 #ifndef 
PTLS_FUZZ_HANDSHAKE


70 #define 
	#PTLS_FUZZ_HANDSHAKE
 0

	)

73 #define 
	#PTLS_HELLO_RANDOM_SIZE
 32

	)

75 #define 
	#PTLS_AES128_KEY_SIZE
 16

	)

76 #define 
	#PTLS_AES256_KEY_SIZE
 32

	)

77 #define 
	#PTLS_AES_BLOCK_SIZE
 16

	)

78 #define 
	#PTLS_AES_IV_SIZE
 16

	)

79 #define 
	#PTLS_AESGCM_IV_SIZE
 12

	)

80 #define 
	#PTLS_AESGCM_TAG_SIZE
 16

	)

81 #define 
	#PTLS_AESGCM_CONFIDENTIALITY_LIMIT
 0x2000000

	)

82 #define 
	#PTLS_AESGCM_INTEGRITY_LIMIT
 
	`UINT64_C
(0x40000000000000)

	)

83 #define 
	#PTLS_AESCCM_CONFIDENTIALITY_LIMIT
 0xB504F3

	)

84 #define 
	#PTLS_AESCCM_INTEGRITY_LIMIT
 0xB504F3

	)

86 #define 
	#PTLS_CHACHA20_KEY_SIZE
 32

	)

87 #define 
	#PTLS_CHACHA20_IV_SIZE
 16

	)

88 #define 
	#PTLS_CHACHA20POLY1305_IV_SIZE
 12

	)

89 #define 
	#PTLS_CHACHA20POLY1305_TAG_SIZE
 16

	)

90 #define 
	#PTLS_CHACHA20POLY1305_CONFIDENTIALITY_LIMIT
 
UINT64_MAX


	)

91 #define 
	#PTLS_CHACHA20POLY1305_INTEGRITY_LIMIT
 
	`UINT64_C
(0x1000000000)

	)

93 #define 
	#PTLS_BLOWFISH_KEY_SIZE
 16

	)

94 #define 
	#PTLS_BLOWFISH_BLOCK_SIZE
 8

	)

96 #define 
	#PTLS_SHA256_BLOCK_SIZE
 64

	)

97 #define 
	#PTLS_SHA256_DIGEST_SIZE
 32

	)

99 #define 
	#PTLS_SHA384_BLOCK_SIZE
 128

	)

100 #define 
	#PTLS_SHA384_DIGEST_SIZE
 48

	)

102 #define 
	#PTLS_MAX_SECRET_SIZE
 32

	)

103 #define 
	#PTLS_MAX_IV_SIZE
 16

	)

104 #define 
	#PTLS_MAX_DIGEST_SIZE
 64

	)

107 #define 
	#PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
 0x1301

	)

108 #define 
	#PTLS_CIPHER_SUITE_NAME_AES_128_GCM_SHA256
 "TLS_AES_128_GCM_SHA256"

	)

109 #define 
	#PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
 0x1302

	)

110 #define 
	#PTLS_CIPHER_SUITE_NAME_AES_256_GCM_SHA384
 "TLS_AES_256_GCM_SHA384"

	)

111 #define 
	#PTLS_CIPHER_SUITE_CHACHA20_POLY1305_SHA256
 0x1303

	)

112 #define 
	#PTLS_CIPHER_SUITE_NAME_CHACHA20_POLY1305_SHA256
 "TLS_CHACHA20_POLY1305_SHA256"

	)

115 #define 
	#PTLS_GROUP_SECP256R1
 23

	)

116 #define 
	#PTLS_GROUP_NAME_SECP256R1
 "scep256r1"

	)

117 #define 
	#PTLS_GROUP_SECP384R1
 24

	)

118 #define 
	#PTLS_GROUP_NAME_SECP384R1
 "secp384r1"

	)

119 #define 
	#PTLS_GROUP_SECP521R1
 25

	)

120 #define 
	#PTLS_GROUP_NAME_SECP521R1
 "secp521r1"

	)

121 #define 
	#PTLS_GROUP_X25519
 29

	)

122 #define 
	#PTLS_GROUP_NAME_X25519
 "x25519"

	)

123 #define 
	#PTLS_GROUP_X448
 30

	)

124 #define 
	#PTLS_GROUP_NAME_X448
 "x448"

	)

127 #define 
	#PTLS_SIGNATURE_RSA_PKCS1_SHA1
 0x0201

	)

128 #define 
	#PTLS_SIGNATURE_RSA_PKCS1_SHA256
 0x0401

	)

129 #define 
	#PTLS_SIGNATURE_ECDSA_SECP256R1_SHA256
 0x0403

	)

130 #define 
	#PTLS_SIGNATURE_ECDSA_SECP384R1_SHA384
 0x0503

	)

131 #define 
	#PTLS_SIGNATURE_ECDSA_SECP521R1_SHA512
 0x0603

	)

132 #define 
	#PTLS_SIGNATURE_RSA_PSS_RSAE_SHA256
 0x0804

	)

133 #define 
	#PTLS_SIGNATURE_RSA_PSS_RSAE_SHA384
 0x0805

	)

134 #define 
	#PTLS_SIGNATURE_RSA_PSS_RSAE_SHA512
 0x0806

	)

135 #define 
	#PTLS_SIGNATURE_ED25519
 0x0807

	)

138 #define 
	#PTLS_ESNI_VERSION_DRAFT03
 0xff02

	)

140 #define 
	#PTLS_ESNI_RESPONSE_TYPE_ACCEPT
 0

	)

141 #define 
	#PTLS_ESNI_RESPONSE_TYPE_RETRY_REQUEST
 1

	)

144 #define 
	#PTLS_ERROR_CLASS_SELF_ALERT
 0

	)

145 #define 
	#PTLS_ERROR_CLASS_PEER_ALERT
 0x100

	)

146 #define 
	#PTLS_ERROR_CLASS_INTERNAL
 0x200

	)

148 #define 
	#PTLS_ERROR_GET_CLASS
(
e
) ((e) & ~0xff)

	)

149 #define 
	#PTLS_ALERT_TO_SELF_ERROR
(
e
) ((e) + 
PTLS_ERROR_CLASS_SELF_ALERT
)

	)

150 #define 
	#PTLS_ALERT_TO_PEER_ERROR
(
e
) ((e) + 
PTLS_ERROR_CLASS_PEER_ALERT
)

	)

151 #define 
	#PTLS_ERROR_TO_ALERT
(
e
) ((e)&0xff)

	)

154 #define 
	#PTLS_HKDF_EXPAND_LABEL_PREFIX
 "tls13 "

	)

157 #define 
	#PTLS_ALERT_LEVEL_WARNING
 1

	)

158 #define 
	#PTLS_ALERT_LEVEL_FATAL
 2

	)

160 #define 
	#PTLS_ALERT_CLOSE_NOTIFY
 0

	)

161 #define 
	#PTLS_ALERT_UNEXPECTED_MESSAGE
 10

	)

162 #define 
	#PTLS_ALERT_BAD_RECORD_MAC
 20

	)

163 #define 
	#PTLS_ALERT_HANDSHAKE_FAILURE
 40

	)

164 #define 
	#PTLS_ALERT_BAD_CERTIFICATE
 42

	)

165 #define 
	#PTLS_ALERT_UNSUPPORTED_CERTIFICATE
 43

	)

166 #define 
	#PTLS_ALERT_CERTIFICATE_REVOKED
 44

	)

167 #define 
	#PTLS_ALERT_CERTIFICATE_EXPIRED
 45

	)

168 #define 
	#PTLS_ALERT_CERTIFICATE_UNKNOWN
 46

	)

169 #define 
	#PTLS_ALERT_ILLEGAL_PARAMETER
 47

	)

170 #define 
	#PTLS_ALERT_UNKNOWN_CA
 48

	)

171 #define 
	#PTLS_ALERT_DECODE_ERROR
 50

	)

172 #define 
	#PTLS_ALERT_DECRYPT_ERROR
 51

	)

173 #define 
	#PTLS_ALERT_PROTOCOL_VERSION
 70

	)

174 #define 
	#PTLS_ALERT_INTERNAL_ERROR
 80

	)

175 #define 
	#PTLS_ALERT_USER_CANCELED
 90

	)

176 #define 
	#PTLS_ALERT_MISSING_EXTENSION
 109

	)

177 #define 
	#PTLS_ALERT_UNRECOGNIZED_NAME
 112

	)

178 #define 
	#PTLS_ALERT_CERTIFICATE_REQUIRED
 116

	)

179 #define 
	#PTLS_ALERT_NO_APPLICATION_PROTOCOL
 120

	)

182 #define 
	#PTLS_ERROR_NO_MEMORY
 (
PTLS_ERROR_CLASS_INTERNAL
 + 1)

	)

183 #define 
	#PTLS_ERROR_IN_PROGRESS
 (
PTLS_ERROR_CLASS_INTERNAL
 + 2)

	)

184 #define 
	#PTLS_ERROR_LIBRARY
 (
PTLS_ERROR_CLASS_INTERNAL
 + 3)

	)

185 #define 
	#PTLS_ERROR_INCOMPATIBLE_KEY
 (
PTLS_ERROR_CLASS_INTERNAL
 + 4)

	)

186 #define 
	#PTLS_ERROR_SESSION_NOT_FOUND
 (
PTLS_ERROR_CLASS_INTERNAL
 + 5)

	)

187 #define 
	#PTLS_ERROR_STATELESS_RETRY
 (
PTLS_ERROR_CLASS_INTERNAL
 + 6)

	)

188 #define 
	#PTLS_ERROR_NOT_AVAILABLE
 (
PTLS_ERROR_CLASS_INTERNAL
 + 7)

	)

189 #define 
	#PTLS_ERROR_COMPRESSION_FAILURE
 (
PTLS_ERROR_CLASS_INTERNAL
 + 8)

	)

190 #define 
	#PTLS_ERROR_ESNI_RETRY
 (
PTLS_ERROR_CLASS_INTERNAL
 + 8)

	)

191 #define 
	#PTLS_ERROR_REJECT_EARLY_DATA
 (
PTLS_ERROR_CLASS_INTERNAL
 + 9)

	)

192 #define 
	#PTLS_ERROR_DELEGATE
 (
PTLS_ERROR_CLASS_INTERNAL
 + 10)

	)

194 #define 
	#PTLS_ERROR_INCORRECT_BASE64
 (
PTLS_ERROR_CLASS_INTERNAL
 + 50)

	)

195 #define 
	#PTLS_ERROR_PEM_LABEL_NOT_FOUND
 (
PTLS_ERROR_CLASS_INTERNAL
 + 51)

	)

196 #define 
	#PTLS_ERROR_BER_INCORRECT_ENCODING
 (
PTLS_ERROR_CLASS_INTERNAL
 + 52)

	)

197 #define 
	#PTLS_ERROR_BER_MALFORMED_TYPE
 (
PTLS_ERROR_CLASS_INTERNAL
 + 53)

	)

198 #define 
	#PTLS_ERROR_BER_MALFORMED_LENGTH
 (
PTLS_ERROR_CLASS_INTERNAL
 + 54)

	)

199 #define 
	#PTLS_ERROR_BER_EXCESSIVE_LENGTH
 (
PTLS_ERROR_CLASS_INTERNAL
 + 55)

	)

200 #define 
	#PTLS_ERROR_BER_ELEMENT_TOO_SHORT
 (
PTLS_ERROR_CLASS_INTERNAL
 + 56)

	)

201 #define 
	#PTLS_ERROR_BER_UNEXPECTED_EOC
 (
PTLS_ERROR_CLASS_INTERNAL
 + 57)

	)

202 #define 
	#PTLS_ERROR_DER_INDEFINITE_LENGTH
 (
PTLS_ERROR_CLASS_INTERNAL
 + 58)

	)

203 #define 
	#PTLS_ERROR_INCORRECT_ASN1_SYNTAX
 (
PTLS_ERROR_CLASS_INTERNAL
 + 59)

	)

204 #define 
	#PTLS_ERROR_INCORRECT_PEM_KEY_VERSION
 (
PTLS_ERROR_CLASS_INTERNAL
 + 60)

	)

205 #define 
	#PTLS_ERROR_INCORRECT_PEM_ECDSA_KEY_VERSION
 (
PTLS_ERROR_CLASS_INTERNAL
 + 61)

	)

206 #define 
	#PTLS_ERROR_INCORRECT_PEM_ECDSA_CURVE
 (
PTLS_ERROR_CLASS_INTERNAL
 + 62)

	)

207 #define 
	#PTLS_ERROR_INCORRECT_PEM_ECDSA_KEYSIZE
 (
PTLS_ERROR_CLASS_INTERNAL
 + 63)

	)

208 #define 
	#PTLS_ERROR_INCORRECT_ASN1_ECDSA_KEY_SYNTAX
 (
PTLS_ERROR_CLASS_INTERNAL
 + 64)

	)

210 #define 
	#PTLS_HANDSHAKE_TYPE_CLIENT_HELLO
 1

	)

211 #define 
	#PTLS_HANDSHAKE_TYPE_SERVER_HELLO
 2

	)

212 #define 
	#PTLS_HANDSHAKE_TYPE_NEW_SESSION_TICKET
 4

	)

213 #define 
	#PTLS_HANDSHAKE_TYPE_END_OF_EARLY_DATA
 5

	)

214 #define 
	#PTLS_HANDSHAKE_TYPE_ENCRYPTED_EXTENSIONS
 8

	)

215 #define 
	#PTLS_HANDSHAKE_TYPE_CERTIFICATE
 11

	)

216 #define 
	#PTLS_HANDSHAKE_TYPE_CERTIFICATE_REQUEST
 13

	)

217 #define 
	#PTLS_HANDSHAKE_TYPE_CERTIFICATE_VERIFY
 15

	)

218 #define 
	#PTLS_HANDSHAKE_TYPE_FINISHED
 20

	)

219 #define 
	#PTLS_HANDSHAKE_TYPE_KEY_UPDATE
 24

	)

220 #define 
	#PTLS_HANDSHAKE_TYPE_COMPRESSED_CERTIFICATE
 25

	)

221 #define 
	#PTLS_HANDSHAKE_TYPE_MESSAGE_HASH
 254

	)

223 #define 
	#PTLS_CERTIFICATE_TYPE_X509
 0

	)

224 #define 
	#PTLS_CERTIFICATE_TYPE_RAW_PUBLIC_KEY
 2

	)

226 #define 
	#PTLS_ZERO_DIGEST_SHA256
 \

230 }

	)

232 #define 
	#PTLS_ZERO_DIGEST_SHA384
 \

237 }

	)

239 typedef struct 
st_ptls_t
 
	tptls_t
;

240 typedef struct 
st_ptls_context_t
 
	tptls_context_t
;

241 typedef struct 
st_ptls_key_schedule_t
 
	tptls_key_schedule_t
;

246 typedef struct 
	sst_ptls_iovec_t
 {

247 
uint8_t
 *
base
;

248 
size_t
 
len
;

249 } 
	tptls_iovec_t
;

254 typedef struct 
	sst_ptls_buffer_t
 {

255 
uint8_t
 *
base
;

256 
size_t
 
capacity
;

257 
size_t
 
off
;

258 int 
is_allocated
;

259 } 
	tptls_buffer_t
;

264 typedef struct 
	sst_ptls_key_exchange_context_t
 {

268 const struct 
st_ptls_key_exchange_algorithm_t
 *
algo
;

272 
ptls_iovec_t
 
pubkey
;

276 int (*
on_exchange
)(struct 
st_ptls_key_exchange_context_t
 **
keyex
, int 
release
, 
ptls_iovec_t
 *
secret
, ptls_iovec_t 
peerkey
);

277 } 
	tptls_key_exchange_context_t
;

282 typedef const struct 
	sst_ptls_key_exchange_algorithm_t
 {

286 
uint16_t
 
id
;

291 int (*
create
)(const struct 
st_ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_key_exchange_context_t
 **
ctx
);

295 int (*
exchange
)(const struct 
st_ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_iovec_t
 *
pubkey
, ptls_iovec_t *
secret
,

296 
ptls_iovec_t
 
peerkey
);

300 
intptr_t
 
data
;

304 const char *
name
;

305 } 
	tptls_key_exchange_algorithm_t
;

310 typedef struct 
	sst_ptls_cipher_context_t
 {

311 const struct 
st_ptls_cipher_algorithm_t
 *
algo
;

313 void (*
do_dispose
)(struct 
st_ptls_cipher_context_t
 *
ctx
);

314 void (*
do_init
)(struct 
st_ptls_cipher_context_t
 *
ctx
, const void *
iv
);

315 void (*
do_transform
)(struct 
st_ptls_cipher_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
len
);

316 } 
	tptls_cipher_context_t
;

321 typedef const struct 
	sst_ptls_cipher_algorithm_t
 {

322 const char *
name
;

323 
size_t
 
key_size
;

324 
size_t
 
block_size
;

325 
size_t
 
iv_size
;

326 
size_t
 
context_size
;

327 int (*
setup_crypto
)(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
);

328 } 
	tptls_cipher_algorithm_t
;

330 typedef struct 
	sst_ptls_aead_supplementary_encryption_t
 {

331 
ptls_cipher_context_t
 *
ctx
;

332 const void *
input
;

333 
uint8_t
 
output
[16];

334 } 
	tptls_aead_supplementary_encryption_t
;

340 typedef struct 
	sst_ptls_aead_context_t
 {

341 const struct 
st_ptls_aead_algorithm_t
 *
algo
;

343 void (*
dispose_crypto
)(struct 
st_ptls_aead_context_t
 *
ctx
);

344 void (*
do_xor_iv
)(struct 
st_ptls_aead_context_t
 *
ctx
, const void *
bytes
, 
size_t
 
len
);

345 void (*
do_encrypt_init
)(struct 
st_ptls_aead_context_t
 *
ctx
, 
uint64_t
 
seq
, const void *
aad
, 
size_t
 
aadlen
);

346 
size_t
 (*
do_encrypt_update
)(struct 
st_ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, size_t 
inlen
);

347 
size_t
 (*
do_encrypt_final
)(struct 
st_ptls_aead_context_t
 *
ctx
, void *
output
);

348 void (*
do_encrypt
)(struct 
st_ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

349 const void *
aad
, 
size_t
 
aadlen
, 
ptls_aead_supplementary_encryption_t
 *
supp
);

350 
size_t
 (*
do_decrypt
)(struct 
st_ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, size_t 
inlen
, 
uint64_t
 
seq
,

351 const void *
aad
, 
size_t
 
aadlen
);

352 } 
	tptls_aead_context_t
;

357 typedef const struct 
	sst_ptls_aead_algorithm_t
 {

361 const char *
name
;

365 const 
uint64_t
 
confidentiality_limit
;

369 const 
uint64_t
 
integrity_limit
;

373 
ptls_cipher_algorithm_t
 *
ctr_cipher
;

377 
ptls_cipher_algorithm_t
 *
ecb_cipher
;

381 
size_t
 
key_size
;

385 
size_t
 
iv_size
;

389 
size_t
 
tag_size
;

394 
size_t
 
context_size
;

398 int (*
setup_crypto
)(
ptls_aead_context_t
 *
ctx
, int 
is_enc
, const void *
key
, const void *
iv
);

399 } 
	tptls_aead_algorithm_t
;

404 typedef enum 
	een_ptls_hash_final_mode_t
 {

408 
PTLS_HASH_FINAL_MODE_FREE
 = 0,

412 
PTLS_HASH_FINAL_MODE_RESET
 = 1,

416 
PTLS_HASH_FINAL_MODE_SNAPSHOT
 = 2

417 } 
	tptls_hash_final_mode_t
;

422 typedef struct 
	sst_ptls_hash_context_t
 {

426 void (*
update
)(struct 
st_ptls_hash_context_t
 *
ctx
, const void *
src
, 
size_t
 
len
);

430 void (*
final
)(struct 
st_ptls_hash_context_t
 *
ctx
, void *
md
, 
ptls_hash_final_mode_t
 
mode
);

434 struct 
st_ptls_hash_context_t
 *(*
clone_
)(struct st_ptls_hash_context_t *
src
);

435 } 
	tptls_hash_context_t
;

440 typedef const struct 
	sst_ptls_hash_algorithm_t
 {

444 
size_t
 
block_size
;

448 
size_t
 
digest_size
;

452 
ptls_hash_context_t
 *(*
create
)(void);

456 
uint8_t
 
empty_digest
[
PTLS_MAX_DIGEST_SIZE
];

457 } 
	tptls_hash_algorithm_t
;

459 typedef const struct 
	sst_ptls_cipher_suite_t
 {

463 
uint16_t
 
id
;

467 
ptls_aead_algorithm_t
 *
aead
;

471 
ptls_hash_algorithm_t
 *
hash
;

475 const char *
name
;

476 } 
	tptls_cipher_suite_t
;

478 struct 
st_ptls_traffic_protection_t
;

480 typedef struct 
	sst_ptls_message_emitter_t
 {

481 
ptls_buffer_t
 *
buf
;

482 struct 
st_ptls_traffic_protection_t
 *
enc
;

483 
size_t
 
record_header_length
;

484 int (*
begin_message
)(struct 
st_ptls_message_emitter_t
 *
self
);

485 int (*
commit_message
)(struct 
st_ptls_message_emitter_t
 *
self
);

486 } 
	tptls_message_emitter_t
;

491 typedef struct 
	sst_ptls_esni_context_t
 {

492 
ptls_key_exchange_context_t
 **
key_exchanges
;

494 
ptls_cipher_suite_t
 *
cipher_suite
;

495 
uint8_t
 
record_digest
[
PTLS_MAX_DIGEST_SIZE
];

496 } * 
cipher_suites
;

497 
uint16_t
 
padded_length
;

498 
uint64_t
 
not_before
;

499 
uint64_t
 
not_after
;

500 
uint16_t
 
version
;

501 } 
	tptls_esni_context_t
;

507 #define 
	#PTLS_ESNI_NONCE_SIZE
 16

	)

509 typedef struct 
	sst_ptls_esni_secret_t
 {

510 
ptls_iovec_t
 
secret
;

511 
uint8_t
 
nonce
[
PTLS_ESNI_NONCE_SIZE
];

512 
uint8_t
 
esni_contents_hash
[
PTLS_MAX_DIGEST_SIZE
];

514 
ptls_key_exchange_algorithm_t
 *
key_share
;

515 
ptls_cipher_suite_t
 *
cipher
;

516 
ptls_iovec_t
 
pubkey
;

517 
uint8_t
 
record_digest
[
PTLS_MAX_DIGEST_SIZE
];

518 
uint16_t
 
padded_length
;

519 } 
client
;

520 
uint16_t
 
version
;

521 } 
	tptls_esni_secret_t
;

523 #define 
	#PTLS_CALLBACK_TYPE0
(
ret
, 
name
) \

524 typedef struct 
st_ptls_
##
	tname
##
	t_t
 { \

525 
	`ret
 (*
cb
)(struct 
st_ptls_
##
name
##
_t
 * 
self
); \

526 } 
	tptls_
##
	tname
##
	t_t


	)

528 #define 
	tPTLS_CALLBACK_TYPE
(
	tret
, 
	tname
, ...) \

529 typedef struct 
st_ptls_
##
	tname
##
	t_t
 { \

530 
	`ret
 (*
cb
)(struct 
st_ptls_
##
name
##
_t
 * 
self
, 
__VA_ARGS__
); \

531 } 
	tptls_
##
	tname
##
	t_t


	)

536 typedef struct 
	sst_ptls_on_client_hello_parameters_t
 {

540 
ptls_iovec_t
 
server_name
;

544 
ptls_iovec_t
 
raw_message
;

549 
ptls_iovec_t
 *
list
;

550 
size_t
 
count
;

551 } 
negotiated_protocols
;

553 const 
uint16_t
 *
list
;

554 
size_t
 
count
;

555 } 
signature_algorithms
;

557 const 
uint16_t
 *
list
;

558 
size_t
 
count
;

559 } 
certificate_compression_algorithms
;

561 const 
uint16_t
 *
list
;

562 
size_t
 
count
;

563 } 
cipher_suites
;

565 const 
uint8_t
 *
list
;

566 
size_t
 
count
;

567 } 
server_certificate_types
;

571 unsigned 
esni
 : 1;

575 unsigned 
incompatible_version
 : 1;

576 } 
	tptls_on_client_hello_parameters_t
;

581 
PTLS_CALLBACK_TYPE0
(
uint64_t
, 
get_time
);

586 
PTLS_CALLBACK_TYPE
(int, 
on_client_hello
, 
ptls_t
 *
tls
, 
ptls_on_client_hello_parameters_t
 *
params
);

590 
PTLS_CALLBACK_TYPE
(int, 
emit_certificate
, 
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_key_schedule_t
 *
key_sched
,

591 
ptls_iovec_t
 
context
, int 
push_status_request
, const 
uint16_t
 *
compress_algos
, 
size_t
 
num_compress_algos
);

595 
PTLS_CALLBACK_TYPE
(int, 
sign_certificate
, 
ptls_t
 *
tls
, 
uint16_t
 *
selected_algorithm
, 
ptls_buffer_t
 *
output
, 
ptls_iovec_t
 
input
,

596 const 
uint16_t
 *
algorithms
, 
size_t
 
num_algorithms
);

604 typedef struct 
	sst_ptls_verify_certificate_t
 {

605 int (*
cb
)(struct 
st_ptls_verify_certificate_t
 *
self
, 
ptls_t
 *
tls
,

606 int (**
verify_sign
)(void *
verify_ctx
, 
uint16_t
 
algo
, 
ptls_iovec_t
 
data
, ptls_iovec_t 
sign
), void **
verify_data
,

607 
ptls_iovec_t
 *
certs
, 
size_t
 
num_certs
);

611 const 
uint16_t
 *
algos
;

612 } 
	tptls_verify_certificate_t
;

619 
PTLS_CALLBACK_TYPE
(int, 
encrypt_ticket
, 
ptls_t
 *
tls
, int 
is_encrypt
, 
ptls_buffer_t
 *
dst
, 
ptls_iovec_t
 
src
);

623 
PTLS_CALLBACK_TYPE
(int, 
save_ticket
, 
ptls_t
 *
tls
, 
ptls_iovec_t
 
input
);

627 typedef struct 
	sst_ptls_log_event_t
 {

628 void (*
cb
)(struct 
st_ptls_log_event_t
 *
self
, 
ptls_t
 *
tls
, const char *
type
, const char *
fmt
, ...)

629 
__attribute__
((
format
(
printf
, 4, 5)));

630 } 
	tptls_log_event_t
;

634 
PTLS_CALLBACK_TYPE
(void, 
update_open_count
, 
ssize_t
 
delta
);

639 
PTLS_CALLBACK_TYPE
(int, 
update_traffic_key
, 
ptls_t
 *
tls
, int 
is_enc
, 
size_t
 
epoch
, const void *
secret
);

643 
PTLS_CALLBACK_TYPE
(int, 
on_extension
, 
ptls_t
 *
tls
, 
uint8_t
 
hstype
, 
uint16_t
 
exttype
, 
ptls_iovec_t
 
extdata
);

647 typedef struct 
	sst_ptls_decompress_certificate_t
 {

651 const 
uint16_t
 *
supported_algorithms
;

655 int (*
cb
)(struct 
st_ptls_decompress_certificate_t
 *
self
, 
ptls_t
 *
tls
, 
uint16_t
 
algorithm
, 
ptls_iovec_t
 
output
,

656 
ptls_iovec_t
 
input
);

657 } 
	tptls_decompress_certificate_t
;

661 
PTLS_CALLBACK_TYPE
(int, 
update_esni_key
, 
ptls_t
 *
tls
, 
ptls_iovec_t
 
secret
, 
ptls_hash_algorithm_t
 *
hash
,

662 const void *
hashed_esni_contents
);

667 struct 
	sst_ptls_context_t
 {

671 void (*
random_bytes
)(void *
buf
, 
size_t
 
len
);

675 
ptls_get_time_t
 *
get_time
;

679 
ptls_key_exchange_algorithm_t
 **
key_exchanges
;

683 
ptls_cipher_suite_t
 **
cipher_suites
;

688 
ptls_iovec_t
 *
list
;

689 
size_t
 
count
;

690 } 
certificates
;

694 
ptls_esni_context_t
 **
esni
;

698 
ptls_on_client_hello_t
 *
on_client_hello
;

702 
ptls_emit_certificate_t
 *
emit_certificate
;

706 
ptls_sign_certificate_t
 *
sign_certificate
;

710 
ptls_verify_certificate_t
 *
verify_certificate
;

714 
uint32_t
 
ticket_lifetime
;

718 
uint32_t
 
max_early_data_size
;

722 
size_t
 
max_buffer_size
;

727 const char *
hkdf_label_prefix__obsolete
;

731 unsigned 
require_dhe_on_psk
 : 1;

735 unsigned 
use_exporter
 : 1;

740 unsigned 
send_change_cipher_spec
 : 1;

745 unsigned 
require_client_authentication
 : 1;

749 unsigned 
omit_end_of_early_data
 : 1;

762 unsigned 
use_raw_public_keys
 : 1;

766 unsigned 
server_cipher_preference
 : 1;

770 
ptls_encrypt_ticket_t
 *
encrypt_ticket
;

774 
ptls_save_ticket_t
 *
save_ticket
;

778 
ptls_log_event_t
 *
log_event
;

782 
ptls_update_open_count_t
 *
update_open_count
;

786 
ptls_update_traffic_key_t
 *
update_traffic_key
;

790 
ptls_decompress_certificate_t
 *
decompress_certificate
;

794 
ptls_update_esni_key_t
 *
update_esni_key
;

798 
ptls_on_extension_t
 *
on_extension
;

801 typedef struct 
	sst_ptls_raw_extension_t
 {

802 
uint16_t
 
type
;

803 
ptls_iovec_t
 
data
;

804 } 
	tptls_raw_extension_t
;

806 typedef enum 
	een_ptls_early_data_acceptance_t
 {

807 
PTLS_EARLY_DATA_ACCEPTANCE_UNKNOWN
 = 0,

808 
PTLS_EARLY_DATA_REJECTED
,

809 
PTLS_EARLY_DATA_ACCEPTED


810 } 
	tptls_early_data_acceptance_t
;

815 #ifdef 
_WINDOWS


817 #pragma 
warning
(
push
)

818 #pragma 
warning
(
disable
 : 4201)

820 typedef struct 
	sst_ptls_handshake_properties_t
 {

827 const 
ptls_iovec_t
 *
list
;

828 
size_t
 
count
;

829 } 
negotiated_protocols
;

833 
ptls_iovec_t
 
session_ticket
;

839 
size_t
 *
max_early_data_size
;

845 
ptls_early_data_acceptance_t
 
early_data_acceptance
;

849 unsigned 
negotiate_before_key_exchange
 : 1;

853 
ptls_iovec_t
 
esni_keys
;

854 } 
client
;

860 
uint8_t
 
base
[
PTLS_MAX_DIGEST_SIZE
];

861 
size_t
 
len
;

862 } 
selected_psk_binder
;

871 const void *
key
;

875 
ptls_iovec_t
 
additional_data
;

876 } 
cookie
;

880 unsigned 
enforce_retry
 : 1;

884 unsigned 
retry_uses_cookie
 : 1;

885 } 
server
;

890 
ptls_raw_extension_t
 *
additional_extensions
;

894 int (*
collect_extension
)(
ptls_t
 *
tls
, struct 
st_ptls_handshake_properties_t
 *
properties
, 
uint16_t
 
type
);

898 int (*
collected_extensions
)(
ptls_t
 *
tls
, struct 
st_ptls_handshake_properties_t
 *
properties
, 
ptls_raw_extension_t
 *
extensions
);

899 } 
	tptls_handshake_properties_t
;

900 #ifdef 
_WINDOWS


901 #pragma 
warning
(
pop
)

903 #ifdef 
_WINDOWS


905 #pragma 
warning
(
disable
 : 4293)

910 static 
ptls_iovec_t
 
ptls_iovec_init
(const void *
p
, 
size_t
 
len
);

914 static void 
ptls_buffer_init
(
ptls_buffer_t
 *
buf
, void *
smallbuf
, 
size_t
 
smallbuf_size
);

918 static void 
ptls_buffer_dispose
(
ptls_buffer_t
 *
buf
);

922 void 
ptls_buffer__release_memory
(
ptls_buffer_t
 *
buf
);

926 int 
ptls_buffer_reserve
(
ptls_buffer_t
 *
buf
, 
size_t
 
delta
);

930 int 
ptls_buffer__do_pushv
(
ptls_buffer_t
 *
buf
, const void *
src
, 
size_t
 
len
);

934 int 
ptls_buffer__adjust_quic_blocksize
(
ptls_buffer_t
 *
buf
, 
size_t
 
body_size
);

938 int 
ptls_buffer__adjust_asn1_blocksize
(
ptls_buffer_t
 *
buf
, 
size_t
 
body_size
);

942 int 
ptls_buffer_push_asn1_ubigint
(
ptls_buffer_t
 *
buf
, const void *
bignum
, 
size_t
 
size
);

946 static 
uint8_t
 *
ptls_encode_quicint
(uint8_t *
p
, 
uint64_t
 
v
);

947 #define 
	#PTLS_ENCODE_QUICINT_CAPACITY
 8

	)

949 #define 
	#ptls_buffer_pushv
(
buf
, 
src
, 
len
) \

951 if ((
ret
 = 
	`ptls_buffer__do_pushv
((
buf
), (
src
), (
len
))) != 0) \

952 goto 
Exit
; \

953 } while (0)

	)

955 #define 
	#ptls_buffer_push
(
buf
, ...) \

957 if ((
ret
 = 
	`ptls_buffer__do_pushv
((
buf
), (
uint8_t
[]){
__VA_ARGS__
}, sizeof((uint8_t[]){__VA_ARGS__}))) != 0) \

958 goto 
Exit
; \

959 } while (0)

	)

961 #define 
	#ptls_buffer_push16
(
buf
, 
v
) \

963 
uint16_t
 
_v
 = (
v
); \

964 
	`ptls_buffer_push
(
buf
, (
uint8_t
)(
_v
 >> 8), (uint8_t)_v); \

965 } while (0)

	)

967 #define 
	#ptls_buffer_push24
(
buf
, 
v
) \

969 
uint32_t
 
_v
 = (
v
); \

970 
	`ptls_buffer_push
(
buf
, (
uint8_t
)(
_v
 >> 16), (uint8_t)(_v >> 8), (uint8_t)_v); \

971 } while (0)

	)

973 #define 
	#ptls_buffer_push32
(
buf
, 
v
) \

975 
uint32_t
 
_v
 = (
v
); \

976 
	`ptls_buffer_push
(
buf
, (
uint8_t
)(
_v
 >> 24), (uint8_t)(_v >> 16), (uint8_t)(_v >> 8), (uint8_t)_v); \

977 } while (0)

	)

979 #define 
	#ptls_buffer_push64
(
buf
, 
v
) \

981 
uint64_t
 
_v
 = (
v
); \

982 
	`ptls_buffer_push
(
buf
, (
uint8_t
)(
_v
 >> 56), (uint8_t)(_v >> 48), (uint8_t)(_v >> 40), (uint8_t)(_v >> 32), \

983 (
uint8_t
)(
_v
 >> 24), (uint8_t)(_v >> 16), (uint8_t)(_v >> 8), (uint8_t)_v); \

984 } while (0)

	)

986 #define 
	#ptls_buffer_push_quicint
(
buf
, 
v
) \

988 if ((
ret
 = 
	`ptls_buffer_reserve
((
buf
), 
PTLS_ENCODE_QUICINT_CAPACITY
)) != 0) \

989 goto 
Exit
; \

990 
uint8_t
 *
d
 = 
	`ptls_encode_quicint
((
buf
)->
base
 + (buf)->
off
, (
v
)); \

991 (
buf
)->
off
 = 
d
 - (buf)->
base
; \

992 } while (0)

	)

994 #define 
	#ptls_buffer_push_block
(
buf
, 
_capacity
, 
block
) \

996 
size_t
 
capacity
 = (
_capacity
); \

997 
	`ptls_buffer_pushv
((
buf
), (
uint8_t
 *)"\0\0\0\0\0\0\0", 
capacity
 != -1 ? capacity : 1); \

998 
size_t
 
body_start
 = (
buf
)->
off
; \

1000 
block
 \

1002 
size_t
 
body_size
 = (
buf
)->
off
 - 
body_start
; \

1003 if (
capacity
 != -1) { \

1004 for (; 
capacity
 != 0; --capacity) \

1005 (
buf
)->
base
[
body_start
 - 
capacity
] = (
uint8_t
)(
body_size
 >> (8 * (capacity - 1))); \

1007 if ((
ret
 = 
	`ptls_buffer__adjust_quic_blocksize
((
buf
), 
body_size
)) != 0) \

1008 goto 
Exit
; \

1010 } while (0)

	)

1012 #define 
	#ptls_buffer_push_asn1_block
(
buf
, 
block
) \

1014 
	`ptls_buffer_push
((
buf
), 0xff); \

1015 
size_t
 
body_start
 = (
buf
)->
off
; \

1017 
block
 \

1019 
size_t
 
body_size
 = (
buf
)->
off
 - 
body_start
; \

1020 if (
body_size
 < 128) { \

1021 (
buf
)->
base
[
body_start
 - 1] = (
uint8_t
)
body_size
; \

1023 if ((
ret
 = 
	`ptls_buffer__adjust_asn1_blocksize
((
buf
), 
body_size
)) != 0) \

1024 goto 
Exit
; \

1026 } while (0)

	)

1028 #define 
	#ptls_buffer_push_asn1_sequence
(
buf
, 
block
) \

1030 
	`ptls_buffer_push
((
buf
), 0x30); \

1031 
	`ptls_buffer_push_asn1_block
((
buf
), 
block
); \

1032 } while (0)

	)

1034 #define 
	#ptls_buffer_push_message_body
(
buf
, 
key_sched
, 
type
, 
block
) \

1036 
ptls_buffer_t
 *
_buf
 = (
buf
); \

1037 
ptls_key_schedule_t
 *
_key_sched
 = (
key_sched
); \

1038 
size_t
 
mess_start
 = 
_buf
->
off
; \

1039 
	`ptls_buffer_push
(
_buf
, (
type
)); \

1040 
	`ptls_buffer_push_block
(
_buf
, 3, 
block
); \

1041 if (
_key_sched
 != 
NULL
) \

1042 
	`ptls__key_schedule_update_hash
(
_key_sched
, 
_buf
->
base
 + 
mess_start
, _buf->
off
 - mess_start); \

1043 } while (0)

	)

1045 #define 
	#ptls_push_message
(
emitter
, 
key_sched
, 
type
, 
block
) \

1047 
ptls_message_emitter_t
 *
_emitter
 = (
emitter
); \

1048 if ((
ret
 = 
_emitter
->
	`begin_message
(_emitter)) != 0) \

1049 goto 
Exit
; \

1050 
	`ptls_buffer_push_message_body
(
_emitter
->
buf
, (
key_sched
), (
type
), 
block
); \

1051 if ((
ret
 = 
_emitter
->
	`commit_message
(_emitter)) != 0) \

1052 goto 
Exit
; \

1053 } while (0)

	)

1055 int 
ptls_decode16
(
uint16_t
 *
value
, const 
uint8_t
 **
src
, const uint8_t *
end
);

1056 int 
ptls_decode24
(
uint32_t
 *
value
, const 
uint8_t
 **
src
, const uint8_t *
end
);

1057 int 
ptls_decode32
(
uint32_t
 *
value
, const 
uint8_t
 **
src
, const uint8_t *
end
);

1058 int 
ptls_decode64
(
uint64_t
 *
value
, const 
uint8_t
 **
src
, const uint8_t *
end
);

1059 
uint64_t
 
ptls_decode_quicint
(const 
uint8_t
 **
src
, const uint8_t *
end
);

1061 #define 
	#ptls_decode_open_block
(
src
, 
end
, 
capacity
, 
block
) \

1063 
size_t
 
_capacity
 = (
capacity
); \

1064 
size_t
 
_block_size
; \

1065 if (
_capacity
 == -1) { \

1066 
uint64_t
 
_block_size64
; \

1067 const 
uint8_t
 *
_src
 = (
src
); \

1068 if ((
_block_size64
 = 
	`ptls_decode_quicint
(&
_src
, 
end
)) == 
UINT64_MAX
 || \

1069 (sizeof(
size_t
) < 8 && (
_block_size64
 >> (8 * sizeof(size_t))) != 0)) { \

1070 
ret
 = 
PTLS_ALERT_DECODE_ERROR
; \

1071 goto 
Exit
; \

1073 (
src
) = 
_src
; \

1074 
_block_size
 = (
size_t
)
_block_size64
; \

1076 if (
_capacity
 > (
size_t
)(
end
 - (
src
))) { \

1077 
ret
 = 
PTLS_ALERT_DECODE_ERROR
; \

1078 goto 
Exit
; \

1080 
_block_size
 = 0; \

1082 
_block_size
 = _block_size << 8 | *(
src
)++; \

1083 } while (--
_capacity
 != 0); \

1085 if (
_block_size
 > (
size_t
)(
end
 - (
src
))) { \

1086 
ret
 = 
PTLS_ALERT_DECODE_ERROR
; \

1087 goto 
Exit
; \

1090 const 
uint8_t
 *const 
end
 = (
src
) + 
_block_size
; \

1092 
block
 \

1094 if ((
src
) != 
end
) { \

1095 
ret
 = 
PTLS_ALERT_DECODE_ERROR
; \

1096 goto 
Exit
; \

1099 } while (0)

	)

1101 #define 
	#ptls_decode_assert_block_close
(
src
, 
end
) \

1103 if ((
src
) != 
end
) { \

1104 
ret
 = 
PTLS_ALERT_DECODE_ERROR
; \

1105 goto 
Exit
; \

1107 } while (0);

	)

1109 #define 
	#ptls_decode_block
(
src
, 
end
, 
capacity
, 
block
) \

1111 
	`ptls_decode_open_block
((
src
), 
end
, 
capacity
, 
block
); \

1112 
	`ptls_decode_assert_block_close
((
src
), 
end
); \

1113 } while (0)

	)

1118 
ptls_t
 *
ptls_client_new
(
ptls_context_t
 *
ctx
);

1122 
ptls_t
 *
ptls_server_new
(
ptls_context_t
 *
ctx
);

1126 static 
ptls_t
 *
ptls_new
(
ptls_context_t
 *
ctx
, int 
is_server
);

1130 void 
ptls_free
(
ptls_t
 *
tls
);

1134 
ptls_context_t
 *
ptls_get_context
(
ptls_t
 *
tls
);

1138 void 
ptls_set_context
(
ptls_t
 *
tls
, 
ptls_context_t
 *
ctx
);

1142 
ptls_iovec_t
 
ptls_get_client_random
(
ptls_t
 *
tls
);

1146 
ptls_cipher_suite_t
 *
ptls_get_cipher
(
ptls_t
 *
tls
);

1150 const char *
ptls_get_server_name
(
ptls_t
 *
tls
);

1158 int 
ptls_set_server_name
(
ptls_t
 *
tls
, const char *
server_name
, 
size_t
 
server_name_len
);

1162 const char *
ptls_get_negotiated_protocol
(
ptls_t
 *
tls
);

1166 int 
ptls_set_negotiated_protocol
(
ptls_t
 *
tls
, const char *
protocol
, 
size_t
 
protocol_len
);

1170 int 
ptls_handshake_is_complete
(
ptls_t
 *
tls
);

1174 int 
ptls_is_psk_handshake
(
ptls_t
 *
tls
);

1178 void **
ptls_get_data_ptr
(
ptls_t
 *
tls
);

1182 int 
ptls_skip_tracing
(
ptls_t
 *
tls
);

1186 void 
ptls_set_skip_tracing
(
ptls_t
 *
tls
, int 
skip_tracing
);

1195 int 
ptls_handshake
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, const void *
input
, 
size_t
 *
inlen
, 
ptls_handshake_properties_t
 *
args
);

1199 int 
ptls_receive
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
plaintextbuf
, const void *
input
, 
size_t
 *
len
);

1203 int 
ptls_send
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, const void *
input
, 
size_t
 
inlen
);

1207 int 
ptls_update_key
(
ptls_t
 *
tls
, int 
request_update
);

1211 int 
ptls_is_server
(
ptls_t
 *
tls
);

1215 
size_t
 
ptls_get_record_overhead
(
ptls_t
 *
tls
);

1219 int 
ptls_send_alert
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, 
uint8_t
 
level
, uint8_t 
description
);

1223 int 
ptls_export_secret
(
ptls_t
 *
tls
, void *
output
, 
size_t
 
outlen
, const char *
label
, 
ptls_iovec_t
 
context_value
, int 
is_early
);

1227 int 
ptls_build_certificate_message
(
ptls_buffer_t
 *
buf
, 
ptls_iovec_t
 
request_context
, ptls_iovec_t *
certificates
,

1228 
size_t
 
num_certificates
, 
ptls_iovec_t
 
ocsp_status
);

1232 int 
ptls_calc_hash
(
ptls_hash_algorithm_t
 *
algo
, void *
output
, const void *
src
, 
size_t
 
len
);

1236 
ptls_hash_context_t
 *
ptls_hmac_create
(
ptls_hash_algorithm_t
 *
algo
, const void *
key
, 
size_t
 
key_size
);

1240 int 
ptls_hkdf_extract
(
ptls_hash_algorithm_t
 *
hash
, void *
output
, 
ptls_iovec_t
 
salt
, ptls_iovec_t 
ikm
);

1244 int 
ptls_hkdf_expand
(
ptls_hash_algorithm_t
 *
hash
, void *
output
, 
size_t
 
outlen
, 
ptls_iovec_t
 
prk
, ptls_iovec_t 
info
);

1248 int 
ptls_hkdf_expand_label
(
ptls_hash_algorithm_t
 *
algo
, void *
output
, 
size_t
 
outlen
, 
ptls_iovec_t
 
secret
, const char *
label
,

1249 
ptls_iovec_t
 
hash_value
, const char *
label_prefix
);

1253 
ptls_cipher_context_t
 *
ptls_cipher_new
(
ptls_cipher_algorithm_t
 *
algo
, int 
is_enc
, const void *
key
);

1257 void 
ptls_cipher_free
(
ptls_cipher_context_t
 *
ctx
);

1261 static void 
ptls_cipher_init
(
ptls_cipher_context_t
 *
ctx
, const void *
iv
);

1267 static void 
ptls_cipher_encrypt
(
ptls_cipher_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
len
);

1276 
ptls_aead_context_t
 *
ptls_aead_new
(
ptls_aead_algorithm_t
 *
aead
, 
ptls_hash_algorithm_t
 *
hash
, int 
is_enc
, const void *
secret
,

1277 const char *
label_prefix
);

1284 
ptls_aead_context_t
 *
ptls_aead_new_direct
(
ptls_aead_algorithm_t
 *
aead
, int 
is_enc
, const void *
key
, const void *
iv
);

1288 void 
ptls_aead_free
(
ptls_aead_context_t
 *
ctx
);

1293 static void 
ptls_aead_xor_iv
(
ptls_aead_context_t
 *
ctx
, const void *
bytes
, 
size_t
 
len
);

1297 static 
size_t
 
ptls_aead_encrypt
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, size_t 
inlen
, 
uint64_t
 
seq
,

1298 const void *
aad
, 
size_t
 
aadlen
);

1299 static void 
ptls_aead_encrypt_s
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

1300 const void *
aad
, 
size_t
 
aadlen
, 
ptls_aead_supplementary_encryption_t
 *
supp
);

1304 static void 
ptls_aead_encrypt_init
(
ptls_aead_context_t
 *
ctx
, 
uint64_t
 
seq
, const void *
aad
, 
size_t
 
aadlen
);

1309 static 
size_t
 
ptls_aead_encrypt_update
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, size_t 
inlen
);

1314 static 
size_t
 
ptls_aead_encrypt_final
(
ptls_aead_context_t
 *
ctx
, void *
output
);

1319 static 
size_t
 
ptls_aead_decrypt
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, size_t 
inlen
, 
uint64_t
 
seq
,

1320 const void *
aad
, 
size_t
 
aadlen
);

1324 
size_t
 
ptls_get_read_epoch
(
ptls_t
 *
tls
);

1342 int 
ptls_handle_message
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, 
size_t
 
epoch_offsets
[5], size_t 
in_epoch
, const void *
input
,

1343 
size_t
 
inlen
, 
ptls_handshake_properties_t
 *
properties
);

1344 int 
ptls_client_handle_message
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, 
size_t
 
epoch_offsets
[5], size_t 
in_epoch
, const void *
input
,

1345 
size_t
 
inlen
, 
ptls_handshake_properties_t
 *
properties
);

1346 int 
ptls_server_handle_message
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, 
size_t
 
epoch_offsets
[5], size_t 
in_epoch
, const void *
input
,

1347 
size_t
 
inlen
, 
ptls_handshake_properties_t
 *
properties
);

1351 void 
ptls_aead__build_iv
(
ptls_aead_algorithm_t
 *
algo
, 
uint8_t
 *
iv
, const uint8_t *
static_iv
, 
uint64_t
 
seq
);

1355 static void 
ptls_aead__do_encrypt
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

1356 const void *
aad
, 
size_t
 
aadlen
, 
ptls_aead_supplementary_encryption_t
 *
supp
);

1360 void 
ptls__key_schedule_update_hash
(
ptls_key_schedule_t
 *
sched
, const 
uint8_t
 *
msg
, 
size_t
 
msglen
);

1364 extern void (*volatile 
ptls_clear_memory
)(void *
p
, 
size_t
 
len
);

1368 extern int (*volatile 
ptls_mem_equal
)(const void *
x
, const void *
y
, 
size_t
 
len
);

1372 static 
ptls_iovec_t
 
ptls_iovec_init
(const void *
p
, 
size_t
 
len
);

1376 int 
ptls_server_name_is_ipaddr
(const char *
name
);

1381 int 
ptls_load_certificates
(
ptls_context_t
 *
ctx
, char const *
cert_pem_file
);

1385 int 
ptls_esni_init_context
(
ptls_context_t
 *
ctx
, 
ptls_esni_context_t
 *
esni
, 
ptls_iovec_t
 
esni_keys
,

1386 
ptls_key_exchange_context_t
 **
key_exchanges
);

1390 void 
ptls_esni_dispose_context
(
ptls_esni_context_t
 *
esni
);

1394 
ptls_esni_secret_t
 *
ptls_get_esni_secret
(
ptls_t
 *
ctx
);

1398 char *
ptls_hexdump
(char *
dst
, const void *
src
, 
size_t
 
len
);

1402 extern 
ptls_get_time_t
 
ptls_get_time
;

1403 #if 
PICOTLS_USE_DTRACE


1407 extern 
PTLS_THREADLOCAL
 unsigned 
ptls_default_skip_tracing
;

1409 #define 
	#ptls_default_skip_tracing
 0

	)

1414 
inline
 
ptls_t
 *
ptls_new
(
ptls_context_t
 *
ctx
, int 
is_server
)

1416 return 
	gis_server
 ? 
ptls_server_new
(
ctx
) : 
ptls_client_new
(ctx);

1419 
inline
 
ptls_iovec_t
 
ptls_iovec_init
(const void *
p
, 
size_t
 
len
)

1424 
ptls_iovec_t
 
	gr
;

1425 
	gr
.
	gbase
 = (
uint8_t
 *)
p
;

1426 
	gr
.
	glen
 = 
len
;

1427 return 
	gr
;

1430 
inline
 void 
ptls_buffer_init
(
ptls_buffer_t
 *
buf
, void *
smallbuf
, 
size_t
 
smallbuf_size
)

1432 
assert
(
smallbuf
 != 
NULL
);

1433 
	gbuf
->
	gbase
 = (
uint8_t
 *)
smallbuf
;

1434 
	gbuf
->
	goff
 = 0;

1435 
	gbuf
->
	gcapacity
 = 
smallbuf_size
;

1436 
	gbuf
->
	gis_allocated
 = 0;

1439 
inline
 void 
ptls_buffer_dispose
(
ptls_buffer_t
 *
buf
)

1441 
ptls_buffer__release_memory
(
buf
);

1442 *
	gbuf
 = (
ptls_buffer_t
){
NULL
};

1445 
inline
 
uint8_t
 *
ptls_encode_quicint
(uint8_t *
p
, 
uint64_t
 
v
)

1447 if (
PTLS_UNLIKELY
(
v
 > 63)) {

1448 if (
PTLS_UNLIKELY
(
v
 > 16383)) {

1449 unsigned 
	gsb
;

1450 if (
PTLS_UNLIKELY
(
v
 > 1073741823)) {

1451 
assert
(
v
 <= 4611686018427387903);

1452 *
	gp
++ = 0xc0 | (
uint8_t
)(
v
 >> 56);

1453 
	gsb
 = 6 * 8;

1455 *
	gp
++ = 0x80 | (
uint8_t
)(
v
 >> 24);

1456 
	gsb
 = 2 * 8;

1459 *
	gp
++ = (
uint8_t
)(
v
 >> 
sb
);

1460 } while ((
	gsb
 -= 8) != 0);

1462 *
	gp
++ = 0x40 | (
uint8_t
)((
uint16_t
)
v
 >> 8);

1465 *
	gp
++ = (
uint8_t
)
v
;

1466 return 
	gp
;

1469 
inline
 void 
ptls_cipher_init
(
ptls_cipher_context_t
 *
ctx
, const void *
iv
)

1471 
	gctx
->
do_init
(
ctx
, 
iv
);

1474 
inline
 void 
ptls_cipher_encrypt
(
ptls_cipher_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
len
)

1476 
	gctx
->
do_transform
(
ctx
, 
output
, 
input
, 
len
);

1479 
inline
 void 
ptls_aead_xor_iv
(
ptls_aead_context_t
 *
ctx
, const void *
bytes
, 
size_t
 
len
)

1481 
	gctx
->
do_xor_iv
(
ctx
, 
bytes
, 
len
);

1484 
inline
 
size_t
 
ptls_aead_encrypt
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, size_t 
inlen
, 
uint64_t
 
seq
,

1485 const void *
aad
, 
size_t
 
aadlen
)

1487 
	gctx
->
do_encrypt
(
ctx
, 
output
, 
input
, 
inlen
, 
seq
, 
aad
, 
aadlen
, 
NULL
);

1488 return 
	ginlen
 + 
	gctx
->
	galgo
->
	gtag_size
;

1491 
inline
 void 
ptls_aead_encrypt_s
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

1492 const void *
aad
, 
size_t
 
aadlen
, 
ptls_aead_supplementary_encryption_t
 *
supp
)

1494 
	gctx
->
do_encrypt
(
ctx
, 
output
, 
input
, 
inlen
, 
seq
, 
aad
, 
aadlen
, 
supp
);

1497 
inline
 void 
ptls_aead_encrypt_init
(
ptls_aead_context_t
 *
ctx
, 
uint64_t
 
seq
, const void *
aad
, 
size_t
 
aadlen
)

1499 
	gctx
->
do_encrypt_init
(
ctx
, 
seq
, 
aad
, 
aadlen
);

1502 
inline
 
size_t
 
ptls_aead_encrypt_update
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, size_t 
inlen
)

1504 return 
	gctx
->
do_encrypt_update
(
ctx
, 
output
, 
input
, 
inlen
);

1507 
inline
 
size_t
 
ptls_aead_encrypt_final
(
ptls_aead_context_t
 *
ctx
, void *
output
)

1509 return 
	gctx
->
do_encrypt_final
(
ctx
, 
output
);

1512 
inline
 void 
ptls_aead__do_encrypt
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

1513 const void *
aad
, 
size_t
 
aadlen
, 
ptls_aead_supplementary_encryption_t
 *
supp
)

1515 
	gctx
->
do_encrypt_init
(
ctx
, 
seq
, 
aad
, 
aadlen
);

1516 
	gctx
->
do_encrypt_update
(
ctx
, 
output
, 
input
, 
inlen
);

1517 
	gctx
->
do_encrypt_final
(
ctx
, (
uint8_t
 *)
output
 + 
inlen
);

1519 if (
	gsupp
 != 
NULL
) {

1520 
ptls_cipher_init
(
supp
->
ctx
, supp->
input
);

1521 
memset
(
supp
->
output
, 0, sizeof(supp->output));

1522 
ptls_cipher_encrypt
(
supp
->
ctx
, supp->
output
, supp->output, sizeof(supp->output));

1526 
inline
 
size_t
 
ptls_aead_decrypt
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, size_t 
inlen
, 
uint64_t
 
seq
,

1527 const void *
aad
, 
size_t
 
aadlen
)

1529 return 
	gctx
->
do_decrypt
(
ctx
, 
output
, 
input
, 
inlen
, 
seq
, 
aad
, 
aadlen
);

1532 #define 
	#ptls_define_hash
(
name
, 
ctx_type
, 
init_func
, 
update_func
, 
final_func
) \

1534 struct 
name
##
_context_t
 { \

1535 
ptls_hash_context_t
 
super
; \

1536 
ctx_type
 
ctx
; \

1539 static void 
name
##
	`_update
(
ptls_hash_context_t
 *
_ctx
, const void *
src
, 
size_t
 
len
) \

1541 struct 
name
##
_context_t
 *
ctx
 = (struct name##_context_t *)
_ctx
; \

1542 
	`update_func
(&
ctx
->ctx, 
src
, 
len
); \

1545 static void 
name
##
	`_final
(
ptls_hash_context_t
 *
_ctx
, void *
md
, 
ptls_hash_final_mode_t
 
mode
) \

1547 struct 
name
##
_context_t
 *
ctx
 = (struct name##_context_t *)
_ctx
; \

1548 if (
mode
 == 
PTLS_HASH_FINAL_MODE_SNAPSHOT
) { \

1549 
ctx_type
 
copy
 = 
ctx
->ctx; \

1550 
	`final_func
(&
copy
, 
md
); \

1551 
	`ptls_clear_memory
(&
copy
, sizeof(copy)); \

1554 if (
md
 != 
NULL
) \

1555 
	`final_func
(&
ctx
->ctx, 
md
); \

1556 switch (
mode
) { \

1557 case 
PTLS_HASH_FINAL_MODE_FREE
: \

1558 
	`ptls_clear_memory
(&
ctx
->ctx, sizeof(ctx->ctx)); \

1559 
	`free
(
ctx
); \

1561 case 
PTLS_HASH_FINAL_MODE_RESET
: \

1562 
	`init_func
(&
ctx
->ctx); \

1565 
	`assert
(!"FIXME"); \

1570 static 
ptls_hash_context_t
 *
name
##
	`_clone
(ptls_hash_context_t *
_src
) \

1572 struct 
name
##
_context_t
 *
dst
, *
src
 = (struct name##_context_t *)
_src
; \

1573 if ((
dst
 = 
	`malloc
(sizeof(*dst))) == 
NULL
) \

1574 return 
NULL
; \

1575 *
dst
 = *
src
; \

1576 return &
dst
->
super
; \

1579 static 
ptls_hash_context_t
 *
name
##
	`_create
(void) \

1581 struct 
name
##
_context_t
 *
ctx
; \

1582 if ((
ctx
 = 
	`malloc
(sizeof(*ctx))) == 
NULL
) \

1583 return 
NULL
; \

1584 
ctx
->
super
 = (
ptls_hash_context_t
){
name
##
_update
, name##
_final
, name##
_clone
}; \

1585 
	`init_func
(&
ctx
->ctx); \

1586 return &
ctx
->
super
; \

1587 }

	)

1589 #ifdef 
__cplusplus


	@deps/picotls/include/picotls/asn1.h

17 #ifndef 
PTLS_ASN1_H


18 #define 
	#PTLS_ASN1_H


	)

37 typedef struct 
	sst_ptls_minicrypto_log_ctx_t
 {

38 void *
	mctx
;

39 void (*
	mfn
)(void *
	mctx
, const char *
	mformat
, ...);

40 } 
	tptls_minicrypto_log_ctx_t
;

42 
size_t
 
ptls_asn1_error_message
(char const *
error_label
, size_t 
bytes_max
, size_t 
byte_index
, int 
level
,

43 
ptls_minicrypto_log_ctx_t
 *
log_ctx
);

45 void 
ptls_asn1_dump_content
(const 
uint8_t
 *
bytes
, 
size_t
 
bytes_max
, size_t 
byte_index
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
);

47 
size_t
 
ptls_asn1_read_type
(const 
uint8_t
 *
bytes
, size_t 
bytes_max
, int *
structure_bit
, int *
type_class
, 
uint32_t
 *
type_number
,

48 int *
decode_error
, int 
level
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
);

50 void 
ptls_asn1_print_type
(int 
type_class
, 
uint32_t
 
type_number
, int 
level
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
);

52 
size_t
 
ptls_asn1_read_length
(const 
uint8_t
 *
bytes
, size_t 
bytes_max
, size_t 
byte_index
, 
uint32_t
 *
length
, int *
indefinite_length
,

53 
size_t
 *
last_byte
, int *
decode_error
, int 
level
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
);

55 
size_t
 
ptls_asn1_get_expected_type_and_length
(const 
uint8_t
 *
bytes
, size_t 
bytes_max
, size_t 
byte_index
, uint8_t 
expected_type
,

56 
uint32_t
 *
length
, int *
indefinite_length
, 
size_t
 *
last_byte
, int *
decode_error
,

57 
ptls_minicrypto_log_ctx_t
 *
log_ctx
);

59 
size_t
 
ptls_asn1_validation_recursive
(const 
uint8_t
 *
bytes
, size_t 
bytes_max
, int *
decode_error
, int 
level
,

60 
ptls_minicrypto_log_ctx_t
 *
log_ctx
);

62 int 
ptls_asn1_validation
(const 
uint8_t
 *
bytes
, 
size_t
 
length
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
);

	@deps/picotls/include/picotls/certificate_compression.h

22 #ifndef 
picotls_certificate_compression_h


23 #define 
	#picotls_certificate_compression_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~"picotls.h
"

31 #define 
	#PTLS_CERTIFICATE_COMPRESSION_ALGORITHM_GZIP
 1

	)

32 #define 
	#PTLS_CERTIFICATE_COMPRESSION_ALGORITHM_BROTLI
 2

	)

34 typedef struct 
	sst_ptls_emit_compressed_certificate_t
 {

35 
ptls_emit_certificate_t
 
super
;

36 
uint16_t
 
algo
;

37 struct 
	sst_ptls_compressed_certificate_entry_t
 {

38 
uint32_t
 
uncompressed_length
;

39 
ptls_iovec_t
 
bytes
;

40 } 
with_ocsp_status
, 
without_ocsp_status
;

41 } 
	tptls_emit_compressed_certificate_t
;

43 extern 
ptls_decompress_certificate_t
 
ptls_decompress_certificate
;

48 int 
ptls_init_compressed_certificate
(
ptls_emit_compressed_certificate_t
 *
ecc
, 
ptls_iovec_t
 *
certificates
, 
size_t
 
num_certificates
,

49 
ptls_iovec_t
 
ocsp_status
);

53 void 
ptls_dispose_compressed_certificate
(
ptls_emit_compressed_certificate_t
 *
ecc
);

55 #ifdef 
__cplusplus


	@deps/picotls/include/picotls/ffx.h

17 #ifndef 
PTLS_FFX_H


18 #define 
	#PTLS_FFX_H


	)

78 typedef struct 
	sst_ptls_ffx_context_t
 {

79 
ptls_cipher_context_t
 
	msuper
;

80 
ptls_cipher_context_t
 *
	menc_ctx
;

81 int 
	mnb_rounds
;

82 int 
	mis_enc
;

83 
size_t
 
	mbyte_length
;

84 
size_t
 
	mnb_left
;

85 
size_t
 
	mnb_right
;

86 
uint8_t
 
	mmask_last_byte
;

87 
uint8_t
 
	mtweaks
[16];

88 } 
	tptls_ffx_context_t
;

114 #define 
	#PTLS_FFX_CIPHER_ALGO_NAME
(
base
, 
bitlength
, 
nbrounds
) #base "-ffx-b" #bitlength "-r" #nbrounds

	)

115 #define 
	#PTLS_FFX_CIPHER_ALGO
(
base
, 
bitlength
, 
nbrounds
, 
keysize
) \

116 static int 
ptls_ffx_
##
base
##
_b
##
bitlength
##
_r
##
nbrounds
##
	`_setup
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
) \

118 return 
	`ptls_ffx_setup_crypto
(
ctx
, &
base
, 
is_enc
, 
nbrounds
, 
bitlength
, 
key
); \

120 static 
ptls_cipher_algorithm_t
 
ptls_ffx_
##
base
##
_b
##
bitlength
##
_r
##
nbrounds
 = { \

121 
	`PTLS_FFX_CIPHER_ALGO_NAME
(
base
, 
bitlength
, 
nbrounds
), 
keysize
, (bitlength + 7) / 8, 16, sizeof(
ptls_ffx_context_t
), \

122 
ptls_ffx_
##
base
##
_b
##
bitlength
##
_r
##
nbrounds
##
_setup
};

	)

129 
ptls_cipher_context_t
 *
ptls_ffx_new
(
ptls_cipher_algorithm_t
 *
algo
, int 
is_enc
, int 
nb_rounds
, 
size_t
 
bit_length
, const void *
key
);

136 int 
ptls_ffx_setup_crypto
(
ptls_cipher_context_t
 *
_ctx
, 
ptls_cipher_algorithm_t
 *
algo
, int 
is_enc
, int 
nb_rounds
, 
size_t
 
bit_length
,

137 const void *
key
);

	@deps/picotls/include/picotls/fusion.h

22 #ifndef 
picotls_fusion_h


23 #define 
	#picotls_fusion_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<stddef.h
>

30 #include 
	~<emmintrin.h
>

31 #include 
	~"../picotls.h
"

33 #define 
	#PTLS_FUSION_AES128_ROUNDS
 10

	)

34 #define 
	#PTLS_FUSION_AES256_ROUNDS
 14

	)

36 typedef struct 
	sptls_fusion_aesecb_context
 {

37 
__m128i
 
keys
[
PTLS_FUSION_AES256_ROUNDS
 + 1];

38 unsigned 
rounds
;

39 } 
	tptls_fusion_aesecb_context_t
;

41 typedef struct 
ptls_fusion_aesgcm_context
 
	tptls_fusion_aesgcm_context_t
;

43 void 
ptls_fusion_aesecb_init
(
ptls_fusion_aesecb_context_t
 *
ctx
, int 
is_enc
, const void *
key
, 
size_t
 
key_size
);

44 void 
ptls_fusion_aesecb_dispose
(
ptls_fusion_aesecb_context_t
 *
ctx
);

45 void 
ptls_fusion_aesecb_encrypt
(
ptls_fusion_aesecb_context_t
 *
ctx
, void *
dst
, const void *
src
);

52 
ptls_fusion_aesgcm_context_t
 *
ptls_fusion_aesgcm_new
(const void *
key
, 
size_t
 
key_size
, size_t 
capacity
);

56 
ptls_fusion_aesgcm_context_t
 *
ptls_fusion_aesgcm_set_capacity
(ptls_fusion_aesgcm_context_t *
ctx
, 
size_t
 
capacity
);

60 void 
ptls_fusion_aesgcm_free
(
ptls_fusion_aesgcm_context_t
 *
ctx
);

72 void 
ptls_fusion_aesgcm_encrypt
(
ptls_fusion_aesgcm_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
__m128i
 
ctr
,

73 const void *
aad
, 
size_t
 
aadlen
, 
ptls_aead_supplementary_encryption_t
 *
supp
);

84 int 
ptls_fusion_aesgcm_decrypt
(
ptls_fusion_aesgcm_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
__m128i
 
ctr
,

85 const void *
aad
, 
size_t
 
aadlen
, const void *
tag
);

87 extern 
ptls_cipher_algorithm_t
 
ptls_fusion_aes128ctr
, 
ptls_fusion_aes256ctr
;

88 extern 
ptls_aead_algorithm_t
 
ptls_fusion_aes128gcm
, 
ptls_fusion_aes256gcm
;

93 int 
ptls_fusion_is_supported_by_cpu
(void);

95 #ifdef 
__cplusplus


	@deps/picotls/include/picotls/minicrypto.h

22 #ifndef 
picotls_minicrypto_h


23 #define 
	#picotls_minicrypto_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~"picotls.h
"

31 #define 
	#SECP256R1_PRIVATE_KEY_SIZE
 32

	)

32 #define 
	#SECP256R1_PUBLIC_KEY_SIZE
 65

	)

33 #define 
	#SECP256R1_SHARED_SECRET_SIZE
 32

	)

35 typedef struct 
	sst_ptls_minicrypto_secp256r1sha256_sign_certificate_t
 {

36 
ptls_sign_certificate_t
 
super
;

37 
uint8_t
 
key
[
SECP256R1_PRIVATE_KEY_SIZE
];

38 } 
	tptls_minicrypto_secp256r1sha256_sign_certificate_t
;

40 void 
ptls_minicrypto_random_bytes
(void *
buf
, 
size_t
 
len
);

42 int 
ptls_minicrypto_init_secp256r1sha256_sign_certificate
(
ptls_minicrypto_secp256r1sha256_sign_certificate_t
 *
self
,

43 
ptls_iovec_t
 
key
);

45 extern 
ptls_key_exchange_algorithm_t
 
ptls_minicrypto_secp256r1
, 
ptls_minicrypto_x25519
;

46 extern 
ptls_key_exchange_algorithm_t
 *
ptls_minicrypto_key_exchanges
[];

47 extern 
ptls_cipher_algorithm_t
 
ptls_minicrypto_aes128ecb
, 
ptls_minicrypto_aes256ecb
, 
ptls_minicrypto_aes128ctr
,

48 
ptls_minicrypto_aes256ctr
, 
ptls_minicrypto_chacha20
;

49 extern 
ptls_aead_algorithm_t
 
ptls_minicrypto_aes128gcm
, 
ptls_minicrypto_aes256gcm
, 
ptls_minicrypto_chacha20poly1305
;

50 extern 
ptls_hash_algorithm_t
 
ptls_minicrypto_sha256
, 
ptls_minicrypto_sha384
;

51 extern 
ptls_cipher_suite_t
 
ptls_minicrypto_aes128gcmsha256
, 
ptls_minicrypto_aes256gcmsha384
, 
ptls_minicrypto_chacha20poly1305sha256
;

52 extern 
ptls_cipher_suite_t
 *
ptls_minicrypto_cipher_suites
[];

54 typedef struct 
	sst_ptls_asn1_pkcs8_private_key_t
 {

55 
ptls_iovec_t
 
	gvec
;

56 
size_t
 
	galgorithm_index
;

57 
uint32_t
 
	galgorithm_length
;

58 
size_t
 
	gparameters_index
;

59 
uint32_t
 
	gparameters_length
;

60 
size_t
 
	gkey_data_index
;

61 
uint32_t
 
	gkey_data_length
;

62 } 
	tptls_asn1_pkcs8_private_key_t
;

64 int 
ptls_minicrypto_load_private_key
(
ptls_context_t
 *
ctx
, char const *
pem_fname
);

66 #ifdef 
__cplusplus


	@deps/picotls/include/picotls/openssl.h

22 #ifndef 
picotls_openssl_h


23 #define 
	#picotls_openssl_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<openssl/opensslv.h
>

30 #include 
	~<openssl/evp.h
>

31 #include 
	~<openssl/hmac.h
>

32 #include 
	~<openssl/x509.h
>

33 #include 
	~<openssl/opensslconf.h
>

34 #include 
	~"../picotls.h
"

36 #if 
OPENSSL_VERSION_NUMBER
 >= 0x10100000L && !
defined
(
LIBRESSL_VERSION_NUMBER
)

37 #if !
defined
(
OPENSSL_NO_CHACHA
) && !defined(
OPENSSL_NO_POLY1305
)

38 #define 
	#PTLS_OPENSSL_HAVE_CHACHA20_POLY1305
 1

	)

42 extern 
ptls_key_exchange_algorithm_t
 
ptls_openssl_secp256r1
;

43 #ifdef 
NID_secp384r1


44 #define 
	#PTLS_OPENSSL_HAVE_SECP384R1
 1

	)

45 #define 
	#PTLS_OPENSSL_HAS_SECP384R1
 1

	)

46 extern 
ptls_key_exchange_algorithm_t
 
ptls_openssl_secp384r1
;

48 #ifdef 
NID_secp521r1


49 #define 
	#PTLS_OPENSSL_HAVE_SECP521R1
 1

	)

50 #define 
	#PTLS_OPENSSL_HAS_SECP521R1
 1

	)

51 extern 
ptls_key_exchange_algorithm_t
 
ptls_openssl_secp521r1
;

53 #ifdef 
EVP_PKEY_ED25519


54 #define 
	#PTLS_OPENSSL_HAVE_ED25519
 1

	)

56 #if 
defined
(
NID_X25519
) && !defined(
LIBRESSL_VERSION_NUMBER
)

57 #define 
	#PTLS_OPENSSL_HAVE_X25519
 1

	)

58 #define 
	#PTLS_OPENSSL_HAS_X25519
 1

	)

59 extern 
ptls_key_exchange_algorithm_t
 
ptls_openssl_x25519
;

61 #ifndef 
OPENSSL_NO_BF


62 #define 
	#PTLS_OPENSSL_HAVE_BF
 1

	)

65 extern 
ptls_key_exchange_algorithm_t
 *
ptls_openssl_key_exchanges
[];

67 extern 
ptls_cipher_algorithm_t
 
ptls_openssl_aes128ecb
;

68 extern 
ptls_cipher_algorithm_t
 
ptls_openssl_aes128ctr
;

69 extern 
ptls_aead_algorithm_t
 
ptls_openssl_aes128gcm
;

70 extern 
ptls_cipher_algorithm_t
 
ptls_openssl_aes256ecb
;

71 extern 
ptls_cipher_algorithm_t
 
ptls_openssl_aes256ctr
;

72 extern 
ptls_aead_algorithm_t
 
ptls_openssl_aes256gcm
;

73 extern 
ptls_hash_algorithm_t
 
ptls_openssl_sha256
;

74 extern 
ptls_hash_algorithm_t
 
ptls_openssl_sha384
;

75 extern 
ptls_cipher_suite_t
 
ptls_openssl_aes128gcmsha256
;

76 extern 
ptls_cipher_suite_t
 
ptls_openssl_aes256gcmsha384
;

77 extern 
ptls_cipher_suite_t
 *
ptls_openssl_cipher_suites
[];

79 #if 
defined
(
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305
)

80 extern 
ptls_cipher_algorithm_t
 
ptls_openssl_chacha20
;

81 extern 
ptls_aead_algorithm_t
 
ptls_openssl_chacha20poly1305
;

82 extern 
ptls_cipher_suite_t
 
ptls_openssl_chacha20poly1305sha256
;

85 #if 
PTLS_OPENSSL_HAVE_BF


86 extern 
ptls_cipher_algorithm_t
 
ptls_openssl_bfecb
;

89 void 
ptls_openssl_random_bytes
(void *
buf
, 
size_t
 
len
);

93 int 
ptls_openssl_create_key_exchange
(
ptls_key_exchange_context_t
 **
ctx
, 
EVP_PKEY
 *
pkey
);

95 struct 
	sst_ptls_openssl_signature_scheme_t
 {

96 
uint16_t
 
	gscheme_id
;

97 const 
	gEVP_MD
 *(*
	gscheme_md
)(void);

100 typedef struct 
	sst_ptls_openssl_sign_certificate_t
 {

101 
ptls_sign_certificate_t
 
	gsuper
;

102 
EVP_PKEY
 *
	gkey
;

103 const struct 
st_ptls_openssl_signature_scheme_t
 *
	gschemes
;

104 } 
	tptls_openssl_sign_certificate_t
;

106 int 
ptls_openssl_init_sign_certificate
(
ptls_openssl_sign_certificate_t
 *
self
, 
EVP_PKEY
 *
key
);

107 void 
ptls_openssl_dispose_sign_certificate
(
ptls_openssl_sign_certificate_t
 *
self
);

108 int 
ptls_openssl_load_certificates
(
ptls_context_t
 *
ctx
, 
X509
 *
cert
, 
STACK_OF
(X509) * 
chain
);

110 typedef struct 
	sst_ptls_openssl_raw_pubkey_verify_certificate_t
 {

111 
ptls_verify_certificate_t
 
	gsuper
;

112 
EVP_PKEY
 *
	gexpected_pubkey
;

113 } 
	tptls_openssl_raw_pubkey_verify_certificate_t
;

115 typedef struct 
	sst_ptls_openssl_verify_certificate_t
 {

116 
ptls_verify_certificate_t
 
	gsuper
;

117 
X509_STORE
 *
	gcert_store
;

118 } 
	tptls_openssl_verify_certificate_t
;

120 int 
ptls_openssl_init_verify_certificate
(
ptls_openssl_verify_certificate_t
 *
self
, 
X509_STORE
 *
store
);

121 void 
ptls_openssl_dispose_verify_certificate
(
ptls_openssl_verify_certificate_t
 *
self
);

122 
X509_STORE
 *
ptls_openssl_create_default_certificate_store
(void);

124 int 
ptls_openssl_raw_pubkey_init_verify_certificate
(
ptls_openssl_raw_pubkey_verify_certificate_t
 *
self
, 
EVP_PKEY
 *
pubkey
);

125 void 
ptls_openssl_raw_pubkey_dispose_verify_certificate
(
ptls_openssl_raw_pubkey_verify_certificate_t
 *
self
);

127 int 
ptls_openssl_encrypt_ticket
(
ptls_buffer_t
 *
dst
, 
ptls_iovec_t
 
src
,

128 int (*
cb
)(unsigned char *, unsigned char *, 
EVP_CIPHER_CTX
 *, 
HMAC_CTX
 *, int));

129 int 
ptls_openssl_decrypt_ticket
(
ptls_buffer_t
 *
dst
, 
ptls_iovec_t
 
src
,

130 int (*
cb
)(unsigned char *, unsigned char *, 
EVP_CIPHER_CTX
 *, 
HMAC_CTX
 *, int));

132 #ifdef 
__cplusplus


	@deps/picotls/include/picotls/pembase64.h

17 #ifndef 
PTLS_PEMBASE64_H


18 #define 
	#PTLS_PEMBASE64_H


	)

24 #define 
	#PTLS_BASE64_DECODE_DONE
 0

	)

25 #define 
	#PTLS_BASE64_DECODE_IN_PROGRESS
 1

	)

26 #define 
	#PTLS_BASE64_DECODE_FAILED
 -1

	)

28 typedef struct 
	sst_ptls_base64_decode_state_t
 {

29 int 
	mnbc
;

30 int 
	mnbo
;

31 int 
	mstatus
;

32 
uint32_t
 
	mv
;

33 } 
	tptls_base64_decode_state_t
;

35 int 
ptls_base64_encode
(const 
uint8_t
 *
data
, 
size_t
 
data_len
, char *
base64_text
);

37 
size_t
 
ptls_base64_howlong
(size_t 
data_length
);

39 void 
ptls_base64_decode_init
(
ptls_base64_decode_state_t
 *
state
);

40 int 
ptls_base64_decode
(const char *
base64_text
, 
ptls_base64_decode_state_t
 *
state
, 
ptls_buffer_t
 *
buf
);

42 int 
ptls_load_pem_objects
(char const *
pem_fname
, const char *
label
, 
ptls_iovec_t
 *
list
, 
size_t
 
list_max
, size_t *
nb_objects
);

	@deps/picotls/include/picotls/ptlsbcrypt.h

22 #ifndef 
picotls_bcrypt_h


23 #define 
	#picotls_bcrypt_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~"../picotls.h
"

31 #ifdef 
_WINDOWS


32 #include 
	~<bcrypt.h
>

34 extern 
ptls_cipher_algorithm_t
 
ptls_bcrypt_aes128ecb
;

35 extern 
ptls_cipher_algorithm_t
 
ptls_bcrypt_aes256ecb
;

36 extern 
ptls_cipher_algorithm_t
 
ptls_bcrypt_aes128ctr
;

37 extern 
ptls_cipher_algorithm_t
 
ptls_bcrypt_aes256ctr
;

39 extern 
ptls_aead_algorithm_t
 
ptls_bcrypt_aes128gcm
;

40 extern 
ptls_aead_algorithm_t
 
ptls_bcrypt_aes256gcm
;

42 extern 
ptls_hash_algorithm_t
 
ptls_bcrypt_sha256
;

43 extern 
ptls_hash_algorithm_t
 
ptls_bcrypt_sha384
;

45 extern 
ptls_cipher_suite_t
 
ptls_bcrypt_aes128gcmsha256
;

46 extern 
ptls_cipher_suite_t
 
ptls_bcrypt_aes256gcmsha384
;

49 #ifdef 
__cplusplus


	@deps/picotls/lib/asn1.c

21 #ifdef 
_WINDOWS


22 #include 
	~"wincompat.h
"

24 #include 
	~<sys/time.h
>

26 #include 
	~<errno.h
>

27 #include 
	~<stdlib.h
>

28 #include 
	~<string.h
>

29 #include 
	~<stdio.h
>

30 #include 
	~"picotls.h
"

31 #include 
	~"picotls/minicrypto.h
"

32 #include 
	~"picotls/asn1.h
"

34 static char const *
	gasn1_type_classes
[4] = {"Universal", "Application", "Context-specific", "Private"};

36 static char const *
	gasn1_universal_types
[] = {

44 static 
size_t
 
	gnb_asn1_universal_types
 = sizeof(
asn1_universal_types
) / sizeof(char const *);

46 static void 
	$ptls_asn1_print_indent
(int 
level
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

48 for (int 
indent
 = 0; indent <= 
level
; indent++) {

49 
log_ctx
->
	`fn
(log_ctx->
ctx
, " ");

51 
	}
}

53 
size_t
 
	$ptls_asn1_error_message
(char const *
error_label
, 
size_t
 
bytes_max
, size_t 
byte_index
, int 
level
,

54 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

56 if (
log_ctx
 != 
NULL
) {

57 
	`ptls_asn1_print_indent
(
level
, 
log_ctx
);

58 
log_ctx
->
	`fn
(log_ctx->
ctx
, "Error: %s (near position: %d (0x%x) out of %d)", 
error_label
, (int)
byte_index
,

59 (
uint32_t
)
byte_index
, (int)
bytes_max
);

61 return 
byte_index
;

62 
	}
}

64 void 
	$ptls_asn1_dump_content
(const 
uint8_t
 *
bytes
, 
size_t
 
bytes_max
, size_t 
byte_index
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

66 if (
log_ctx
 != 
NULL
 && 
bytes_max
 > 
byte_index
) {

67 
size_t
 
nb_bytes
 = 
bytes_max
 - 
byte_index
;

69 
log_ctx
->
	`fn
(log_ctx->
ctx
, " ");

71 for (
size_t
 
i
 = 0; i < 16 && i < 
nb_bytes
; i++) {

72 
log_ctx
->
	`fn
(log_ctx->
ctx
, "%02x", 
bytes
[
byte_index
 + 
i
]);

75 if (
nb_bytes
 > 16) {

76 
log_ctx
->
	`fn
(log_ctx->
ctx
, "...");

79 
	}
}

81 
size_t
 
	$ptls_asn1_read_type
(const 
uint8_t
 *
bytes
, 
size_t
 
bytes_max
, int *
structure_bit
, int *
type_class
, 
uint32_t
 *
type_number
,

82 int *
decode_error
, int 
level
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

85 
size_t
 
byte_index
 = 1;

86 
uint8_t
 
first_byte
 = 
bytes
[0];

87 *
structure_bit
 = (
first_byte
 >> 5) & 1;

88 *
type_class
 = (
first_byte
 >> 6) & 3;

89 *
type_number
 = 
first_byte
 & 31;

91 if (*
type_number
 == 31) {

92 
uint32_t
 
long_type
 = 0;

93 const 
uint32_t
 
type_number_limit
 = 0x07FFFFFFF;

94 int 
next_byte
;

95 int 
end_found
 = 0;

97 while (
byte_index
 < 
bytes_max
 && 
long_type
 <= 
type_number_limit
) {

98 
next_byte
 = 
bytes
[
byte_index
++];

99 
long_type
 <<= 7;

100 
long_type
 |= 
next_byte
 & 127;

101 if ((
next_byte
 & 128) == 0) {

102 
end_found
 = 1;

107 if (
end_found
) {

108 *
type_number
 = 
long_type
;

111 
byte_index
 = 
	`ptls_asn1_error_message
("Incorrect type coding", 
bytes_max
, byte_index, 
level
, 
log_ctx
);

112 *
decode_error
 = 
PTLS_ERROR_BER_MALFORMED_TYPE
;

116 return 
byte_index
;

117 
	}
}

119 void 
	$ptls_asn1_print_type
(int 
type_class
, 
uint32_t
 
type_number
, int 
level
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

122 
	`ptls_asn1_print_indent
(
level
, 
log_ctx
);

123 if (
type_class
 == 0 && 
type_number
 < 
nb_asn1_universal_types
) {

124 
log_ctx
->
	`fn
(log_ctx->
ctx
, "%s", 
asn1_universal_types
[
type_number
]);

125 } else if (
type_class
 == 2) {

126 
log_ctx
->
	`fn
(log_ctx->
ctx
, "[%d]", 
type_number
);

128 
log_ctx
->
	`fn
(log_ctx->
ctx
, "%s[%d]", 
asn1_type_classes
[
type_class
], 
type_number
);

130 
	}
}

132 
size_t
 
	$ptls_asn1_read_length
(const 
uint8_t
 *
bytes
, 
size_t
 
bytes_max
, size_t 
byte_index
, 
uint32_t
 *
length
, int *
indefinite_length
,

133 
size_t
 *
last_byte
, int *
decode_error
, int 
level
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

135 int 
length_of_length
 = 0;

137 *
indefinite_length
 = 0;

138 *
length
 = 0;

139 *
last_byte
 = 
bytes_max
;

141 if (
byte_index
 < 
bytes_max
) {

142 *
length
 = 
bytes
[
byte_index
++];

143 if ((*
length
 & 128) != 0) {

144 
length_of_length
 = *
length
 & 127;

145 *
length
 = 0;

147 if (
byte_index
 + 
length_of_length
 >= 
bytes_max
) {

149 
byte_index
 = 
	`ptls_asn1_error_message
("Incorrect length coding", 
bytes_max
, byte_index, 
level
, 
log_ctx
);

150 *
decode_error
 = 
PTLS_ERROR_BER_MALFORMED_LENGTH
;

152 for (int 
i
 = 0; i < 
length_of_length
 && 
byte_index
 < 
bytes_max
; i++) {

153 *
length
 <<= 8;

154 *
length
 |= 
bytes
[
byte_index
++];

157 if (
length_of_length
 == 0) {

158 *
last_byte
 = 
bytes_max
;

159 *
indefinite_length
 = 1;

161 *
last_byte
 = 
byte_index
 + *
length
;

165 *
last_byte
 = 
byte_index
 + *
length
;

168 if (*
decode_error
 == 0) {

170 if (*
last_byte
 > 
bytes_max
) {

171 
byte_index
 = 
	`ptls_asn1_error_message
("Length larger than message", 
bytes_max
, byte_index, 
level
, 
log_ctx
);

172 *
decode_error
 = 
PTLS_ERROR_BER_EXCESSIVE_LENGTH
;

177 return 
byte_index
;

178 
	}
}

180 
size_t
 
	$ptls_asn1_get_expected_type_and_length
(const 
uint8_t
 *
bytes
, 
size_t
 
bytes_max
, size_t 
byte_index
, uint8_t 
expected_type
,

181 
uint32_t
 *
length
, int *
indefinite_length
, 
size_t
 *
last_byte
, int *
decode_error
,

182 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

184 int 
is_indefinite
 = 0;

187 if (
bytes
[
byte_index
] != 
expected_type
) {

188 
byte_index
 = 
	`ptls_asn1_error_message
("Unexpected type", 
bytes_max
, byte_index, 0, 
log_ctx
);

189 *
decode_error
 = 
PTLS_ERROR_INCORRECT_ASN1_SYNTAX
;

192 
byte_index
++;

193 
byte_index
 =

194 
	`ptls_asn1_read_length
(
bytes
, 
bytes_max
, 
byte_index
, 
length
, &
is_indefinite
, 
last_byte
, 
decode_error
, 0, 
log_ctx
);

196 if (
indefinite_length
 != 
NULL
) {

197 *
indefinite_length
 = 
is_indefinite
;

198 } else if (
is_indefinite
) {

199 
byte_index
 = 
	`ptls_asn1_error_message
("Incorrect length for DER", 
bytes_max
, byte_index, 0, 
log_ctx
);

200 *
decode_error
 = 
PTLS_ERROR_DER_INDEFINITE_LENGTH
;

204 return 
byte_index
;

205 
	}
}

207 
size_t
 
	$ptls_asn1_validation_recursive
(const 
uint8_t
 *
bytes
, 
size_t
 
bytes_max
, int *
decode_error
, int 
level
,

208 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

211 int 
structure_bit
 = 0;

212 int 
type_class
 = 0;

213 
uint32_t
 
type_number
 = 0;

214 
uint32_t
 
length
 = 0;

215 int 
indefinite_length
 = 0;

216 
size_t
 
last_byte
 = 0;

218 
size_t
 
byte_index
 =

219 
	`ptls_asn1_read_type
(
bytes
, 
bytes_max
, &
structure_bit
, &
type_class
, &
type_number
, 
decode_error
, 
level
, 
log_ctx
);

221 if (*
decode_error
 == 0 && 
log_ctx
 != 
NULL
) {

222 
	`ptls_asn1_print_type
(
type_class
, 
type_number
, 
level
, 
log_ctx
);

226 
byte_index
 =

227 
	`ptls_asn1_read_length
(
bytes
, 
bytes_max
, 
byte_index
, &
length
, &
indefinite_length
, &
last_byte
, 
decode_error
, 
level
, 
log_ctx
);

229 if (
last_byte
 <= 
bytes_max
) {

230 if (
structure_bit
) {

232 if (
log_ctx
 != 
NULL
) {

233 
log_ctx
->
	`fn
(log_ctx->
ctx
, " {\n");

236 while (
byte_index
 < 
last_byte
) {

237 if (
indefinite_length
 != 0 && 
bytes
[
byte_index
] == 0) {

238 if (
byte_index
 + 2 > 
bytes_max
 || 
bytes
[byte_index + 1] != 0) {

239 
byte_index
 =

240 
	`ptls_asn1_error_message
("EOC: unexpected end of content", 
bytes_max
, 
byte_index
, 
level
 + 1, 
log_ctx
);

242 *
decode_error
 = 
PTLS_ERROR_BER_UNEXPECTED_EOC
;

243 
byte_index
 = 
bytes_max
;

246 if (
log_ctx
 != 
NULL
) {

247 
	`ptls_asn1_print_indent
(
level
, 
log_ctx
);

248 
log_ctx
->
	`fn
(log_ctx->
ctx
, "EOC\n");

250 
byte_index
 += 2;

254 
byte_index
 += 
	`ptls_asn1_validation_recursive
(
bytes
 + byte_index, 
last_byte
 - byte_index, 
decode_error
,

255 
level
 + 1, 
log_ctx
);

257 if (*
decode_error
) {

258 
byte_index
 = 
bytes_max
;

263 if (
log_ctx
 != 
NULL
) {

264 if (
byte_index
 < 
last_byte
) {

265 
log_ctx
->
	`fn
(log_ctx->
ctx
, ",");

267 
log_ctx
->
	`fn
(log_ctx->
ctx
, "\n");

271 if (
log_ctx
 != 
NULL
) {

272 
	`ptls_asn1_print_indent
(
level
, 
log_ctx
);

273 
log_ctx
->
	`fn
(log_ctx->
ctx
, "}");

276 
	`ptls_asn1_dump_content
(
bytes
, 
last_byte
, 
byte_index
, 
log_ctx
);

277 
byte_index
 = 
last_byte
;

281 return 
byte_index
;

282 
	}
}

284 int 
	$ptls_asn1_validation
(const 
uint8_t
 *
bytes
, 
size_t
 
length
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

286 int 
decode_error
 = 0;

287 
size_t
 
decoded
 = 
	`ptls_asn1_validation_recursive
(
bytes
, 
length
, &
decode_error
, 0, 
log_ctx
);

289 if (
decode_error
 == 0 && 
decoded
 < 
length
) {

290 
decode_error
 = 
PTLS_ERROR_BER_ELEMENT_TOO_SHORT
;

291 if (
log_ctx
 != 
NULL
) {

292 
log_ctx
->
	`fn
(log_ctx->
ctx
, "Type too short, %d bytes only out of %d\n", (int)
decoded
, (int)
length
);

296 return 
decode_error
;

297 
	}
}

	@deps/picotls/lib/certificate_compression.c

22 #include 
	~<assert.h
>

23 #include 
	~<stdlib.h
>

24 #include 
	~"brotli/decode.h
"

25 #include 
	~"brotli/encode.h
"

26 #include 
	~"picotls/certificate_compression.h
"

28 static 
inline
 int 
	$decompress_certificate
(
ptls_decompress_certificate_t
 *
self
, 
ptls_t
 *
tls
, 
uint16_t
 
algorithm
, 
ptls_iovec_t
 
output
,

29 
ptls_iovec_t
 
input
)

31 if (
algorithm
 != 
PTLS_CERTIFICATE_COMPRESSION_ALGORITHM_BROTLI
)

32 goto 
Fail
;

34 
size_t
 
decoded_size
 = 
output
.
len
;

35 if (
	`BrotliDecoderDecompress
(
input
.
len
, input.
base
, &
decoded_size
, 
output
.base) != 
BROTLI_DECODER_RESULT_SUCCESS
)

36 goto 
Fail
;

38 if (
decoded_size
 != 
output
.
len
)

39 goto 
Fail
;

42 
Fail
:

43 return 
PTLS_ALERT_BAD_CERTIFICATE
;

44 
	}
}

46 static const 
uint16_t
 
	galgorithms
[] = {
PTLS_CERTIFICATE_COMPRESSION_ALGORITHM_BROTLI
, 
UINT16_MAX
};

48 
ptls_decompress_certificate_t
 
	gptls_decompress_certificate
 = {
algorithms
, 
decompress_certificate
};

50 static int 
	$emit_compressed_certificate
(
ptls_emit_certificate_t
 *
_self
, 
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
,

51 
ptls_key_schedule_t
 *
key_sched
, 
ptls_iovec_t
 
context
, int 
push_status_request
,

52 const 
uint16_t
 *
compress_algos
, 
size_t
 
num_compress_algos
)

54 
ptls_emit_compressed_certificate_t
 *
self
 = (void *)
_self
;

55 struct 
st_ptls_compressed_certificate_entry_t
 *
entry
;

56 int 
ret
;

58 
	`assert
(
context
.
len
 == 0 || !"precompressed mode can only be used for server certificates");

60 for (
size_t
 
i
 = 0; i != 
num_compress_algos
; ++i) {

61 if (
compress_algos
[
i
] == 
PTLS_CERTIFICATE_COMPRESSION_ALGORITHM_BROTLI
)

62 goto 
FoundBrotli
;

65 
ret
 = 
PTLS_ERROR_DELEGATE
;

66 goto 
Exit
;

68 
FoundBrotli
:

69 
entry
 = &
self
->
without_ocsp_status
;

70 if (
push_status_request
 && 
self
->
with_ocsp_status
.
uncompressed_length
 != 0)

71 
entry
 = &
self
->
with_ocsp_status
;

73 
	`ptls_push_message
(
emitter
, 
key_sched
, 
PTLS_HANDSHAKE_TYPE_COMPRESSED_CERTIFICATE
, {

74 
	`ptls_buffer_push16
(
emitter
->
buf
, 
PTLS_CERTIFICATE_COMPRESSION_ALGORITHM_BROTLI
);

75 
	`ptls_buffer_push24
(
emitter
->
buf
, 
entry
->
uncompressed_length
);

76 
	`ptls_buffer_push_block
(
emitter
->
buf
, 3, { 
	`ptls_buffer_pushv
(emitter->buf, 
entry
->
bytes
.
base
, entry->bytes.
len
); });

79 
ret
 = 0;

81 
Exit
:

82 return 
ret
;

83 
	}
}

85 static int 
	$build_compressed
(struct 
st_ptls_compressed_certificate_entry_t
 *
entry
, 
ptls_iovec_t
 *
certificates
,

86 
size_t
 
num_certificates
, 
ptls_iovec_t
 
ocsp_status
)

88 
ptls_buffer_t
 
uncompressed
;

89 int 
ret
;

91 
	`ptls_buffer_init
(&
uncompressed
, "", 0);

94 if ((
ret
 = 
	`ptls_build_certificate_message
(&
uncompressed
, 
	`ptls_iovec_init
(
NULL
, 0), 
certificates
, 
num_certificates
,

95 
ocsp_status
)) != 0)

96 goto 
Exit
;

97 
entry
->
uncompressed_length
 = (
uint32_t
)
uncompressed
.
off
;

100 
entry
->
bytes
.
len
 = 
uncompressed
.
off
 - 1;

101 if ((
entry
->
bytes
.
base
 = 
	`malloc
(entry->bytes.
len
)) == 
NULL
) {

102 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

103 goto 
Exit
;

105 if (
	`BrotliEncoderCompress
(
BROTLI_MAX_QUALITY
, 
BROTLI_DEFAULT_WINDOW
, 
BROTLI_MODE_GENERIC
, 
uncompressed
.
off
, uncompressed.
base
,

106 &
entry
->
bytes
.
len
, entry->bytes.
base
) != 
BROTLI_TRUE
) {

107 
ret
 = 
PTLS_ERROR_COMPRESSION_FAILURE
;

108 goto 
Exit
;

111 
ret
 = 0;

113 
Exit
:

114 if (
ret
 != 0) {

115 
	`free
(
entry
->
bytes
.
base
);

116 *
entry
 = (struct 
st_ptls_compressed_certificate_entry_t
){0};

118 
	`ptls_buffer_dispose
(&
uncompressed
);

119 return 
ret
;

120 
	}
}

122 int 
	$ptls_init_compressed_certificate
(
ptls_emit_compressed_certificate_t
 *
self
, 
ptls_iovec_t
 *
certificates
, 
size_t
 
num_certificates
,

123 
ptls_iovec_t
 
ocsp_status
)

125 int 
ret
;

127 *
self
 = (
ptls_emit_compressed_certificate_t
){{
emit_compressed_certificate
}, 
PTLS_CERTIFICATE_COMPRESSION_ALGORITHM_BROTLI
};

130 if ((
ret
 = 
	`build_compressed
(&
self
->
without_ocsp_status
, 
certificates
, 
num_certificates
, 
	`ptls_iovec_init
(
NULL
, 0))) != 0)

131 goto 
Exit
;

132 if (
ocsp_status
.
len
 != 0) {

133 if ((
ret
 = 
	`build_compressed
(&
self
->
with_ocsp_status
, 
certificates
, 
num_certificates
, 
ocsp_status
)) != 0)

134 goto 
Exit
;

137 
ret
 = 0;

139 
Exit
:

140 if (
ret
 != 0)

141 
	`ptls_dispose_compressed_certificate
(
self
);

142 return 
ret
;

143 
	}
}

145 void 
	$ptls_dispose_compressed_certificate
(
ptls_emit_compressed_certificate_t
 *
self
)

147 
	`free
(
self
->
with_ocsp_status
.
bytes
.
base
);

148 
	`free
(
self
->
without_ocsp_status
.
bytes
.
base
);

149 
	}
}

	@deps/picotls/lib/cifra.c

22 #include 
	~<stddef.h
>

23 #include 
	~"picotls.h
"

24 #include 
	~"picotls/minicrypto.h
"

26 
ptls_cipher_suite_t
 *
	gptls_minicrypto_cipher_suites
[] = {&
ptls_minicrypto_aes256gcmsha384
, &
ptls_minicrypto_aes128gcmsha256
,

27 &
ptls_minicrypto_chacha20poly1305sha256
, 
NULL
};

	@deps/picotls/lib/cifra/aes-common.h

22 #include 
	~<stdlib.h
>

23 #include 
	~<string.h
>

24 #include 
	~"aes.h
"

25 #include 
	~"modes.h
"

26 #include 
	~"sha2.h
"

27 #include 
	~"picotls.h
"

28 #include 
	~"picotls/minicrypto.h
"

30 struct 
	saesecb_context_t
 {

31 
ptls_cipher_context_t
 
	msuper
;

32 
cf_aes_context
 
	maes
;

35 static 
inline
 void 
	$aesecb_dispose
(
ptls_cipher_context_t
 *
_ctx
)

37 struct 
aesecb_context_t
 *
ctx
 = (struct aesecb_context_t *)
_ctx
;

38 
	`ptls_clear_memory
(
ctx
, sizeof(*ctx));

39 
	}
}

41 static 
inline
 void 
	$aesecb_encrypt
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
len
)

43 struct 
aesecb_context_t
 *
ctx
 = (struct aesecb_context_t *)
_ctx
;

44 
	`assert
(
len
 % 
AES_BLOCKSZ
 == 0);

45 
	`cf_aes_encrypt
(&
ctx
->
aes
, 
input
, 
output
);

46 
	}
}

48 static 
inline
 void 
	$aesecb_decrypt
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
len
)

50 struct 
aesecb_context_t
 *
ctx
 = (struct aesecb_context_t *)
_ctx
;

51 
	`assert
(
len
 % 
AES_BLOCKSZ
 == 0);

52 
	`cf_aes_decrypt
(&
ctx
->
aes
, 
input
, 
output
);

53 
	}
}

55 static 
inline
 int 
	$aesecb_setup_crypto
(
ptls_cipher_context_t
 *
_ctx
, int 
is_enc
, const void *
key
)

57 struct 
aesecb_context_t
 *
ctx
 = (struct aesecb_context_t *)
_ctx
;

58 
ctx
->
super
.
do_dispose
 = 
aesecb_dispose
;

59 
ctx
->
super
.
do_init
 = 
NULL
;

60 
ctx
->
super
.
do_transform
 = 
is_enc
 ? 
aesecb_encrypt
 : 
aesecb_decrypt
;

61 
	`cf_aes_init
(&
ctx
->
aes
, 
key
, ctx->
super
.
algo
->
key_size
);

63 
	}
}

65 struct 
	saesctr_context_t
 {

66 
ptls_cipher_context_t
 
	msuper
;

67 
cf_aes_context
 
	maes
;

68 
cf_ctr
 
	mctr
;

71 static 
inline
 void 
	$aesctr_dispose
(
ptls_cipher_context_t
 *
_ctx
)

73 struct 
aesctr_context_t
 *
ctx
 = (struct aesctr_context_t *)
_ctx
;

74 
	`ptls_clear_memory
(
ctx
, sizeof(*ctx));

75 
	}
}

77 static 
inline
 void 
	$aesctr_init
(
ptls_cipher_context_t
 *
_ctx
, const void *
iv
)

79 struct 
aesctr_context_t
 *
ctx
 = (struct aesctr_context_t *)
_ctx
;

80 
	`cf_ctr_init
(&
ctx
->
ctr
, &
cf_aes
, &ctx->
aes
, 
iv
);

81 
	}
}

83 static 
inline
 void 
	$aesctr_transform
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
len
)

85 struct 
aesctr_context_t
 *
ctx
 = (struct aesctr_context_t *)
_ctx
;

86 
	`cf_ctr_cipher
(&
ctx
->
ctr
, 
input
, 
output
, 
len
);

87 
	}
}

89 static 
inline
 int 
	$aesctr_setup_crypto
(
ptls_cipher_context_t
 *
_ctx
, int 
is_enc
, const void *
key
)

91 struct 
aesctr_context_t
 *
ctx
 = (struct aesctr_context_t *)
_ctx
;

92 
ctx
->
super
.
do_dispose
 = 
aesctr_dispose
;

93 
ctx
->
super
.
do_init
 = 
aesctr_init
;

94 
ctx
->
super
.
do_transform
 = 
aesctr_transform
;

95 
	`cf_aes_init
(&
ctx
->
aes
, 
key
, ctx->
super
.
algo
->
key_size
);

97 
	}
}

99 struct 
	saesgcm_context_t
 {

100 
ptls_aead_context_t
 
	msuper
;

101 
cf_aes_context
 
	maes
;

102 
cf_gcm_ctx
 
	mgcm
;

103 
uint8_t
 
	mstatic_iv
[
PTLS_AESGCM_IV_SIZE
];

106 static 
inline
 void 
	$aesgcm_dispose_crypto
(
ptls_aead_context_t
 *
_ctx
)

108 struct 
aesgcm_context_t
 *
ctx
 = (struct aesgcm_context_t *)
_ctx
;

111 
	`ptls_clear_memory
((
uint8_t
 *)
ctx
 + sizeof(ctx->
super
), sizeof(*ctx) - sizeof(ctx->super));

112 
	}
}

114 static 
inline
 void 
	$aesgcm_encrypt_init
(
ptls_aead_context_t
 *
_ctx
, 
uint64_t
 
seq
, const void *
aad
, 
size_t
 
aadlen
)

116 struct 
aesgcm_context_t
 *
ctx
 = (struct aesgcm_context_t *)
_ctx
;

117 
uint8_t
 
iv
[
PTLS_AES_BLOCK_SIZE
];

119 
	`ptls_aead__build_iv
(
ctx
->
super
.
algo
, 
iv
, ctx->
static_iv
, 
seq
);

120 
	`cf_gcm_encrypt_init
(&
cf_aes
, &
ctx
->
aes
, &ctx->
gcm
, 
aad
, 
aadlen
, 
iv
, 
PTLS_AESGCM_IV_SIZE
);

121 
	}
}

123 static 
inline
 
size_t
 
	$aesgcm_encrypt_update
(
ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
)

125 struct 
aesgcm_context_t
 *
ctx
 = (struct aesgcm_context_t *)
_ctx
;

127 
	`cf_gcm_encrypt_update
(&
ctx
->
gcm
, 
input
, 
inlen
, 
output
);

128 return 
inlen
;

129 
	}
}

131 static 
inline
 
size_t
 
	$aesgcm_encrypt_final
(
ptls_aead_context_t
 *
_ctx
, void *
output
)

133 struct 
aesgcm_context_t
 *
ctx
 = (struct aesgcm_context_t *)
_ctx
;

135 
	`cf_gcm_encrypt_final
(&
ctx
->
gcm
, 
output
, 
PTLS_AESGCM_TAG_SIZE
);

136 return 
PTLS_AESGCM_TAG_SIZE
;

137 
	}
}

139 static 
inline
 
size_t
 
	$aesgcm_decrypt
(
ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

140 const void *
aad
, 
size_t
 
aadlen
)

142 struct 
aesgcm_context_t
 *
ctx
 = (struct aesgcm_context_t *)
_ctx
;

143 
uint8_t
 
iv
[
PTLS_AES_BLOCK_SIZE
];

145 if (
inlen
 < 
PTLS_AESGCM_TAG_SIZE
)

146 return 
SIZE_MAX
;

147 
size_t
 
tag_offset
 = 
inlen
 - 
PTLS_AESGCM_TAG_SIZE
;

149 
	`ptls_aead__build_iv
(
ctx
->
super
.
algo
, 
iv
, ctx->
static_iv
, 
seq
);

150 if (
	`cf_gcm_decrypt
(&
cf_aes
, &
ctx
->
aes
, 
input
, 
tag_offset
, 
aad
, 
aadlen
, 
iv
, 
PTLS_AESGCM_IV_SIZE
, (
uint8_t
 *)input + tag_offset,

151 
PTLS_AESGCM_TAG_SIZE
, 
output
) != 0)

152 return 
SIZE_MAX
;

154 return 
tag_offset
;

155 
	}
}

157 static 
inline
 void 
	$aesgcm_xor_iv
(
ptls_aead_context_t
 *
_ctx
, const void *
_bytes
, 
size_t
 
len
)

159 struct 
aesgcm_context_t
 *
ctx
 = (struct aesgcm_context_t *)
_ctx
;

160 const 
uint8_t
 *
bytes
 = 
_bytes
;

162 for (
size_t
 
i
 = 0; i < 
len
; ++i)

163 
ctx
->
static_iv
[
i
] ^= 
bytes
[i];

164 
	}
}

166 static 
inline
 int 
	$aead_aesgcm_setup_crypto
(
ptls_aead_context_t
 *
_ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

168 struct 
aesgcm_context_t
 *
ctx
 = (struct aesgcm_context_t *)
_ctx
;

170 
ctx
->
super
.
dispose_crypto
 = 
aesgcm_dispose_crypto
;

171 
ctx
->
super
.
do_xor_iv
 = 
aesgcm_xor_iv
;

172 if (
is_enc
) {

173 
ctx
->
super
.
do_encrypt_init
 = 
aesgcm_encrypt_init
;

174 
ctx
->
super
.
do_encrypt_update
 = 
aesgcm_encrypt_update
;

175 
ctx
->
super
.
do_encrypt_final
 = 
aesgcm_encrypt_final
;

176 
ctx
->
super
.
do_encrypt
 = 
ptls_aead__do_encrypt
;

177 
ctx
->
super
.
do_decrypt
 = 
NULL
;

179 
ctx
->
super
.
do_encrypt_init
 = 
NULL
;

180 
ctx
->
super
.
do_encrypt_update
 = 
NULL
;

181 
ctx
->
super
.
do_encrypt_final
 = 
NULL
;

182 
ctx
->
super
.
do_decrypt
 = 
aesgcm_decrypt
;

185 
	`cf_aes_init
(&
ctx
->
aes
, 
key
, ctx->
super
.
algo
->
key_size
);

186 
	`memcpy
(
ctx
->
static_iv
, 
iv
, sizeof(ctx->static_iv));

188 
	}
}

	@deps/picotls/lib/cifra/aes128.c

22 #include 
	~"aes-common.h
"

24 static int 
	$aes128ecb_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

26 return 
	`aesecb_setup_crypto
(
ctx
, 
is_enc
, 
key
);

27 
	}
}

29 static int 
	$aes128ctr_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

31 return 
	`aesctr_setup_crypto
(
ctx
, 
is_enc
, 
key
);

32 
	}
}

34 static int 
	$aead_aes128gcm_setup_crypto
(
ptls_aead_context_t
 *
ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

36 return 
	`aead_aesgcm_setup_crypto
(
ctx
, 
is_enc
, 
key
, 
iv
);

37 
	}
}

39 
ptls_define_hash
(
sha256
, 
cf_sha256_context
, 
cf_sha256_init
, 
cf_sha256_update
, 
cf_sha256_digest_final
);

41 
ptls_hash_algorithm_t
 
	gptls_minicrypto_sha256
 = {
PTLS_SHA256_BLOCK_SIZE
, 
PTLS_SHA256_DIGEST_SIZE
, 
sha256_create
,

42 
PTLS_ZERO_DIGEST_SHA256
};

44 
ptls_cipher_algorithm_t
 
	gptls_minicrypto_aes128ecb
 = {

45 "AES128-ECB", 
PTLS_AES128_KEY_SIZE
, 
PTLS_AES_BLOCK_SIZE
, 0 , sizeof(struct 
aesecb_context_t
),

46 
aes128ecb_setup_crypto
};

47 
ptls_cipher_algorithm_t
 
	gptls_minicrypto_aes128ctr
 = {

48 "AES128-CTR", 
PTLS_AES128_KEY_SIZE
, 1 , 
PTLS_AES_IV_SIZE
, sizeof(struct 
aesctr_context_t
),

49 
aes128ctr_setup_crypto
};

50 
ptls_aead_algorithm_t
 
	gptls_minicrypto_aes128gcm
 = {"AES128-GCM",

51 
PTLS_AESGCM_CONFIDENTIALITY_LIMIT
,

52 
PTLS_AESGCM_INTEGRITY_LIMIT
,

53 &
ptls_minicrypto_aes128ctr
,

54 &
ptls_minicrypto_aes128ecb
,

55 
PTLS_AES128_KEY_SIZE
,

56 
PTLS_AESGCM_IV_SIZE
,

57 
PTLS_AESGCM_TAG_SIZE
,

58 sizeof(struct 
aesgcm_context_t
),

59 
aead_aes128gcm_setup_crypto
};

60 
ptls_cipher_suite_t
 
	gptls_minicrypto_aes128gcmsha256
 = {.
id
 = 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
,

61 .
	gname
 = 
PTLS_CIPHER_SUITE_NAME_AES_128_GCM_SHA256
,

62 .
	gaead
 = &
ptls_minicrypto_aes128gcm
,

63 .
	ghash
 = &
ptls_minicrypto_sha256
};

	@deps/picotls/lib/cifra/aes256.c

22 #include 
	~"aes-common.h
"

24 static int 
	$aes256ecb_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

26 return 
	`aesecb_setup_crypto
(
ctx
, 
is_enc
, 
key
);

27 
	}
}

29 static int 
	$aes256ctr_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

31 return 
	`aesctr_setup_crypto
(
ctx
, 
is_enc
, 
key
);

32 
	}
}

34 static int 
	$aead_aes256gcm_setup_crypto
(
ptls_aead_context_t
 *
ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

36 return 
	`aead_aesgcm_setup_crypto
(
ctx
, 
is_enc
, 
key
, 
iv
);

37 
	}
}

39 
ptls_define_hash
(
sha384
, 
cf_sha512_context
, 
cf_sha384_init
, 
cf_sha384_update
, 
cf_sha384_digest_final
);

41 
ptls_hash_algorithm_t
 
	gptls_minicrypto_sha384
 = {
PTLS_SHA384_BLOCK_SIZE
, 
PTLS_SHA384_DIGEST_SIZE
, 
sha384_create
,

42 
PTLS_ZERO_DIGEST_SHA384
};

44 
ptls_cipher_algorithm_t
 
	gptls_minicrypto_aes256ecb
 = {

45 "AES256-ECB", 
PTLS_AES256_KEY_SIZE
, 
PTLS_AES_BLOCK_SIZE
, 0 , sizeof(struct 
aesecb_context_t
),

46 
aes256ecb_setup_crypto
};

47 
ptls_cipher_algorithm_t
 
	gptls_minicrypto_aes256ctr
 = {

48 "AES256-CTR", 
PTLS_AES256_KEY_SIZE
, 1 , 
PTLS_AES_IV_SIZE
, sizeof(struct 
aesctr_context_t
),

49 
aes256ctr_setup_crypto
};

50 
ptls_aead_algorithm_t
 
	gptls_minicrypto_aes256gcm
 = {"AES256-GCM",

51 
PTLS_AESGCM_CONFIDENTIALITY_LIMIT
,

52 
PTLS_AESGCM_INTEGRITY_LIMIT
,

53 &
ptls_minicrypto_aes256ctr
,

54 &
ptls_minicrypto_aes256ecb
,

55 
PTLS_AES256_KEY_SIZE
,

56 
PTLS_AESGCM_IV_SIZE
,

57 
PTLS_AESGCM_TAG_SIZE
,

58 sizeof(struct 
aesgcm_context_t
),

59 
aead_aes256gcm_setup_crypto
};

60 
ptls_cipher_suite_t
 
	gptls_minicrypto_aes256gcmsha384
 = {.
id
 = 
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
,

61 .
	gname
 = 
PTLS_CIPHER_SUITE_NAME_AES_256_GCM_SHA384
,

62 .
	gaead
 = &
ptls_minicrypto_aes256gcm
,

63 .
	ghash
 = &
ptls_minicrypto_sha384
};

	@deps/picotls/lib/cifra/chacha20.c

22 #include 
	~<stdlib.h
>

23 #include 
	~"bitops.h
"

24 #include 
	~"../deps/cifra/src/ext/handy.h
"

25 #include 
	~"poly1305.h
"

26 #include 
	~"salsa20.h
"

27 #include 
	~"sha2.h
"

28 #include 
	~"picotls.h
"

29 #include 
	~"picotls/minicrypto.h
"

31 struct 
	schacha20_context_t
 {

32 
ptls_cipher_context_t
 
	msuper
;

33 
cf_chacha20_ctx
 
	mchacha
;

34 
uint8_t
 
	mkey
[
PTLS_CHACHA20_KEY_SIZE
];

37 static void 
	$chacha20_dispose
(
ptls_cipher_context_t
 *
_ctx
)

39 struct 
chacha20_context_t
 *
ctx
 = (struct chacha20_context_t *)
_ctx
;

40 
	`ptls_clear_memory
(
ctx
, sizeof(*ctx));

41 
	}
}

43 static void 
	$chacha20_init
(
ptls_cipher_context_t
 *
_ctx
, const void *
iv
)

45 struct 
chacha20_context_t
 *
ctx
 = (struct chacha20_context_t *)
_ctx
;

46 
ctx
->
chacha
.
nblock
 = 0;

47 
ctx
->
chacha
.
ncounter
 = 0;

48 
	`memcpy
(
ctx
->
chacha
.
nonce
, 
iv
, sizeof ctx->chacha.nonce);

49 
	}
}

51 static void 
	$chacha20_transform
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
len
)

53 struct 
chacha20_context_t
 *
ctx
 = (struct chacha20_context_t *)
_ctx
;

54 
	`cf_chacha20_cipher
(&
ctx
->
chacha
, 
input
, 
output
, 
len
);

55 
	}
}

57 static int 
	$chacha20_setup_crypto
(
ptls_cipher_context_t
 *
_ctx
, int 
is_enc
, const void *
key
)

59 struct 
chacha20_context_t
 *
ctx
 = (struct chacha20_context_t *)
_ctx
;

60 
ctx
->
super
.
do_dispose
 = 
chacha20_dispose
;

61 
ctx
->
super
.
do_init
 = 
chacha20_init
;

62 
ctx
->
super
.
do_transform
 = 
chacha20_transform
;

63 
	`cf_chacha20_init
(&
ctx
->
chacha
, 
key
, 
PTLS_CHACHA20_KEY_SIZE
, (const 
uint8_t
 *)"01234567" );

65 
	}
}

67 struct 
	schacha20poly1305_context_t
 {

68 
ptls_aead_context_t
 
	msuper
;

69 
uint8_t
 
	mkey
[
PTLS_CHACHA20_KEY_SIZE
];

70 
uint8_t
 
	mstatic_iv
[
PTLS_CHACHA20POLY1305_IV_SIZE
];

71 
cf_chacha20_ctx
 
	mchacha
;

72 
cf_poly1305
 
	mpoly
;

73 
size_t
 
	maadlen
;

74 
size_t
 
	mtextlen
;

77 static void 
	$chacha20poly1305_dispose_crypto
(
ptls_aead_context_t
 *
_ctx
)

79 struct 
chacha20poly1305_context_t
 *
ctx
 = (struct chacha20poly1305_context_t *)
_ctx
;

82 
	`ptls_clear_memory
(&
ctx
->
key
, sizeof(*ctx) - 
	`offsetof
(struct 
chacha20poly1305_context_t
, key));

83 
	}
}

85 static const 
uint8_t
 
	gzeros64
[64] = {0};

87 static void 
	$chacha20poly1305_encrypt_pad
(
cf_poly1305
 *
poly
, 
size_t
 
n
)

89 if (
n
 % 16 != 0)

90 
	`cf_poly1305_update
(
poly
, 
zeros64
, 16 - (
n
 % 16));

91 
	}
}

93 static void 
	$chacha20poly1305_finalize
(struct 
chacha20poly1305_context_t
 *
ctx
, 
uint8_t
 *
tag
)

95 
uint8_t
 
lenbuf
[16];

97 
	`chacha20poly1305_encrypt_pad
(&
ctx
->
poly
, ctx->
textlen
);

99 
	`write64_le
(
ctx
->
aadlen
, 
lenbuf
);

100 
	`write64_le
(
ctx
->
textlen
, 
lenbuf
 + 8);

101 
	`cf_poly1305_update
(&
ctx
->
poly
, 
lenbuf
, sizeof(lenbuf));

103 
	`cf_poly1305_finish
(&
ctx
->
poly
, 
tag
);

104 
	}
}

106 static void 
	$chacha20poly1305_init
(
ptls_aead_context_t
 *
_ctx
, 
uint64_t
 
seq
, const void *
aad
, 
size_t
 
aadlen
)

108 struct 
chacha20poly1305_context_t
 *
ctx
 = (struct chacha20poly1305_context_t *)
_ctx
;

109 
uint8_t
 
tmpbuf
[64];

112 
	`memset
(
tmpbuf
, 0, 16 - 
PTLS_CHACHA20POLY1305_IV_SIZE
);

113 
	`ptls_aead__build_iv
(
ctx
->
super
.
algo
, 
tmpbuf
 + 16 - 
PTLS_CHACHA20POLY1305_IV_SIZE
, ctx->
static_iv
, 
seq
);

114 
	`cf_chacha20_init_custom
(&
ctx
->
chacha
, ctx->
key
, sizeof(ctx->key), 
tmpbuf
, 4);

117 
	`cf_chacha20_cipher
(&
ctx
->
chacha
, 
zeros64
, 
tmpbuf
, 64);

118 
	`cf_poly1305_init
(&
ctx
->
poly
, 
tmpbuf
, tmpbuf + 16);

120 
	`ptls_clear_memory
(
tmpbuf
, sizeof(tmpbuf));

123 if (
aadlen
 != 0) {

124 
	`cf_poly1305_update
(&
ctx
->
poly
, 
aad
, 
aadlen
);

125 
	`chacha20poly1305_encrypt_pad
(&
ctx
->
poly
, 
aadlen
);

128 
ctx
->
aadlen
 = aadlen;

129 
ctx
->
textlen
 = 0;

130 
	}
}

132 static 
size_t
 
	$chacha20poly1305_encrypt_update
(
ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
)

134 struct 
chacha20poly1305_context_t
 *
ctx
 = (struct chacha20poly1305_context_t *)
_ctx
;

136 
	`cf_chacha20_cipher
(&
ctx
->
chacha
, 
input
, 
output
, 
inlen
);

137 
	`cf_poly1305_update
(&
ctx
->
poly
, 
output
, 
inlen
);

138 
ctx
->
textlen
 += 
inlen
;

140 return 
inlen
;

141 
	}
}

143 static 
size_t
 
	$chacha20poly1305_encrypt_final
(
ptls_aead_context_t
 *
_ctx
, void *
output
)

145 struct 
chacha20poly1305_context_t
 *
ctx
 = (struct chacha20poly1305_context_t *)
_ctx
;

147 
	`chacha20poly1305_finalize
(
ctx
, 
output
);

149 
	`ptls_clear_memory
(&
ctx
->
chacha
, sizeof(ctx->chacha));

150 return 
PTLS_CHACHA20POLY1305_TAG_SIZE
;

151 
	}
}

153 static 
size_t
 
	$chacha20poly1305_decrypt
(
ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

154 const void *
aad
, 
size_t
 
aadlen
)

156 struct 
chacha20poly1305_context_t
 *
ctx
 = (struct chacha20poly1305_context_t *)
_ctx
;

157 
uint8_t
 
tag
[
PTLS_CHACHA20POLY1305_TAG_SIZE
];

158 
size_t
 
ret
;

160 if (
inlen
 < sizeof(
tag
))

161 return 
SIZE_MAX
;

163 
	`chacha20poly1305_init
(&
ctx
->
super
, 
seq
, 
aad
, 
aadlen
);

165 
	`cf_poly1305_update
(&
ctx
->
poly
, 
input
, 
inlen
 - sizeof(
tag
));

166 
ctx
->
textlen
 = 
inlen
 - sizeof(
tag
);

168 
	`chacha20poly1305_finalize
(
ctx
, 
tag
);

169 if (
	`mem_eq
(
tag
, (const 
uint8_t
 *)
input
 + 
inlen
 - sizeof(tag), sizeof(tag))) {

170 
	`cf_chacha20_cipher
(&
ctx
->
chacha
, 
input
, 
output
, 
inlen
 - sizeof(
tag
));

171 
ret
 = 
inlen
 - sizeof(
tag
);

173 
ret
 = 
SIZE_MAX
;

176 
	`ptls_clear_memory
(
tag
, sizeof(tag));

177 
	`ptls_clear_memory
(&
ctx
->
poly
, sizeof(ctx->poly));

179 return 
ret
;

180 
	}
}

182 static void 
	$chacha20poly1305_xor_iv
(
ptls_aead_context_t
 *
_ctx
, const void *
_bytes
, 
size_t
 
len
)

184 struct 
chacha20poly1305_context_t
 *
ctx
 = (struct chacha20poly1305_context_t *)
_ctx
;

185 const 
uint8_t
 *
bytes
 = 
_bytes
;

187 for (
size_t
 
i
 = 0; i < 
len
; ++i)

188 
ctx
->
static_iv
[
i
] ^= 
bytes
[i];

189 
	}
}

191 static int 
	$aead_chacha20poly1305_setup_crypto
(
ptls_aead_context_t
 *
_ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

193 struct 
chacha20poly1305_context_t
 *
ctx
 = (struct chacha20poly1305_context_t *)
_ctx
;

195 
ctx
->
super
.
dispose_crypto
 = 
chacha20poly1305_dispose_crypto
;

196 
ctx
->
super
.
do_xor_iv
 = 
chacha20poly1305_xor_iv
;

197 if (
is_enc
) {

198 
ctx
->
super
.
do_encrypt_init
 = 
chacha20poly1305_init
;

199 
ctx
->
super
.
do_encrypt_update
 = 
chacha20poly1305_encrypt_update
;

200 
ctx
->
super
.
do_encrypt_final
 = 
chacha20poly1305_encrypt_final
;

201 
ctx
->
super
.
do_encrypt
 = 
ptls_aead__do_encrypt
;

202 
ctx
->
super
.
do_decrypt
 = 
NULL
;

204 
ctx
->
super
.
do_encrypt_init
 = 
NULL
;

205 
ctx
->
super
.
do_encrypt_update
 = 
NULL
;

206 
ctx
->
super
.
do_encrypt_final
 = 
NULL
;

207 
ctx
->
super
.
do_decrypt
 = 
chacha20poly1305_decrypt
;

210 
	`memcpy
(
ctx
->
key
, key, sizeof(ctx->key));

211 
	`memcpy
(
ctx
->
static_iv
, 
iv
, sizeof(ctx->static_iv));

213 
	}
}

215 
ptls_cipher_algorithm_t
 
	gptls_minicrypto_chacha20
 = {

216 "CHACHA20", 
PTLS_CHACHA20_KEY_SIZE
, 1 , 
PTLS_CHACHA20_IV_SIZE
, sizeof(struct 
chacha20_context_t
),

217 
chacha20_setup_crypto
};

218 
ptls_aead_algorithm_t
 
	gptls_minicrypto_chacha20poly1305
 = {"CHACHA20-POLY1305",

219 
PTLS_CHACHA20POLY1305_CONFIDENTIALITY_LIMIT
,

220 
PTLS_CHACHA20POLY1305_INTEGRITY_LIMIT
,

221 &
ptls_minicrypto_chacha20
,

222 
NULL
,

223 
PTLS_CHACHA20_KEY_SIZE
,

224 
PTLS_CHACHA20POLY1305_IV_SIZE
,

225 
PTLS_CHACHA20POLY1305_TAG_SIZE
,

226 sizeof(struct 
chacha20poly1305_context_t
),

227 
aead_chacha20poly1305_setup_crypto
};

228 
ptls_cipher_suite_t
 
	gptls_minicrypto_chacha20poly1305sha256
 = {.
id
 = 
PTLS_CIPHER_SUITE_CHACHA20_POLY1305_SHA256
,

229 .
	gname
 = 
PTLS_CIPHER_SUITE_NAME_CHACHA20_POLY1305_SHA256
,

230 .
	gaead
 = &
ptls_minicrypto_chacha20poly1305
,

231 .
	ghash
 = &
ptls_minicrypto_sha256
};

	@deps/picotls/lib/cifra/random.c

22 #ifndef 
_XOPEN_SOURCE


23 #define 
	#_XOPEN_SOURCE
 700

	)

25 #include 
	~<errno.h
>

26 #include 
	~<fcntl.h
>

27 #include 
	~<stdio.h
>

28 #include 
	~<stdlib.h
>

29 #ifdef 
_WINDOWS


30 #include 
	~"wincompat.h
"

32 #include 
	~<unistd.h
>

34 #include 
	~"drbg.h
"

35 #include 
	~"picotls.h
"

36 #include 
	~"picotls/minicrypto.h
"

37 #include 
	~<stdio.h
>

38 #ifdef 
_WINDOWS


39 #ifdef 
_WINDOWS_XP


42 #include 
	~<wincrypt.h
>

44 static void 
	$read_entropy
(
uint8_t
 *
entropy
, 
size_t
 
size
)

46 
HCRYPTPROV
 
hCryptProv
 = 0;

47 
BOOL
 
ret
 = 
FALSE
;

49 if (
	`CryptAcquireContext
(&
hCryptProv
, 
NULL
, NULL, 
PROV_RSA_FULL
, 0)) {

50 
ret
 = 
	`CryptGenRandom
(
hCryptProv
, (
DWORD
)
size
, 
entropy
);

51 (void)
	`CryptReleaseContext
(
hCryptProv
, 0);

54 if (
ret
 == 
FALSE
) {

55 
	`perror
("ptls_minicrypto_random_bytes: could not use CryptGenRandom");

56 
	`abort
();

58 
	}
}

63 #include 
	~<bcrypt.h
>

65 static void 
	$read_entropy
(
uint8_t
 *
entropy
, 
size_t
 
size
)

67 
NTSTATUS
 
nts
 = 0;

68 
BCRYPT_ALG_HANDLE
 
hAlgorithm
 = 0;

70 
nts
 = 
	`BCryptOpenAlgorithmProvider
(&
hAlgorithm
, 
BCRYPT_RNG_ALGORITHM
, 
NULL
, 0);

72 if (
	`BCRYPT_SUCCESS
(
nts
)) {

73 
nts
 = 
	`BCryptGenRandom
(
hAlgorithm
, (
PUCHAR
)
entropy
, (
ULONG
)
size
, 0);

75 (void)
	`BCryptCloseAlgorithmProvider
(
hAlgorithm
, 0);

78 if (!
	`BCRYPT_SUCCESS
(
nts
)) {

79 
	`perror
("ptls_minicrypto_random_bytes: could not open BCrypt RNG Algorithm");

80 
	`abort
();

82 
	}
}

85 static void 
	$read_entropy
(
uint8_t
 *
entropy
, 
size_t
 
size
)

87 int 
fd
;

89 if ((
fd
 = 
	`open
("/dev/urandom", 
O_RDONLY
 | 
O_CLOEXEC
)) == -1) {

90 if ((
fd
 = 
	`open
("/dev/random", 
O_RDONLY
 | 
O_CLOEXEC
)) == -1) {

91 
	`perror
("ptls_minicrypto_random_bytes: could not open neither /dev/random or /dev/urandom");

92 
	`abort
();

96 while (
size
 != 0) {

97 
ssize_t
 
rret
;

98 while ((
rret
 = 
	`read
(
fd
, 
entropy
, 
size
)) == -1 && 
errno
 == 
EINTR
)

100 if (
rret
 < 0) {

101 
	`perror
("ptls_minicrypto_random_bytes");

102 
	`abort
();

104 
entropy
 += 
rret
;

105 
size
 -= 
rret
;

108 
	`close
(
fd
);

109 
	}
}

112 void 
	$ptls_minicrypto_random_bytes
(void *
buf
, 
size_t
 
len
)

114 static 
PTLS_THREADLOCAL
 
cf_hash_drbg_sha256
 
ctx
;

116 if (
	`cf_hash_drbg_sha256_needs_reseed
(&
ctx
)) {

117 
uint8_t
 
entropy
[256];

118 
	`read_entropy
(
entropy
, sizeof(entropy));

119 
	`cf_hash_drbg_sha256_init
(&
ctx
, 
entropy
, sizeof(entropy) / 2, entropy + sizeof(entropy) / 2, sizeof(entropy) / 2, "ptls", 4);

121 
	`cf_hash_drbg_sha256_gen
(&
ctx
, 
buf
, 
len
);

122 
	}
}

	@deps/picotls/lib/cifra/x25519.c

22 #include 
	~<stdlib.h
>

23 #include 
	~"curve25519.h
"

24 #include 
	~"picotls.h
"

25 #include 
	~"picotls/minicrypto.h
"

27 #define 
	#X25519_KEY_SIZE
 32

	)

29 struct 
	sst_x25519_key_exchange_t
 {

30 
ptls_key_exchange_context_t
 
	msuper
;

31 
uint8_t
 
	mpriv
[
X25519_KEY_SIZE
];

32 
uint8_t
 
	mpub
[
X25519_KEY_SIZE
];

35 static void 
	$x25519_create_keypair
(
uint8_t
 *
priv
, uint8_t *
pub
)

37 
	`ptls_minicrypto_random_bytes
(
priv
, 
X25519_KEY_SIZE
);

38 
	`cf_curve25519_mul_base
(
pub
, 
priv
);

39 
	}
}

41 static int 
	$x25519_derive_secret
(
ptls_iovec_t
 *
secret
, const 
uint8_t
 *
clientpriv
, const uint8_t *
clientpub
,

42 const 
uint8_t
 *
serverpriv
, const uint8_t *
serverpub
)

44 if ((
secret
->
base
 = 
	`malloc
(
X25519_KEY_SIZE
)) == 
NULL
)

45 return 
PTLS_ERROR_NO_MEMORY
;

47 
	`cf_curve25519_mul
(
secret
->
base
, 
clientpriv
 != 
NULL
 ? clientpriv : 
serverpriv
, clientpriv != NULL ? 
serverpub
 : 
clientpub
);

48 
secret
->
len
 = 
X25519_KEY_SIZE
;

50 
	}
}

52 static int 
	$x25519_on_exchange
(
ptls_key_exchange_context_t
 **
_ctx
, int 
release
, 
ptls_iovec_t
 *
secret
, ptls_iovec_t 
peerkey
)

54 struct 
st_x25519_key_exchange_t
 *
ctx
 = (struct st_x25519_key_exchange_t *)*
_ctx
;

55 int 
ret
;

57 if (
secret
 == 
NULL
) {

58 
ret
 = 0;

59 goto 
Exit
;

62 if (
peerkey
.
len
 != 
X25519_KEY_SIZE
) {

63 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

64 goto 
Exit
;

66 
ret
 = 
	`x25519_derive_secret
(
secret
, 
ctx
->
priv
, ctx->
pub
, 
NULL
, 
peerkey
.
base
);

68 
Exit
:

69 if (
release
) {

70 
	`ptls_clear_memory
(
ctx
->
priv
, sizeof(ctx->priv));

71 
	`free
(
ctx
);

72 *
_ctx
 = 
NULL
;

74 return 
ret
;

75 
	}
}

77 static int 
	$x25519_create_key_exchange
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_key_exchange_context_t
 **
_ctx
)

79 struct 
st_x25519_key_exchange_t
 *
ctx
;

81 if ((
ctx
 = (struct 
st_x25519_key_exchange_t
 *)
	`malloc
(sizeof(*ctx))) == 
NULL
)

82 return 
PTLS_ERROR_NO_MEMORY
;

83 
ctx
->
super
 = (
ptls_key_exchange_context_t
){
algo
, 
	`ptls_iovec_init
(ctx->
pub
, sizeof(ctx->pub)), 
x25519_on_exchange
};

84 
	`x25519_create_keypair
(
ctx
->
priv
, ctx->
pub
);

86 *
_ctx
 = &
ctx
->
super
;

88 
	}
}

90 static int 
	$x25519_key_exchange
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_iovec_t
 *
pubkey
, ptls_iovec_t *
secret
,

91 
ptls_iovec_t
 
peerkey
)

93 
uint8_t
 
priv
[
X25519_KEY_SIZE
], *
pub
 = 
NULL
;

94 int 
ret
;

96 if (
peerkey
.
len
 != 
X25519_KEY_SIZE
) {

97 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

98 goto 
Exit
;

100 if ((
pub
 = 
	`malloc
(
X25519_KEY_SIZE
)) == 
NULL
) {

101 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

102 goto 
Exit
;

105 
	`x25519_create_keypair
(
priv
, 
pub
);

106 if ((
ret
 = 
	`x25519_derive_secret
(
secret
, 
NULL
, 
peerkey
.
base
, 
priv
, 
pub
)) != 0)

107 goto 
Exit
;

109 *
pubkey
 = 
	`ptls_iovec_init
(
pub
, 
X25519_KEY_SIZE
);

110 
ret
 = 0;

112 
Exit
:

113 
	`ptls_clear_memory
(
priv
, sizeof(priv));

114 if (
pub
 != 
NULL
 && 
ret
 != 0)

115 
	`ptls_clear_memory
(
pub
, 
X25519_KEY_SIZE
);

116 return 
ret
;

117 
	}
}

119 
ptls_key_exchange_algorithm_t
 
	gptls_minicrypto_x25519
 = {

120 .
id
 = 
PTLS_GROUP_X25519
, .
	gname
 = 
PTLS_GROUP_NAME_X25519
, .
	gcreate
 = 
x25519_create_key_exchange
, .
	gexchange
 = 
x25519_key_exchange
};

	@deps/picotls/lib/ffx.c

16 #ifdef 
_WINDOWS


17 #include 
	~"wincompat.h
"

19 #include 
	~<unistd.h
>

21 #include 
	~<errno.h
>

22 #include 
	~<stdlib.h
>

23 #include 
	~<string.h
>

24 #include 
	~"picotls.h
"

25 #include 
	~"picotls/minicrypto.h
"

26 #include 
	~"picotls/ffx.h
"

28 static void 
ffx_dispose
(
ptls_cipher_context_t
 *
_ctx
);

29 static void 
ffx_encrypt
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
len
);

30 static void 
ffx_init
(struct 
st_ptls_cipher_context_t
 *
ctx
, const void *
iv
);

32 int 
	$ptls_ffx_setup_crypto
(
ptls_cipher_context_t
 *
_ctx
, 
ptls_cipher_algorithm_t
 *
algo
, int 
is_enc
, int 
nb_rounds
, 
size_t
 
bit_length
,

33 const void *
key
)

35 int 
ret
 = 0;

36 
ptls_ffx_context_t
 *
ctx
 = (ptls_ffx_context_t *)
_ctx
;

37 
ptls_cipher_context_t
 *
enc_ctx
 = 
NULL
;

38 
size_t
 
len
 = (
bit_length
 + 7) / 8;

39 
uint8_t
 
last_byte_mask
[8] = {0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80};

41 
	`assert
(
len
 <= 32 && len >= 2);

42 
	`assert
(
ctx
->
super
.
do_dispose
 == 
NULL
);

43 
	`assert
(
ctx
->
super
.
do_init
 == 
NULL
);

44 
	`assert
(
ctx
->
super
.
do_transform
 == 
NULL
);

45 
	`assert
(
ctx
->
super
.
algo
 == 
NULL
 || algo->
key_size
 == ctx->super.algo->key_size);

46 
	`assert
(
ctx
->
super
.
algo
 == 
NULL
 || algo->
iv_size
 == ctx->super.algo->iv_size);

47 
	`assert
(
ctx
->
super
.
algo
 == 
NULL
 || ctx->super.algo->
block_size
 == 
len
);

48 
	`assert
(
algo
->
iv_size
 == 16);

50 if (
len
 <= 32 && len >= 2) {

52 
enc_ctx
 = 
	`ptls_cipher_new
(
algo
, 1, 
key
);

54 if (
enc_ctx
 == 
NULL
) {

55 
ret
 = 
PTLS_ERROR_LIBRARY
;

58 
ret
 = 
PTLS_ERROR_LIBRARY
;

61 if (
ret
 == 0) {

62 
ctx
->
enc_ctx
 = enc_ctx;

63 
ctx
->
nb_rounds
 = nb_rounds;

64 
ctx
->
is_enc
 = is_enc;

65 
ctx
->
byte_length
 = 
len
;

66 
ctx
->
nb_left
 = (int)
len
 / 2;

67 
ctx
->
nb_right
 = (int)
len
 - ctx->
nb_left
;

68 
ctx
->
mask_last_byte
 = 
last_byte_mask
[
bit_length
 % 8];

69 
	`ptls_clear_memory
(
ctx
->
tweaks
, sizeof(ctx->tweaks));

71 
ctx
->
super
.
do_dispose
 = 
ffx_dispose
;

72 
ctx
->
super
.
do_init
 = 
ffx_init
;

73 
ctx
->
super
.
do_transform
 = 
ffx_encrypt
;

75 
	`ffx_dispose
(
_ctx
);

78 return 
ret
;

79 
	}
}

81 static void 
	$ffx_dispose
(
ptls_cipher_context_t
 *
_ctx
)

83 
ptls_ffx_context_t
 *
ctx
 = (ptls_ffx_context_t *)
_ctx
;

85 
	`assert
(
ctx
->
super
.
do_dispose
 == 
ffx_dispose
);

87 if (
ctx
->
enc_ctx
 != 
NULL
) {

88 
	`ptls_cipher_free
(
ctx
->
enc_ctx
);

91 
ctx
->
enc_ctx
 = 
NULL
;

92 
ctx
->
nb_rounds
 = 0;

93 
ctx
->
byte_length
 = 0;

94 
ctx
->
nb_left
 = 0;

95 
ctx
->
nb_right
 = 0;

96 
ctx
->
mask_last_byte
 = 0;

97 
ctx
->
is_enc
 = 0;

99 
ctx
->
super
.
do_dispose
 = 
NULL
;

100 
ctx
->
super
.
do_init
 = 
NULL
;

101 
ctx
->
super
.
do_transform
 = 
NULL
;

102 
	}
}

104 
ptls_cipher_context_t
 *
	$ptls_ffx_new
(
ptls_cipher_algorithm_t
 *
algo
, int 
is_enc
, int 
nb_rounds
, 
size_t
 
bit_length
, const void *
key
)

106 
ptls_cipher_context_t
 *
ctx
 = (ptls_cipher_context_t *)
	`malloc
(sizeof(
ptls_ffx_context_t
));

108 if (
ctx
 != 
NULL
) {

109 
	`memset
(
ctx
, 0, sizeof(
ptls_ffx_context_t
));

110 if (
	`ptls_ffx_setup_crypto
(
ctx
, 
algo
, 
is_enc
, 
nb_rounds
, 
bit_length
, 
key
) != 0) {

111 
	`free
(
ctx
);

112 
ctx
 = 
NULL
;

116 return 
ctx
;

117 
	}
}

119 static void 
	$ptls_ffx_one_pass
(
ptls_cipher_context_t
 *
enc_ctx
, 
uint8_t
 *
source
, 
size_t
 
source_size
, uint8_t *
target
,

120 
size_t
 
target_size
, 
uint8_t
 
mask_last_byte
, uint8_t *
confusion
, uint8_t *
iv
, uint8_t *
tweaks
,

121 
uint8_t
 
round
, uint8_t 
nb_rounds
)

123 static const 
uint8_t
 
zeros
[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

125 
	`memcpy
(
iv
, 
tweaks
, 16);

126 
iv
[
round
 & 15] ^= 
nb_rounds
;

127 for (
size_t
 
i
 = 0; i < 
source_size
; i++) {

128 
iv
[
i
] ^= 
source
[i];

130 
	`ptls_cipher_init
(
enc_ctx
, 
iv
);

131 
	`ptls_cipher_encrypt
(
enc_ctx
, 
confusion
, 
zeros
, 16);

132 for (
size_t
 
j
 = 0; j < 
target_size
 - 1; j++) {

133 
target
[
j
] ^= 
confusion
[j];

135 
target
[
target_size
 - 1] ^= (
confusion
[target_size - 1] & 
mask_last_byte
);

136 
	}
}

138 static void 
	$ffx_encrypt
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
len
)

140 
ptls_ffx_context_t
 *
ctx
 = (ptls_ffx_context_t *)
_ctx
;

141 
uint8_t
 
left
[16], 
right
[16], 
confusion
[32], 
iv
[16];

142 
uint8_t
 
last_byte
;

144 
	`assert
(
ctx
->
super
.
do_transform
 == 
ffx_encrypt
);

147 
	`assert
(
len
 == 
ctx
->
byte_length
);

148 if (
len
 != 
ctx
->
byte_length
) {

149 
	`memset
(
output
, 0, 
len
);

154 
	`memcpy
(
left
, 
input
, 
ctx
->
nb_left
);

155 
	`memcpy
(
right
, ((
uint8_t
 *)
input
) + 
ctx
->
nb_left
, ctx->
nb_right
);

156 
	`memset
(
left
 + 
ctx
->
nb_left
, 0, 16 - ctx->nb_left);

157 
	`memset
(
right
 + 
ctx
->
nb_right
, 0, 16 - ctx->nb_right);

158 
last_byte
 = 
right
[
ctx
->
nb_right
 - 1];

159 
right
[
ctx
->
nb_right
 - 1] &= ctx->
mask_last_byte
;

161 if (
ctx
->
is_enc
) {

163 for (int 
i
 = 0; i < 
ctx
->
nb_rounds
; i += 2) {

167 
	`ptls_ffx_one_pass
(
ctx
->
enc_ctx
, 
right
, ctx->
nb_right
, 
left
, ctx->
nb_left
, 0xFF, 
confusion
, 
iv
, ctx->
tweaks
, 
i
,

168 
ctx
->
nb_rounds
);

169 
	`ptls_ffx_one_pass
(
ctx
->
enc_ctx
, 
left
, ctx->
nb_left
, 
right
, ctx->
nb_right
, ctx->
mask_last_byte
, 
confusion
, 
iv
,

170 
ctx
->
tweaks
, 
i
 + 1, ctx->
nb_rounds
);

176 for (int 
i
 = 0; i < 
ctx
->
nb_rounds
; i += 2) {

181 
	`ptls_ffx_one_pass
(
ctx
->
enc_ctx
, 
left
, ctx->
nb_left
, 
right
, ctx->
nb_right
, ctx->
mask_last_byte
, 
confusion
, 
iv
,

182 
ctx
->
tweaks
, ctx->
nb_rounds
 - 1 - 
i
, ctx->nb_rounds);

183 
	`ptls_ffx_one_pass
(
ctx
->
enc_ctx
, 
right
, ctx->
nb_right
, 
left
, ctx->
nb_left
, 0xFF, 
confusion
, 
iv
, ctx->
tweaks
,

184 
ctx
->
nb_rounds
 - 2 - 
i
, ctx->nb_rounds);

190 
	`memcpy
(
output
, 
left
, 
ctx
->
nb_left
);

192 
right
[
ctx
->
nb_right
 - 1] &= ctx->
mask_last_byte
;

193 
right
[
ctx
->
nb_right
 - 1] |= (
last_byte
 & ~ctx->
mask_last_byte
);

195 
	`memcpy
(((
uint8_t
 *)
output
) + 
ctx
->
nb_left
, 
right
, ctx->
nb_right
);

197 
	`ptls_clear_memory
(
left
, sizeof(left));

198 
	`ptls_clear_memory
(
right
, sizeof(right));

199 
	`ptls_clear_memory
(
confusion
, sizeof(confusion));

200 
	}
}

202 static void 
	$ffx_init
(struct 
st_ptls_cipher_context_t
 *
_ctx
, const void *
iv
)

204 
ptls_ffx_context_t
 *
ctx
 = (ptls_ffx_context_t *)
_ctx
;

205 
	`assert
(
ctx
->
super
.
do_init
 == 
ffx_init
);

206 
	`memcpy
(
ctx
->
tweaks
, 
iv
, 16);

207 
	}
}

	@deps/picotls/lib/fusion.c

40 #include 
	~<stdint.h
>

42 #include 
	~<stdlib.h
>

43 #include 
	~<string.h
>

44 #include 
	~<immintrin.h
>

45 #include 
	~<tmmintrin.h
>

46 #include 
	~<nmmintrin.h
>

47 #include 
	~<wmmintrin.h
>

48 #include 
	~"picotls.h
"

49 #include 
	~"picotls/fusion.h
"

51 struct 
	sptls_fusion_aesgcm_context
 {

52 
ptls_fusion_aesecb_context_t
 
	mecb
;

53 
size_t
 
	mcapacity
;

54 
size_t
 
	mghash_cnt
;

55 struct 
	sptls_fusion_aesgcm_ghash_precompute
 {

56 
__m128i
 
	mH
;

57 
__m128i
 
	mr
;

58 } 
	mghash
[0];

61 struct 
	sctr_context
 {

62 
ptls_cipher_context_t
 
	msuper
;

63 
ptls_fusion_aesecb_context_t
 
	mfusion
;

64 
__m128i
 
	mbits
;

65 
uint8_t
 
	mis_ready
;

68 struct 
	saesgcm_context
 {

69 
ptls_aead_context_t
 
	msuper
;

70 
ptls_fusion_aesgcm_context_t
 *
	maesgcm
;

74 
__m128i
 
	mstatic_iv
;

77 static const 
uint64_t
 
	gpoly_
[2] 
__attribute__
((
aligned
(16))) = {1, 0xc200000000000000};

78 #define 
	#poly
 (*(
__m128i
 *)
poly_
)

	)

79 static const 
uint8_t
 
	gbswap8_
[16] 
__attribute__
((
aligned
(16))) = {15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

80 #define 
	#bswap8
 (*(
__m128i
 *)
bswap8_
)

	)

81 static const 
uint8_t
 
	gone8_
[16] 
__attribute__
((
aligned
(16))) = {1};

82 #define 
	#one8
 (*(
__m128i
 *)
one8_
)

	)

86 static 
__m128i
 
	$transformH
(
__m128i
 
H
)

90 
__m128i
 
t2
 = 
	`_mm_shuffle_epi32
(
H
, 0xff);

92 
__m128i
 
t1
 = 
H
;

94 
H
 = 
	`_mm_slli_epi64
(H, 1);

96 
__m128i
 
t3
 = 
	`_mm_setzero_si128
();

98 
t1
 = 
	`_mm_srli_epi64
(t1, 63);

100 
t3
 = 
	`_mm_cmplt_epi32
(
t2
, t3);

102 
t1
 = 
	`_mm_slli_si128
(t1, 8);

104 
H
 = 
	`_mm_or_si128
(
t1
, H);

108 
t3
 = 
	`_mm_and_si128
(t3, 
poly
);

110 
H
 = 
	`_mm_xor_si128
(
t3
, H);

112 return 
H
;

113 
	}
}

116 static 
__m128i
 
	$gfmul
(
__m128i
 
x
, __m128i 
y
)

118 
__m128i
 
lo
 = 
	`_mm_clmulepi64_si128
(
x
, 
y
, 0x00);

119 
__m128i
 
hi
 = 
	`_mm_clmulepi64_si128
(
x
, 
y
, 0x11);

121 
__m128i
 
a
 = 
	`_mm_shuffle_epi32
(
x
, 78);

122 
__m128i
 
b
 = 
	`_mm_shuffle_epi32
(
y
, 78);

123 
a
 = 
	`_mm_xor_si128
(a, 
x
);

124 
b
 = 
	`_mm_xor_si128
(b, 
y
);

126 
a
 = 
	`_mm_clmulepi64_si128
(a, 
b
, 0x00);

127 
a
 = 
	`_mm_xor_si128
(a, 
lo
);

128 
a
 = 
	`_mm_xor_si128
(a, 
hi
);

130 
b
 = 
	`_mm_slli_si128
(
a
, 8);

131 
a
 = 
	`_mm_srli_si128
(a, 8);

133 
lo
 = 
	`_mm_xor_si128
(lo, 
b
);

134 
hi
 = 
	`_mm_xor_si128
(hi, 
a
);

137 
__m128i
 
t
 = 
	`_mm_clmulepi64_si128
(
lo
, 
poly
, 0x10);

138 
lo
 = 
	`_mm_shuffle_epi32
(lo, 78);

139 
lo
 = 
	`_mm_xor_si128
(lo, 
t
);

140 
t
 = 
	`_mm_clmulepi64_si128
(
lo
, 
poly
, 0x10);

141 
lo
 = 
	`_mm_shuffle_epi32
(lo, 78);

142 
lo
 = 
	`_mm_xor_si128
(lo, 
t
);

144 return 
	`_mm_xor_si128
(
hi
, 
lo
);

145 
	}
}

147 struct 
	sptls_fusion_gfmul_state
 {

148 
__m128i
 
	mhi
, 
	mlo
, 
	mmid
;

151 static 
inline
 void 
	$gfmul_onestep
(struct 
ptls_fusion_gfmul_state
 *
gstate
, 
__m128i
 
X
,

152 struct 
ptls_fusion_aesgcm_ghash_precompute
 *
precompute
)

154 
X
 = 
	`_mm_shuffle_epi8
(X, 
bswap8
);

155 
__m128i
 
t
 = 
	`_mm_clmulepi64_si128
(
precompute
->
H
, 
X
, 0x00);

156 
gstate
->
lo
 = 
	`_mm_xor_si128
(gstate->lo, 
t
);

157 
t
 = 
	`_mm_clmulepi64_si128
(
precompute
->
H
, 
X
, 0x11);

158 
gstate
->
hi
 = 
	`_mm_xor_si128
(gstate->hi, 
t
);

159 
t
 = 
	`_mm_shuffle_epi32
(
X
, 78);

160 
t
 = 
	`_mm_xor_si128
(t, 
X
);

161 
t
 = 
	`_mm_clmulepi64_si128
(
precompute
->
r
, t, 0x00);

162 
gstate
->
mid
 = 
	`_mm_xor_si128
(gstate->mid, 
t
);

163 
	}
}

165 static 
inline
 
__m128i
 
	$gfmul_final
(struct 
ptls_fusion_gfmul_state
 *
gstate
, 
__m128i
 
ek0
)

168 
gstate
->
mid
 = 
	`_mm_xor_si128
(gstate->mid, gstate->
hi
);

169 
gstate
->
mid
 = 
	`_mm_xor_si128
(gstate->mid, gstate->
lo
);

170 
gstate
->
lo
 = 
	`_mm_xor_si128
(gstate->lo, 
	`_mm_slli_si128
(gstate->
mid
, 8));

171 
gstate
->
hi
 = 
	`_mm_xor_si128
(gstate->hi, 
	`_mm_srli_si128
(gstate->
mid
, 8));

174 
__m128i
 
r
 = 
	`_mm_clmulepi64_si128
(
gstate
->
lo
, 
poly
, 0x10);

175 
gstate
->
lo
 = 
	`_mm_shuffle_epi32
(gstate->lo, 78);

176 
gstate
->
lo
 = 
	`_mm_xor_si128
(gstate->lo, 
r
);

177 
r
 = 
	`_mm_clmulepi64_si128
(
gstate
->
lo
, 
poly
, 0x10);

178 
gstate
->
lo
 = 
	`_mm_shuffle_epi32
(gstate->lo, 78);

179 
gstate
->
lo
 = 
	`_mm_xor_si128
(gstate->lo, 
r
);

180 
__m128i
 
tag
 = 
	`_mm_xor_si128
(
gstate
->
hi
, gstate->
lo
);

181 
tag
 = 
	`_mm_shuffle_epi8
(tag, 
bswap8
);

182 
tag
 = 
	`_mm_xor_si128
(tag, 
ek0
);

184 return 
tag
;

185 
	}
}

187 static 
inline
 
__m128i
 
	$aesecb_encrypt
(
ptls_fusion_aesecb_context_t
 *
ctx
, 
__m128i
 
v
)

189 
size_t
 
i
;

191 
v
 = 
	`_mm_xor_si128
(v, 
ctx
->
keys
[0]);

192 for (
i
 = 1; i < 
ctx
->
rounds
; ++i)

193 
v
 = 
	`_mm_aesenc_si128
(v, 
ctx
->
keys
[
i
]);

194 
v
 = 
	`_mm_aesenclast_si128
(v, 
ctx
->
keys
[
i
]);

196 return 
v
;

197 
	}
}

199 static const 
uint8_t
 
	gloadn_mask
[31] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

201 static const 
uint8_t
 
	gloadn_shuffle
[31] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,

206 static 
inline
 
__m128i
 
	$loadn
(const void *
p
, 
size_t
 
l
)

208 
__m128i
 
v
, 
mask
 = 
	`_mm_loadu_si128
((__m128i *)(
loadn_mask
 + 16 - 
l
));

209 
uintptr_t
 
mod4k
 = (uintptr_t)
p
 % 4096;

211 if (
	`PTLS_LIKELY
(
mod4k
 <= 4080) || mod4k + 
l
 > 4096) {

212 
v
 = 
	`_mm_loadu_si128
(
p
);

214 
uintptr_t
 
shift
 = (uintptr_t)
p
 & 15;

215 
__m128i
 
pattern
 = 
	`_mm_loadu_si128
((const __m128i *)(
loadn_shuffle
 + 
shift
));

216 
v
 = 
	`_mm_shuffle_epi8
(
	`_mm_load_si128
((const 
__m128i
 *)((
uintptr_t
)
p
 - 
shift
)), 
pattern
);

218 
v
 = 
	`_mm_and_si128
(v, 
mask
);

219 return 
v
;

220 
	}
}

222 static 
inline
 void 
	$storen
(void *
_p
, 
size_t
 
l
, 
__m128i
 
v
)

224 
uint8_t
 
buf
[16], *
p
 = 
_p
;

226 *(
__m128i
 *)
buf
 = 
v
;

228 for (
size_t
 
i
 = 0; i != 
l
; ++i)

229 
p
[
i
] = 
buf
[i];

230 
	}
}

232 void 
	$ptls_fusion_aesgcm_encrypt
(
ptls_fusion_aesgcm_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
__m128i
 
ctr
,

233 const void *
_aad
, 
size_t
 
aadlen
, 
ptls_aead_supplementary_encryption_t
 *
supp
)

236 #define 
	#AESECB6_INIT
() \

238 
ctr
 = 
	`_mm_add_epi64
(ctr, 
one8
); \

239 
bits0
 = 
	`_mm_shuffle_epi8
(
ctr
, 
bswap8
); \

240 
ctr
 = 
	`_mm_add_epi64
(ctr, 
one8
); \

241 
bits1
 = 
	`_mm_shuffle_epi8
(
ctr
, 
bswap8
); \

242 
ctr
 = 
	`_mm_add_epi64
(ctr, 
one8
); \

243 
bits2
 = 
	`_mm_shuffle_epi8
(
ctr
, 
bswap8
); \

244 
ctr
 = 
	`_mm_add_epi64
(ctr, 
one8
); \

245 
bits3
 = 
	`_mm_shuffle_epi8
(
ctr
, 
bswap8
); \

246 
ctr
 = 
	`_mm_add_epi64
(ctr, 
one8
); \

247 
bits4
 = 
	`_mm_shuffle_epi8
(
ctr
, 
bswap8
); \

248 if (
	`PTLS_LIKELY
(
srclen
 > 16 * 5)) { \

249 
ctr
 = 
	`_mm_add_epi64
(ctr, 
one8
); \

250 
bits5
 = 
	`_mm_shuffle_epi8
(
ctr
, 
bswap8
); \

252 if ((
state
 & 
STATE_EK0_BEEN_FED
) == 0) { \

253 
bits5
 = 
ek0
; \

254 
state
 |= 
STATE_EK0_BEEN_FED
; \

256 if ((
state
 & 
STATE_SUPP_USED
) != 0 && 
srclen
 <= 16 * 4 && (const 
__m128i
 *)
supp
->
input
 + 1 <= 
dst_ghash
) { \

257 
bits4
 = 
	`_mm_loadu_si128
(
supp
->
input
); \

258 
bits4keys
 = ((struct 
ctr_context
 *)
supp
->
ctx
)->
fusion
.
keys
; \

259 
state
 |= 
STATE_SUPP_IN_PROCESS
; \

262 
__m128i
 
k
 = 
ctx
->
ecb
.
keys
[0]; \

263 
bits0
 = 
	`_mm_xor_si128
(bits0, 
k
); \

264 
bits1
 = 
	`_mm_xor_si128
(bits1, 
k
); \

265 
bits2
 = 
	`_mm_xor_si128
(bits2, 
k
); \

266 
bits3
 = 
	`_mm_xor_si128
(bits3, 
k
); \

267 
bits4
 = 
	`_mm_xor_si128
(bits4, 
bits4keys
[0]); \

268 
bits5
 = 
	`_mm_xor_si128
(bits5, 
k
); \

269 } while (0)

	)

272 #define 
	#AESECB6_UPDATE
(
i
) \

274 
__m128i
 
k
 = 
ctx
->
ecb
.
keys
[
i
]; \

275 
bits0
 = 
	`_mm_aesenc_si128
(bits0, 
k
); \

276 
bits1
 = 
	`_mm_aesenc_si128
(bits1, 
k
); \

277 
bits2
 = 
	`_mm_aesenc_si128
(bits2, 
k
); \

278 
bits3
 = 
	`_mm_aesenc_si128
(bits3, 
k
); \

279 
bits4
 = 
	`_mm_aesenc_si128
(bits4, 
bits4keys
[
i
]); \

280 
bits5
 = 
	`_mm_aesenc_si128
(bits5, 
k
); \

281 } while (0)

	)

284 #define 
	#AESECB6_FINAL
(
i
) \

286 
__m128i
 
k
 = 
ctx
->
ecb
.
keys
[
i
]; \

287 
bits0
 = 
	`_mm_aesenclast_si128
(bits0, 
k
); \

288 
bits1
 = 
	`_mm_aesenclast_si128
(bits1, 
k
); \

289 
bits2
 = 
	`_mm_aesenclast_si128
(bits2, 
k
); \

290 
bits3
 = 
	`_mm_aesenclast_si128
(bits3, 
k
); \

291 
bits4
 = 
	`_mm_aesenclast_si128
(bits4, 
bits4keys
[
i
]); \

292 
bits5
 = 
	`_mm_aesenclast_si128
(bits5, 
k
); \

293 } while (0)

	)

295 
__m128i
 
ek0
, 
bits0
, 
bits1
, 
bits2
, 
bits3
, 
bits4
, 
bits5
 = 
	`_mm_setzero_si128
();

296 const 
__m128i
 *
bits4keys
 = 
ctx
->
ecb
.
keys
;

297 struct 
ptls_fusion_gfmul_state
 
gstate
 = {0};

298 
__m128i
 
gdatabuf
[6];

299 
__m128i
 
ac
 = 
	`_mm_shuffle_epi8
(
	`_mm_set_epi32
(0, (int)
aadlen
 * 8, 0, (int)
inlen
 * 8), 
bswap8
);

302 const 
__m128i
 *
src
 = 
input
;

303 
__m128i
 *
dst
 = 
output
;

304 
size_t
 
srclen
 = 
inlen
;

306 const 
__m128i
 *
aad
 = 
_aad
, *
dst_ghash
 = 
dst
;

307 
size_t
 
dst_ghashlen
 = 
srclen
;

309 struct 
ptls_fusion_aesgcm_ghash_precompute
 *
ghash_precompute
 = 
ctx
->
ghash
 + (
aadlen
 + 15) / 16 + (
srclen
 + 15) / 16 + 1;

311 #define 
	#STATE_EK0_BEEN_FED
 0x3

	)

312 #define 
	#STATE_EK0_INCOMPLETE
 0x2

	)

313 #define 
	#STATE_EK0_READY
() ((
state
 & 
STATE_EK0_BEEN_FED
) == 0x1)

	)

314 #define 
	#STATE_SUPP_USED
 0x4

	)

315 #define 
	#STATE_SUPP_IN_PROCESS
 0x8

	)

316 
int32_t
 
state
 = 
supp
 != 
NULL
 ? 
STATE_SUPP_USED
 : 0;

319 
ctr
 = 
	`_mm_insert_epi32
(ctr, 1, 0);

320 
ek0
 = 
	`_mm_shuffle_epi8
(
ctr
, 
bswap8
);

323 
	`AESECB6_INIT
();

324 
	`AESECB6_UPDATE
(1);

327 const 
__m128i
 *
gdata
 = 
gdatabuf
;

328 
size_t
 
gdata_cnt
 = 0;

329 if (
	`PTLS_LIKELY
(
aadlen
 != 0)) {

330 while (
gdata_cnt
 < 6) {

331 if (
	`PTLS_LIKELY
(
aadlen
 < 16)) {

332 if (
aadlen
 != 0) {

333 
gdatabuf
[
gdata_cnt
++] = 
	`loadn
(
aad
, 
aadlen
);

334 
aadlen
 = 0;

336 goto 
MainLoop
;

338 
gdatabuf
[
gdata_cnt
++] = 
	`_mm_loadu_si128
(
aad
++);

339 
aadlen
 -= 16;

344 
MainLoop
:

347 
size_t
 
i
;

348 for (
i
 = 2; i < 
gdata_cnt
 + 2; ++i) {

349 
	`AESECB6_UPDATE
(
i
);

350 
	`gfmul_onestep
(&
gstate
, 
	`_mm_loadu_si128
(
gdata
++), --
ghash_precompute
);

352 for (; 
i
 < 
ctx
->
ecb
.
rounds
; ++i)

353 
	`AESECB6_UPDATE
(
i
);

354 
	`AESECB6_FINAL
(
i
);

357 if (
	`PTLS_LIKELY
(
srclen
 >= 6 * 16)) {

358 #define 
	#APPLY
(
i
) 
	`_mm_storeu_si128
(
dst
 + i, 
	`_mm_xor_si128
(
	`_mm_loadu_si128
(
src
 + i), 
bits
##i))

	)

359 
	`APPLY
(0);

360 
	`APPLY
(1);

361 
	`APPLY
(2);

362 
	`APPLY
(3);

363 
	`APPLY
(4);

364 
	`APPLY
(5);

365 #undef 
APPLY


366 
dst
 += 6;

367 
src
 += 6;

368 
srclen
 -= 6 * 16;

370 if ((
state
 & 
STATE_EK0_BEEN_FED
) == STATE_EK0_BEEN_FED) {

371 
ek0
 = 
bits5
;

372 
state
 &= ~
STATE_EK0_INCOMPLETE
;

374 if ((
state
 & 
STATE_SUPP_IN_PROCESS
) != 0) {

375 
	`_mm_storeu_si128
((
__m128i
 *)
supp
->
output
, 
bits4
);

376 
state
 &= ~(
STATE_SUPP_USED
 | 
STATE_SUPP_IN_PROCESS
);

378 if (
srclen
 != 0) {

379 #define 
	#APPLY
(
i
) \

381 if (
	`PTLS_LIKELY
(
srclen
 >= 16)) { \

382 
	`_mm_storeu_si128
(
dst
++, 
	`_mm_xor_si128
(
	`_mm_loadu_si128
(
src
++), 
bits
##
i
)); \

383 
srclen
 -= 16; \

384 } else if (
	`PTLS_LIKELY
(
srclen
 != 0)) { \

385 
bits0
 = 
bits
##
i
; \

386 goto 
ApplyRemainder
; \

388 goto 
ApplyEnd
; \

390 } while (0)

	)

391 
	`APPLY
(0);

392 
	`APPLY
(1);

393 
	`APPLY
(2);

394 
	`APPLY
(3);

395 
	`APPLY
(4);

396 
	`APPLY
(5);

397 #undef 
APPLY


398 goto 
ApplyEnd
;

399 
ApplyRemainder
:

400 
	`storen
(
dst
, 
srclen
, 
	`_mm_xor_si128
(
	`loadn
(
src
, srclen), 
bits0
));

401 
dst
 = (
__m128i
 *)((
uint8_t
 *)dst + 
srclen
);

402 
srclen
 = 0;

403 
ApplyEnd
:;

408 
	`AESECB6_INIT
();

410 
	`AESECB6_UPDATE
(1);

413 if (
	`PTLS_UNLIKELY
(
aadlen
 != 0)) {

414 
gdata_cnt
 = 0;

415 while (
gdata_cnt
 < 6) {

416 if (
aadlen
 < 16) {

417 if (
aadlen
 != 0) {

418 
gdatabuf
[
gdata_cnt
++] = 
	`loadn
(
aad
, 
aadlen
);

419 
aadlen
 = 0;

421 goto 
GdataFillDST
;

423 
gdatabuf
[
gdata_cnt
++] = 
	`_mm_loadu_si128
(
aad
++);

424 
aadlen
 -= 16;

426 
gdata
 = 
gdatabuf
;

427 } else if (
	`PTLS_LIKELY
(
dst_ghashlen
 >= 6 * 16)) {

428 
gdata
 = 
dst_ghash
;

429 
gdata_cnt
 = 6;

430 
dst_ghash
 += 6;

431 
dst_ghashlen
 -= 96;

433 
gdata_cnt
 = 0;

434 
GdataFillDST
:

435 while (
gdata_cnt
 < 6) {

436 if (
dst_ghashlen
 < 16) {

437 if (
dst_ghashlen
 != 0) {

438 
gdatabuf
[
gdata_cnt
++] = 
	`loadn
(
dst_ghash
, 
dst_ghashlen
);

439 
dst_ghashlen
 = 0;

441 if (
gdata_cnt
 < 6)

442 goto 
Finish
;

445 
gdatabuf
[
gdata_cnt
++] = 
	`_mm_loadu_si128
(
dst_ghash
++);

446 
dst_ghashlen
 -= 16;

448 
gdata
 = 
gdatabuf
;

452 
Finish
:

453 
gdatabuf
[
gdata_cnt
++] = 
ac
;

459 
	`assert
(
	`STATE_EK0_READY
());

460 for (
size_t
 
i
 = 0; i < 
gdata_cnt
; ++i)

461 
	`gfmul_onestep
(&
gstate
, 
gdatabuf
[
i
], --
ghash_precompute
);

463 
	`_mm_storeu_si128
(
dst
, 
	`gfmul_final
(&
gstate
, 
ek0
));

466 if ((
state
 & 
STATE_SUPP_USED
) != 0) {

467 
size_t
 
i
;

468 if ((
state
 & 
STATE_SUPP_IN_PROCESS
) == 0) {

469 
bits4keys
 = ((struct 
ctr_context
 *)
supp
->
ctx
)->
fusion
.
keys
;

470 
bits4
 = 
	`_mm_xor_si128
(
	`_mm_loadu_si128
(
supp
->
input
), 
bits4keys
[0]);

471 
i
 = 1;

473 
i
 = 2;

476 
bits4
 = 
	`_mm_aesenc_si128
(bits4, 
bits4keys
[
i
++]);

477 } while (
i
 != 
ctx
->
ecb
.
rounds
);

478 
bits4
 = 
	`_mm_aesenclast_si128
(bits4, 
bits4keys
[
i
]);

479 
	`_mm_storeu_si128
((
__m128i
 *)
supp
->
output
, 
bits4
);

482 #undef 
AESECB6_INIT


483 #undef 
AESECB6_UPDATE


484 #undef 
AESECB6_FINAL


485 #undef 
STATE_EK0_BEEN_FOUND


486 #undef 
STATE_EK0_READY


487 #undef 
STATE_SUPP_IN_PROCESS


488 
	}
}

490 int 
	$ptls_fusion_aesgcm_decrypt
(
ptls_fusion_aesgcm_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
__m128i
 
ctr
,

491 const void *
_aad
, 
size_t
 
aadlen
, const void *
tag
)

493 
__m128i
 
ek0
 = 
	`_mm_setzero_si128
(), 
bits0
, 
bits1
 = _mm_setzero_si128(), 
bits2
 = _mm_setzero_si128(), 
bits3
 = _mm_setzero_si128(),

494 
bits4
 = 
	`_mm_setzero_si128
(), 
bits5
 = _mm_setzero_si128();

495 struct 
ptls_fusion_gfmul_state
 
gstate
 = {0};

496 
__m128i
 
gdatabuf
[6];

497 
__m128i
 
ac
 = 
	`_mm_shuffle_epi8
(
	`_mm_set_epi32
(0, (int)
aadlen
 * 8, 0, (int)
inlen
 * 8), 
bswap8
);

498 struct 
ptls_fusion_aesgcm_ghash_precompute
 *
ghash_precompute
 = 
ctx
->
ghash
 + (
aadlen
 + 15) / 16 + (
inlen
 + 15) / 16 + 1;

500 const 
__m128i
 *
gdata
;

501 
size_t
 
gdata_cnt
;

503 const 
__m128i
 *
src_ghash
 = 
input
, *
src_aes
 = input, *
aad
 = 
_aad
;

504 
__m128i
 *
dst
 = 
output
;

505 
size_t
 
nondata_aes_cnt
 = 0, 
src_ghashlen
 = 
inlen
, 
src_aeslen
 = inlen;

508 
ctr
 = 
	`_mm_add_epi64
(ctr, 
one8
);

509 
bits0
 = 
	`_mm_xor_si128
(
	`_mm_shuffle_epi8
(
ctr
, 
bswap8
), 
ctx
->
ecb
.
keys
[0]);

510 ++
nondata_aes_cnt
;

512 #define 
	#STATE_IS_FIRST_RUN
 0x1

	)

513 #define 
	#STATE_GHASH_HAS_MORE
 0x2

	)

514 int 
state
 = 
STATE_IS_FIRST_RUN
 | 
STATE_GHASH_HAS_MORE
;

520 if (
	`PTLS_UNLIKELY
(
aadlen
 != 0)) {

521 
gdata
 = 
gdatabuf
;

522 
gdata_cnt
 = 0;

523 while (
gdata_cnt
 < 6) {

524 if (
aadlen
 < 16) {

525 if (
aadlen
 != 0) {

526 
gdatabuf
[
gdata_cnt
++] = 
	`loadn
(
aad
, 
aadlen
);

527 
aadlen
 = 0;

528 ++
nondata_aes_cnt
;

530 goto 
GdataFillSrc
;

532 
gdatabuf
[
gdata_cnt
++] = 
	`_mm_loadu_si128
(
aad
++);

533 
aadlen
 -= 16;

534 ++
nondata_aes_cnt
;

536 } else if (
	`PTLS_LIKELY
(
src_ghashlen
 >= 6 * 16)) {

537 
gdata
 = 
src_ghash
;

538 
gdata_cnt
 = 6;

539 
src_ghash
 += 6;

540 
src_ghashlen
 -= 6 * 16;

542 
gdata
 = 
gdatabuf
;

543 
gdata_cnt
 = 0;

544 
GdataFillSrc
:

545 while (
gdata_cnt
 < 6) {

546 if (
src_ghashlen
 < 16) {

547 if (
src_ghashlen
 != 0) {

548 
gdatabuf
[
gdata_cnt
++] = 
	`loadn
(
src_ghash
, 
src_ghashlen
);

549 
src_ghash
 = (
__m128i
 *)((
uint8_t
 *)src_ghash + 
src_ghashlen
);

550 
src_ghashlen
 = 0;

552 if (
gdata_cnt
 < 6 && (
state
 & 
STATE_GHASH_HAS_MORE
) != 0) {

553 
gdatabuf
[
gdata_cnt
++] = 
ac
;

554 
state
 &= ~
STATE_GHASH_HAS_MORE
;

558 
gdatabuf
[
gdata_cnt
++] = 
	`_mm_loadu_si128
(
src_ghash
++);

559 
src_ghashlen
 -= 16;

564 if (
	`PTLS_LIKELY
(
nondata_aes_cnt
 == 0))

565 goto 
InitAllBits
;

566 switch (
nondata_aes_cnt
) {

567 #define 
	#INIT_BITS
(
n
, 
keys
) \

568 case 
n
: \

569 
ctr
 = 
	`_mm_add_epi64
(ctr, 
one8
); \

570 
bits
##
n
 = 
	`_mm_xor_si128
(
	`_mm_shuffle_epi8
(
ctr
, 
bswap8
), 
keys
[0]);

	)

571 
InitAllBits
:

572 
	`INIT_BITS
(0, 
ctx
->
ecb
.
keys
);

573 
	`INIT_BITS
(1, 
ctx
->
ecb
.
keys
);

574 
	`INIT_BITS
(2, 
ctx
->
ecb
.
keys
);

575 
	`INIT_BITS
(3, 
ctx
->
ecb
.
keys
);

576 
	`INIT_BITS
(4, 
ctx
->
ecb
.
keys
);

577 
	`INIT_BITS
(5, 
ctx
->
ecb
.
keys
);

578 #undef 
INIT_BITS


582 #define 
	#AESECB6_UPDATE
(
i
) \

584 
__m128i
 
k
 = 
ctx
->
ecb
.
keys
[
i
]; \

585 
bits0
 = 
	`_mm_aesenc_si128
(bits0, 
k
); \

586 
bits1
 = 
	`_mm_aesenc_si128
(bits1, 
k
); \

587 
bits2
 = 
	`_mm_aesenc_si128
(bits2, 
k
); \

588 
bits3
 = 
	`_mm_aesenc_si128
(bits3, 
k
); \

589 
bits4
 = 
	`_mm_aesenc_si128
(bits4, 
k
); \

590 
bits5
 = 
	`_mm_aesenc_si128
(bits5, 
k
); \

591 } while (0)

	)

593 
size_t
 
aesi
;

594 for (
aesi
 = 1; aesi <= 
gdata_cnt
; ++aesi) {

595 
	`AESECB6_UPDATE
(
aesi
);

596 
	`gfmul_onestep
(&
gstate
, 
	`_mm_loadu_si128
(
gdata
++), --
ghash_precompute
);

598 for (; 
aesi
 < 
ctx
->
ecb
.
rounds
; ++aesi)

599 
	`AESECB6_UPDATE
(
aesi
);

600 
__m128i
 
k
 = 
ctx
->
ecb
.
keys
[
aesi
];

601 
bits0
 = 
	`_mm_aesenclast_si128
(bits0, 
k
);

602 
bits1
 = 
	`_mm_aesenclast_si128
(bits1, 
k
);

603 
bits2
 = 
	`_mm_aesenclast_si128
(bits2, 
k
);

604 
bits3
 = 
	`_mm_aesenclast_si128
(bits3, 
k
);

605 
bits4
 = 
	`_mm_aesenclast_si128
(bits4, 
k
);

606 
bits5
 = 
	`_mm_aesenclast_si128
(bits5, 
k
);

608 #undef 
AESECB6_UPDATE


612 if (
	`PTLS_LIKELY
(
nondata_aes_cnt
 == 0 && 
src_aeslen
 >= 6 * 16)) {

613 #define 
	#APPLY
(
i
) 
	`_mm_storeu_si128
(
dst
 + i, 
	`_mm_xor_si128
(
	`_mm_loadu_si128
(
src_aes
 + i), 
bits
##i))

	)

614 
	`APPLY
(0);

615 
	`APPLY
(1);

616 
	`APPLY
(2);

617 
	`APPLY
(3);

618 
	`APPLY
(4);

619 
	`APPLY
(5);

620 #undef 
APPLY


621 
dst
 += 6;

622 
src_aes
 += 6;

623 
src_aeslen
 -= 6 * 16;

625 if ((
state
 & 
STATE_IS_FIRST_RUN
) != 0) {

626 
ek0
 = 
bits0
;

627 
state
 &= ~
STATE_IS_FIRST_RUN
;

629 switch (
nondata_aes_cnt
) {

630 #define 
	#APPLY
(
i
) \

631 case 
i
: \

632 if (
	`PTLS_LIKELY
(
src_aeslen
 > 16)) { \

633 
	`_mm_storeu_si128
(
dst
++, 
	`_mm_xor_si128
(
	`_mm_loadu_si128
(
src_aes
++), 
bits
##
i
)); \

634 
src_aeslen
 -= 16; \

636 
bits0
 = 
bits
##
i
; \

637 goto 
Finish
; \

638 }

	)

639 
	`APPLY
(0);

640 
	`APPLY
(1);

641 
	`APPLY
(2);

642 
	`APPLY
(3);

643 
	`APPLY
(4);

644 
	`APPLY
(5);

645 #undef 
APPLY


647 
nondata_aes_cnt
 = 0;

651 
Finish
:

652 if (
src_aeslen
 == 16) {

653 
	`_mm_storeu_si128
(
dst
, 
	`_mm_xor_si128
(
	`_mm_loadu_si128
(
src_aes
), 
bits0
));

654 } else if (
src_aeslen
 != 0) {

655 
	`storen
(
dst
, 
src_aeslen
, 
	`_mm_xor_si128
(
	`loadn
(
src_aes
, src_aeslen), 
bits0
));

658 
	`assert
((
state
 & 
STATE_IS_FIRST_RUN
) == 0);

661 if ((
state
 & 
STATE_GHASH_HAS_MORE
) != 0) {

662 
	`assert
(
ghash_precompute
 - 1 == 
ctx
->
ghash
);

663 
	`gfmul_onestep
(&
gstate
, 
ac
, --
ghash_precompute
);

666 
__m128i
 
calctag
 = 
	`gfmul_final
(&
gstate
, 
ek0
);

668 return 
	`_mm_movemask_epi8
(
	`_mm_cmpeq_epi8
(
calctag
, 
	`_mm_loadu_si128
(
tag
))) == 0xffff;

670 #undef 
STATE_IS_FIRST_RUN


671 #undef 
STATE_GHASH_HAS_MORE


672 
	}
}

674 static 
__m128i
 
	$expand_key
(
__m128i
 
key
, __m128i 
temp
)

676 
key
 = 
	`_mm_xor_si128
(key, 
	`_mm_slli_si128
(key, 4));

677 
key
 = 
	`_mm_xor_si128
(key, 
	`_mm_slli_si128
(key, 4));

678 
key
 = 
	`_mm_xor_si128
(key, 
	`_mm_slli_si128
(key, 4));

680 
key
 = 
	`_mm_xor_si128
(key, 
temp
);

682 return 
key
;

683 
	}
}

685 void 
	$ptls_fusion_aesecb_init
(
ptls_fusion_aesecb_context_t
 *
ctx
, int 
is_enc
, const void *
key
, 
size_t
 
key_size
)

687 
	`assert
(
is_enc
 && "decryption is not supported (yet)");

689 
size_t
 
i
 = 0;

691 switch (
key_size
) {

693 
ctx
->
rounds
 = 10;

696 
ctx
->
rounds
 = 14;

699 
	`assert
(!"invalid key size; AES128 / AES256 are supported");

703 
ctx
->
keys
[
i
++] = 
	`_mm_loadu_si128
((
__m128i
 *)
key
);

704 if (
key_size
 == 32)

705 
ctx
->
keys
[
i
++] = 
	`_mm_loadu_si128
((
__m128i
 *)
key
 + 1);

707 #define 
	#EXPAND
(
R
) \

709 
ctx
->
keys
[
i
] = 
	`expand_key
(ctx->keys[i - 
key_size
 / 16], \

710 
	`_mm_shuffle_epi32
(
	`_mm_aeskeygenassist_si128
(
ctx
->
keys
[
i
 - 1], 
R
), 
	`_MM_SHUFFLE
(3, 3, 3, 3))); \

711 if (
i
 == 
ctx
->
rounds
) \

712 goto 
Done
; \

713 ++
i
; \

714 if (
key_size
 > 24) { \

715 
ctx
->
keys
[
i
] = 
	`expand_key
(ctx->keys[i - 
key_size
 / 16], \

716 
	`_mm_shuffle_epi32
(
	`_mm_aeskeygenassist_si128
(
ctx
->
keys
[
i
 - 1], 
R
), 
	`_MM_SHUFFLE
(2, 2, 2, 2))); \

717 ++
i
; \

719 } while (0)

	)

720 
	`EXPAND
(0x1);

721 
	`EXPAND
(0x2);

722 
	`EXPAND
(0x4);

723 
	`EXPAND
(0x8);

724 
	`EXPAND
(0x10);

725 
	`EXPAND
(0x20);

726 
	`EXPAND
(0x40);

727 
	`EXPAND
(0x80);

728 
	`EXPAND
(0x1b);

729 
	`EXPAND
(0x36);

730 #undef 
EXPAND


731 
Done
:

732 
	`assert
(
i
 == 
ctx
->
rounds
);

733 
	}
}

735 void 
	$ptls_fusion_aesecb_dispose
(
ptls_fusion_aesecb_context_t
 *
ctx
)

737 
	`ptls_clear_memory
(
ctx
, sizeof(*ctx));

738 
	}
}

740 void 
	$ptls_fusion_aesecb_encrypt
(
ptls_fusion_aesecb_context_t
 *
ctx
, void *
dst
, const void *
src
)

742 
__m128i
 
v
 = 
	`_mm_loadu_si128
(
src
);

743 
v
 = 
	`aesecb_encrypt
(
ctx
, v);

744 
	`_mm_storeu_si128
(
dst
, 
v
);

745 
	}
}

750 static 
size_t
 
	$aesgcm_calc_ghash_cnt
(
size_t
 
capacity
)

753 return (
capacity
 + 15) / 16 + 2;

754 
	}
}

756 static void 
	$setup_one_ghash_entry
(
ptls_fusion_aesgcm_context_t
 *
ctx
)

758 if (
ctx
->
ghash_cnt
 != 0)

759 
ctx
->
ghash
[ctx->
ghash_cnt
].
H
 = 
	`gfmul
(ctx->ghash[ctx->ghash_cnt - 1].H, ctx->ghash[0].H);

761 
__m128i
 
r
 = 
	`_mm_shuffle_epi32
(
ctx
->
ghash
[ctx->
ghash_cnt
].
H
, 78);

762 
r
 = 
	`_mm_xor_si128
(r, 
ctx
->
ghash
[ctx->
ghash_cnt
].
H
);

763 
ctx
->
ghash
[ctx->
ghash_cnt
].
r
 = r;

765 ++
ctx
->
ghash_cnt
;

766 
	}
}

768 
ptls_fusion_aesgcm_context_t
 *
	$ptls_fusion_aesgcm_new
(const void *
key
, 
size_t
 
key_size
, size_t 
capacity
)

770 
ptls_fusion_aesgcm_context_t
 *
ctx
;

771 
size_t
 
ghash_cnt
 = 
	`aesgcm_calc_ghash_cnt
(
capacity
);

773 if ((
ctx
 = 
	`malloc
(sizeof(*ctx) + sizeof(ctx->
ghash
[0]) * 
ghash_cnt
)) == 
NULL
)

774 return 
NULL
;

776 
	`ptls_fusion_aesecb_init
(&
ctx
->
ecb
, 1, 
key
, 
key_size
);

778 
ctx
->
capacity
 = capacity;

780 
ctx
->
ghash
[0].
H
 = 
	`aesecb_encrypt
(&ctx->
ecb
, 
	`_mm_setzero_si128
());

781 
ctx
->
ghash
[0].
H
 = 
	`_mm_shuffle_epi8
(ctx->ghash[0].H, 
bswap8
);

782 
ctx
->
ghash
[0].
H
 = 
	`transformH
(ctx->ghash[0].H);

783 
ctx
->
ghash_cnt
 = 0;

784 while (
ctx
->
ghash_cnt
 < ghash_cnt)

785 
	`setup_one_ghash_entry
(
ctx
);

787 return 
ctx
;

788 
	}
}

790 
ptls_fusion_aesgcm_context_t
 *
	$ptls_fusion_aesgcm_set_capacity
(
ptls_fusion_aesgcm_context_t
 *
ctx
, 
size_t
 
capacity
)

792 
size_t
 
ghash_cnt
 = 
	`aesgcm_calc_ghash_cnt
(
capacity
);

794 if (
ghash_cnt
 <= 
ctx
->ghash_cnt)

795 return 
ctx
;

797 if ((
ctx
 = 
	`realloc
(ctx, sizeof(*ctx) + sizeof(ctx->
ghash
[0]) * 
ghash_cnt
)) == 
NULL
)

798 return 
NULL
;

800 
ctx
->
capacity
 = capacity;

801 while (
ghash_cnt
 < 
ctx
->ghash_cnt)

802 
	`setup_one_ghash_entry
(
ctx
);

804 return 
ctx
;

805 
	}
}

807 void 
	$ptls_fusion_aesgcm_free
(
ptls_fusion_aesgcm_context_t
 *
ctx
)

809 
	`ptls_clear_memory
(
ctx
->
ghash
, sizeof(ctx->ghash[0]) * ctx->
ghash_cnt
);

810 
ctx
->
ghash_cnt
 = 0;

811 
	`ptls_fusion_aesecb_dispose
(&
ctx
->
ecb
);

812 
	`free
(
ctx
);

813 
	}
}

815 static void 
	$ctr_dispose
(
ptls_cipher_context_t
 *
_ctx
)

817 struct 
ctr_context
 *
ctx
 = (struct ctr_context *)
_ctx
;

818 
	`ptls_fusion_aesecb_dispose
(&
ctx
->
fusion
);

819 
	`_mm_storeu_si128
(&
ctx
->
bits
, 
	`_mm_setzero_si128
());

820 
	}
}

822 static void 
	$ctr_init
(
ptls_cipher_context_t
 *
_ctx
, const void *
iv
)

824 struct 
ctr_context
 *
ctx
 = (struct ctr_context *)
_ctx
;

825 
	`_mm_storeu_si128
(&
ctx
->
bits
, 
	`aesecb_encrypt
(&ctx->
fusion
, 
	`_mm_loadu_si128
(
iv
)));

826 
ctx
->
is_ready
 = 1;

827 
	}
}

829 static void 
	$ctr_transform
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
len
)

831 struct 
ctr_context
 *
ctx
 = (struct ctr_context *)
_ctx
;

833 
	`assert
((
ctx
->
is_ready
 && 
len
 <= 16) ||

835 
ctx
->
is_ready
 = 0;

837 if (
len
 < 16) {

838 
	`storen
(
output
, 
len
, 
	`_mm_xor_si128
(
	`_mm_loadu_si128
(&
ctx
->
bits
), 
	`loadn
(
input
, len)));

840 
	`_mm_storeu_si128
(
output
, 
	`_mm_xor_si128
(
	`_mm_loadu_si128
(&
ctx
->
bits
), _mm_loadu_si128(
input
)));

842 
	}
}

844 static int 
	$aesctr_setup
(
ptls_cipher_context_t
 *
_ctx
, int 
is_enc
, const void *
key
, 
size_t
 
key_size
)

846 struct 
ctr_context
 *
ctx
 = (struct ctr_context *)
_ctx
;

848 
ctx
->
super
.
do_dispose
 = 
ctr_dispose
;

849 
ctx
->
super
.
do_init
 = 
ctr_init
;

850 
ctx
->
super
.
do_transform
 = 
ctr_transform
;

851 
	`ptls_fusion_aesecb_init
(&
ctx
->
fusion
, 1, 
key
, 
key_size
);

852 
ctx
->
is_ready
 = 0;

855 
	}
}

857 static int 
	$aes128ctr_setup
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

859 return 
	`aesctr_setup
(
ctx
, 
is_enc
, 
key
, 
PTLS_AES128_KEY_SIZE
);

860 
	}
}

862 static int 
	$aes256ctr_setup
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

864 return 
	`aesctr_setup
(
ctx
, 
is_enc
, 
key
, 
PTLS_AES256_KEY_SIZE
);

865 
	}
}

867 static void 
	$aesgcm_dispose_crypto
(
ptls_aead_context_t
 *
_ctx
)

869 struct 
aesgcm_context
 *
ctx
 = (struct aesgcm_context *)
_ctx
;

871 
	`ptls_fusion_aesgcm_free
(
ctx
->
aesgcm
);

872 
	}
}

874 static void 
	$aead_do_encrypt_init
(
ptls_aead_context_t
 *
_ctx
, 
uint64_t
 
seq
, const void *
aad
, 
size_t
 
aadlen
)

876 
	`assert
(!"FIXME");

877 
	}
}

879 static 
size_t
 
	$aead_do_encrypt_update
(
ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
)

881 
	`assert
(!"FIXME");

882 return 
SIZE_MAX
;

883 
	}
}

885 static 
size_t
 
	$aead_do_encrypt_final
(
ptls_aead_context_t
 *
_ctx
, void *
_output
)

887 
	`assert
(!"FIXME");

888 return 
SIZE_MAX
;

889 
	}
}

891 static 
inline
 
__m128i
 
	$calc_counter
(struct 
aesgcm_context
 *
ctx
, 
uint64_t
 
seq
)

893 
__m128i
 
ctr
 = 
	`_mm_setzero_si128
();

894 
ctr
 = 
	`_mm_insert_epi64
(ctr, 
seq
, 0);

895 
ctr
 = 
	`_mm_slli_si128
(ctr, 4);

896 
ctr
 = 
	`_mm_xor_si128
(
ctx
->
static_iv
, ctr);

897 return 
ctr
;

898 
	}
}

900 void 
	$aead_do_encrypt
(struct 
st_ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

901 const void *
aad
, 
size_t
 
aadlen
, 
ptls_aead_supplementary_encryption_t
 *
supp
)

903 struct 
aesgcm_context
 *
ctx
 = (void *)
_ctx
;

905 if (
inlen
 + 
aadlen
 > 
ctx
->
aesgcm
->
capacity
)

906 
ctx
->
aesgcm
 = 
	`ptls_fusion_aesgcm_set_capacity
(ctx->aesgcm, 
inlen
 + 
aadlen
);

907 
	`ptls_fusion_aesgcm_encrypt
(
ctx
->
aesgcm
, 
output
, 
input
, 
inlen
, 
	`calc_counter
(ctx, 
seq
), 
aad
, 
aadlen
, 
supp
);

908 
	}
}

910 static 
size_t
 
	$aead_do_decrypt
(
ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

911 const void *
aad
, 
size_t
 
aadlen
)

913 struct 
aesgcm_context
 *
ctx
 = (void *)
_ctx
;

915 if (
inlen
 < 16)

916 return 
SIZE_MAX
;

918 
size_t
 
enclen
 = 
inlen
 - 16;

919 if (
enclen
 + 
aadlen
 > 
ctx
->
aesgcm
->
capacity
)

920 
ctx
->
aesgcm
 = 
	`ptls_fusion_aesgcm_set_capacity
(ctx->aesgcm, 
enclen
 + 
aadlen
);

921 if (!
	`ptls_fusion_aesgcm_decrypt
(
ctx
->
aesgcm
, 
output
, 
input
, 
enclen
, 
	`calc_counter
(ctx, 
seq
), 
aad
, 
aadlen
,

922 (const 
uint8_t
 *)
input
 + 
enclen
))

923 return 
SIZE_MAX
;

924 return 
enclen
;

925 
	}
}

927 static 
inline
 void 
	$aesgcm_xor_iv
(
ptls_aead_context_t
 *
_ctx
, const void *
_bytes
, 
size_t
 
len
)

929 struct 
aesgcm_context
 *
ctx
 = (struct aesgcm_context *)
_ctx
;

930 
__m128i
 
xor_mask
 = 
	`loadn
(
_bytes
, 
len
);

931 
xor_mask
 = 
	`_mm_shuffle_epi8
(xor_mask, 
bswap8
);

932 
ctx
->
static_iv
 = 
	`_mm_xor_si128
(ctx->static_iv, 
xor_mask
);

933 
	}
}

935 static int 
	$aesgcm_setup
(
ptls_aead_context_t
 *
_ctx
, int 
is_enc
, const void *
key
, const void *
iv
, 
size_t
 
key_size
)

937 struct 
aesgcm_context
 *
ctx
 = (struct aesgcm_context *)
_ctx
;

939 
ctx
->
static_iv
 = 
	`loadn
(
iv
, 
PTLS_AESGCM_IV_SIZE
);

940 
ctx
->
static_iv
 = 
	`_mm_shuffle_epi8
(ctx->static_iv, 
bswap8
);

941 if (
key
 == 
NULL
)

944 
ctx
->
super
.
dispose_crypto
 = 
aesgcm_dispose_crypto
;

945 
ctx
->
super
.
do_xor_iv
 = 
aesgcm_xor_iv
;

946 
ctx
->
super
.
do_encrypt_init
 = 
aead_do_encrypt_init
;

947 
ctx
->
super
.
do_encrypt_update
 = 
aead_do_encrypt_update
;

948 
ctx
->
super
.
do_encrypt_final
 = 
aead_do_encrypt_final
;

949 
ctx
->
super
.
do_encrypt
 = 
aead_do_encrypt
;

950 
ctx
->
super
.
do_decrypt
 = 
aead_do_decrypt
;

952 
ctx
->
aesgcm
 = 
	`ptls_fusion_aesgcm_new
(
key
, 
key_size
, 1500 );

955 
	}
}

957 static int 
	$aes128gcm_setup
(
ptls_aead_context_t
 *
ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

959 return 
	`aesgcm_setup
(
ctx
, 
is_enc
, 
key
, 
iv
, 
PTLS_AES128_KEY_SIZE
);

960 
	}
}

962 static int 
	$aes256gcm_setup
(
ptls_aead_context_t
 *
ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

964 return 
	`aesgcm_setup
(
ctx
, 
is_enc
, 
key
, 
iv
, 
PTLS_AES256_KEY_SIZE
);

965 
	}
}

967 
ptls_cipher_algorithm_t
 
	gptls_fusion_aes128ctr
 = {"AES128-CTR",

968 
PTLS_AES128_KEY_SIZE
,

970 
PTLS_AES_IV_SIZE
,

971 sizeof(struct 
ctr_context
),

972 
aes128ctr_setup
};

973 
ptls_cipher_algorithm_t
 
	gptls_fusion_aes256ctr
 = {"AES256-CTR",

974 
PTLS_AES256_KEY_SIZE
,

976 
PTLS_AES_IV_SIZE
,

977 sizeof(struct 
ctr_context
),

978 
aes256ctr_setup
};

979 
ptls_aead_algorithm_t
 
	gptls_fusion_aes128gcm
 = {"AES128-GCM",

980 
PTLS_AESGCM_CONFIDENTIALITY_LIMIT
,

981 
PTLS_AESGCM_INTEGRITY_LIMIT
,

982 &
ptls_fusion_aes128ctr
,

983 
NULL
,

984 
PTLS_AES128_KEY_SIZE
,

985 
PTLS_AESGCM_IV_SIZE
,

986 
PTLS_AESGCM_TAG_SIZE
,

987 sizeof(struct 
aesgcm_context
),

988 
aes128gcm_setup
};

989 
ptls_aead_algorithm_t
 
	gptls_fusion_aes256gcm
 = {"AES256-GCM",

990 
PTLS_AESGCM_CONFIDENTIALITY_LIMIT
,

991 
PTLS_AESGCM_INTEGRITY_LIMIT
,

992 &
ptls_fusion_aes256ctr
,

993 
NULL
,

994 
PTLS_AES256_KEY_SIZE
,

995 
PTLS_AESGCM_IV_SIZE
,

996 
PTLS_AESGCM_TAG_SIZE
,

997 sizeof(struct 
aesgcm_context
),

998 
aes256gcm_setup
};

1000 #ifdef 
_WINDOWS


1008 int 
	$ptls_fusion_is_supported_by_cpu
(void)

1010 
uint32_t
 
cpu_info
[4];

1011 
uint32_t
 
nb_ids
;

1012 int 
is_supported
 = 0;

1014 
	`__cpuid
(
cpu_info
, 0);

1015 
nb_ids
 = 
cpu_info
[0];

1017 if (
nb_ids
 >= 7) {

1018 
uint32_t
 
leaf1_ecx
;

1019 
	`__cpuid
(
cpu_info
, 1);

1020 
leaf1_ecx
 = 
cpu_info
[2];

1022 if ( (
leaf1_ecx
 & (1 << 5)) != 0 && (leaf1_ecx & (1 << 25)) != 0) {

1023 
uint32_t
 
leaf7_ebx
;

1024 
	`__cpuid
(
cpu_info
, 7);

1025 
leaf7_ebx
 = 
cpu_info
[1];

1027 
is_supported
 = (
leaf7_ebx
 & (1 << 5)) != 0;

1031 return 
is_supported
;

1032 
	}
}

1034 int 
	$ptls_fusion_is_supported_by_cpu
(void)

1036 unsigned 
leaf1_ecx
, 
leaf7_ebx
;

1039 unsigned 
leaf_cnt
;

1040 
	`__asm__
("cpuid" : "=a"(
leaf_cnt
) : "a"(0) : "ebx", "ecx", "edx");

1041 if (
leaf_cnt
 < 7)

1043 
	`__asm__
("cpuid" : "=c"(
leaf1_ecx
) : "a"(1) : "ebx", "edx");

1044 
	`__asm__
("cpuid" : "=b"(
leaf7_ebx
) : "a"(7), "c"(0) : "edx");

1048 if ((
leaf7_ebx
 & (1 << 5)) == 0)

1051 if ((
leaf1_ecx
 & (1 << 25)) == 0)

1054 if ((
leaf1_ecx
 & (1 << 1)) == 0)

1058 
	}
}

	@deps/picotls/lib/minicrypto-pem.c

22 #include 
	~<fcntl.h
>

23 #include 
	~<stdio.h
>

24 #include 
	~<stdlib.h
>

25 #include 
	~<string.h
>

26 #ifdef 
_WINDOWS


27 #include 
	~"wincompat.h
"

29 #include 
	~<unistd.h
>

31 #include 
	~"picotls.h
"

32 #include 
	~"picotls/minicrypto.h
"

33 #include 
	~"picotls/asn1.h
"

34 #include 
	~"picotls/pembase64.h
"

40 
size_t
 
	$ptls_minicrypto_asn1_decode_private_key
(
ptls_asn1_pkcs8_private_key_t
 *
pkey
, int *
decode_error
,

41 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

43 
uint8_t
 *
bytes
 = 
pkey
->
vec
.
base
;

44 
size_t
 
bytes_max
 = 
pkey
->
vec
.
len
;

47 
size_t
 
byte_index
 = 0;

48 
uint32_t
 
seq0_length
 = 0;

49 
size_t
 
last_byte0
;

50 
uint32_t
 
seq1_length
 = 0;

51 
size_t
 
last_byte1
 = 0;

52 
uint32_t
 
oid_length
;

53 
size_t
 
last_oid_byte
;

54 
uint32_t
 
key_data_length
;

55 
size_t
 
key_data_last
;

58 
byte_index
 = 
	`ptls_asn1_get_expected_type_and_length
(
bytes
, 
bytes_max
, byte_index, 0x30, &
seq0_length
, 
NULL
, &
last_byte0
,

59 
decode_error
, 
log_ctx
);

61 if (*
decode_error
 == 0 && 
bytes_max
 != 
last_byte0
) {

62 
byte_index
 = 
	`ptls_asn1_error_message
("Length larger than message", 
bytes_max
, byte_index, 0, 
log_ctx
);

63 *
decode_error
 = 
PTLS_ERROR_BER_EXCESSIVE_LENGTH
;

66 if (*
decode_error
 == 0) {

68 if (
byte_index
 + 3 > 
bytes_max
) {

69 
byte_index
 = 
	`ptls_asn1_error_message
("Cannot find key version", 
bytes_max
, byte_index, 0, 
log_ctx
);

70 *
decode_error
 = 
PTLS_ERROR_INCORRECT_PEM_KEY_VERSION
;

71 } else if (
bytes
[
byte_index
] != 0x02 || bytes[byte_index + 1] != 0x01 || bytes[byte_index + 2] != 0x00) {

72 *
decode_error
 = 
PTLS_ERROR_INCORRECT_PEM_KEY_VERSION
;

73 
byte_index
 = 
	`ptls_asn1_error_message
("Incorrect PEM Version", 
bytes_max
, byte_index, 0, 
log_ctx
);

75 
byte_index
 += 3;

76 if (
log_ctx
 != 
NULL
) {

77 
log_ctx
->
	`fn
(log_ctx->
ctx
, " Version = 1,\n");

82 if (*
decode_error
 == 0) {

84 
byte_index
 = 
	`ptls_asn1_get_expected_type_and_length
(
bytes
, 
bytes_max
, byte_index, 0x30, &
seq1_length
, 
NULL
, &
last_byte1
,

85 
decode_error
, 
log_ctx
);

88 if (*
decode_error
 == 0) {

89 if (
log_ctx
 != 
NULL
) {

90 
log_ctx
->
	`fn
(log_ctx->
ctx
, " Algorithm Identifier:\n");

93 
byte_index
 = 
	`ptls_asn1_get_expected_type_and_length
(
bytes
, 
last_byte1
, byte_index, 0x06, &
oid_length
, 
NULL
, &
last_oid_byte
,

94 
decode_error
, 
log_ctx
);

96 if (*
decode_error
 == 0) {

97 if (
log_ctx
 != 
NULL
) {

99 
log_ctx
->
	`fn
(log_ctx->
ctx
, " Algorithm:");

100 
	`ptls_asn1_dump_content
(
bytes
 + 
byte_index
, 
oid_length
, 0, 
log_ctx
);

101 
log_ctx
->
	`fn
(log_ctx->
ctx
, ",\n");

103 
pkey
->
algorithm_index
 = 
byte_index
;

104 
pkey
->
algorithm_length
 = 
oid_length
;

105 
byte_index
 += 
oid_length
;

109 if (*
decode_error
 == 0) {

111 if (
log_ctx
 != 
NULL
) {

112 
log_ctx
->
	`fn
(log_ctx->
ctx
, " Parameters:\n");

115 if (
last_byte1
 <= 
byte_index
) {

116 
pkey
->
parameters_index
 = 0;

117 
pkey
->
parameters_length
 = 0;

119 
pkey
->
parameters_index
 = 
byte_index
;

121 
pkey
->
parameters_length
 =

122 (
uint32_t
)
	`ptls_asn1_validation_recursive
(
bytes
 + 
byte_index
, 
last_byte1
 - byte_index, 
decode_error
, 2, 
log_ctx
);

123 if (*
decode_error
 == 0) {

124 
byte_index
 += 
pkey
->
parameters_length
;

127 if (
log_ctx
 != 
NULL
) {

128 
log_ctx
->
	`fn
(log_ctx->
ctx
, "\n");

131 if (*
decode_error
 == 0 && 
byte_index
 != 
last_byte1
) {

132 
byte_index
 = 
	`ptls_asn1_error_message
("Length larger than element", 
bytes_max
, byte_index, 2, 
log_ctx
);

133 *
decode_error
 = 
PTLS_ERROR_BER_ELEMENT_TOO_SHORT
;

138 if (*
decode_error
 == 0) {

139 
byte_index
 = 
	`ptls_asn1_get_expected_type_and_length
(
bytes
, 
last_byte0
, byte_index, 0x04, &
key_data_length
, 
NULL
,

140 &
key_data_last
, 
decode_error
, 
log_ctx
);

142 if (*
decode_error
 == 0) {

143 
pkey
->
key_data_index
 = 
byte_index
;

144 
pkey
->
key_data_length
 = key_data_length;

145 
byte_index
 += 
key_data_length
;

147 if (
log_ctx
 != 
NULL
) {

148 
log_ctx
->
	`fn
(log_ctx->
ctx
, " Key data (%d bytes):\n", 
key_data_length
);

150 (void)
	`ptls_asn1_validation_recursive
(
bytes
 + 
pkey
->
key_data_index
, 
key_data_length
, 
decode_error
, 1, 
log_ctx
);

151 
log_ctx
->
	`fn
(log_ctx->
ctx
, "\n");

156 if (*
decode_error
 == 0 && 
byte_index
 != 
last_byte0
) {

157 
byte_index
 = 
	`ptls_asn1_error_message
("Length larger than element", 
bytes_max
, byte_index, 0, 
log_ctx
);

158 *
decode_error
 = 
PTLS_ERROR_BER_ELEMENT_TOO_SHORT
;

161 if (
log_ctx
 != 
NULL
) {

162 
log_ctx
->
	`fn
(log_ctx->
ctx
, "\n");

165 return 
byte_index
;

166 
	}
}

168 static int 
	$ptls_pem_parse_private_key
(char const *
pem_fname
, 
ptls_asn1_pkcs8_private_key_t
 *
pkey
,

169 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

171 
size_t
 
nb_keys
 = 0;

172 int 
ret
 = 
	`ptls_load_pem_objects
(
pem_fname
, "PRIVATE KEY", &
pkey
->
vec
, 1, &
nb_keys
);

174 if (
ret
 == 0) {

175 if (
nb_keys
 != 1) {

176 
ret
 = 
PTLS_ERROR_PEM_LABEL_NOT_FOUND
;

180 if (
ret
 == 0 && 
nb_keys
 == 1) {

181 int 
decode_error
 = 0;

183 if (
log_ctx
 != 
NULL
) {

184 
log_ctx
->
	`fn
(log_ctx->
ctx
, "\nFound PRIVATE KEY, length = %d bytes\n", (int)
pkey
->
vec
.
len
);

187 (void)
	`ptls_minicrypto_asn1_decode_private_key
(
pkey
, &
decode_error
, 
log_ctx
);

189 if (
decode_error
 != 0) {

190 
ret
 = 
decode_error
;

194 return 
ret
;

195 
	}
}

197 static const 
uint8_t
 
	gptls_asn1_algorithm_ecdsa
[] = {0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01};

199 static const 
uint8_t
 
	gptls_asn1_curve_secp256r1
[] = {0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07};

201 static int 
	$ptls_set_ecdsa_private_key
(
ptls_context_t
 *
ctx
, 
ptls_asn1_pkcs8_private_key_t
 *
pkey
, 
ptls_minicrypto_log_ctx_t
 *
log_ctx
)

203 
uint8_t
 *
bytes
 = 
pkey
->
vec
.
base
 + pkey->
parameters_index
;

204 
size_t
 
bytes_max
 = 
pkey
->
parameters_length
;

205 
size_t
 
byte_index
 = 0;

206 
uint8_t
 *
curve_id
 = 
NULL
;

207 
uint32_t
 
curve_id_length
 = 0;

208 int 
decode_error
 = 0;

209 
uint32_t
 
seq_length
;

210 
size_t
 
last_byte
 = 0;

211 
uint8_t
 *
ecdsa_key_data
 = 
NULL
;

212 
uint32_t
 
ecdsa_key_data_length
 = 0;

213 
size_t
 
ecdsa_key_data_last
 = 0;

217 
byte_index
 = 
	`ptls_asn1_get_expected_type_and_length
(
bytes
, 
bytes_max
, byte_index, 0x06, &
curve_id_length
, 
NULL
, &
last_byte
,

218 &
decode_error
, 
log_ctx
);

220 if (
decode_error
 == 0 && 
bytes_max
 != 
last_byte
) {

221 
byte_index
 = 
	`ptls_asn1_error_message
("Length larger than parameters", 
bytes_max
, byte_index, 0, 
log_ctx
);

222 
decode_error
 = 
PTLS_ERROR_BER_EXCESSIVE_LENGTH
;

225 if (
decode_error
 == 0) {

226 
curve_id
 = 
bytes
 + 
byte_index
;

228 if (
log_ctx
 != 
NULL
) {

230 
log_ctx
->
	`fn
(log_ctx->
ctx
, "Curve: ");

231 
	`ptls_asn1_dump_content
(
curve_id
, 
curve_id_length
, 0, 
log_ctx
);

232 
log_ctx
->
	`fn
(log_ctx->
ctx
, "\n");

237 
bytes
 = 
pkey
->
vec
.
base
 + pkey->
key_data_index
;

238 
bytes_max
 = 
pkey
->
key_data_length
;

239 
byte_index
 = 0;

242 if (
decode_error
 == 0) {

243 
byte_index
 = 
	`ptls_asn1_get_expected_type_and_length
(
bytes
, 
bytes_max
, byte_index, 0x30, &
seq_length
, 
NULL
, &
last_byte
,

244 &
decode_error
, 
log_ctx
);

247 if (
decode_error
 == 0 && 
bytes_max
 != 
last_byte
) {

248 
byte_index
 = 
	`ptls_asn1_error_message
("Length larger than key data", 
bytes_max
, byte_index, 0, 
log_ctx
);

249 
decode_error
 = 
PTLS_ERROR_BER_ELEMENT_TOO_SHORT
;

253 if (
decode_error
 == 0) {

255 if (
byte_index
 + 3 > 
bytes_max
) {

256 
byte_index
 = 
	`ptls_asn1_error_message
("Cannot find ECDSA Key Data Version", 
bytes_max
, byte_index, 0, 
log_ctx
);

257 
decode_error
 = 
PTLS_ERROR_INCORRECT_ASN1_ECDSA_KEY_SYNTAX
;

258 } else if (
bytes
[
byte_index
] != 0x02 || bytes[byte_index + 1] != 0x01 || bytes[byte_index + 2] != 0x01) {

259 
decode_error
 = 
PTLS_ERROR_INCORRECT_PEM_ECDSA_KEY_VERSION
;

260 
byte_index
 = 
	`ptls_asn1_error_message
("Incorrect ECDSA Key Data Version", 
bytes_max
, byte_index, 0, 
log_ctx
);

262 
byte_index
 += 3;

263 if (
log_ctx
 != 
NULL
) {

264 
log_ctx
->
	`fn
(log_ctx->
ctx
, "ECDSA Version = 1,\n");

270 if (
decode_error
 == 0) {

271 
byte_index
 = 
	`ptls_asn1_get_expected_type_and_length
(
bytes
, 
last_byte
, byte_index, 0x04, &
ecdsa_key_data_length
, 
NULL
,

272 &
ecdsa_key_data_last
, &
decode_error
, 
log_ctx
);

274 if (
decode_error
 == 0) {

275 
ecdsa_key_data
 = 
bytes
 + 
byte_index
;

280 if (
curve_id_length
 == sizeof(
ptls_asn1_curve_secp256r1
) && 
curve_id
 != 
NULL
 &&

281 
	`memcmp
(
curve_id
, 
ptls_asn1_curve_secp256r1
, sizeof(ptls_asn1_curve_secp256r1)) == 0) {

282 if (
SECP256R1_PRIVATE_KEY_SIZE
 != 
ecdsa_key_data_length
) {

283 
decode_error
 = 
PTLS_ERROR_INCORRECT_PEM_ECDSA_KEYSIZE
;

284 if (
log_ctx
 != 
NULL
) {

286 
log_ctx
->
	`fn
(log_ctx->
ctx
, "Wrong SECP256R1 key length, %d instead of %d.\n", 
ecdsa_key_data_length
,

287 
SECP256R1_PRIVATE_KEY_SIZE
);

290 
ptls_minicrypto_secp256r1sha256_sign_certificate_t
 *
minicrypto_sign_certificate
;

292 
minicrypto_sign_certificate
 = (
ptls_minicrypto_secp256r1sha256_sign_certificate_t
 *)
	`malloc
(

293 sizeof(
ptls_minicrypto_secp256r1sha256_sign_certificate_t
));

295 if (
minicrypto_sign_certificate
 == 
NULL
) {

296 
decode_error
 = 
PTLS_ERROR_NO_MEMORY
;

298 
	`memset
(
minicrypto_sign_certificate
, 0, sizeof(
ptls_minicrypto_secp256r1sha256_sign_certificate_t
));

299 
decode_error
 = 
	`ptls_minicrypto_init_secp256r1sha256_sign_certificate
(

300 
minicrypto_sign_certificate
, 
	`ptls_iovec_init
(
ecdsa_key_data
, 
ecdsa_key_data_length
));

302 if (
decode_error
 == 0) {

303 
ctx
->
sign_certificate
 = &
minicrypto_sign_certificate
->
super
;

305 if (
log_ctx
 != 
NULL
) {

307 
log_ctx
->
	`fn
(log_ctx->
ctx
, "Initialized SECP512R1 signing key with %d bytes.\n", 
ecdsa_key_data_length
);

309 } else if (
log_ctx
 != 
NULL
) {

310 
log_ctx
->
	`fn
(log_ctx->
ctx
, "SECP512R1 init with %d bytes returns %d.\n", 
ecdsa_key_data_length
, 
decode_error
);

314 
decode_error
 = 
PTLS_ERROR_INCORRECT_PEM_ECDSA_CURVE
;

315 if (
log_ctx
 != 
NULL
) {

317 
log_ctx
->
	`fn
(log_ctx->
ctx
, "Curve is not supported for signatures.\n");

321 return 
decode_error
;

322 
	}
}

324 int 
	$ptls_minicrypto_load_private_key
(
ptls_context_t
 *
ctx
, char const *
pem_fname
)

326 
ptls_asn1_pkcs8_private_key_t
 
pkey
 = {{0}};

327 int 
ret
 = 
	`ptls_pem_parse_private_key
(
pem_fname
, &
pkey
, 
NULL
);

329 if (
ret
 != 0)

330 goto 
err
;

336 if (
pkey
.
algorithm_length
 != sizeof(
ptls_asn1_algorithm_ecdsa
) ||

337 
	`memcmp
(
pkey
.
vec
.
base
 + pkey.
algorithm_index
, 
ptls_asn1_algorithm_ecdsa
, sizeof(ptls_asn1_algorithm_ecdsa)) != 0) {

338 
ret
 = -1;

339 goto 
err
;

342 
ret
 = 
	`ptls_set_ecdsa_private_key
(
ctx
, &
pkey
, 
NULL
);

344 
err
:

345 if (
pkey
.
vec
.
base
) {

346 
	`ptls_clear_memory
(
pkey
.
vec
.
base
, pkey.vec.
len
);

347 
	`free
(
pkey
.
vec
.
base
);

349 return 
ret
;

350 
	}
}

	@deps/picotls/lib/openssl.c

23 #ifdef 
_WINDOWS


24 #include 
	~"wincompat.h
"

26 #include 
	~<unistd.h
>

28 #include 
	~<assert.h
>

29 #include 
	~<stdio.h
>

30 #include 
	~<stdlib.h
>

31 #include 
	~<string.h
>

32 #include 
	~<openssl/bn.h
>

33 #include 
	~<openssl/crypto.h
>

34 #include 
	~<openssl/ec.h
>

35 #include 
	~<openssl/ecdh.h
>

36 #include 
	~<openssl/err.h
>

37 #include 
	~<openssl/evp.h
>

38 #include 
	~<openssl/objects.h
>

39 #include 
	~<openssl/rand.h
>

40 #include 
	~<openssl/rsa.h
>

41 #include 
	~<openssl/x509.h
>

42 #include 
	~<openssl/x509v3.h
>

43 #include 
	~<openssl/x509_vfy.h
>

44 #include 
	~"picotls.h
"

45 #include 
	~"picotls/openssl.h
"

47 #ifdef 
_WINDOWS


48 #ifndef 
_CRT_SECURE_NO_WARNINGS


49 #define 
	#_CRT_SECURE_NO_WARNINGS


	)

51 #pragma 
warning
(
disable
 : 4996)

54 #if !
defined
(
LIBRESSL_VERSION_NUMBER
) && 
OPENSSL_VERSION_NUMBER
 >= 0x10100000L

55 #define 
	#OPENSSL_1_1_API
 1

	)

56 #elif 
defined
(
LIBRESSL_VERSION_NUMBER
) && LIBRESSL_VERSION_NUMBER >= 0x2070000fL

57 #define 
	#OPENSSL_1_1_API
 1

	)

59 #define 
	#OPENSSL_1_1_API
 0

	)

62 #if !
OPENSSL_1_1_API


64 #define 
	#EVP_PKEY_up_ref
(
p
) 
	`CRYPTO_add
(&(p)->
references
, 1, 
CRYPTO_LOCK_EVP_PKEY
)

	)

65 #define 
	#X509_STORE_up_ref
(
p
) 
	`CRYPTO_add
(&(p)->
references
, 1, 
CRYPTO_LOCK_X509_STORE
)

	)

66 #define 
	#X509_STORE_get0_param
(
p
) ((p)->
param
)

	)

68 static 
HMAC_CTX
 *
	$HMAC_CTX_new
(void)

70 
HMAC_CTX
 *
ctx
;

72 if ((
ctx
 = 
	`OPENSSL_malloc
(sizeof(*ctx))) == 
NULL
)

73 return 
NULL
;

74 
	`HMAC_CTX_init
(
ctx
);

75 return 
ctx
;

76 
	}
}

78 static void 
	$HMAC_CTX_free
(
HMAC_CTX
 *
ctx
)

80 
	`HMAC_CTX_cleanup
(
ctx
);

81 
	`OPENSSL_free
(
ctx
);

82 
	}
}

84 static int 
	$EVP_CIPHER_CTX_reset
(
EVP_CIPHER_CTX
 *
ctx
)

86 return 
	`EVP_CIPHER_CTX_cleanup
(
ctx
);

87 
	}
}

91 static const struct 
st_ptls_openssl_signature_scheme_t
 
	grsa_signature_schemes
[] = {{
PTLS_SIGNATURE_RSA_PSS_RSAE_SHA256
, 
EVP_sha256
},

92 {
PTLS_SIGNATURE_RSA_PSS_RSAE_SHA384
, 
EVP_sha384
},

93 {
PTLS_SIGNATURE_RSA_PSS_RSAE_SHA512
, 
EVP_sha512
},

94 {
UINT16_MAX
, 
NULL
}};

95 static const struct 
st_ptls_openssl_signature_scheme_t
 
	gsecp256r1_signature_schemes
[] = {

96 {
PTLS_SIGNATURE_ECDSA_SECP256R1_SHA256
, 
EVP_sha256
}, {
UINT16_MAX
, 
NULL
}};

97 #if 
PTLS_OPENSSL_HAVE_SECP384R1


98 static const struct 
st_ptls_openssl_signature_scheme_t
 
	gsecp384r1_signature_schemes
[] = {

99 {
PTLS_SIGNATURE_ECDSA_SECP384R1_SHA384
, 
EVP_sha384
}, {
UINT16_MAX
, 
NULL
}};

101 #if 
PTLS_OPENSSL_HAVE_SECP521R1


102 static const struct 
st_ptls_openssl_signature_scheme_t
 
	gsecp521r1_signature_schemes
[] = {

103 {
PTLS_SIGNATURE_ECDSA_SECP521R1_SHA512
, 
EVP_sha512
}, {
UINT16_MAX
, 
NULL
}};

105 #if 
PTLS_OPENSSL_HAVE_ED25519


106 static const struct 
st_ptls_openssl_signature_scheme_t
 
	ged25519_signature_schemes
[] = {{
PTLS_SIGNATURE_ED25519
, 
NULL
},

107 {
UINT16_MAX
, 
NULL
}};

113 static const 
uint16_t
 
	gdefault_signature_schemes
[] = {

114 #if 
PTLS_OPENSSL_HAVE_ED25519


115 
PTLS_SIGNATURE_ED25519
,

117 
PTLS_SIGNATURE_ECDSA_SECP256R1_SHA256
,

118 #if 
PTLS_OPENSSL_HAVE_SECP384R1


119 
PTLS_SIGNATURE_ECDSA_SECP384R1_SHA384
,

121 #if 
PTLS_OPENSSL_HAVE_SECP521R1


122 
PTLS_SIGNATURE_ECDSA_SECP521R1_SHA512
,

124 
PTLS_SIGNATURE_RSA_PSS_RSAE_SHA512
,

125 
PTLS_SIGNATURE_RSA_PSS_RSAE_SHA384
,

126 
PTLS_SIGNATURE_RSA_PSS_RSAE_SHA256
,

127 
UINT16_MAX
};

129 static const struct 
st_ptls_openssl_signature_scheme_t
 *
	$lookup_signature_schemes
(
EVP_PKEY
 *
key
)

131 const struct 
st_ptls_openssl_signature_scheme_t
 *
schemes
 = 
NULL
;

133 switch (
	`EVP_PKEY_id
(
key
)) {

134 case 
EVP_PKEY_RSA
:

135 
schemes
 = 
rsa_signature_schemes
;

137 case 
EVP_PKEY_EC
: {

138 
EC_KEY
 *
eckey
 = 
	`EVP_PKEY_get1_EC_KEY
(
key
);

139 switch (
	`EC_GROUP_get_curve_name
(
	`EC_KEY_get0_group
(
eckey
))) {

140 case 
NID_X9_62_prime256v1
:

141 
schemes
 = 
secp256r1_signature_schemes
;

143 #if 
PTLS_OPENSSL_HAVE_SECP384R1


144 case 
NID_secp384r1
:

145 
schemes
 = 
secp384r1_signature_schemes
;

148 #if 
PTLS_OPENSSL_HAVE_SECP521R1


149 case 
NID_secp521r1
:

150 
schemes
 = 
secp521r1_signature_schemes
;

156 
	`EC_KEY_free
(
eckey
);

158 #if 
PTLS_OPENSSL_HAVE_ED25519


159 case 
EVP_PKEY_ED25519
:

160 
schemes
 = 
ed25519_signature_schemes
;

167 return 
schemes
;

168 
	}
}

170 void 
	$ptls_openssl_random_bytes
(void *
buf
, 
size_t
 
len
)

172 int 
ret
 = 
	`RAND_bytes
(
buf
, (int)
len
);

173 if (
ret
 != 1) {

174 
	`fprintf
(
stderr
, "RAND_bytes() failed with code: %d\n", 
ret
);

175 
	`abort
();

177 
	}
}

179 static 
EC_KEY
 *
	$ecdh_gerenate_key
(
EC_GROUP
 *
group
)

181 
EC_KEY
 *
key
;

183 if ((
key
 = 
	`EC_KEY_new
()) == 
NULL
)

184 return 
NULL
;

185 if (!
	`EC_KEY_set_group
(
key
, 
group
) || !
	`EC_KEY_generate_key
(key)) {

186 
	`EC_KEY_free
(
key
);

187 return 
NULL
;

190 return 
key
;

191 
	}
}

193 static int 
	$ecdh_calc_secret
(
ptls_iovec_t
 *
out
, const 
EC_GROUP
 *
group
, 
EC_KEY
 *
privkey
, 
EC_POINT
 *
peer_point
)

195 
ptls_iovec_t
 
secret
;

196 int 
ret
;

198 
secret
.
len
 = (
	`EC_GROUP_get_degree
(
group
) + 7) / 8;

199 if ((
secret
.
base
 = 
	`malloc
(secret.
len
)) == 
NULL
) {

200 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

201 goto 
Exit
;

203 if (
	`ECDH_compute_key
(
secret
.
base
, secret.
len
, 
peer_point
, 
privkey
, 
NULL
) <= 0) {

204 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

205 goto 
Exit
;

207 
ret
 = 0;

209 
Exit
:

210 if (
ret
 == 0) {

211 *
out
 = 
secret
;

213 
	`free
(
secret
.
base
);

214 *
out
 = (
ptls_iovec_t
){
NULL
};

216 return 
ret
;

217 
	}
}

219 static 
EC_POINT
 *
	$x9_62_decode_point
(const 
EC_GROUP
 *
group
, 
ptls_iovec_t
 
vec
, 
BN_CTX
 *
bn_ctx
)

221 
EC_POINT
 *
point
 = 
NULL
;

223 if ((
point
 = 
	`EC_POINT_new
(
group
)) == 
NULL
)

224 return 
NULL
;

225 if (!
	`EC_POINT_oct2point
(
group
, 
point
, 
vec
.
base
, vec.
len
, 
bn_ctx
)) {

226 
	`EC_POINT_free
(
point
);

227 return 
NULL
;

230 return 
point
;

231 
	}
}

233 static 
ptls_iovec_t
 
	$x9_62_encode_point
(const 
EC_GROUP
 *
group
, const 
EC_POINT
 *
point
, 
BN_CTX
 *
bn_ctx
)

235 
ptls_iovec_t
 
vec
;

237 if ((
vec
.
len
 = 
	`EC_POINT_point2oct
(
group
, 
point
, 
POINT_CONVERSION_UNCOMPRESSED
, 
NULL
, 0, 
bn_ctx
)) == 0)

238 return (
ptls_iovec_t
){
NULL
};

239 if ((
vec
.
base
 = 
	`malloc
(vec.
len
)) == 
NULL
)

240 return (
ptls_iovec_t
){
NULL
};

241 if (
	`EC_POINT_point2oct
(
group
, 
point
, 
POINT_CONVERSION_UNCOMPRESSED
, 
vec
.
base
, vec.
len
, 
bn_ctx
) != vec.len) {

242 
	`free
(
vec
.
base
);

243 return (
ptls_iovec_t
){
NULL
};

246 return 
vec
;

247 
	}
}

249 struct 
	sst_x9_62_keyex_context_t
 {

250 
ptls_key_exchange_context_t
 
	msuper
;

251 
BN_CTX
 *
	mbn_ctx
;

252 
EC_KEY
 *
	mprivkey
;

255 static void 
	$x9_62_free_context
(struct 
st_x9_62_keyex_context_t
 *
ctx
)

257 
	`free
(
ctx
->
super
.
pubkey
.
base
);

258 if (
ctx
->
privkey
 != 
NULL
)

259 
	`EC_KEY_free
(
ctx
->
privkey
);

260 if (
ctx
->
bn_ctx
 != 
NULL
)

261 
	`BN_CTX_free
(
ctx
->
bn_ctx
);

262 
	`free
(
ctx
);

263 
	}
}

265 static int 
	$x9_62_on_exchange
(
ptls_key_exchange_context_t
 **
_ctx
, int 
release
, 
ptls_iovec_t
 *
secret
, ptls_iovec_t 
peerkey
)

267 struct 
st_x9_62_keyex_context_t
 *
ctx
 = (struct st_x9_62_keyex_context_t *)*
_ctx
;

268 const 
EC_GROUP
 *
group
 = 
	`EC_KEY_get0_group
(
ctx
->
privkey
);

269 
EC_POINT
 *
peer_point
 = 
NULL
;

270 int 
ret
;

272 if (
secret
 == 
NULL
) {

273 
ret
 = 0;

274 goto 
Exit
;

277 if ((
peer_point
 = 
	`x9_62_decode_point
(
group
, 
peerkey
, 
ctx
->
bn_ctx
)) == 
NULL
) {

278 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

279 goto 
Exit
;

281 if ((
ret
 = 
	`ecdh_calc_secret
(
secret
, 
group
, 
ctx
->
privkey
, 
peer_point
)) != 0)

282 goto 
Exit
;

284 
Exit
:

285 if (
peer_point
 != 
NULL
)

286 
	`EC_POINT_free
(
peer_point
);

287 if (
release
) {

288 
	`x9_62_free_context
(
ctx
);

289 *
_ctx
 = 
NULL
;

291 return 
ret
;

292 
	}
}

294 static int 
	$x9_62_create_context
(
ptls_key_exchange_algorithm_t
 *
algo
, struct 
st_x9_62_keyex_context_t
 **
ctx
)

296 int 
ret
;

298 if ((*
ctx
 = (struct 
st_x9_62_keyex_context_t
 *)
	`malloc
(sizeof(**ctx))) == 
NULL
) {

299 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

300 goto 
Exit
;

302 **
ctx
 = (struct 
st_x9_62_keyex_context_t
){{
algo
, {
NULL
}, 
x9_62_on_exchange
}};

304 if (((*
ctx
)->
bn_ctx
 = 
	`BN_CTX_new
()) == 
NULL
) {

305 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

306 goto 
Exit
;

309 
ret
 = 0;

310 
Exit
:

311 if (
ret
 != 0 && *
ctx
 != 
NULL
) {

312 
	`x9_62_free_context
(*
ctx
);

313 *
ctx
 = 
NULL
;

315 return 
ret
;

316 
	}
}

318 static int 
	$x9_62_setup_pubkey
(struct 
st_x9_62_keyex_context_t
 *
ctx
)

320 const 
EC_GROUP
 *
group
 = 
	`EC_KEY_get0_group
(
ctx
->
privkey
);

321 const 
EC_POINT
 *
pubkey
 = 
	`EC_KEY_get0_public_key
(
ctx
->
privkey
);

322 if ((
ctx
->
super
.
pubkey
 = 
	`x9_62_encode_point
(
group
, pubkey, ctx->
bn_ctx
)).
base
 == 
NULL
)

323 return 
PTLS_ERROR_NO_MEMORY
;

325 
	}
}

327 static int 
	$x9_62_create_key_exchange
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_key_exchange_context_t
 **
_ctx
)

329 
EC_GROUP
 *
group
 = 
NULL
;

330 struct 
st_x9_62_keyex_context_t
 *
ctx
 = 
NULL
;

331 int 
ret
;

334 if ((
group
 = 
	`EC_GROUP_new_by_curve_name
((int)
algo
->
data
)) == 
NULL
) {

335 
ret
 = 
PTLS_ERROR_LIBRARY
;

336 goto 
Exit
;

338 if ((
ret
 = 
	`x9_62_create_context
(
algo
, &
ctx
)) != 0)

339 goto 
Exit
;

340 if ((
ctx
->
privkey
 = 
	`ecdh_gerenate_key
(
group
)) == 
NULL
) {

341 
ret
 = 
PTLS_ERROR_LIBRARY
;

342 goto 
Exit
;

344 if ((
ret
 = 
	`x9_62_setup_pubkey
(
ctx
)) != 0)

345 goto 
Exit
;

346 
ret
 = 0;

348 
Exit
:

349 if (
group
 != 
NULL
)

350 
	`EC_GROUP_free
(
group
);

351 if (
ret
 == 0) {

352 *
_ctx
 = &
ctx
->
super
;

354 if (
ctx
 != 
NULL
)

355 
	`x9_62_free_context
(
ctx
);

356 *
_ctx
 = 
NULL
;

359 return 
ret
;

360 
	}
}

362 static int 
	$x9_62_init_key
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_key_exchange_context_t
 **
_ctx
, 
EC_KEY
 *
eckey
)

364 struct 
st_x9_62_keyex_context_t
 *
ctx
 = 
NULL
;

365 int 
ret
;

367 if ((
ret
 = 
	`x9_62_create_context
(
algo
, &
ctx
)) != 0)

368 goto 
Exit
;

369 
ctx
->
privkey
 = 
eckey
;

370 if ((
ret
 = 
	`x9_62_setup_pubkey
(
ctx
)) != 0)

371 goto 
Exit
;

372 
ret
 = 0;

374 
Exit
:

375 if (
ret
 == 0) {

376 *
_ctx
 = &
ctx
->
super
;

378 if (
ctx
 != 
NULL
)

379 
	`x9_62_free_context
(
ctx
);

380 *
_ctx
 = 
NULL
;

382 return 
ret
;

383 
	}
}

385 static int 
	$x9_62_key_exchange
(
EC_GROUP
 *
group
, 
ptls_iovec_t
 *
pubkey
, ptls_iovec_t *
secret
, ptls_iovec_t 
peerkey
, 
BN_CTX
 *
bn_ctx
)

387 
EC_POINT
 *
peer_point
 = 
NULL
;

388 
EC_KEY
 *
privkey
 = 
NULL
;

389 int 
ret
;

391 *
pubkey
 = (
ptls_iovec_t
){
NULL
};

392 *
secret
 = (
ptls_iovec_t
){
NULL
};

395 if ((
peer_point
 = 
	`x9_62_decode_point
(
group
, 
peerkey
, 
bn_ctx
)) == 
NULL
) {

396 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

397 goto 
Exit
;

401 if ((
privkey
 = 
	`ecdh_gerenate_key
(
group
)) == 
NULL
) {

402 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

403 goto 
Exit
;

407 if ((*
pubkey
 = 
	`x9_62_encode_point
(
group
, 
	`EC_KEY_get0_public_key
(
privkey
), 
bn_ctx
)).
base
 == 
NULL
) {

408 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

409 goto 
Exit
;

413 
secret
->
len
 = (
	`EC_GROUP_get_degree
(
group
) + 7) / 8;

414 if ((
secret
->
base
 = 
	`malloc
(secret->
len
)) == 
NULL
) {

415 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

416 goto 
Exit
;

420 if (
	`ECDH_compute_key
(
secret
->
base
, secret->
len
, 
peer_point
, 
privkey
, 
NULL
) <= 0) {

421 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

422 goto 
Exit
;

425 
ret
 = 0;

427 
Exit
:

428 if (
peer_point
 != 
NULL
)

429 
	`EC_POINT_free
(
peer_point
);

430 if (
privkey
 != 
NULL
)

431 
	`EC_KEY_free
(
privkey
);

432 if (
ret
 != 0) {

433 
	`free
(
pubkey
->
base
);

434 *
pubkey
 = (
ptls_iovec_t
){
NULL
};

435 
	`free
(
secret
->
base
);

436 *
secret
 = (
ptls_iovec_t
){
NULL
};

438 return 
ret
;

439 
	}
}

441 static int 
	$secp_key_exchange
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_iovec_t
 *
pubkey
, ptls_iovec_t *
secret
, ptls_iovec_t 
peerkey
)

443 
EC_GROUP
 *
group
 = 
NULL
;

444 
BN_CTX
 *
bn_ctx
 = 
NULL
;

445 int 
ret
;

447 if ((
group
 = 
	`EC_GROUP_new_by_curve_name
((int)
algo
->
data
)) == 
NULL
) {

448 
ret
 = 
PTLS_ERROR_LIBRARY
;

449 goto 
Exit
;

451 if ((
bn_ctx
 = 
	`BN_CTX_new
()) == 
NULL
) {

452 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

453 goto 
Exit
;

456 
ret
 = 
	`x9_62_key_exchange
(
group
, 
pubkey
, 
secret
, 
peerkey
, 
bn_ctx
);

458 
Exit
:

459 if (
bn_ctx
 != 
NULL
)

460 
	`BN_CTX_free
(
bn_ctx
);

461 if (
group
 != 
NULL
)

462 
	`EC_GROUP_free
(
group
);

463 return 
ret
;

464 
	}
}

466 #if 
PTLS_OPENSSL_HAVE_X25519


468 struct 
	sst_evp_keyex_context_t
 {

469 
ptls_key_exchange_context_t
 
	msuper
;

470 
EVP_PKEY
 *
	mprivkey
;

473 static void 
	$evp_keyex_free
(struct 
st_evp_keyex_context_t
 *
ctx
)

475 if (
ctx
->
privkey
 != 
NULL
)

476 
	`EVP_PKEY_free
(
ctx
->
privkey
);

477 if (
ctx
->
super
.
pubkey
.
base
 != 
NULL
)

478 
	`OPENSSL_free
(
ctx
->
super
.
pubkey
.
base
);

479 
	`free
(
ctx
);

480 
	}
}

482 static int 
	$evp_keyex_on_exchange
(
ptls_key_exchange_context_t
 **
_ctx
, int 
release
, 
ptls_iovec_t
 *
secret
, ptls_iovec_t 
peerkey
)

484 struct 
st_evp_keyex_context_t
 *
ctx
 = (void *)*
_ctx
;

485 
EVP_PKEY
 *
evppeer
 = 
NULL
;

486 
EVP_PKEY_CTX
 *
evpctx
 = 
NULL
;

487 int 
ret
;

489 if (
secret
 == 
NULL
) {

490 
ret
 = 0;

491 goto 
Exit
;

494 
secret
->
base
 = 
NULL
;

496 if (
peerkey
.
len
 != 
ctx
->
super
.
pubkey
.len) {

497 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

498 goto 
Exit
;

501 if ((
evppeer
 = 
	`EVP_PKEY_new
()) == 
NULL
) {

502 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

503 goto 
Exit
;

505 if (
	`EVP_PKEY_copy_parameters
(
evppeer
, 
ctx
->
privkey
) <= 0) {

506 
ret
 = 
PTLS_ERROR_LIBRARY
;

507 goto 
Exit
;

509 if (
	`EVP_PKEY_set1_tls_encodedpoint
(
evppeer
, 
peerkey
.
base
, peerkey.
len
) <= 0) {

510 
ret
 = 
PTLS_ERROR_LIBRARY
;

511 goto 
Exit
;

513 if ((
evpctx
 = 
	`EVP_PKEY_CTX_new
(
ctx
->
privkey
, 
NULL
)) == NULL) {

514 
ret
 = 
PTLS_ERROR_LIBRARY
;

515 goto 
Exit
;

517 if (
	`EVP_PKEY_derive_init
(
evpctx
) <= 0) {

518 
ret
 = 
PTLS_ERROR_LIBRARY
;

519 goto 
Exit
;

521 if (
	`EVP_PKEY_derive_set_peer
(
evpctx
, 
evppeer
) <= 0) {

522 
ret
 = 
PTLS_ERROR_LIBRARY
;

523 goto 
Exit
;

525 if (
	`EVP_PKEY_derive
(
evpctx
, 
NULL
, &
secret
->
len
) <= 0) {

526 
ret
 = 
PTLS_ERROR_LIBRARY
;

527 goto 
Exit
;

529 if ((
secret
->
base
 = 
	`malloc
(secret->
len
)) == 
NULL
) {

530 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

531 goto 
Exit
;

533 if (
	`EVP_PKEY_derive
(
evpctx
, 
secret
->
base
, &secret->
len
) <= 0) {

534 
ret
 = 
PTLS_ERROR_LIBRARY
;

535 goto 
Exit
;

538 
ret
 = 0;

539 
Exit
:

540 if (
evpctx
 != 
NULL
)

541 
	`EVP_PKEY_CTX_free
(
evpctx
);

542 if (
evppeer
 != 
NULL
)

543 
	`EVP_PKEY_free
(
evppeer
);

544 if (
ret
 != 0)

545 
	`free
(
secret
->
base
);

546 if (
release
) {

547 
	`evp_keyex_free
(
ctx
);

548 *
_ctx
 = 
NULL
;

550 return 
ret
;

551 
	}
}

553 static int 
	$evp_keyex_init
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_key_exchange_context_t
 **
_ctx
, 
EVP_PKEY
 *
pkey
)

555 struct 
st_evp_keyex_context_t
 *
ctx
 = 
NULL
;

556 int 
ret
;

559 if ((
ctx
 = 
	`malloc
(sizeof(*ctx))) == 
NULL
) {

560 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

561 goto 
Exit
;

563 *
ctx
 = (struct 
st_evp_keyex_context_t
){{
algo
, {
NULL
}, 
evp_keyex_on_exchange
}, 
pkey
};

566 if ((
ctx
->
super
.
pubkey
.
len
 = 
	`EVP_PKEY_get1_tls_encodedpoint
(ctx->
privkey
, &ctx->super.pubkey.
base
)) == 0) {

567 
ctx
->
super
.
pubkey
.
base
 = 
NULL
;

568 return 
PTLS_ERROR_NO_MEMORY
;

571 *
_ctx
 = &
ctx
->
super
;

572 
ret
 = 0;

573 
Exit
:

574 if (
ret
 != 0 && 
ctx
 != 
NULL
)

575 
	`evp_keyex_free
(
ctx
);

576 return 
ret
;

577 
	}
}

579 static int 
	$evp_keyex_create
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_key_exchange_context_t
 **
ctx
)

581 
EVP_PKEY_CTX
 *
evpctx
 = 
NULL
;

582 
EVP_PKEY
 *
pkey
 = 
NULL
;

583 int 
ret
;

586 if ((
evpctx
 = 
	`EVP_PKEY_CTX_new_id
((int)
algo
->
data
, 
NULL
)) == NULL) {

587 
ret
 = 
PTLS_ERROR_LIBRARY
;

588 goto 
Exit
;

590 if (
	`EVP_PKEY_keygen_init
(
evpctx
) <= 0) {

591 
ret
 = 
PTLS_ERROR_LIBRARY
;

592 goto 
Exit
;

594 if (
	`EVP_PKEY_keygen
(
evpctx
, &
pkey
) <= 0) {

595 
ret
 = 
PTLS_ERROR_LIBRARY
;

596 goto 
Exit
;

600 if ((
ret
 = 
	`evp_keyex_init
(
algo
, 
ctx
, 
pkey
)) != 0)

601 goto 
Exit
;

602 
pkey
 = 
NULL
;

603 
ret
 = 0;

605 
Exit
:

606 if (
pkey
 != 
NULL
)

607 
	`EVP_PKEY_free
(
pkey
);

608 if (
evpctx
 != 
NULL
)

609 
	`EVP_PKEY_CTX_free
(
evpctx
);

610 return 
ret
;

611 
	}
}

613 static int 
	$evp_keyex_exchange
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_iovec_t
 *
outpubkey
, ptls_iovec_t *
secret
,

614 
ptls_iovec_t
 
peerkey
)

616 
ptls_key_exchange_context_t
 *
ctx
 = 
NULL
;

617 int 
ret
;

619 
outpubkey
->
base
 = 
NULL
;

621 if ((
ret
 = 
	`evp_keyex_create
(
algo
, &
ctx
)) != 0)

622 goto 
Exit
;

623 if ((
outpubkey
->
base
 = 
	`malloc
(
ctx
->
pubkey
.
len
)) == 
NULL
) {

624 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

625 goto 
Exit
;

627 
	`memcpy
(
outpubkey
->
base
, 
ctx
->
pubkey
.base, ctx->pubkey.
len
);

628 
outpubkey
->
len
 = 
ctx
->
pubkey
.len;

629 
ret
 = 
	`evp_keyex_on_exchange
(&
ctx
, 1, 
secret
, 
peerkey
);

630 
	`assert
(
ctx
 == 
NULL
);

632 
Exit
:

633 if (
ctx
 != 
NULL
)

634 
	`evp_keyex_on_exchange
(&
ctx
, 1, 
NULL
, 
	`ptls_iovec_init
(NULL, 0));

635 if (
ret
 != 0)

636 
	`free
(
outpubkey
->
base
);

637 return 
ret
;

638 
	}
}

642 int 
	$ptls_openssl_create_key_exchange
(
ptls_key_exchange_context_t
 **
ctx
, 
EVP_PKEY
 *
pkey
)

644 int 
ret
, 
id
;

646 switch (
id
 = 
	`EVP_PKEY_id
(
pkey
)) {

648 case 
EVP_PKEY_EC
: {

650 
EC_KEY
 *
eckey
 = 
	`EVP_PKEY_get1_EC_KEY
(
pkey
);

653 
ptls_key_exchange_algorithm_t
 *
algo
;

654 switch (
	`EC_GROUP_get_curve_name
(
	`EC_KEY_get0_group
(
eckey
))) {

655 case 
NID_X9_62_prime256v1
:

656 
algo
 = &
ptls_openssl_secp256r1
;

658 #if 
PTLS_OPENSSL_HAVE_SECP384R1


659 case 
NID_secp384r1
:

660 
algo
 = &
ptls_openssl_secp384r1
;

663 #if 
PTLS_OPENSSL_HAVE_SECP521R1


664 case 
NID_secp521r1
:

665 
algo
 = &
ptls_openssl_secp521r1
;

669 
	`EC_KEY_free
(
eckey
);

670 return 
PTLS_ERROR_INCOMPATIBLE_KEY
;

674 if ((
ret
 = 
	`x9_62_init_key
(
algo
, 
ctx
, 
eckey
)) != 0) {

675 
	`EC_KEY_free
(
eckey
);

676 return 
ret
;

682 #if 
PTLS_OPENSSL_HAVE_X25519


683 case 
NID_X25519
:

684 if ((
ret
 = 
	`evp_keyex_init
(&
ptls_openssl_x25519
, 
ctx
, 
pkey
)) != 0)

685 return 
ret
;

686 
	`EVP_PKEY_up_ref
(
pkey
);

691 return 
PTLS_ERROR_INCOMPATIBLE_KEY
;

693 
	}
}

695 static int 
	$do_sign
(
EVP_PKEY
 *
key
, const struct 
st_ptls_openssl_signature_scheme_t
 *
scheme
, 
ptls_buffer_t
 *
outbuf
,

696 
ptls_iovec_t
 
input
)

698 
EVP_MD_CTX
 *
ctx
 = 
NULL
;

699 const 
EVP_MD
 *
md
 = 
scheme
->
scheme_md
 != 
NULL
 ? scheme->
	`scheme_md
() : NULL;

700 
EVP_PKEY_CTX
 *
pkey_ctx
;

701 
size_t
 
siglen
;

702 int 
ret
;

704 if ((
ctx
 = 
	`EVP_MD_CTX_create
()) == 
NULL
) {

705 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

706 goto 
Exit
;

709 if (
	`EVP_DigestSignInit
(
ctx
, &
pkey_ctx
, 
md
, 
NULL
, 
key
) != 1) {

710 
ret
 = 
PTLS_ERROR_LIBRARY
;

711 goto 
Exit
;

714 #if 
PTLS_OPENSSL_HAVE_ED25519


715 if (
	`EVP_PKEY_id
(
key
) == 
EVP_PKEY_ED25519
) {

717 if (
	`EVP_DigestSign
(
ctx
, 
NULL
, &
siglen
, 
input
.
base
, input.
len
) != 1) {

718 
ret
 = 
PTLS_ERROR_LIBRARY
;

719 goto 
Exit
;

721 if ((
ret
 = 
	`ptls_buffer_reserve
(
outbuf
, 
siglen
)) != 0)

722 goto 
Exit
;

723 if (
	`EVP_DigestSign
(
ctx
, 
outbuf
->
base
 + outbuf->
off
, &
siglen
, 
input
.base, input.
len
) != 1) {

724 
ret
 = 
PTLS_ERROR_LIBRARY
;

725 goto 
Exit
;

730 if (
	`EVP_PKEY_id
(
key
) == 
EVP_PKEY_RSA
) {

731 if (
	`EVP_PKEY_CTX_set_rsa_padding
(
pkey_ctx
, 
RSA_PKCS1_PSS_PADDING
) != 1) {

732 
ret
 = 
PTLS_ERROR_LIBRARY
;

733 goto 
Exit
;

735 if (
	`EVP_PKEY_CTX_set_rsa_pss_saltlen
(
pkey_ctx
, -1) != 1) {

736 
ret
 = 
PTLS_ERROR_LIBRARY
;

737 goto 
Exit
;

739 if (
	`EVP_PKEY_CTX_set_rsa_mgf1_md
(
pkey_ctx
, 
md
) != 1) {

740 
ret
 = 
PTLS_ERROR_LIBRARY
;

741 goto 
Exit
;

744 if (
	`EVP_DigestSignUpdate
(
ctx
, 
input
.
base
, input.
len
) != 1) {

745 
ret
 = 
PTLS_ERROR_LIBRARY
;

746 goto 
Exit
;

748 if (
	`EVP_DigestSignFinal
(
ctx
, 
NULL
, &
siglen
) != 1) {

749 
ret
 = 
PTLS_ERROR_LIBRARY
;

750 goto 
Exit
;

752 if ((
ret
 = 
	`ptls_buffer_reserve
(
outbuf
, 
siglen
)) != 0)

753 goto 
Exit
;

754 if (
	`EVP_DigestSignFinal
(
ctx
, 
outbuf
->
base
 + outbuf->
off
, &
siglen
) != 1) {

755 
ret
 = 
PTLS_ERROR_LIBRARY
;

756 goto 
Exit
;

760 
outbuf
->
off
 += 
siglen
;

762 
ret
 = 0;

763 
Exit
:

764 if (
ctx
 != 
NULL
)

765 
	`EVP_MD_CTX_destroy
(
ctx
);

766 return 
ret
;

767 
	}
}

769 struct 
	scipher_context_t
 {

770 
ptls_cipher_context_t
 
	msuper
;

771 
EVP_CIPHER_CTX
 *
	mevp
;

774 static void 
	$cipher_dispose
(
ptls_cipher_context_t
 *
_ctx
)

776 struct 
cipher_context_t
 *
ctx
 = (struct cipher_context_t *)
_ctx
;

777 
	`EVP_CIPHER_CTX_free
(
ctx
->
evp
);

778 
	}
}

780 static void 
	$cipher_do_init
(
ptls_cipher_context_t
 *
_ctx
, const void *
iv
)

782 struct 
cipher_context_t
 *
ctx
 = (struct cipher_context_t *)
_ctx
;

783 int 
ret
;

784 
ret
 = 
	`EVP_EncryptInit_ex
(
ctx
->
evp
, 
NULL
, NULL, NULL, 
iv
);

785 
	`assert
(
ret
);

786 
	}
}

788 static int 
	$cipher_setup_crypto
(
ptls_cipher_context_t
 *
_ctx
, int 
is_enc
, const void *
key
, const 
EVP_CIPHER
 *
cipher
,

789 void (*
do_transform
)(
ptls_cipher_context_t
 *, void *, const void *, 
size_t
))

791 struct 
cipher_context_t
 *
ctx
 = (struct cipher_context_t *)
_ctx
;

793 
ctx
->
super
.
do_dispose
 = 
cipher_dispose
;

794 
ctx
->
super
.
do_init
 = 
cipher_do_init
;

795 
ctx
->
super
.
do_transform
 = do_transform;

797 if ((
ctx
->
evp
 = 
	`EVP_CIPHER_CTX_new
()) == 
NULL
)

798 return 
PTLS_ERROR_NO_MEMORY
;

800 if (
is_enc
) {

801 if (!
	`EVP_EncryptInit_ex
(
ctx
->
evp
, 
cipher
, 
NULL
, 
key
, NULL))

802 goto 
Error
;

804 if (!
	`EVP_DecryptInit_ex
(
ctx
->
evp
, 
cipher
, 
NULL
, 
key
, NULL))

805 goto 
Error
;

806 
	`EVP_CIPHER_CTX_set_padding
(
ctx
->
evp
, 0);

810 
Error
:

811 
	`EVP_CIPHER_CTX_free
(
ctx
->
evp
);

812 return 
PTLS_ERROR_LIBRARY
;

813 
	}
}

815 static void 
	$cipher_encrypt
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
_len
)

817 struct 
cipher_context_t
 *
ctx
 = (struct cipher_context_t *)
_ctx
;

818 int 
len
 = (int)
_len
, 
ret
 = 
	`EVP_EncryptUpdate
(
ctx
->
evp
, 
output
, &len, 
input
, len);

819 
	`assert
(
ret
);

820 
	`assert
(
len
 == (int)
_len
);

821 
	}
}

823 static void 
	$cipher_decrypt
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
_len
)

825 struct 
cipher_context_t
 *
ctx
 = (struct cipher_context_t *)
_ctx
;

826 int 
len
 = (int)
_len
, 
ret
 = 
	`EVP_DecryptUpdate
(
ctx
->
evp
, 
output
, &len, 
input
, len);

827 
	`assert
(
ret
);

828 
	`assert
(
len
 == (int)
_len
);

829 
	}
}

831 static int 
	$aes128ecb_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

833 return 
	`cipher_setup_crypto
(
ctx
, 
is_enc
, 
key
, 
	`EVP_aes_128_ecb
(), is_enc ? 
cipher_encrypt
 : 
cipher_decrypt
);

834 
	}
}

836 static int 
	$aes256ecb_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

838 return 
	`cipher_setup_crypto
(
ctx
, 
is_enc
, 
key
, 
	`EVP_aes_256_ecb
(), is_enc ? 
cipher_encrypt
 : 
cipher_decrypt
);

839 
	}
}

841 static int 
	$aes128ctr_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

843 return 
	`cipher_setup_crypto
(
ctx
, 1, 
key
, 
	`EVP_aes_128_ctr
(), 
cipher_encrypt
);

844 
	}
}

846 static int 
	$aes256ctr_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

848 return 
	`cipher_setup_crypto
(
ctx
, 1, 
key
, 
	`EVP_aes_256_ctr
(), 
cipher_encrypt
);

849 
	}
}

851 #if 
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305


853 static int 
	$chacha20_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

855 return 
	`cipher_setup_crypto
(
ctx
, 1, 
key
, 
	`EVP_chacha20
(), 
cipher_encrypt
);

856 
	}
}

860 #if 
PTLS_OPENSSL_HAVE_BF


862 static int 
	$bfecb_setup_crypto
(
ptls_cipher_context_t
 *
ctx
, int 
is_enc
, const void *
key
)

864 return 
	`cipher_setup_crypto
(
ctx
, 
is_enc
, 
key
, 
	`EVP_bf_ecb
(), is_enc ? 
cipher_encrypt
 : 
cipher_decrypt
);

865 
	}
}

869 struct 
	saead_crypto_context_t
 {

870 
ptls_aead_context_t
 
	msuper
;

871 
EVP_CIPHER_CTX
 *
	mevp_ctx
;

872 
uint8_t
 
	mstatic_iv
[
PTLS_MAX_IV_SIZE
];

875 static void 
	$aead_dispose_crypto
(
ptls_aead_context_t
 *
_ctx
)

877 struct 
aead_crypto_context_t
 *
ctx
 = (struct aead_crypto_context_t *)
_ctx
;

879 if (
ctx
->
evp_ctx
 != 
NULL
)

880 
	`EVP_CIPHER_CTX_free
(
ctx
->
evp_ctx
);

881 
	}
}

883 static void 
	$aead_xor_iv
(
ptls_aead_context_t
 *
_ctx
, const void *
_bytes
, 
size_t
 
len
)

885 struct 
aead_crypto_context_t
 *
ctx
 = (struct aead_crypto_context_t *)
_ctx
;

886 const 
uint8_t
 *
bytes
 = 
_bytes
;

888 for (
size_t
 
i
 = 0; i < 
len
; ++i)

889 
ctx
->
static_iv
[
i
] ^= 
bytes
[i];

890 
	}
}

892 static void 
	$aead_do_encrypt_init
(
ptls_aead_context_t
 *
_ctx
, 
uint64_t
 
seq
, const void *
aad
, 
size_t
 
aadlen
)

894 struct 
aead_crypto_context_t
 *
ctx
 = (struct aead_crypto_context_t *)
_ctx
;

895 
uint8_t
 
iv
[
PTLS_MAX_IV_SIZE
];

896 int 
ret
;

898 
	`ptls_aead__build_iv
(
ctx
->
super
.
algo
, 
iv
, ctx->
static_iv
, 
seq
);

899 
ret
 = 
	`EVP_EncryptInit_ex
(
ctx
->
evp_ctx
, 
NULL
, NULL, NULL, 
iv
);

900 
	`assert
(
ret
);

902 if (
aadlen
 != 0) {

903 int 
blocklen
;

904 
ret
 = 
	`EVP_EncryptUpdate
(
ctx
->
evp_ctx
, 
NULL
, &
blocklen
, 
aad
, (int)
aadlen
);

905 
	`assert
(
ret
);

907 
	}
}

909 static 
size_t
 
	$aead_do_encrypt_update
(
ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
)

911 struct 
aead_crypto_context_t
 *
ctx
 = (struct aead_crypto_context_t *)
_ctx
;

912 int 
blocklen
, 
ret
;

914 
ret
 = 
	`EVP_EncryptUpdate
(
ctx
->
evp_ctx
, 
output
, &
blocklen
, 
input
, (int)
inlen
);

915 
	`assert
(
ret
);

917 return 
blocklen
;

918 
	}
}

920 static 
size_t
 
	$aead_do_encrypt_final
(
ptls_aead_context_t
 *
_ctx
, void *
_output
)

922 struct 
aead_crypto_context_t
 *
ctx
 = (struct aead_crypto_context_t *)
_ctx
;

923 
uint8_t
 *
output
 = 
_output
;

924 
size_t
 
off
 = 0, 
tag_size
 = 
ctx
->
super
.
algo
->tag_size;

925 int 
blocklen
, 
ret
;

927 
ret
 = 
	`EVP_EncryptFinal_ex
(
ctx
->
evp_ctx
, 
output
 + 
off
, &
blocklen
);

928 
	`assert
(
ret
);

929 
off
 += 
blocklen
;

930 
ret
 = 
	`EVP_CIPHER_CTX_ctrl
(
ctx
->
evp_ctx
, 
EVP_CTRL_GCM_GET_TAG
, (int)
tag_size
, 
output
 + 
off
);

931 
	`assert
(
ret
);

932 
off
 += 
tag_size
;

934 return 
off
;

935 
	}
}

937 static 
size_t
 
	$aead_do_decrypt
(
ptls_aead_context_t
 *
_ctx
, void *
_output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
,

938 const void *
aad
, 
size_t
 
aadlen
)

940 struct 
aead_crypto_context_t
 *
ctx
 = (struct aead_crypto_context_t *)
_ctx
;

941 
uint8_t
 *
output
 = 
_output
, 
iv
[
PTLS_MAX_IV_SIZE
];

942 
size_t
 
off
 = 0, 
tag_size
 = 
ctx
->
super
.
algo
->tag_size;

943 int 
blocklen
, 
ret
;

945 if (
inlen
 < 
tag_size
)

946 return 
SIZE_MAX
;

948 
	`ptls_aead__build_iv
(
ctx
->
super
.
algo
, 
iv
, ctx->
static_iv
, 
seq
);

949 
ret
 = 
	`EVP_DecryptInit_ex
(
ctx
->
evp_ctx
, 
NULL
, NULL, NULL, 
iv
);

950 
	`assert
(
ret
);

951 if (
aadlen
 != 0) {

952 
ret
 = 
	`EVP_DecryptUpdate
(
ctx
->
evp_ctx
, 
NULL
, &
blocklen
, 
aad
, (int)
aadlen
);

953 
	`assert
(
ret
);

955 
ret
 = 
	`EVP_DecryptUpdate
(
ctx
->
evp_ctx
, 
output
 + 
off
, &
blocklen
, 
input
, (int)(
inlen
 - 
tag_size
));

956 
	`assert
(
ret
);

957 
off
 += 
blocklen
;

958 if (!
	`EVP_CIPHER_CTX_ctrl
(
ctx
->
evp_ctx
, 
EVP_CTRL_GCM_SET_TAG
, (int)
tag_size
, (void *)((
uint8_t
 *)
input
 + 
inlen
 - tag_size)))

959 return 
SIZE_MAX
;

960 if (!
	`EVP_DecryptFinal_ex
(
ctx
->
evp_ctx
, 
output
 + 
off
, &
blocklen
))

961 return 
SIZE_MAX
;

962 
off
 += 
blocklen
;

964 return 
off
;

965 
	}
}

967 static int 
	$aead_setup_crypto
(
ptls_aead_context_t
 *
_ctx
, int 
is_enc
, const void *
key
, const void *
iv
, const 
EVP_CIPHER
 *
cipher
)

969 struct 
aead_crypto_context_t
 *
ctx
 = (struct aead_crypto_context_t *)
_ctx
;

970 int 
ret
;

972 
	`memcpy
(
ctx
->
static_iv
, 
iv
, ctx->
super
.
algo
->
iv_size
);

973 if (
key
 == 
NULL
)

976 
ctx
->
super
.
dispose_crypto
 = 
aead_dispose_crypto
;

977 
ctx
->
super
.
do_xor_iv
 = 
aead_xor_iv
;

978 if (
is_enc
) {

979 
ctx
->
super
.
do_encrypt_init
 = 
aead_do_encrypt_init
;

980 
ctx
->
super
.
do_encrypt_update
 = 
aead_do_encrypt_update
;

981 
ctx
->
super
.
do_encrypt_final
 = 
aead_do_encrypt_final
;

982 
ctx
->
super
.
do_encrypt
 = 
ptls_aead__do_encrypt
;

983 
ctx
->
super
.
do_decrypt
 = 
NULL
;

985 
ctx
->
super
.
do_encrypt_init
 = 
NULL
;

986 
ctx
->
super
.
do_encrypt_update
 = 
NULL
;

987 
ctx
->
super
.
do_encrypt_final
 = 
NULL
;

988 
ctx
->
super
.
do_decrypt
 = 
aead_do_decrypt
;

990 
ctx
->
evp_ctx
 = 
NULL
;

992 if ((
ctx
->
evp_ctx
 = 
	`EVP_CIPHER_CTX_new
()) == 
NULL
) {

993 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

994 goto 
Error
;

996 if (
is_enc
) {

997 if (!
	`EVP_EncryptInit_ex
(
ctx
->
evp_ctx
, 
cipher
, 
NULL
, 
key
, NULL)) {

998 
ret
 = 
PTLS_ERROR_LIBRARY
;

999 goto 
Error
;

1002 if (!
	`EVP_DecryptInit_ex
(
ctx
->
evp_ctx
, 
cipher
, 
NULL
, 
key
, NULL)) {

1003 
ret
 = 
PTLS_ERROR_LIBRARY
;

1004 goto 
Error
;

1007 if (!
	`EVP_CIPHER_CTX_ctrl
(
ctx
->
evp_ctx
, 
EVP_CTRL_GCM_SET_IVLEN
, (int)ctx->
super
.
algo
->
iv_size
, 
NULL
)) {

1008 
ret
 = 
PTLS_ERROR_LIBRARY
;

1009 goto 
Error
;

1014 
Error
:

1015 
	`aead_dispose_crypto
(&
ctx
->
super
);

1016 return 
ret
;

1017 
	}
}

1019 static int 
	$aead_aes128gcm_setup_crypto
(
ptls_aead_context_t
 *
ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

1021 return 
	`aead_setup_crypto
(
ctx
, 
is_enc
, 
key
, 
iv
, 
	`EVP_aes_128_gcm
());

1022 
	}
}

1024 static int 
	$aead_aes256gcm_setup_crypto
(
ptls_aead_context_t
 *
ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

1026 return 
	`aead_setup_crypto
(
ctx
, 
is_enc
, 
key
, 
iv
, 
	`EVP_aes_256_gcm
());

1027 
	}
}

1029 #if 
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305


1030 static int 
	$aead_chacha20poly1305_setup_crypto
(
ptls_aead_context_t
 *
ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

1032 return 
	`aead_setup_crypto
(
ctx
, 
is_enc
, 
key
, 
iv
, 
	`EVP_chacha20_poly1305
());

1033 
	}
}

1036 #define 
	#_sha256_final
(
ctx
, 
md
) 
	`SHA256_Final
((md), (ctx))

	)

1037 
ptls_define_hash
(
sha256
, 
SHA256_CTX
, 
SHA256_Init
, 
SHA256_Update
, 
_sha256_final
);

1039 #define 
	#_sha384_final
(
ctx
, 
md
) 
	`SHA384_Final
((md), (ctx))

	)

1040 
ptls_define_hash
(
sha384
, 
SHA512_CTX
, 
SHA384_Init
, 
SHA384_Update
, 
_sha384_final
);

1042 static int 
	$sign_certificate
(
ptls_sign_certificate_t
 *
_self
, 
ptls_t
 *
tls
, 
uint16_t
 *
selected_algorithm
, 
ptls_buffer_t
 *
outbuf
,

1043 
ptls_iovec_t
 
input
, const 
uint16_t
 *
algorithms
, 
size_t
 
num_algorithms
)

1045 
ptls_openssl_sign_certificate_t
 *
self
 = (ptls_openssl_sign_certificate_t *)
_self
;

1046 const struct 
st_ptls_openssl_signature_scheme_t
 *
scheme
;

1049 for (
scheme
 = 
self
->
schemes
; scheme->
scheme_id
 != 
UINT16_MAX
; ++scheme) {

1050 
size_t
 
i
;

1051 for (
i
 = 0; i != 
num_algorithms
; ++i)

1052 if (
algorithms
[
i
] == 
scheme
->
scheme_id
)

1053 goto 
Found
;

1055 return 
PTLS_ALERT_HANDSHAKE_FAILURE
;

1057 
Found
:

1058 *
selected_algorithm
 = 
scheme
->
scheme_id
;

1059 return 
	`do_sign
(
self
->
key
, 
scheme
, 
outbuf
, 
input
);

1060 
	}
}

1062 static 
X509
 *
	$to_x509
(
ptls_iovec_t
 
vec
)

1064 const 
uint8_t
 *
p
 = 
vec
.
base
;

1065 return 
	`d2i_X509
(
NULL
, &
p
, (long)
vec
.
len
);

1066 
	}
}

1068 static int 
	$verify_sign
(void *
verify_ctx
, 
uint16_t
 
algo
, 
ptls_iovec_t
 
data
, ptls_iovec_t 
signature
)

1070 
EVP_PKEY
 *
key
 = 
verify_ctx
;

1071 const struct 
st_ptls_openssl_signature_scheme_t
 *
scheme
;

1072 
EVP_MD_CTX
 *
ctx
 = 
NULL
;

1073 
EVP_PKEY_CTX
 *
pkey_ctx
 = 
NULL
;

1074 int 
ret
 = 0;

1076 if (
data
.
base
 == 
NULL
)

1077 goto 
Exit
;

1079 if ((
scheme
 = 
	`lookup_signature_schemes
(
key
)) == 
NULL
) {

1080 
ret
 = 
PTLS_ERROR_LIBRARY
;

1081 goto 
Exit
;

1083 for (; 
scheme
->
scheme_id
 != 
UINT16_MAX
; ++scheme)

1084 if (
scheme
->
scheme_id
 == 
algo
)

1085 goto 
SchemeFound
;

1086 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

1087 goto 
Exit
;

1089 
SchemeFound
:

1090 if ((
ctx
 = 
	`EVP_MD_CTX_create
()) == 
NULL
) {

1091 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1092 goto 
Exit
;

1095 #if 
PTLS_OPENSSL_HAVE_ED25519


1096 if (
	`EVP_PKEY_id
(
key
) == 
EVP_PKEY_ED25519
) {

1098 if (
	`EVP_DigestVerifyInit
(
ctx
, &
pkey_ctx
, 
NULL
, NULL, 
key
) != 1) {

1099 
ret
 = 
PTLS_ERROR_LIBRARY
;

1100 goto 
Exit
;

1102 if (
	`EVP_DigestVerify
(
ctx
, 
signature
.
base
, signature.
len
, 
data
.base, data.len) != 1) {

1103 
ret
 = 
PTLS_ERROR_LIBRARY
;

1104 goto 
Exit
;

1109 if (
	`EVP_DigestVerifyInit
(
ctx
, &
pkey_ctx
, 
scheme
->
	`scheme_md
(), 
NULL
, 
key
) != 1) {

1110 
ret
 = 
PTLS_ERROR_LIBRARY
;

1111 goto 
Exit
;

1114 if (
	`EVP_PKEY_id
(
key
) == 
EVP_PKEY_RSA
) {

1115 if (
	`EVP_PKEY_CTX_set_rsa_padding
(
pkey_ctx
, 
RSA_PKCS1_PSS_PADDING
) != 1) {

1116 
ret
 = 
PTLS_ERROR_LIBRARY
;

1117 goto 
Exit
;

1119 if (
	`EVP_PKEY_CTX_set_rsa_pss_saltlen
(
pkey_ctx
, -1) != 1) {

1120 
ret
 = 
PTLS_ERROR_LIBRARY
;

1121 goto 
Exit
;

1123 if (
	`EVP_PKEY_CTX_set_rsa_mgf1_md
(
pkey_ctx
, 
scheme
->
	`scheme_md
()) != 1) {

1124 
ret
 = 
PTLS_ERROR_LIBRARY
;

1125 goto 
Exit
;

1128 if (
	`EVP_DigestVerifyUpdate
(
ctx
, 
data
.
base
, data.
len
) != 1) {

1129 
ret
 = 
PTLS_ERROR_LIBRARY
;

1130 goto 
Exit
;

1132 if (
	`EVP_DigestVerifyFinal
(
ctx
, 
signature
.
base
, signature.
len
) != 1) {

1133 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

1134 goto 
Exit
;

1138 
ret
 = 0;

1140 
Exit
:

1141 if (
ctx
 != 
NULL
)

1142 
	`EVP_MD_CTX_destroy
(
ctx
);

1143 
	`EVP_PKEY_free
(
key
);

1144 return 
ret
;

1145 
	}
}

1147 int 
	$ptls_openssl_init_sign_certificate
(
ptls_openssl_sign_certificate_t
 *
self
, 
EVP_PKEY
 *
key
)

1149 *
self
 = (
ptls_openssl_sign_certificate_t
){{
sign_certificate
}};

1151 if ((
self
->
schemes
 = 
	`lookup_signature_schemes
(
key
)) == 
NULL
)

1152 return 
PTLS_ERROR_INCOMPATIBLE_KEY
;

1153 
	`EVP_PKEY_up_ref
(
key
);

1154 
self
->
key
 = key;

1157 
	}
}

1159 void 
	$ptls_openssl_dispose_sign_certificate
(
ptls_openssl_sign_certificate_t
 *
self
)

1161 
	`EVP_PKEY_free
(
self
->
key
);

1162 
	}
}

1164 static int 
	$serialize_cert
(
X509
 *
cert
, 
ptls_iovec_t
 *
dst
)

1166 int 
len
 = 
	`i2d_X509
(
cert
, 
NULL
);

1167 
	`assert
(
len
 > 0);

1169 if ((
dst
->
base
 = 
	`malloc
(
len
)) == 
NULL
)

1170 return 
PTLS_ERROR_NO_MEMORY
;

1171 unsigned char *
p
 = 
dst
->
base
;

1172 
dst
->
len
 = 
	`i2d_X509
(
cert
, &
p
);

1173 
	`assert
(
len
 == 
dst
->len);

1176 
	}
}

1178 int 
ptls_openssl_load_certificates
(
ptls_context_t
 *
ctx
, 
X509
 *
cert
, 
STACK_OF
(X509) * 
chain
)

1180 
ptls_iovec_t
 *
	glist
 = 
NULL
;

1181 
size_t
 
	gslot
 = 0, 
	gcount
 = (
cert
 != 
NULL
) + (
chain
 != NULL ? 
sk_X509_num
(chain) : 0);

1182 int 
	gret
;

1184 
assert
(
ctx
->
certificates
.
list
 == 
NULL
);

1186 if ((
	glist
 = 
malloc
(sizeof(*
list
) * 
count
)) == 
NULL
) {

1187 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1188 goto 
	gExit
;

1190 if (
	gcert
 != 
NULL
) {

1191 if ((
ret
 = 
serialize_cert
(
cert
, 
list
 + 
slot
++)) != 0)

1192 goto 
Exit
;

1194 if (
	gchain
 != 
NULL
) {

1195 int 
i
;

1196 for (
	gi
 = 0; i != 
sk_X509_num
(
chain
); ++i) {

1197 if ((
	gret
 = 
serialize_cert
(
sk_X509_value
(
chain
, 
i
), 
list
 + 
slot
++)) != 0)

1198 goto 
Exit
;

1202 
assert
(
slot
 == 
count
);

1204 
	gctx
->
	gcertificates
.
	glist
 = 
list
;

1205 
	gctx
->
	gcertificates
.
	gcount
 = 
count
;

1206 
	gret
 = 0;

1208 
	gExit
:

1209 if (
ret
 != 0 && 
list
 != 
NULL
) {

1210 
size_t
 
i
;

1211 for (
	gi
 = 0; i != 
slot
; ++i)

1212 
free
(
list
[
i
].
base
);

1213 
free
(
list
);

1215 return 
	gret
;

1218 static int 
verify_cert_chain
(
X509_STORE
 *
store
, 
X509
 *
cert
, 
STACK_OF
(X509) * 
chain
, int 
is_server
, const char *
server_name
)

1220 
X509_STORE_CTX
 *
	gverify_ctx
;

1221 int 
	gret
;

1224 if ((
	gverify_ctx
 = 
X509_STORE_CTX_new
()) == 
NULL
) {

1225 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1226 goto 
	gExit
;

1228 if (
X509_STORE_CTX_init
(
verify_ctx
, 
store
, 
cert
, 
chain
) != 1) {

1229 
ret
 = 
PTLS_ERROR_LIBRARY
;

1230 goto 
	gExit
;

1234 
X509_VERIFY_PARAM
 *
	gparams
 = 
X509_STORE_CTX_get0_param
(
verify_ctx
);

1235 
X509_VERIFY_PARAM_set_purpose
(
params
, 
is_server
 ? 
X509_PURPOSE_SSL_SERVER
 : 
X509_PURPOSE_SSL_CLIENT
);

1236 
X509_VERIFY_PARAM_set_depth
(
params
, 98);

1238 if (!
	gis_server
) {

1239 
assert
(
server_name
 != 
NULL
 && "ptls_set_server_name MUST be called");

1240 if (
ptls_server_name_is_ipaddr
(
server_name
)) {

1241 
X509_VERIFY_PARAM_set1_ip_asc
(
params
, 
server_name
);

1243 
X509_VERIFY_PARAM_set1_host
(
params
, 
server_name
, 0);

1244 
X509_VERIFY_PARAM_set_hostflags
(
params
, 
X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS
);

1249 if (
X509_verify_cert
(
verify_ctx
) != 1) {

1250 int 
x509_err
 = 
X509_STORE_CTX_get_error
(
verify_ctx
);

1251 switch (
	gx509_err
) {

1252 case 
	gX509_V_ERR_OUT_OF_MEM
:

1253 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1255 case 
	gX509_V_ERR_CERT_REVOKED
:

1256 
ret
 = 
PTLS_ALERT_CERTIFICATE_REVOKED
;

1258 case 
	gX509_V_ERR_CERT_NOT_YET_VALID
:

1259 case 
X509_V_ERR_CERT_HAS_EXPIRED
:

1260 
ret
 = 
PTLS_ALERT_CERTIFICATE_EXPIRED
;

1262 case 
	gX509_V_ERR_UNABLE_TO_GET_ISSUER_CERT
:

1263 case 
X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
:

1264 case 
X509_V_ERR_CERT_UNTRUSTED
:

1265 case 
X509_V_ERR_CERT_REJECTED
:

1266 
ret
 = 
PTLS_ALERT_UNKNOWN_CA
;

1268 case 
	gX509_V_ERR_HOSTNAME_MISMATCH
:

1269 case 
X509_V_ERR_INVALID_CA
:

1270 
ret
 = 
PTLS_ALERT_BAD_CERTIFICATE
;

1273 
ret
 = 
PTLS_ALERT_CERTIFICATE_UNKNOWN
;

1276 goto 
	gExit
;

1279 
	gret
 = 0;

1281 
	gExit
:

1282 if (
verify_ctx
 != 
NULL
)

1283 
X509_STORE_CTX_free
(
verify_ctx
);

1284 return 
	gret
;

1287 static int 
verify_cert
(
ptls_verify_certificate_t
 *
_self
, 
ptls_t
 *
tls
,

1288 int (**
verifier
)(void *, 
uint16_t
, 
ptls_iovec_t
, ptls_iovec_t), void **
verify_data
, ptls_iovec_t *
certs
,

1289 
size_t
 
num_certs
)

1291 
ptls_openssl_verify_certificate_t
 *
self
 = (ptls_openssl_verify_certificate_t *)
_self
;

1292 
X509
 *
cert
 = 
NULL
;

1293 
	`STACK_OF
(
X509
) *
chain
 = 
	`sk_X509_new_null
();

1294 
size_t
 
i
;

1295 int 
ret
 = 0;

1297 
	`assert
(
num_certs
 != 0);

1300 if ((
cert
 = 
	`to_x509
(
certs
[0])) == 
NULL
) {

1301 
ret
 = 
PTLS_ALERT_BAD_CERTIFICATE
;

1302 goto 
Exit
;

1304 for (
i
 = 1; i != 
num_certs
; ++i) {

1305 
X509
 *
interm
 = 
	`to_x509
(
certs
[
i
]);

1306 if (
interm
 == 
NULL
) {

1307 
ret
 = 
PTLS_ALERT_BAD_CERTIFICATE
;

1308 goto 
Exit
;

1310 
	`sk_X509_push
(
chain
, 
interm
);

1314 if ((
ret
 = 
	`verify_cert_chain
(
self
->
cert_store
, 
cert
, 
chain
, 
	`ptls_is_server
(
tls
), 
	`ptls_get_server_name
(tls))) != 0)

1315 goto 
Exit
;

1318 if ((*
verify_data
 = 
	`X509_get_pubkey
(
cert
)) == 
NULL
) {

1319 
ret
 = 
PTLS_ALERT_BAD_CERTIFICATE
;

1320 goto 
Exit
;

1322 *
verifier
 = 
verify_sign
;

1324 
Exit
:

1325 if (
chain
 != 
NULL
)

1326 
	`sk_X509_pop_free
(
chain
, 
X509_free
);

1327 if (
cert
 != 
NULL
)

1328 
	`X509_free
(
cert
);

1329 return 
ret
;

1330 
	}
}

1332 int 
	$ptls_openssl_init_verify_certificate
(
ptls_openssl_verify_certificate_t
 *
self
, 
X509_STORE
 *
store
)

1334 *
self
 = (
ptls_openssl_verify_certificate_t
){{
verify_cert
, 
default_signature_schemes
}};

1336 if (
store
 != 
NULL
) {

1337 
	`X509_STORE_up_ref
(
store
);

1338 
self
->
cert_store
 = 
store
;

1341 if ((
self
->
cert_store
 = 
	`ptls_openssl_create_default_certificate_store
()) == 
NULL
)

1346 
	}
}

1348 void 
	$ptls_openssl_dispose_verify_certificate
(
ptls_openssl_verify_certificate_t
 *
self
)

1350 
	`X509_STORE_free
(
self
->
cert_store
);

1351 
	}
}

1353 
X509_STORE
 *
	$ptls_openssl_create_default_certificate_store
(void)

1355 
X509_STORE
 *
store
;

1356 
X509_LOOKUP
 *
lookup
;

1358 if ((
store
 = 
	`X509_STORE_new
()) == 
NULL
)

1359 goto 
Error
;

1360 if ((
lookup
 = 
	`X509_STORE_add_lookup
(
store
, 
	`X509_LOOKUP_file
())) == 
NULL
)

1361 goto 
Error
;

1362 
	`X509_LOOKUP_load_file
(
lookup
, 
NULL
, 
X509_FILETYPE_DEFAULT
);

1363 if ((
lookup
 = 
	`X509_STORE_add_lookup
(
store
, 
	`X509_LOOKUP_hash_dir
())) == 
NULL
)

1364 goto 
Error
;

1365 
	`X509_LOOKUP_add_dir
(
lookup
, 
NULL
, 
X509_FILETYPE_DEFAULT
);

1367 return 
store
;

1368 
Error
:

1369 if (
store
 != 
NULL
)

1370 
	`X509_STORE_free
(
store
);

1371 return 
NULL
;

1372 
	}
}

1374 static int 
verify_raw_cert
(
ptls_verify_certificate_t
 *
_self
, 
ptls_t
 *
tls
,

1375 int (**
verifier
)(void *, 
uint16_t
 
algo
, 
ptls_iovec_t
, ptls_iovec_t), void **
verify_data
,

1376 
ptls_iovec_t
 *
certs
, 
size_t
 
num_certs
)

1378 
ptls_openssl_raw_pubkey_verify_certificate_t
 *
self
 = (ptls_openssl_raw_pubkey_verify_certificate_t *)
_self
;

1379 int 
ret
 = 
PTLS_ALERT_BAD_CERTIFICATE
;

1380 
ptls_iovec_t
 
expected_pubkey
 = {0};

1382 
	`assert
(
num_certs
 != 0);

1384 if (
num_certs
 != 1)

1385 goto 
Exit
;

1387 int 
r
 = 
	`i2d_PUBKEY
(
self
->
expected_pubkey
, &expected_pubkey.
base
);

1388 if (
r
 <= 0) {

1389 
ret
 = 
PTLS_ALERT_BAD_CERTIFICATE
;

1390 goto 
Exit
;

1393 
expected_pubkey
.
len
 = 
r
;

1394 if (
certs
[0].
len
 != 
expected_pubkey
.len)

1395 goto 
Exit
;

1397 if (!
	`ptls_mem_equal
(
expected_pubkey
.
base
, 
certs
[0].base, certs[0].
len
))

1398 goto 
Exit
;

1400 
	`EVP_PKEY_up_ref
(
self
->
expected_pubkey
);

1401 *
verify_data
 = 
self
->
expected_pubkey
;

1402 *
verifier
 = 
verify_sign
;

1403 
ret
 = 0;

1404 
Exit
:

1405 
	`free
(
expected_pubkey
.
base
);

1406 return 
ret
;

1407 
	}
}

1409 int 
	$ptls_openssl_raw_pubkey_init_verify_certificate
(
ptls_openssl_raw_pubkey_verify_certificate_t
 *
self
, 
EVP_PKEY
 *
expected_pubkey
)

1411 
	`EVP_PKEY_up_ref
(
expected_pubkey
);

1412 *
self
 = (
ptls_openssl_raw_pubkey_verify_certificate_t
){{
verify_raw_cert
, 
default_signature_schemes
}, 
expected_pubkey
};

1414 
	}
}

1415 void 
	$ptls_openssl_raw_pubkey_dispose_verify_certificate
(
ptls_openssl_raw_pubkey_verify_certificate_t
 *
self
)

1417 
	`EVP_PKEY_free
(
self
->
expected_pubkey
);

1418 
	}
}

1420 #define 
	#TICKET_LABEL_SIZE
 16

	)

1421 #define 
	#TICKET_IV_SIZE
 
EVP_MAX_IV_LENGTH


	)

1423 int 
	$ptls_openssl_encrypt_ticket
(
ptls_buffer_t
 *
buf
, 
ptls_iovec_t
 
src
,

1424 int (*
cb
)(unsigned char *
key_name
, unsigned char *
iv
, 
EVP_CIPHER_CTX
 *
ctx
, 
HMAC_CTX
 *
hctx
, int 
enc
))

1426 
EVP_CIPHER_CTX
 *
cctx
 = 
NULL
;

1427 
HMAC_CTX
 *
hctx
 = 
NULL
;

1428 
uint8_t
 *
dst
;

1429 int 
clen
, 
ret
;

1431 if ((
cctx
 = 
	`EVP_CIPHER_CTX_new
()) == 
NULL
) {

1432 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1433 goto 
Exit
;

1435 if ((
hctx
 = 
	`HMAC_CTX_new
()) == 
NULL
) {

1436 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1437 goto 
Exit
;

1440 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
TICKET_LABEL_SIZE
 + 
TICKET_IV_SIZE
 + 
src
.
len
 + 
EVP_MAX_BLOCK_LENGTH
 + 
EVP_MAX_MD_SIZE
)) !=

1442 goto 
Exit
;

1443 
dst
 = 
buf
->
base
 + buf->
off
;

1446 if (!(*
cb
)(
dst
, dst + 
TICKET_LABEL_SIZE
, 
cctx
, 
hctx
, 1)) {

1447 
ret
 = 
PTLS_ERROR_LIBRARY
;

1448 goto 
Exit
;

1450 
dst
 += 
TICKET_LABEL_SIZE
 + 
TICKET_IV_SIZE
;

1453 if (!
	`EVP_EncryptUpdate
(
cctx
, 
dst
, &
clen
, 
src
.
base
, (int)src.
len
)) {

1454 
ret
 = 
PTLS_ERROR_LIBRARY
;

1455 goto 
Exit
;

1457 
dst
 += 
clen
;

1458 if (!
	`EVP_EncryptFinal_ex
(
cctx
, 
dst
, &
clen
)) {

1459 
ret
 = 
PTLS_ERROR_LIBRARY
;

1460 goto 
Exit
;

1462 
dst
 += 
clen
;

1465 if (!
	`HMAC_Update
(
hctx
, 
buf
->
base
 + buf->
off
, 
dst
 - (buf->base + buf->off)) || !
	`HMAC_Final
(hctx, dst, 
NULL
)) {

1466 
ret
 = 
PTLS_ERROR_LIBRARY
;

1467 goto 
Exit
;

1469 
dst
 += 
	`HMAC_size
(
hctx
);

1471 
	`assert
(
dst
 <= 
buf
->
base
 + buf->
capacity
);

1472 
buf
->
off
 += 
dst
 - (buf->
base
 + buf->off);

1473 
ret
 = 0;

1475 
Exit
:

1476 if (
cctx
 != 
NULL
)

1477 
	`EVP_CIPHER_CTX_free
(
cctx
);

1478 if (
hctx
 != 
NULL
)

1479 
	`HMAC_CTX_free
(
hctx
);

1480 return 
ret
;

1481 
	}
}

1483 int 
	$ptls_openssl_decrypt_ticket
(
ptls_buffer_t
 *
buf
, 
ptls_iovec_t
 
src
,

1484 int (*
cb
)(unsigned char *
key_name
, unsigned char *
iv
, 
EVP_CIPHER_CTX
 *
ctx
, 
HMAC_CTX
 *
hctx
, int 
enc
))

1486 
EVP_CIPHER_CTX
 *
cctx
 = 
NULL
;

1487 
HMAC_CTX
 *
hctx
 = 
NULL
;

1488 int 
clen
, 
ret
;

1490 if ((
cctx
 = 
	`EVP_CIPHER_CTX_new
()) == 
NULL
) {

1491 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1492 goto 
Exit
;

1494 if ((
hctx
 = 
	`HMAC_CTX_new
()) == 
NULL
) {

1495 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1496 goto 
Exit
;

1501 if (
src
.
len
 < 
TICKET_LABEL_SIZE
 + 
TICKET_IV_SIZE
) {

1502 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

1503 goto 
Exit
;

1505 if (!(*
cb
)(
src
.
base
, src.base + 
TICKET_LABEL_SIZE
, 
cctx
, 
hctx
, 0)) {

1506 
ret
 = 
PTLS_ERROR_LIBRARY
;

1507 goto 
Exit
;

1511 
size_t
 
hmac_size
 = 
	`HMAC_size
(
hctx
);

1512 if (
src
.
len
 < 
TICKET_LABEL_SIZE
 + 
TICKET_IV_SIZE
 + 
hmac_size
) {

1513 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

1514 goto 
Exit
;

1516 
src
.
len
 -= 
hmac_size
;

1517 
uint8_t
 
hmac
[
EVP_MAX_MD_SIZE
];

1518 if (!
	`HMAC_Update
(
hctx
, 
src
.
base
, src.
len
) || !
	`HMAC_Final
(hctx, 
hmac
, 
NULL
)) {

1519 
ret
 = 
PTLS_ERROR_LIBRARY
;

1520 goto 
Exit
;

1522 if (!
	`ptls_mem_equal
(
src
.
base
 + src.
len
, 
hmac
, 
hmac_size
)) {

1523 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

1524 goto 
Exit
;

1526 
src
.
base
 += 
TICKET_LABEL_SIZE
 + 
TICKET_IV_SIZE
;

1527 
src
.
len
 -= 
TICKET_LABEL_SIZE
 + 
TICKET_IV_SIZE
;

1530 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
src
.
len
)) != 0)

1531 goto 
Exit
;

1532 if (!
	`EVP_DecryptUpdate
(
cctx
, 
buf
->
base
 + buf->
off
, &
clen
, 
src
.base, (int)src.
len
)) {

1533 
ret
 = 
PTLS_ERROR_LIBRARY
;

1534 goto 
Exit
;

1536 
buf
->
off
 += 
clen
;

1537 if (!
	`EVP_DecryptFinal_ex
(
cctx
, 
buf
->
base
 + buf->
off
, &
clen
)) {

1538 
ret
 = 
PTLS_ERROR_LIBRARY
;

1539 goto 
Exit
;

1541 
buf
->
off
 += 
clen
;

1543 
ret
 = 0;

1545 
Exit
:

1546 if (
cctx
 != 
NULL
)

1547 
	`EVP_CIPHER_CTX_free
(
cctx
);

1548 if (
hctx
 != 
NULL
)

1549 
	`HMAC_CTX_free
(
hctx
);

1550 return 
ret
;

1551 
	}
}

1553 
ptls_key_exchange_algorithm_t
 
	gptls_openssl_secp256r1
 = {.
id
 = 
PTLS_GROUP_SECP256R1
,

1554 .
	gname
 = 
PTLS_GROUP_NAME_SECP256R1
,

1555 .
	gcreate
 = 
x9_62_create_key_exchange
,

1556 .
	gexchange
 = 
secp_key_exchange
,

1557 .
	gdata
 = 
NID_X9_62_prime256v1
};

1558 #if 
PTLS_OPENSSL_HAVE_SECP384R1


1559 
ptls_key_exchange_algorithm_t
 
	gptls_openssl_secp384r1
 = {.
id
 = 
PTLS_GROUP_SECP384R1
,

1560 .
	gname
 = 
PTLS_GROUP_NAME_SECP384R1
,

1561 .
	gcreate
 = 
x9_62_create_key_exchange
,

1562 .
	gexchange
 = 
secp_key_exchange
,

1563 .
	gdata
 = 
NID_secp384r1
};

1565 #if 
PTLS_OPENSSL_HAVE_SECP521R1


1566 
ptls_key_exchange_algorithm_t
 
	gptls_openssl_secp521r1
 = {.
id
 = 
PTLS_GROUP_SECP521R1
,

1567 .
	gname
 = 
PTLS_GROUP_NAME_SECP521R1
,

1568 .
	gcreate
 = 
x9_62_create_key_exchange
,

1569 .
	gexchange
 = 
secp_key_exchange
,

1570 .
	gdata
 = 
NID_secp521r1
};

1572 #if 
PTLS_OPENSSL_HAVE_X25519


1573 
ptls_key_exchange_algorithm_t
 
	gptls_openssl_x25519
 = {.
id
 = 
PTLS_GROUP_X25519
,

1574 .
	gname
 = 
PTLS_GROUP_NAME_X25519
,

1575 .
	gcreate
 = 
evp_keyex_create
,

1576 .
	gexchange
 = 
evp_keyex_exchange
,

1577 .
	gdata
 = 
NID_X25519
};

1579 
ptls_key_exchange_algorithm_t
 *
	gptls_openssl_key_exchanges
[] = {&
ptls_openssl_secp256r1
, 
NULL
};

1580 
ptls_cipher_algorithm_t
 
	gptls_openssl_aes128ecb
 = {

1581 "AES128-ECB", 
PTLS_AES128_KEY_SIZE
, 
PTLS_AES_BLOCK_SIZE
, 0 , sizeof(struct 
cipher_context_t
),

1582 
aes128ecb_setup_crypto
};

1583 
ptls_cipher_algorithm_t
 
	gptls_openssl_aes128ctr
 = {

1584 "AES128-CTR", 
PTLS_AES128_KEY_SIZE
, 1, 
PTLS_AES_IV_SIZE
, sizeof(struct 
cipher_context_t
), 
aes128ctr_setup_crypto
};

1585 
ptls_aead_algorithm_t
 
	gptls_openssl_aes128gcm
 = {"AES128-GCM",

1586 
PTLS_AESGCM_CONFIDENTIALITY_LIMIT
,

1587 
PTLS_AESGCM_INTEGRITY_LIMIT
,

1588 &
ptls_openssl_aes128ctr
,

1589 &
ptls_openssl_aes128ecb
,

1590 
PTLS_AES128_KEY_SIZE
,

1591 
PTLS_AESGCM_IV_SIZE
,

1592 
PTLS_AESGCM_TAG_SIZE
,

1593 sizeof(struct 
aead_crypto_context_t
),

1594 
aead_aes128gcm_setup_crypto
};

1595 
ptls_cipher_algorithm_t
 
	gptls_openssl_aes256ecb
 = {

1596 "AES256-ECB", 
PTLS_AES256_KEY_SIZE
, 
PTLS_AES_BLOCK_SIZE
, 0 , sizeof(struct 
cipher_context_t
),

1597 
aes256ecb_setup_crypto
};

1598 
ptls_cipher_algorithm_t
 
	gptls_openssl_aes256ctr
 = {

1599 "AES256-CTR", 
PTLS_AES256_KEY_SIZE
, 1 , 
PTLS_AES_IV_SIZE
, sizeof(struct 
cipher_context_t
),

1600 
aes256ctr_setup_crypto
};

1601 
ptls_aead_algorithm_t
 
	gptls_openssl_aes256gcm
 = {"AES256-GCM",

1602 
PTLS_AESGCM_CONFIDENTIALITY_LIMIT
,

1603 
PTLS_AESGCM_INTEGRITY_LIMIT
,

1604 &
ptls_openssl_aes256ctr
,

1605 &
ptls_openssl_aes256ecb
,

1606 
PTLS_AES256_KEY_SIZE
,

1607 
PTLS_AESGCM_IV_SIZE
,

1608 
PTLS_AESGCM_TAG_SIZE
,

1609 sizeof(struct 
aead_crypto_context_t
),

1610 
aead_aes256gcm_setup_crypto
};

1611 
ptls_hash_algorithm_t
 
	gptls_openssl_sha256
 = {
PTLS_SHA256_BLOCK_SIZE
, 
PTLS_SHA256_DIGEST_SIZE
, 
sha256_create
,

1612 
PTLS_ZERO_DIGEST_SHA256
};

1613 
ptls_hash_algorithm_t
 
	gptls_openssl_sha384
 = {
PTLS_SHA384_BLOCK_SIZE
, 
PTLS_SHA384_DIGEST_SIZE
, 
sha384_create
,

1614 
PTLS_ZERO_DIGEST_SHA384
};

1615 
ptls_cipher_suite_t
 
	gptls_openssl_aes128gcmsha256
 = {.
id
 = 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
,

1616 .
	gname
 = 
PTLS_CIPHER_SUITE_NAME_AES_128_GCM_SHA256
,

1617 .
	gaead
 = &
ptls_openssl_aes128gcm
,

1618 .
	ghash
 = &
ptls_openssl_sha256
};

1619 
ptls_cipher_suite_t
 
	gptls_openssl_aes256gcmsha384
 = {.
id
 = 
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
,

1620 .
	gname
 = 
PTLS_CIPHER_SUITE_NAME_AES_256_GCM_SHA384
,

1621 .
	gaead
 = &
ptls_openssl_aes256gcm
,

1622 .
	ghash
 = &
ptls_openssl_sha384
};

1623 #if 
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305


1624 
ptls_cipher_algorithm_t
 
	gptls_openssl_chacha20
 = {

1625 "CHACHA20", 
PTLS_CHACHA20_KEY_SIZE
, 1 , 
PTLS_CHACHA20_IV_SIZE
, sizeof(struct 
cipher_context_t
),

1626 
chacha20_setup_crypto
};

1627 
ptls_aead_algorithm_t
 
	gptls_openssl_chacha20poly1305
 = {"CHACHA20-POLY1305",

1628 
PTLS_CHACHA20POLY1305_CONFIDENTIALITY_LIMIT
,

1629 
PTLS_CHACHA20POLY1305_INTEGRITY_LIMIT
,

1630 &
ptls_openssl_chacha20
,

1631 
NULL
,

1632 
PTLS_CHACHA20_KEY_SIZE
,

1633 
PTLS_CHACHA20POLY1305_IV_SIZE
,

1634 
PTLS_CHACHA20POLY1305_TAG_SIZE
,

1635 sizeof(struct 
aead_crypto_context_t
),

1636 
aead_chacha20poly1305_setup_crypto
};

1637 
ptls_cipher_suite_t
 
	gptls_openssl_chacha20poly1305sha256
 = {.
id
 = 
PTLS_CIPHER_SUITE_CHACHA20_POLY1305_SHA256
,

1638 .
	gname
 = 
PTLS_CIPHER_SUITE_NAME_CHACHA20_POLY1305_SHA256
,

1639 .
	gaead
 = &
ptls_openssl_chacha20poly1305
,

1640 .
	ghash
 = &
ptls_openssl_sha256
};

1642 
ptls_cipher_suite_t
 *
	gptls_openssl_cipher_suites
[] = {&
ptls_openssl_aes256gcmsha384
, &
ptls_openssl_aes128gcmsha256
,

1643 #if 
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305


1644 &
ptls_openssl_chacha20poly1305sha256
,

1646 
NULL
};

1648 #if 
PTLS_OPENSSL_HAVE_BF


1649 
ptls_cipher_algorithm_t
 
	gptls_openssl_bfecb
 = {"BF-ECB", 
PTLS_BLOWFISH_KEY_SIZE
, 
PTLS_BLOWFISH_BLOCK_SIZE
,

1650 0 , sizeof(struct 
cipher_context_t
), 
bfecb_setup_crypto
};

	@deps/picotls/lib/pembase64.c

20 #ifdef 
_WINDOWS


21 #include 
	~"wincompat.h
"

23 #include 
	~<sys/time.h
>

25 #include 
	~<errno.h
>

26 #include 
	~<stdlib.h
>

27 #include 
	~<string.h
>

28 #include 
	~<stdio.h
>

29 #include 
	~"picotls.h
"

30 #include 
	~"picotls/pembase64.h
"

32 static char 
	gptls_base64_alphabet
[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',

37 static signed char 
	gptls_base64_values
[] = {

55 static void 
	$ptls_base64_cell
(const 
uint8_t
 *
data
, char *
text
)

57 int 
n
[4];

59 
n
[0] = 
data
[0] >> 2;

60 
n
[1] = ((
data
[0] & 3) << 4) | (data[1] >> 4);

61 
n
[2] = ((
data
[1] & 15) << 2) | (data[2] >> 6);

62 
n
[3] = 
data
[2] & 63;

64 for (int 
i
 = 0; i < 4; i++) {

65 
text
[
i
] = 
ptls_base64_alphabet
[
n
[i]];

67 
	}
}

69 
size_t
 
	$ptls_base64_howlong
(
size_t
 
data_length
)

71 return (((
data_length
 + 2) / 3) * 4);

72 
	}
}

74 int 
	$ptls_base64_encode
(const 
uint8_t
 *
data
, 
size_t
 
data_len
, char *
ptls_base64_text
)

76 int 
l
 = 0;

77 int 
lt
 = 0;

79 while ((
data_len
 - 
l
) >= 3) {

80 
	`ptls_base64_cell
(
data
 + 
l
, 
ptls_base64_text
 + 
lt
);

81 
l
 += 3;

82 
lt
 += 4;

85 switch (
data_len
 - 
l
) {

89 
ptls_base64_text
[
lt
++] = 
ptls_base64_alphabet
[
data
[
l
] >> 2];

90 
ptls_base64_text
[
lt
++] = 
ptls_base64_alphabet
[(
data
[
l
] & 3) << 4];

91 
ptls_base64_text
[
lt
++] = '=';

92 
ptls_base64_text
[
lt
++] = '=';

95 
ptls_base64_text
[
lt
++] = 
ptls_base64_alphabet
[
data
[
l
] >> 2];

96 
ptls_base64_text
[
lt
++] = 
ptls_base64_alphabet
[((
data
[
l
] & 3) << 4) | (data[l + 1] >> 4)];

97 
ptls_base64_text
[
lt
++] = 
ptls_base64_alphabet
[((
data
[
l
 + 1] & 15) << 2)];

98 
ptls_base64_text
[
lt
++] = '=';

103 
ptls_base64_text
[
lt
++] = 0;

105 return 
lt
;

106 
	}
}

115 void 
	$ptls_base64_decode_init
(
ptls_base64_decode_state_t
 *
state
)

117 
state
->
nbc
 = 0;

118 
state
->
nbo
 = 3;

119 
state
->
v
 = 0;

120 
state
->
status
 = 
PTLS_BASE64_DECODE_IN_PROGRESS
;

121 
	}
}

123 int 
	$ptls_base64_decode
(const char *
text
, 
ptls_base64_decode_state_t
 *
state
, 
ptls_buffer_t
 *
buf
)

125 int 
ret
 = 0;

126 
uint8_t
 
decoded
[3];

127 
size_t
 
text_index
 = 0;

128 int 
c
;

129 signed char 
vc
;

132 while (
text
[
text_index
] != 0) {

133 
c
 = 
text
[
text_index
];

135 if (
c
 == ' ' || c == '\t' || c == '\r' || c == '\n') {

136 
text_index
++;

142 while (
text
[
text_index
] != 0 && 
ret
 == 0 && 
state
->
status
 == 
PTLS_BASE64_DECODE_IN_PROGRESS
) {

143 
c
 = 
text
[
text_index
++];

145 
vc
 = 0 < 
c
 && c < 0x7f ? 
ptls_base64_values
[c] : -1;

146 if (
vc
 == -1) {

147 if (
state
->
nbc
 == 2 && 
c
 == '=' && 
text
[
text_index
] == '=') {

148 
state
->
nbc
 = 4;

149 
text_index
++;

150 
state
->
nbo
 = 1;

151 
state
->
v
 <<= 12;

152 } else if (
state
->
nbc
 == 3 && 
c
 == '=') {

153 
state
->
nbc
 = 4;

154 
state
->
nbo
 = 2;

155 
state
->
v
 <<= 6;

158 for (--
text_index
; 
text
[text_index] != 0; ++text_index) {

159 
c
 = 
text
[
text_index
];

160 if (!(
c
 == ' ' || c == '\t' || c == '\r' || c == '\n' || c == 0x0B || c == 0x0C))

165 if (
text
[
text_index
] == 0) {

169 
state
->
nbo
 = 0;

170 
state
->
status
 = 
PTLS_BASE64_DECODE_FAILED
;

171 
ret
 = 
PTLS_ERROR_INCORRECT_BASE64
;

175 
state
->
nbc
++;

176 
state
->
v
 <<= 6;

177 
state
->
v
 |= 
vc
;

180 if (
ret
 == 0 && 
state
->
nbc
 == 4) {

182 for (int 
j
 = 0; j < 
state
->
nbo
; j++) {

183 
decoded
[
j
] = (
uint8_t
)(
state
->
v
 >> (8 * (2 - j)));

186 
ret
 = 
	`ptls_buffer__do_pushv
(
buf
, 
decoded
, 
state
->
nbo
);

188 if (
ret
 == 0) {

190 if (
state
->
nbo
 < 3) {

192 while (
text
[
text_index
] != 0) {

193 
c
 = 
text
[
text_index
++];

195 if (
c
 == ' ' || c == '\t' || c == '\r' || c == '\n' || c == 0x0B || c == 0x0C) {

199 if (
text
[
text_index
] == 0) {

200 
state
->
status
 = 
PTLS_BASE64_DECODE_DONE
;

202 
state
->
status
 = 
PTLS_BASE64_DECODE_FAILED
;

203 
ret
 = 
PTLS_ERROR_INCORRECT_BASE64
;

207 
state
->
v
 = 0;

208 
state
->
nbo
 = 3;

209 
state
->
nbc
 = 0;

214 return 
ret
;

215 
	}
}

239 static int 
	$ptls_compare_separator_line
(const char *
line
, const char *
begin_or_end
, const char *
label
)

241 int 
ret
 = 
	`strncmp
(
line
, "-----", 5);

242 
size_t
 
text_index
 = 5;

244 if (
ret
 == 0) {

245 
size_t
 
begin_or_end_length
 = 
	`strlen
(
begin_or_end
);

246 
ret
 = 
	`strncmp
(
line
 + 
text_index
, 
begin_or_end
, 
begin_or_end_length
);

247 
text_index
 += 
begin_or_end_length
;

250 if (
ret
 == 0) {

251 
ret
 = 
line
[
text_index
] - ' ';

252 
text_index
++;

255 if (
ret
 == 0) {

256 
size_t
 
label_length
 = 
	`strlen
(
label
);

257 
ret
 = 
	`strncmp
(
line
 + 
text_index
, 
label
, 
label_length
);

258 
text_index
 += 
label_length
;

261 if (
ret
 == 0) {

262 
ret
 = 
	`strncmp
(
line
 + 
text_index
, "-----", 5);

265 return 
ret
;

266 
	}
}

268 static int 
	$ptls_get_pem_object
(
FILE
 *
F
, const char *
label
, 
ptls_buffer_t
 *
buf
)

270 int 
ret
 = 
PTLS_ERROR_PEM_LABEL_NOT_FOUND
;

271 char 
line
[256];

272 
ptls_base64_decode_state_t
 
state
;

275 while (
	`fgets
(
line
, 256, 
F
)) {

276 if (
	`ptls_compare_separator_line
(
line
, "BEGIN", 
label
) == 0) {

277 
ret
 = 0;

278 
	`ptls_base64_decode_init
(&
state
);

283 while (
ret
 == 0 && 
	`fgets
(
line
, 256, 
F
)) {

284 if (
	`ptls_compare_separator_line
(
line
, "END", 
label
) == 0) {

285 if (
state
.
status
 == 
PTLS_BASE64_DECODE_DONE
 || (state.status == 
PTLS_BASE64_DECODE_IN_PROGRESS
 && state.
nbc
 == 0)) {

286 
ret
 = 0;

288 
ret
 = 
PTLS_ERROR_INCORRECT_BASE64
;

292 
ret
 = 
	`ptls_base64_decode
(
line
, &
state
, 
buf
);

296 return 
ret
;

297 
	}
}

299 int 
	$ptls_load_pem_objects
(char const *
pem_fname
, const char *
label
, 
ptls_iovec_t
 *
list
, 
size_t
 
list_max
, size_t *
nb_objects
)

301 
FILE
 *
F
;

302 int 
ret
 = 0;

303 
size_t
 
count
 = 0;

304 #ifdef 
_WINDOWS


305 
errno_t
 
err
 = 
	`fopen_s
(&
F
, 
pem_fname
, "r");

306 if (
err
 != 0) {

307 
ret
 = -1;

310 
F
 = 
	`fopen
(
pem_fname
, "r");

311 if (
F
 == 
NULL
) {

312 
ret
 = -1;

316 *
nb_objects
 = 0;

318 if (
ret
 == 0) {

319 while (
count
 < 
list_max
) {

320 
ptls_buffer_t
 
buf
;

322 
	`ptls_buffer_init
(&
buf
, "", 0);

324 
ret
 = 
	`ptls_get_pem_object
(
F
, 
label
, &
buf
);

326 if (
ret
 == 0) {

327 if (
buf
.
off
 > 0 && buf.
is_allocated
) {

328 
list
[
count
].
base
 = 
buf
.base;

329 
list
[
count
].
len
 = 
buf
.
off
;

330 
count
++;

332 
	`ptls_buffer_dispose
(&
buf
);

335 
	`ptls_buffer_dispose
(&
buf
);

341 if (
ret
 == 
PTLS_ERROR_PEM_LABEL_NOT_FOUND
 && 
count
 > 0) {

342 
ret
 = 0;

345 *
nb_objects
 = 
count
;

347 if (
F
 != 
NULL
) {

348 
	`fclose
(
F
);

351 return 
ret
;

352 
	}
}

354 #define 
	#PTLS_MAX_CERTS_IN_CONTEXT
 16

	)

356 int 
	$ptls_load_certificates
(
ptls_context_t
 *
ctx
, char const *
cert_pem_file
)

358 int 
ret
 = 0;

360 
ctx
->
certificates
.
list
 = (
ptls_iovec_t
 *)
	`malloc
(
PTLS_MAX_CERTS_IN_CONTEXT
 * sizeof(ptls_iovec_t));

362 if (
ctx
->
certificates
.
list
 == 
NULL
) {

363 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

365 
ret
 = 
	`ptls_load_pem_objects
(
cert_pem_file
, "CERTIFICATE", 
ctx
->
certificates
.
list
, 
PTLS_MAX_CERTS_IN_CONTEXT
,

366 &
ctx
->
certificates
.
count
);

369 return 
ret
;

370 
	}
}

	@deps/picotls/lib/picotls.c

22 #include 
	~<assert.h
>

23 #include 
	~<stddef.h
>

24 #include 
	~<stdio.h
>

25 #include 
	~<stdlib.h
>

26 #include 
	~<string.h
>

27 #ifdef 
_WINDOWS


28 #include 
	~"wincompat.h
"

30 #include 
	~<arpa/inet.h
>

31 #include 
	~<sys/time.h
>

33 #include 
	~"picotls.h
"

34 #if 
PICOTLS_USE_DTRACE


35 #include 
	~"picotls-probes.h
"

38 #define 
	#PTLS_MAX_PLAINTEXT_RECORD_SIZE
 16384

	)

39 #define 
	#PTLS_MAX_ENCRYPTED_RECORD_SIZE
 (16384 + 256)

	)

41 #define 
	#PTLS_RECORD_VERSION_MAJOR
 3

	)

42 #define 
	#PTLS_RECORD_VERSION_MINOR
 3

	)

44 #define 
	#PTLS_CONTENT_TYPE_CHANGE_CIPHER_SPEC
 20

	)

45 #define 
	#PTLS_CONTENT_TYPE_ALERT
 21

	)

46 #define 
	#PTLS_CONTENT_TYPE_HANDSHAKE
 22

	)

47 #define 
	#PTLS_CONTENT_TYPE_APPDATA
 23

	)

49 #define 
	#PTLS_PSK_KE_MODE_PSK
 0

	)

50 #define 
	#PTLS_PSK_KE_MODE_PSK_DHE
 1

	)

52 #define 
	#PTLS_HANDSHAKE_HEADER_SIZE
 4

	)

54 #define 
	#PTLS_EXTENSION_TYPE_SERVER_NAME
 0

	)

55 #define 
	#PTLS_EXTENSION_TYPE_STATUS_REQUEST
 5

	)

56 #define 
	#PTLS_EXTENSION_TYPE_SUPPORTED_GROUPS
 10

	)

57 #define 
	#PTLS_EXTENSION_TYPE_SIGNATURE_ALGORITHMS
 13

	)

58 #define 
	#PTLS_EXTENSION_TYPE_ALPN
 16

	)

59 #define 
	#PTLS_EXTENSION_TYPE_SERVER_CERTIFICATE_TYPE
 20

	)

60 #define 
	#PTLS_EXTENSION_TYPE_COMPRESS_CERTIFICATE
 27

	)

61 #define 
	#PTLS_EXTENSION_TYPE_PRE_SHARED_KEY
 41

	)

62 #define 
	#PTLS_EXTENSION_TYPE_EARLY_DATA
 42

	)

63 #define 
	#PTLS_EXTENSION_TYPE_SUPPORTED_VERSIONS
 43

	)

64 #define 
	#PTLS_EXTENSION_TYPE_COOKIE
 44

	)

65 #define 
	#PTLS_EXTENSION_TYPE_PSK_KEY_EXCHANGE_MODES
 45

	)

66 #define 
	#PTLS_EXTENSION_TYPE_KEY_SHARE
 51

	)

67 #define 
	#PTLS_EXTENSION_TYPE_ENCRYPTED_SERVER_NAME
 0xffce

	)

69 #define 
	#PTLS_PROTOCOL_VERSION_TLS13_FINAL
 0x0304

	)

70 #define 
	#PTLS_PROTOCOL_VERSION_TLS13_DRAFT26
 0x7f1a

	)

71 #define 
	#PTLS_PROTOCOL_VERSION_TLS13_DRAFT27
 0x7f1b

	)

72 #define 
	#PTLS_PROTOCOL_VERSION_TLS13_DRAFT28
 0x7f1c

	)

74 #define 
	#PTLS_SERVER_NAME_TYPE_HOSTNAME
 0

	)

76 #define 
	#PTLS_SERVER_CERTIFICATE_VERIFY_CONTEXT_STRING
 "TLS 1.3, server CertificateVerify"

	)

77 #define 
	#PTLS_CLIENT_CERTIFICATE_VERIFY_CONTEXT_STRING
 "TLS 1.3, client CertificateVerify"

	)

78 #define 
	#PTLS_MAX_CERTIFICATE_VERIFY_SIGNDATA_SIZE
 \

79 (64 + sizeof(
PTLS_SERVER_CERTIFICATE_VERIFY_CONTEXT_STRING
) + 
PTLS_MAX_DIGEST_SIZE
 * 2)

	)

81 #define 
	#PTLS_EARLY_DATA_MAX_DELAY
 10000

	)

83 #ifndef 
PTLS_MAX_EARLY_DATA_SKIP_SIZE


84 #define 
	#PTLS_MAX_EARLY_DATA_SKIP_SIZE
 65536

	)

86 #if 
defined
(
PTLS_DEBUG
) && PTLS_DEBUG

87 #define 
	#PTLS_DEBUGF
(...) 
	`fprintf
(
stderr
, 
__VA_ARGS__
)

	)

89 #define 
	#PTLS_DEBUGF
(...)

	)

92 #ifndef 
PTLS_MEMORY_DEBUG


93 #define 
	#PTLS_MEMORY_DEBUG
 0

	)

96 #if 
PICOTLS_USE_DTRACE


97 #define 
	#PTLS_SHOULD_PROBE
(
LABEL
, 
tls
) (
	`PTLS_UNLIKELY
(
PICOTLS_
##LABEL##
	`_ENABLED
()) && !(tls)->
skip_tracing
)

	)

98 #define 
	#PTLS_PROBE0
(
LABEL
, 
tls
) \

100 
ptls_t
 *
_tls
 = (
tls
); \

101 if (
	`PTLS_SHOULD_PROBE
(
LABEL
, 
_tls
)) \

102 
PICOTLS_
##
	`LABEL
(
_tls
); \

103 } while (0)

	)

104 #define 
	#PTLS_PROBE
(
LABEL
, 
tls
, ...) \

106 
ptls_t
 *
_tls
 = (
tls
); \

107 if (
	`PTLS_SHOULD_PROBE
(
LABEL
, 
_tls
)) \

108 
PICOTLS_
##
	`LABEL
(
_tls
, 
__VA_ARGS__
); \

109 } while (0)

	)

111 #define 
	#PTLS_PROBE0
(
LABEL
, 
tls
)

	)

112 #define 
	#PTLS_PROBE
(
LABEL
, 
tls
, ...)

	)

118 static const 
uint16_t
 
	gsupported_versions
[] = {
PTLS_PROTOCOL_VERSION_TLS13_FINAL
, 
PTLS_PROTOCOL_VERSION_TLS13_DRAFT28
,

119 
PTLS_PROTOCOL_VERSION_TLS13_DRAFT27
, 
PTLS_PROTOCOL_VERSION_TLS13_DRAFT26
};

121 static const 
uint8_t
 
	ghello_retry_random
[
PTLS_HELLO_RANDOM_SIZE
] = {0xCF, 0x21, 0xAD, 0x74, 0xE5, 0x9A, 0x61, 0x11, 0xBE, 0x1D, 0x8C,

125 struct 
	sst_ptls_traffic_protection_t
 {

126 
uint8_t
 
	msecret
[
PTLS_MAX_DIGEST_SIZE
];

127 
size_t
 
	mepoch
;

129 
ptls_aead_context_t
 *
	maead
;

130 
uint64_t
 
	mseq
;

133 struct 
	sst_ptls_record_message_emitter_t
 {

134 
ptls_message_emitter_t
 
	msuper
;

135 
size_t
 
	mrec_start
;

138 struct 
	sst_ptls_signature_algorithms_t
 {

139 
uint16_t
 
	mlist
[16];

140 
size_t
 
	mcount
;

143 struct 
	sst_ptls_certificate_request_t
 {

147 
ptls_iovec_t
 
	mcontext
;

148 struct 
st_ptls_signature_algorithms_t
 
	msignature_algorithms
;

151 struct 
	sst_ptls_t
 {

155 
ptls_context_t
 *
	mctx
;

159 enum 
	een_ptls_state_t
 {

160 
	mPTLS_STATE_CLIENT_HANDSHAKE_START
,

161 
	mPTLS_STATE_CLIENT_EXPECT_SERVER_HELLO
,

162 
	mPTLS_STATE_CLIENT_EXPECT_SECOND_SERVER_HELLO
,

163 
	mPTLS_STATE_CLIENT_EXPECT_ENCRYPTED_EXTENSIONS
,

164 
	mPTLS_STATE_CLIENT_EXPECT_CERTIFICATE_REQUEST_OR_CERTIFICATE
,

165 
	mPTLS_STATE_CLIENT_EXPECT_CERTIFICATE
,

166 
	mPTLS_STATE_CLIENT_EXPECT_CERTIFICATE_VERIFY
,

167 
	mPTLS_STATE_CLIENT_EXPECT_FINISHED
,

168 
	mPTLS_STATE_SERVER_EXPECT_CLIENT_HELLO
,

169 
	mPTLS_STATE_SERVER_EXPECT_SECOND_CLIENT_HELLO
,

170 
	mPTLS_STATE_SERVER_EXPECT_CERTIFICATE
,

171 
	mPTLS_STATE_SERVER_EXPECT_CERTIFICATE_VERIFY
,

173 
	mPTLS_STATE_SERVER_EXPECT_END_OF_EARLY_DATA
,

174 
	mPTLS_STATE_SERVER_EXPECT_FINISHED
,

175 
	mPTLS_STATE_POST_HANDSHAKE_MIN
,

176 
	mPTLS_STATE_CLIENT_POST_HANDSHAKE
 = 
PTLS_STATE_POST_HANDSHAKE_MIN
,

177 
	mPTLS_STATE_SERVER_POST_HANDSHAKE


178 } 
	mstate
;

183 
ptls_buffer_t
 
	mrec
;

184 
ptls_buffer_t
 
	mmess
;

185 } 
	mrecvbuf
;

189 
ptls_key_schedule_t
 *
	mkey_schedule
;

194 struct 
st_ptls_traffic_protection_t
 
	mdec
;

195 struct 
st_ptls_traffic_protection_t
 
	menc
;

196 } 
	mtraffic_protection
;

200 char *
	mserver_name
;

204 char *
	mnegotiated_protocol
;

208 
ptls_key_exchange_algorithm_t
 *
	mkey_share
;

212 
ptls_cipher_suite_t
 *
	mcipher_suite
;

216 
uint8_t
 
	mclient_random
[
PTLS_HELLO_RANDOM_SIZE
];

220 
ptls_esni_secret_t
 *
	mesni
;

225 
uint8_t
 *
	mearly
;

226 
uint8_t
 *
	mone_rtt
;

227 } 
	mexporter_master_secret
;

229 unsigned 
	mis_server
 : 1;

230 unsigned 
	mis_psk_handshake
 : 1;

231 unsigned 
	msend_change_cipher_spec
 : 1;

232 unsigned 
	mneeds_key_update
 : 1;

233 unsigned 
	mkey_update_send_request
 : 1;

234 unsigned 
	mskip_tracing
 : 1;

240 
ptls_iovec_t
 
	mlegacy_session_id
;

241 
uint8_t
 
	mlegacy_session_id_buf
[32];

242 
ptls_key_exchange_context_t
 *
	mkey_share_ctx
;

243 unsigned 
	moffered_psk
 : 1;

247 unsigned 
	musing_early_data
 : 1;

248 struct 
st_ptls_certificate_request_t
 
	mcertificate_request
;

249 } 
	mclient
;

251 
uint8_t
 
	mpending_traffic_secret
[
PTLS_MAX_DIGEST_SIZE
];

252 
uint32_t
 
	mearly_data_skipped_bytes
;

253 } 
	mserver
;

260 int (*
	mcb
)(void *
	mverify_ctx
, 
uint16_t
 
	malgo
, 
ptls_iovec_t
 
	mdata
, ptls_iovec_t 
	msignature
);

261 void *
	mverify_ctx
;

262 } 
	mcertificate_verify
;

266 
uint8_t
 *
	mpending_handshake_secret
;

270 void *
	mdata_ptr
;

273 struct 
	sst_ptls_record_t
 {

274 
uint8_t
 
	mtype
;

275 
uint16_t
 
	mversion
;

276 
size_t
 
	mlength
;

277 const 
uint8_t
 *
	mfragment
;

280 struct 
	sst_ptls_client_hello_psk_t
 {

281 
ptls_iovec_t
 
	midentity
;

282 
uint32_t
 
	mobfuscated_ticket_age
;

283 
ptls_iovec_t
 
	mbinder
;

286 #define 
	#MAX_UNKNOWN_EXTENSIONS
 16

	)

287 #define 
	#MAX_CLIENT_CIPHERS
 32

	)

288 #define 
	#MAX_CERTIFICATE_TYPES
 8

	)

290 struct 
	sst_ptls_client_hello_t
 {

291 
uint16_t
 
	mlegacy_version
;

292 const 
uint8_t
 *
	mrandom_bytes
;

293 
ptls_iovec_t
 
	mlegacy_session_id
;

295 const 
uint8_t
 *
	mids
;

296 
size_t
 
	mcount
;

297 } 
	mcompression_methods
;

298 
uint16_t
 
	mselected_version
;

299 
ptls_iovec_t
 
	mcipher_suites
;

300 
ptls_iovec_t
 
	mnegotiated_groups
;

301 
ptls_iovec_t
 
	mkey_shares
;

302 struct 
st_ptls_signature_algorithms_t
 
	msignature_algorithms
;

303 
ptls_iovec_t
 
	mserver_name
;

305 
ptls_cipher_suite_t
 *
	mcipher
;

306 
ptls_key_exchange_algorithm_t
 *
	mkey_share
;

307 
ptls_iovec_t
 
	mpeer_key
;

308 const 
uint8_t
 *
	mrecord_digest
;

309 
ptls_iovec_t
 
	mencrypted_sni
;

310 } 
	mesni
;

312 
ptls_iovec_t
 
	mlist
[16];

313 
size_t
 
	mcount
;

314 } 
	malpn
;

316 
uint16_t
 
	mlist
[16];

317 
size_t
 
	mcount
;

318 } 
	mcert_compression_algos
;

320 
uint16_t
 
	mlist
[
MAX_CLIENT_CIPHERS
];

321 
size_t
 
	mcount
;

322 } 
	mclient_ciphers
;

324 
ptls_iovec_t
 
	mall
;

325 
ptls_iovec_t
 
	mtbs
;

326 
ptls_iovec_t
 
	mch1_hash
;

327 
ptls_iovec_t
 
	msignature
;

328 unsigned 
	msent_key_share
 : 1;

329 } 
	mcookie
;

331 const 
uint8_t
 *
	mhash_end
;

333 struct 
st_ptls_client_hello_psk_t
 
	mlist
[4];

334 
size_t
 
	mcount
;

335 } 
	midentities
;

336 unsigned 
	mke_modes
;

337 unsigned 
	mearly_data_indication
 : 1;

338 unsigned 
	mis_last_extension
 : 1;

339 } 
	mpsk
;

341 
uint8_t
 
	mlist
[
MAX_CERTIFICATE_TYPES
];

342 
size_t
 
	mcount
;

343 } 
	mserver_certificate_types
;

344 
ptls_raw_extension_t
 
	munknown_extensions
[
MAX_UNKNOWN_EXTENSIONS
 + 1];

345 unsigned 
	mstatus_request
 : 1;

348 struct 
	sst_ptls_server_hello_t
 {

349 
uint8_t
 
	mrandom_
[
PTLS_HELLO_RANDOM_SIZE
];

350 
ptls_iovec_t
 
	mlegacy_session_id
;

351 int 
	mis_retry_request
;

353 
ptls_iovec_t
 
	mpeerkey
;

355 
uint16_t
 
	mselected_group
;

356 
ptls_iovec_t
 
	mcookie
;

357 } 
	mretry_request
;

361 struct 
	sst_ptls_key_schedule_t
 {

362 unsigned 
	mgeneration
;

363 const char *
	mhkdf_label_prefix
;

364 
uint8_t
 
	msecret
[
PTLS_MAX_DIGEST_SIZE
];

365 
size_t
 
	mnum_hashes
;

367 
ptls_hash_algorithm_t
 *
	malgo
;

368 
ptls_hash_context_t
 *
	mctx
;

369 } 
	mhashes
[1];

372 struct 
	sst_ptls_extension_decoder_t
 {

373 
uint16_t
 
	mtype
;

374 int (*
	mcb
)(
ptls_t
 *
	mtls
, void *
	marg
, const 
uint8_t
 *
	msrc
, const uint8_t *const 
	mend
);

377 struct 
	sst_ptls_extension_bitmap_t
 {

378 
uint8_t
 
	mbits
[8];

381 static const 
uint8_t
 
	gzeroes_of_max_digest_size
[
PTLS_MAX_DIGEST_SIZE
] = {0};

383 static int 
hkdf_expand_label
(
ptls_hash_algorithm_t
 *
algo
, void *
output
, 
size_t
 
outlen
, 
ptls_iovec_t
 
secret
, const char *
label
,

384 
ptls_iovec_t
 
hash_value
, const char *
label_prefix
);

385 static 
ptls_aead_context_t
 *
new_aead
(
ptls_aead_algorithm_t
 *
aead
, 
ptls_hash_algorithm_t
 *
hash
, int 
is_enc
, const void *
secret
,

386 
ptls_iovec_t
 
hash_value
, const char *
label_prefix
);

388 static int 
	$is_supported_version
(
uint16_t
 
v
)

390 
size_t
 
i
;

391 for (
i
 = 0; i != 
	`PTLS_ELEMENTSOF
(
supported_versions
); ++i)

392 if (
supported_versions
[
i
] == 
v
)

395 
	}
}

397 static 
inline
 int 
	$extension_bitmap_is_set
(struct 
st_ptls_extension_bitmap_t
 *
bitmap
, 
uint16_t
 
id
)

399 if (
id
 < sizeof(
bitmap
->
bits
) * 8)

400 return (
bitmap
->
bits
[
id
 / 8] & (1 << (id % 8))) != 0;

402 
	}
}

404 static 
inline
 void 
	$extension_bitmap_set
(struct 
st_ptls_extension_bitmap_t
 *
bitmap
, 
uint16_t
 
id
)

406 if (
id
 < sizeof(
bitmap
->
bits
) * 8)

407 
bitmap
->
bits
[
id
 / 8] |= 1 << (id % 8);

408 
	}
}

410 static 
inline
 void 
	$init_extension_bitmap
(struct 
st_ptls_extension_bitmap_t
 *
bitmap
, 
uint8_t
 
hstype
)

412 *
bitmap
 = (struct 
st_ptls_extension_bitmap_t
){{0}};

414 #define 
	#EXT
(
extid
, 
proc
) \

416 int 
_found
 = 0; \

418 
proc
 \

420 if (!
_found
) \

421 
	`extension_bitmap_set
(
bitmap
, 
PTLS_EXTENSION_TYPE_
##
extid
); \

422 } while (0)

	)

423 #define 
	#ALLOW
(
allowed_hstype
) 
_found
 = _found || 
hstype
 == 
PTLS_HANDSHAKE_TYPE_
##
	)
allowed_hstype

428 
	`EXT
(
SERVER_NAME
, {

429 
	`ALLOW
(
CLIENT_HELLO
);

430 
	`ALLOW
(
ENCRYPTED_EXTENSIONS
);

432 
	`EXT
(
STATUS_REQUEST
, {

433 
	`ALLOW
(
CLIENT_HELLO
);

434 
	`ALLOW
(
CERTIFICATE
);

435 
	`ALLOW
(
CERTIFICATE_REQUEST
);

437 
	`EXT
(
SUPPORTED_GROUPS
, {

438 
	`ALLOW
(
CLIENT_HELLO
);

439 
	`ALLOW
(
ENCRYPTED_EXTENSIONS
);

441 
	`EXT
(
SIGNATURE_ALGORITHMS
, {

442 
	`ALLOW
(
CLIENT_HELLO
);

443 
	`ALLOW
(
CERTIFICATE_REQUEST
);

445 
	`EXT
(
ALPN
, {

446 
	`ALLOW
(
CLIENT_HELLO
);

447 
	`ALLOW
(
ENCRYPTED_EXTENSIONS
);

449 
	`EXT
(
KEY_SHARE
, {

450 
	`ALLOW
(
CLIENT_HELLO
);

451 
	`ALLOW
(
SERVER_HELLO
);

453 
	`EXT
(
PRE_SHARED_KEY
, {

454 
	`ALLOW
(
CLIENT_HELLO
);

455 
	`ALLOW
(
SERVER_HELLO
);

457 
	`EXT
(
PSK_KEY_EXCHANGE_MODES
, { 
	`ALLOW
(
CLIENT_HELLO
); });

458 
	`EXT
(
EARLY_DATA
, {

459 
	`ALLOW
(
CLIENT_HELLO
);

460 
	`ALLOW
(
ENCRYPTED_EXTENSIONS
);

461 
	`ALLOW
(
NEW_SESSION_TICKET
);

463 
	`EXT
(
COOKIE
, {

464 
	`ALLOW
(
CLIENT_HELLO
);

465 
	`ALLOW
(
SERVER_HELLO
);

467 
	`EXT
(
SUPPORTED_VERSIONS
, {

468 
	`ALLOW
(
CLIENT_HELLO
);

469 
	`ALLOW
(
SERVER_HELLO
);

471 
	`EXT
(
SERVER_CERTIFICATE_TYPE
, {

472 
	`ALLOW
(
CLIENT_HELLO
);

473 
	`ALLOW
(
ENCRYPTED_EXTENSIONS
);

476 #undef 
ALLOW


477 #undef 
EXT


478 
	}
}

480 #ifndef 
ntoh16


481 static 
uint16_t
 
	$ntoh16
(const 
uint8_t
 *
src
)

483 return (
uint16_t
)
src
[0] << 8 | src[1];

484 
	}
}

487 #ifndef 
ntoh24


488 static 
uint32_t
 
	$ntoh24
(const 
uint8_t
 *
src
)

490 return (
uint32_t
)
src
[0] << 16 | (uint32_t)src[1] << 8 | src[2];

491 
	}
}

494 #ifndef 
ntoh32


495 static 
uint32_t
 
	$ntoh32
(const 
uint8_t
 *
src
)

497 return (
uint32_t
)
src
[0] << 24 | (uint32_t)src[1] << 16 | (uint32_t)src[2] << 8 | src[3];

498 
	}
}

501 #ifndef 
ntoh64


502 static 
uint64_t
 
	$ntoh64
(const 
uint8_t
 *
src
)

504 return (
uint64_t
)
src
[0] << 56 | (uint64_t)src[1] << 48 | (uint64_t)src[2] << 40 | (uint64_t)src[3] << 32 |

505 (
uint64_t
)
src
[4] << 24 | (uint64_t)src[5] << 16 | (uint64_t)src[6] << 8 | src[7];

506 
	}
}

509 void 
	$ptls_buffer__release_memory
(
ptls_buffer_t
 *
buf
)

511 
	`ptls_clear_memory
(
buf
->
base
, buf->
off
);

512 if (
buf
->
is_allocated
)

513 
	`free
(
buf
->
base
);

514 
	}
}

516 int 
	$ptls_buffer_reserve
(
ptls_buffer_t
 *
buf
, 
size_t
 
delta
)

518 if (
buf
->
base
 == 
NULL
)

519 return 
PTLS_ERROR_NO_MEMORY
;

521 if (
PTLS_MEMORY_DEBUG
 || 
buf
->
capacity
 < buf->
off
 + 
delta
) {

522 
uint8_t
 *
newp
;

523 
size_t
 
new_capacity
 = 
buf
->
capacity
;

524 if (
new_capacity
 < 1024)

525 
new_capacity
 = 1024;

526 while (
new_capacity
 < 
buf
->
off
 + 
delta
) {

527 
new_capacity
 *= 2;

529 if ((
newp
 = 
	`malloc
(
new_capacity
)) == 
NULL
)

530 return 
PTLS_ERROR_NO_MEMORY
;

531 
	`memcpy
(
newp
, 
buf
->
base
, buf->
off
);

532 
	`ptls_buffer__release_memory
(
buf
);

533 
buf
->
base
 = 
newp
;

534 
buf
->
capacity
 = 
new_capacity
;

535 
buf
->
is_allocated
 = 1;

539 
	}
}

541 int 
	$ptls_buffer__do_pushv
(
ptls_buffer_t
 *
buf
, const void *
src
, 
size_t
 
len
)

543 int 
ret
;

545 if (
len
 == 0)

547 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
len
)) != 0)

548 return 
ret
;

549 
	`memcpy
(
buf
->
base
 + buf->
off
, 
src
, 
len
);

550 
buf
->
off
 += 
len
;

552 
	}
}

554 int 
	$ptls_buffer__adjust_quic_blocksize
(
ptls_buffer_t
 *
buf
, 
size_t
 
body_size
)

556 
uint8_t
 
sizebuf
[
PTLS_ENCODE_QUICINT_CAPACITY
];

557 
size_t
 
sizelen
 = 
	`ptls_encode_quicint
(
sizebuf
, 
body_size
) - sizebuf;

560 if (
sizelen
 != 1) {

561 int 
ret
;

562 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
sizelen
 - 1)) != 0)

563 return 
ret
;

564 
	`memmove
(
buf
->
base
 + buf->
off
 - 
body_size
 - 1 + 
sizelen
, buf->base + buf->off - body_size, body_size);

565 
buf
->
off
 += 
sizelen
 - 1;

569 
	`memcpy
(
buf
->
base
 + buf->
off
 - 
body_size
 - 
sizelen
, 
sizebuf
, sizelen);

572 
	}
}

574 int 
	$ptls_buffer__adjust_asn1_blocksize
(
ptls_buffer_t
 *
buf
, 
size_t
 
body_size
)

576 
	`fprintf
(
stderr
, "unimplemented\n");

577 
	`abort
();

578 
	}
}

580 int 
	$ptls_buffer_push_asn1_ubigint
(
ptls_buffer_t
 *
buf
, const void *
bignum
, 
size_t
 
size
)

582 const 
uint8_t
 *
p
 = 
bignum
, *const 
end
 = p + 
size
;

583 int 
ret
;

586 for (; 
end
 - 
p
 >= 1; ++p)

587 if (*
p
 != 0)

591 
	`ptls_buffer_push
(
buf
, 2);

592 
	`ptls_buffer_push_asn1_block
(
buf
, {

593 if (*
p
 >= 0x80)

594 
	`ptls_buffer_push
(
buf
, 0);

595 if (
p
 != 
end
) {

596 
	`ptls_buffer_pushv
(
buf
, 
p
, 
end
 - p);

598 
	`ptls_buffer_pushv
(
buf
, "", 1);

601 
ret
 = 0;

603 
Exit
:

604 return 
ret
;

605 
	}
}

607 #if 
PTLS_FUZZ_HANDSHAKE


609 static 
size_t
 
	$aead_encrypt
(struct 
st_ptls_traffic_protection_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
,

610 
uint8_t
 
content_type
)

612 
	`memcpy
(
output
, 
input
, 
inlen
);

613 
	`memcpy
(
output
 + 
inlen
, &
content_type
, 1);

614 return 
inlen
 + 1 + 16;

615 
	}
}

617 static int 
	$aead_decrypt
(struct 
st_ptls_traffic_protection_t
 *
ctx
, void *
output
, 
size_t
 *
outlen
, const void *
input
, size_t 
inlen
)

619 if (
inlen
 < 16) {

620 return 
PTLS_ALERT_BAD_RECORD_MAC
;

622 
	`memcpy
(
output
, 
input
, 
inlen
 - 16);

623 *
outlen
 = 
inlen
 - 16;

625 
	}
}

629 static void 
	$build_aad
(
uint8_t
 
aad
[5], 
size_t
 
reclen
)

631 
aad
[0] = 
PTLS_CONTENT_TYPE_APPDATA
;

632 
aad
[1] = 
PTLS_RECORD_VERSION_MAJOR
;

633 
aad
[2] = 
PTLS_RECORD_VERSION_MINOR
;

634 
aad
[3] = (
uint8_t
)(
reclen
 >> 8);

635 
aad
[4] = (
uint8_t
)
reclen
;

636 
	}
}

638 static 
size_t
 
	$aead_encrypt
(struct 
st_ptls_traffic_protection_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
,

639 
uint8_t
 
content_type
)

641 
uint8_t
 
aad
[5];

642 
size_t
 
off
 = 0;

644 
	`build_aad
(
aad
, 
inlen
 + 1 + 
ctx
->
aead
->
algo
->
tag_size
);

645 
	`ptls_aead_encrypt_init
(
ctx
->
aead
, ctx->
seq
++, 
aad
, sizeof(aad));

646 
off
 += 
	`ptls_aead_encrypt_update
(
ctx
->
aead
, ((
uint8_t
 *)
output
) + off, 
input
, 
inlen
);

647 
off
 += 
	`ptls_aead_encrypt_update
(
ctx
->
aead
, ((
uint8_t
 *)
output
) + off, &
content_type
, 1);

648 
off
 += 
	`ptls_aead_encrypt_final
(
ctx
->
aead
, ((
uint8_t
 *)
output
) + off);

650 return 
off
;

651 
	}
}

653 static int 
	$aead_decrypt
(struct 
st_ptls_traffic_protection_t
 *
ctx
, void *
output
, 
size_t
 *
outlen
, const void *
input
, size_t 
inlen
)

655 
uint8_t
 
aad
[5];

657 
	`build_aad
(
aad
, 
inlen
);

658 if ((*
outlen
 = 
	`ptls_aead_decrypt
(
ctx
->
aead
, 
output
, 
input
, 
inlen
, ctx->
seq
, 
aad
, sizeof(aad))) == 
SIZE_MAX
)

659 return 
PTLS_ALERT_BAD_RECORD_MAC
;

660 ++
ctx
->
seq
;

662 
	}
}

666 #define 
	#buffer_push_record
(
buf
, 
type
, 
block
) \

668 
	`ptls_buffer_push
((
buf
), (
type
), 
PTLS_RECORD_VERSION_MAJOR
, 
PTLS_RECORD_VERSION_MINOR
); \

669 
	`ptls_buffer_push_block
((
buf
), 2, 
block
); \

670 } while (0)

	)

672 static int 
	$buffer_push_encrypted_records
(
ptls_buffer_t
 *
buf
, 
uint8_t
 
type
, const uint8_t *
src
, 
size_t
 
len
,

673 struct 
st_ptls_traffic_protection_t
 *
enc
)

675 int 
ret
 = 0;

677 while (
len
 != 0) {

678 
size_t
 
chunk_size
 = 
len
;

679 if (
chunk_size
 > 
PTLS_MAX_PLAINTEXT_RECORD_SIZE
)

680 
chunk_size
 = 
PTLS_MAX_PLAINTEXT_RECORD_SIZE
;

681 
	`buffer_push_record
(
buf
, 
PTLS_CONTENT_TYPE_APPDATA
, {

682 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
chunk_size
 + 
enc
->
aead
->
algo
->
tag_size
 + 1)) != 0)

683 goto 
Exit
;

684 
buf
->
off
 += 
	`aead_encrypt
(
enc
, buf->
base
 + buf->off, 
src
, 
chunk_size
, 
type
);

686 
src
 += 
chunk_size
;

687 
len
 -= 
chunk_size
;

690 
Exit
:

691 return 
ret
;

692 
	}
}

694 static int 
	$buffer_encrypt_record
(
ptls_buffer_t
 *
buf
, 
size_t
 
rec_start
, struct 
st_ptls_traffic_protection_t
 *
enc
)

696 
size_t
 
bodylen
 = 
buf
->
off
 - 
rec_start
 - 5;

697 
uint8_t
 *
tmpbuf
, 
type
 = 
buf
->
base
[
rec_start
];

698 int 
ret
;

701 if (
bodylen
 <= 
PTLS_MAX_PLAINTEXT_RECORD_SIZE
) {

702 
size_t
 
overhead
 = 1 + 
enc
->
aead
->
algo
->
tag_size
;

703 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
overhead
)) != 0)

704 return 
ret
;

705 
size_t
 
encrypted_len
 = 
	`aead_encrypt
(
enc
, 
buf
->
base
 + 
rec_start
 + 5, buf->base + rec_start + 5, 
bodylen
, 
type
);

706 
	`assert
(
encrypted_len
 == 
bodylen
 + 
overhead
);

707 
buf
->
off
 += 
overhead
;

708 
buf
->
base
[
rec_start
] = 
PTLS_CONTENT_TYPE_APPDATA
;

709 
buf
->
base
[
rec_start
 + 3] = (
encrypted_len
 >> 8) & 0xff;

710 
buf
->
base
[
rec_start
 + 4] = 
encrypted_len
 & 0xff;

715 if ((
tmpbuf
 = 
	`malloc
(
bodylen
)) == 
NULL
) {

716 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

717 goto 
Exit
;

719 
	`memcpy
(
tmpbuf
, 
buf
->
base
 + 
rec_start
 + 5, 
bodylen
);

720 
	`ptls_clear_memory
(
buf
->
base
 + 
rec_start
, 
bodylen
 + 5);

721 
buf
->
off
 = 
rec_start
;

724 
ret
 = 
	`buffer_push_encrypted_records
(
buf
, 
type
, 
tmpbuf
, 
bodylen
, 
enc
);

726 
Exit
:

727 if (
tmpbuf
 != 
NULL
) {

728 
	`ptls_clear_memory
(
tmpbuf
, 
bodylen
);

729 
	`free
(
tmpbuf
);

731 return 
ret
;

732 
	}
}

734 static int 
	$begin_record_message
(
ptls_message_emitter_t
 *
_self
)

736 struct 
st_ptls_record_message_emitter_t
 *
self
 = (void *)
_self
;

737 int 
ret
;

739 
self
->
rec_start
 = self->
super
.
buf
->
off
;

740 
	`ptls_buffer_push
(
self
->
super
.
buf
, 
PTLS_CONTENT_TYPE_HANDSHAKE
, 
PTLS_RECORD_VERSION_MAJOR
, 
PTLS_RECORD_VERSION_MINOR
, 0, 0);

741 
ret
 = 0;

742 
Exit
:

743 return 
ret
;

744 
	}
}

746 static int 
	$commit_record_message
(
ptls_message_emitter_t
 *
_self
)

748 struct 
st_ptls_record_message_emitter_t
 *
self
 = (void *)
_self
;

749 int 
ret
;

751 if (
self
->
super
.
enc
->
aead
 != 
NULL
) {

752 
ret
 = 
	`buffer_encrypt_record
(
self
->
super
.
buf
, self->
rec_start
, self->super.
enc
);

755 
size_t
 
sz
 = 
self
->
super
.
buf
->
off
 - self->
rec_start
 - 5;

756 
	`assert
(
sz
 <= 
PTLS_MAX_PLAINTEXT_RECORD_SIZE
);

757 
self
->
super
.
buf
->
base
[self->
rec_start
 + 3] = (
uint8_t
)(
sz
 >> 8);

758 
self
->
super
.
buf
->
base
[self->
rec_start
 + 4] = (
uint8_t
)(
sz
);

759 
ret
 = 0;

762 return 
ret
;

763 
	}
}

765 #define 
	#buffer_push_extension
(
buf
, 
type
, 
block
) \

767 
	`ptls_buffer_push16
((
buf
), (
type
)); \

768 
	`ptls_buffer_push_block
((
buf
), 2, 
block
); \

769 } while (0);

	)

771 #define 
	#decode_open_extensions
(
src
, 
end
, 
hstype
, 
exttype
, 
block
) \

773 struct 
st_ptls_extension_bitmap_t
 
bitmap
; \

774 
	`init_extension_bitmap
(&
bitmap
, (
hstype
)); \

775 
	`ptls_decode_open_block
((
src
), 
end
, 2, { \

776 while ((
src
) != 
end
) { \

777 if ((
ret
 = 
	`ptls_decode16
((
exttype
), &(
src
), 
end
)) != 0) \

778 goto 
Exit
; \

779 if (
	`extension_bitmap_is_set
(&
bitmap
, *(
exttype
)) != 0) { \

780 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
; \

781 goto 
Exit
; \

783 
	`extension_bitmap_set
(&
bitmap
, *(
exttype
)); \

784 
	`ptls_decode_open_block
((
src
), 
end
, 2, 
block
); \

787 } while (0)

	)

789 #define 
	#decode_extensions
(
src
, 
end
, 
hstype
, 
exttype
, 
block
) \

791 
	`decode_open_extensions
((
src
), 
end
, 
hstype
, 
exttype
, 
block
); \

792 
	`ptls_decode_assert_block_close
((
src
), 
end
); \

793 } while (0)

	)

795 int 
	$ptls_decode16
(
uint16_t
 *
value
, const 
uint8_t
 **
src
, const uint8_t *
end
)

797 if (
end
 - *
src
 < 2)

798 return 
PTLS_ALERT_DECODE_ERROR
;

799 *
value
 = 
	`ntoh16
(*
src
);

800 *
src
 += 2;

802 
	}
}

804 int 
	$ptls_decode24
(
uint32_t
 *
value
, const 
uint8_t
 **
src
, const uint8_t *
end
)

806 if (
end
 - *
src
 < 3)

807 return 
PTLS_ALERT_DECODE_ERROR
;

808 *
value
 = ((
uint32_t
)(*
src
)[0] << 16) | ((uint32_t)(*src)[1] << 8) | (*src)[2];

809 *
src
 += 3;

811 
	}
}

813 int 
	$ptls_decode32
(
uint32_t
 *
value
, const 
uint8_t
 **
src
, const uint8_t *
end
)

815 if (
end
 - *
src
 < 4)

816 return 
PTLS_ALERT_DECODE_ERROR
;

817 *
value
 = 
	`ntoh32
(*
src
);

818 *
src
 += 4;

820 
	}
}

822 int 
	$ptls_decode64
(
uint64_t
 *
value
, const 
uint8_t
 **
src
, const uint8_t *
end
)

824 if (
end
 - *
src
 < 8)

825 return 
PTLS_ALERT_DECODE_ERROR
;

826 *
value
 = 
	`ntoh64
(*
src
);

827 *
src
 += 8;

829 
	}
}

831 
uint64_t
 
	$ptls_decode_quicint
(const 
uint8_t
 **
src
, const uint8_t *
end
)

833 if (
	`PTLS_UNLIKELY
(*
src
 == 
end
))

834 return 
UINT64_MAX
;

836 
uint8_t
 
b
 = *(*
src
)++;

838 if (
	`PTLS_LIKELY
(
b
 <= 0x3f))

839 return 
b
;

841 
uint64_t
 
v
 = 
b
 & 0x3f;

842 unsigned 
bytes_left
 = (1 << (
b
 >> 6)) - 1;

843 if (
	`PTLS_UNLIKELY
((
size_t
)(
end
 - *
src
) < 
bytes_left
))

844 return 
UINT64_MAX
;

846 
v
 = (v << 8) | *(*
src
)++;

847 } while (--
bytes_left
 != 0);

848 return 
v
;

849 
	}
}

851 static void 
	$log_secret
(
ptls_t
 *
tls
, const char *
type
, 
ptls_iovec_t
 
secret
)

853 char 
hexbuf
[
PTLS_MAX_DIGEST_SIZE
 * 2 + 1];

855 
	`PTLS_PROBE
(
NEW_SECRET
, 
tls
, 
type
, 
	`ptls_hexdump
(
hexbuf
, 
secret
.
base
, secret.
len
));

857 if (
tls
->
ctx
->
log_event
 != 
NULL
)

858 
tls
->
ctx
->
log_event
->
	`cb
(tls->ctx->log_event, tls, 
type
, "%s", 
	`ptls_hexdump
(
hexbuf
, 
secret
.
base
, secret.
len
));

859 
	}
}

861 static void 
	$key_schedule_free
(
ptls_key_schedule_t
 *
sched
)

863 
size_t
 
i
;

864 
	`ptls_clear_memory
(
sched
->
secret
, sizeof(sched->secret));

865 for (
i
 = 0; i != 
sched
->
num_hashes
; ++i)

866 
sched
->
hashes
[
i
].
ctx
->
	`final
(sched->hashes[i].ctx, 
NULL
, 
PTLS_HASH_FINAL_MODE_FREE
);

867 
	`free
(
sched
);

868 
	}
}

870 static 
ptls_key_schedule_t
 *
	$key_schedule_new
(
ptls_cipher_suite_t
 *
preferred
, ptls_cipher_suite_t **
offered
,

871 const char *
hkdf_label_prefix
)

873 #define 
	#FOREACH_HASH
(
block
) \

875 
ptls_cipher_suite_t
 *
cs
; \

876 if ((
cs
 = 
preferred
) != 
NULL
) { \

877 
block
 \

879 if (
offered
 != 
NULL
) { \

880 
size_t
 
i
, 
j
; \

881 for (
i
 = 0; (
cs
 = 
offered
[i]) != 
NULL
; ++i) { \

882 if (
preferred
 == 
NULL
 || 
cs
->
hash
 != preferred->hash) { \

883 for (
j
 = 0; j != 
i
; ++j) \

884 if (
cs
->
hash
 == 
offered
[
j
]->hash) \

886 if (
j
 == 
i
) { \

887 
block
 \

892 } while (0)

	)

894 
ptls_key_schedule_t
 *
sched
;

896 if (
hkdf_label_prefix
 == 
NULL
)

897 
hkdf_label_prefix
 = 
PTLS_HKDF_EXPAND_LABEL_PREFIX
;

900 
size_t
 
num_hashes
 = 0;

901 
	`FOREACH_HASH
({ ++
num_hashes
; });

902 if ((
sched
 = 
	`malloc
(
	`offsetof
(
ptls_key_schedule_t
, 
hashes
) + sizeof(sched->hashes[0]) * 
num_hashes
)) == 
NULL
)

903 return 
NULL
;

904 *
sched
 = (
ptls_key_schedule_t
){0, 
hkdf_label_prefix
};

908 
	`FOREACH_HASH
({

909 
sched
->
hashes
[sched->
num_hashes
].
algo
 = 
cs
->
hash
;

910 if ((
sched
->
hashes
[sched->
num_hashes
].
ctx
 = 
cs
->
hash
->
	`create
()) == 
NULL
)

911 goto 
Fail
;

912 ++
sched
->
num_hashes
;

915 return 
sched
;

916 
Fail
:

917 
	`key_schedule_free
(
sched
);

918 return 
NULL
;

920 #undef 
FOREACH_HASH


921 
	}
}

923 static int 
	$key_schedule_extract
(
ptls_key_schedule_t
 *
sched
, 
ptls_iovec_t
 
ikm
)

925 int 
ret
;

927 if (
ikm
.
base
 == 
NULL
)

928 
ikm
 = 
	`ptls_iovec_init
(
zeroes_of_max_digest_size
, 
sched
->
hashes
[0].
algo
->
digest_size
);

930 if (
sched
->
generation
 != 0 &&

931 (
ret
 = 
	`hkdf_expand_label
(
sched
->
hashes
[0].
algo
, sched->
secret
, sched->hashes[0].algo->
digest_size
,

932 
	`ptls_iovec_init
(
sched
->
secret
, sched->
hashes
[0].
algo
->
digest_size
), "derived",

933 
	`ptls_iovec_init
(
sched
->
hashes
[0].
algo
->
empty_digest
, sched->hashes[0].algo->
digest_size
),

934 
sched
->
hkdf_label_prefix
)) != 0)

935 return 
ret
;

937 ++
sched
->
generation
;

938 
ret
 = 
	`ptls_hkdf_extract
(
sched
->
hashes
[0].
algo
, sched->
secret
,

939 
	`ptls_iovec_init
(
sched
->
secret
, sched->
hashes
[0].
algo
->
digest_size
), 
ikm
);

940 
	`PTLS_DEBUGF
("%s: %u, %02x%02x\n", 
__FUNCTION__
, 
sched
->
generation
, (int)sched->
secret
[0], (int)sched->secret[1]);

941 return 
ret
;

942 
	}
}

944 static int 
	$key_schedule_select_one
(
ptls_key_schedule_t
 *
sched
, 
ptls_cipher_suite_t
 *
cs
, int 
reset
)

946 
size_t
 
found_slot
 = 
SIZE_MAX
, 
i
;

947 int 
ret
;

949 
	`assert
(
sched
->
generation
 == 1);

952 for (
i
 = 0; i != 
sched
->
num_hashes
; ++i) {

953 if (
sched
->
hashes
[
i
].
algo
 == 
cs
->
hash
) {

954 
	`assert
(
found_slot
 == 
SIZE_MAX
);

955 
found_slot
 = 
i
;

957 
sched
->
hashes
[
i
].
ctx
->
	`final
(sched->hashes[i].ctx, 
NULL
, 
PTLS_HASH_FINAL_MODE_FREE
);

960 if (
found_slot
 != 0) {

961 
sched
->
hashes
[0] = sched->hashes[
found_slot
];

962 
reset
 = 1;

964 
sched
->
num_hashes
 = 1;

967 if (
reset
) {

968 --
sched
->
generation
;

969 
	`memset
(
sched
->
secret
, 0, sizeof(sched->secret));

970 if ((
ret
 = 
	`key_schedule_extract
(
sched
, 
	`ptls_iovec_init
(
NULL
, 0))) != 0)

971 goto 
Exit
;

974 
ret
 = 0;

975 
Exit
:

976 return 
ret
;

977 
	}
}

979 void 
	$ptls__key_schedule_update_hash
(
ptls_key_schedule_t
 *
sched
, const 
uint8_t
 *
msg
, 
size_t
 
msglen
)

981 
size_t
 
i
;

983 
	`PTLS_DEBUGF
("%s:%zu\n", 
__FUNCTION__
, 
msglen
);

984 for (
i
 = 0; i != 
sched
->
num_hashes
; ++i)

985 
sched
->
hashes
[
i
].
ctx
->
	`update
(sched->hashes[i].ctx, 
msg
, 
msglen
);

986 
	}
}

988 static void 
	$key_schedule_update_ch1hash_prefix
(
ptls_key_schedule_t
 *
sched
)

990 
uint8_t
 
prefix
[4] = {
PTLS_HANDSHAKE_TYPE_MESSAGE_HASH
, 0, 0, (uint8_t)
sched
->
hashes
[0].
algo
->
digest_size
};

991 
	`ptls__key_schedule_update_hash
(
sched
, 
prefix
, sizeof(prefix));

992 
	}
}

994 static void 
	$key_schedule_extract_ch1hash
(
ptls_key_schedule_t
 *
sched
, 
uint8_t
 *
hash
)

996 
sched
->
hashes
[0].
ctx
->
	`final
(sched->hashes[0].ctx, 
hash
, 
PTLS_HASH_FINAL_MODE_RESET
);

997 
	}
}

999 static void 
	$key_schedule_transform_post_ch1hash
(
ptls_key_schedule_t
 *
sched
)

1001 
uint8_t
 
ch1hash
[
PTLS_MAX_DIGEST_SIZE
];

1003 
	`key_schedule_extract_ch1hash
(
sched
, 
ch1hash
);

1005 
	`key_schedule_update_ch1hash_prefix
(
sched
);

1006 
	`ptls__key_schedule_update_hash
(
sched
, 
ch1hash
, sched->
hashes
[0].
algo
->
digest_size
);

1007 
	}
}

1009 static int 
	$derive_secret_with_hash
(
ptls_key_schedule_t
 *
sched
, void *
secret
, const char *
label
, const 
uint8_t
 *
hash
)

1011 int 
ret
 = 
	`hkdf_expand_label
(
sched
->
hashes
[0].
algo
, 
secret
, sched->hashes[0].algo->
digest_size
,

1012 
	`ptls_iovec_init
(
sched
->
secret
, sched->
hashes
[0].
algo
->
digest_size
), 
label
,

1013 
	`ptls_iovec_init
(
hash
, 
sched
->
hashes
[0].
algo
->
digest_size
), sched->
hkdf_label_prefix
);

1014 
	`PTLS_DEBUGF
("%s: (label=%s, hash=%02x%02x) => %02x%02x\n", 
__FUNCTION__
, 
label
, 
hash
[0], hash[1], ((
uint8_t
 *)
secret
)[0],

1015 ((
uint8_t
 *)
secret
)[1]);

1016 return 
ret
;

1017 
	}
}

1019 static int 
	$derive_secret
(
ptls_key_schedule_t
 *
sched
, void *
secret
, const char *
label
)

1021 
uint8_t
 
hash_value
[
PTLS_MAX_DIGEST_SIZE
];

1023 
sched
->
hashes
[0].
ctx
->
	`final
(sched->hashes[0].ctx, 
hash_value
, 
PTLS_HASH_FINAL_MODE_SNAPSHOT
);

1024 int 
ret
 = 
	`derive_secret_with_hash
(
sched
, 
secret
, 
label
, 
hash_value
);

1025 
	`ptls_clear_memory
(
hash_value
, sizeof(hash_value));

1026 return 
ret
;

1027 
	}
}

1029 static int 
	$derive_secret_with_empty_digest
(
ptls_key_schedule_t
 *
sched
, void *
secret
, const char *
label
)

1031 return 
	`derive_secret_with_hash
(
sched
, 
secret
, 
label
, sched->
hashes
[0].
algo
->
empty_digest
);

1032 
	}
}

1034 static int 
	$derive_exporter_secret
(
ptls_t
 *
tls
, int 
is_early
)

1036 int 
ret
;

1038 if (!
tls
->
ctx
->
use_exporter
)

1041 
uint8_t
 **
slot
 = 
is_early
 ? &
tls
->
exporter_master_secret
.
early
 : &tls->exporter_master_secret.
one_rtt
;

1042 
	`assert
(*
slot
 == 
NULL
);

1043 if ((*
slot
 = 
	`malloc
(
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
)) == 
NULL
)

1044 return 
PTLS_ERROR_NO_MEMORY
;

1046 if ((
ret
 = 
	`derive_secret
(
tls
->
key_schedule
, *
slot
, 
is_early
 ? "e exp master" : "exp master")) != 0)

1047 return 
ret
;

1049 
	`log_secret
(
tls
, 
is_early
 ? "EARLY_EXPORTER_SECRET" : "EXPORTER_SECRET",

1050 
	`ptls_iovec_init
(*
slot
, 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
));

1053 
	}
}

1055 static void 
	$free_exporter_master_secret
(
ptls_t
 *
tls
, int 
is_early
)

1057 
uint8_t
 *
slot
 = 
is_early
 ? 
tls
->
exporter_master_secret
.
early
 : tls->exporter_master_secret.
one_rtt
;

1058 if (
slot
 == 
NULL
)

1060 
	`assert
(
tls
->
key_schedule
 != 
NULL
);

1061 
	`ptls_clear_memory
(
slot
, 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
);

1062 
	`free
(
slot
);

1063 
	}
}

1065 static int 
	$derive_resumption_secret
(
ptls_key_schedule_t
 *
sched
, 
uint8_t
 *
secret
, 
ptls_iovec_t
 
nonce
)

1067 int 
ret
;

1069 if ((
ret
 = 
	`derive_secret
(
sched
, 
secret
, "res master")) != 0)

1070 goto 
Exit
;

1071 if ((
ret
 = 
	`hkdf_expand_label
(
sched
->
hashes
[0].
algo
, 
secret
, sched->hashes[0].algo->
digest_size
,

1072 
	`ptls_iovec_init
(
secret
, 
sched
->
hashes
[0].
algo
->
digest_size
), "resumption", 
nonce
,

1073 
sched
->
hkdf_label_prefix
)) != 0)

1074 goto 
Exit
;

1076 
Exit
:

1077 if (
ret
 != 0)

1078 
	`ptls_clear_memory
(
secret
, 
sched
->
hashes
[0].
algo
->
digest_size
);

1079 return 
ret
;

1080 
	}
}

1082 static int 
	$decode_new_session_ticket
(
ptls_t
 *
tls
, 
uint32_t
 *
lifetime
, uint32_t *
age_add
, 
ptls_iovec_t
 *
nonce
, ptls_iovec_t *
ticket
,

1083 
uint32_t
 *
max_early_data_size
, const 
uint8_t
 *
src
, const uint8_t *const 
end
)

1085 
uint16_t
 
exttype
;

1086 int 
ret
;

1088 if ((
ret
 = 
	`ptls_decode32
(
lifetime
, &
src
, 
end
)) != 0)

1089 goto 
Exit
;

1090 if ((
ret
 = 
	`ptls_decode32
(
age_add
, &
src
, 
end
)) != 0)

1091 goto 
Exit
;

1092 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

1093 *
nonce
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

1094 
src
 = 
end
;

1096 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

1097 if (
src
 == 
end
) {

1098 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

1099 goto 
Exit
;

1101 *
ticket
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

1102 
src
 = 
end
;

1105 *
max_early_data_size
 = 0;

1106 
	`decode_extensions
(
src
, 
end
, 
PTLS_HANDSHAKE_TYPE_NEW_SESSION_TICKET
, &
exttype
, {

1107 if (
tls
->
ctx
->
on_extension
 != 
NULL
 &&

1108 (
ret
 = 
tls
->
ctx
->
on_extension
->
	`cb
(tls->ctx->on_extension, tls, 
PTLS_HANDSHAKE_TYPE_NEW_SESSION_TICKET
, 
exttype
,

1109 
	`ptls_iovec_init
(
src
, 
end
 - src)) != 0))

1110 goto 
Exit
;

1111 switch (
exttype
) {

1112 case 
PTLS_EXTENSION_TYPE_EARLY_DATA
:

1113 if ((
ret
 = 
	`ptls_decode32
(
max_early_data_size
, &
src
, 
end
)) != 0)

1114 goto 
Exit
;

1117 
src
 = 
end
;

1122 
ret
 = 0;

1123 
Exit
:

1124 return 
ret
;

1125 
	}
}

1127 static int 
	$decode_stored_session_ticket
(
ptls_t
 *
tls
, 
ptls_key_exchange_algorithm_t
 **
key_share
, 
ptls_cipher_suite_t
 **
cs
,

1128 
ptls_iovec_t
 *
secret
, 
uint32_t
 *
obfuscated_ticket_age
, ptls_iovec_t *
ticket
,

1129 
uint32_t
 *
max_early_data_size
, const 
uint8_t
 *
src
, const uint8_t *const 
end
)

1131 
uint16_t
 
kxid
, 
csid
;

1132 
uint32_t
 
lifetime
, 
age_add
;

1133 
uint64_t
 
obtained_at
, 
now
;

1134 
ptls_iovec_t
 
nonce
;

1135 int 
ret
;

1138 if ((
ret
 = 
	`ptls_decode64
(&
obtained_at
, &
src
, 
end
)) != 0)

1139 goto 
Exit
;

1140 if ((
ret
 = 
	`ptls_decode16
(&
kxid
, &
src
, 
end
)) != 0)

1141 goto 
Exit
;

1142 if ((
ret
 = 
	`ptls_decode16
(&
csid
, &
src
, 
end
)) != 0)

1143 goto 
Exit
;

1144 
	`ptls_decode_open_block
(
src
, 
end
, 3, {

1145 if ((
ret
 = 
	`decode_new_session_ticket
(
tls
, &
lifetime
, &
age_add
, &
nonce
, 
ticket
, 
max_early_data_size
, 
src
, 
end
)) != 0)

1146 goto 
Exit
;

1147 
src
 = 
end
;

1149 
	`ptls_decode_block
(
src
, 
end
, 2, {

1150 *
secret
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

1151 
src
 = 
end
;

1155 
ptls_key_exchange_algorithm_t
 **
cand
;

1156 for (
cand
 = 
tls
->
ctx
->
key_exchanges
; *cand != 
NULL
; ++cand)

1157 if ((*
cand
)->
id
 == 
kxid
)

1159 if (*
cand
 == 
NULL
) {

1160 
ret
 = 
PTLS_ERROR_LIBRARY
;

1161 goto 
Exit
;

1163 *
key_share
 = *
cand
;

1167 
ptls_cipher_suite_t
 **
cand
;

1168 for (
cand
 = 
tls
->
ctx
->
cipher_suites
; *cand != 
NULL
; ++cand)

1169 if ((*
cand
)->
id
 == 
csid
)

1171 if (*
cand
 == 
NULL
) {

1172 
ret
 = 
PTLS_ERROR_LIBRARY
;

1173 goto 
Exit
;

1175 *
cs
 = *
cand
;

1179 
now
 = 
tls
->
ctx
->
get_time
->
	`cb
(tls->ctx->get_time);

1180 if (!(
obtained_at
 <= 
now
 && now - obtained_at < 7 * 86400 * 1000)) {

1181 
ret
 = 
PTLS_ERROR_LIBRARY
;

1182 goto 
Exit
;

1184 *
obfuscated_ticket_age
 = (
uint32_t
)(
now
 - 
obtained_at
) + 
age_add
;

1186 
ret
 = 0;

1187 
Exit
:

1188 return 
ret
;

1189 
	}
}

1191 static int 
	$get_traffic_key
(
ptls_hash_algorithm_t
 *
algo
, void *
key
, 
size_t
 
key_size
, int 
is_iv
, const void *
secret
,

1192 
ptls_iovec_t
 
hash_value
, const char *
label_prefix
)

1194 return 
	`ptls_hkdf_expand_label
(
algo
, 
key
, 
key_size
, 
	`ptls_iovec_init
(
secret
, algo->
digest_size
), 
is_iv
 ? "iv" : "key", 
hash_value
,

1195 
label_prefix
);

1196 
	}
}

1198 static int 
	$setup_traffic_protection
(
ptls_t
 *
tls
, int 
is_enc
, const char *
secret_label
, 
size_t
 
epoch
, int 
skip_notify
)

1200 static const char *
log_labels
[2][4] = {

1201 {
NULL
, "CLIENT_EARLY_TRAFFIC_SECRET", "CLIENT_HANDSHAKE_TRAFFIC_SECRET", "CLIENT_TRAFFIC_SECRET_0"},

1202 {
NULL
, NULL, "SERVER_HANDSHAKE_TRAFFIC_SECRET", "SERVER_TRAFFIC_SECRET_0"}};

1203 struct 
st_ptls_traffic_protection_t
 *
ctx
 = 
is_enc
 ? &
tls
->
traffic_protection
.
enc
 : &tls->traffic_protection.
dec
;

1205 if (
secret_label
 != 
NULL
) {

1206 int 
ret
;

1207 if ((
ret
 = 
	`derive_secret
(
tls
->
key_schedule
, 
ctx
->
secret
, 
secret_label
)) != 0)

1208 return 
ret
;

1211 
ctx
->
epoch
 = epoch;

1214 if (
tls
->
ctx
->
update_traffic_key
 != 
NULL
) {

1215 if (
skip_notify
)

1217 return 
tls
->
ctx
->
update_traffic_key
->
	`cb
(tls->ctx->update_traffic_key, tls, 
is_enc
, 
epoch
, ctx->
secret
);

1220 if (
ctx
->
aead
 != 
NULL
)

1221 
	`ptls_aead_free
(
ctx
->
aead
);

1222 if ((
ctx
->
aead
 = 
	`ptls_aead_new
(
tls
->
cipher_suite
->aead, tls->cipher_suite->
hash
, 
is_enc
, ctx->
secret
,

1223 
tls
->
ctx
->
hkdf_label_prefix__obsolete
)) == 
NULL
)

1224 return 
PTLS_ERROR_NO_MEMORY
;

1225 
ctx
->
seq
 = 0;

1227 
	`log_secret
(
tls
, 
log_labels
[
	`ptls_is_server
(tls) == 
is_enc
][
epoch
],

1228 
	`ptls_iovec_init
(
ctx
->
secret
, 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
));

1229 
	`PTLS_DEBUGF
("[%s] %02x%02x,%02x%02x\n", 
log_labels
[
	`ptls_is_server
(
tls
)][
epoch
], (unsigned)
ctx
->
secret
[0],

1230 (unsigned)
ctx
->
secret
[1], (unsigned)ctx->
aead
->
static_iv
[0], (unsigned)ctx->aead->static_iv[1]);

1233 
	}
}

1235 static int 
	$commission_handshake_secret
(
ptls_t
 *
tls
)

1237 int 
is_enc
 = !
	`ptls_is_server
(
tls
);

1239 
	`assert
(
tls
->
pending_handshake_secret
 != 
NULL
);

1240 
	`memcpy
((
is_enc
 ? &
tls
->
traffic_protection
.
enc
 : &tls->traffic_protection.
dec
)->
secret
, tls->
pending_handshake_secret
,

1241 
PTLS_MAX_DIGEST_SIZE
);

1242 
	`ptls_clear_memory
(
tls
->
pending_handshake_secret
, 
PTLS_MAX_DIGEST_SIZE
);

1243 
	`free
(
tls
->
pending_handshake_secret
);

1244 
tls
->
pending_handshake_secret
 = 
NULL
;

1246 return 
	`setup_traffic_protection
(
tls
, 
is_enc
, 
NULL
, 2, 1);

1247 
	}
}

1249 static void 
	$log_client_random
(
ptls_t
 *
tls
)

1251 
	`PTLS_PROBE
(
CLIENT_RANDOM
, 
tls
,

1252 
	`ptls_hexdump
(
	`alloca
(sizeof(
tls
->
client_random
) * 2 + 1), tls->client_random, sizeof(tls->client_random)));

1253 
	}
}

1255 #define 
	#SESSION_IDENTIFIER_MAGIC
 "ptls0001"

	)

1256 #define 
	#SESSION_IDENTIFIER_MAGIC_SIZE
 (sizeof(
SESSION_IDENTIFIER_MAGIC
) - 1)

	)

1258 static int 
	$encode_session_identifier
(
ptls_context_t
 *
ctx
, 
ptls_buffer_t
 *
buf
, 
uint32_t
 
ticket_age_add
, 
ptls_iovec_t
 
ticket_nonce
,

1259 
ptls_key_schedule_t
 *
sched
, const char *
server_name
, 
uint16_t
 
key_exchange_id
, uint16_t 
csid
,

1260 const char *
negotiated_protocol
)

1262 int 
ret
 = 0;

1264 
	`ptls_buffer_push_block
(
buf
, 2, {

1266 
	`ptls_buffer_pushv
(
buf
, 
SESSION_IDENTIFIER_MAGIC
, 
SESSION_IDENTIFIER_MAGIC_SIZE
);

1268 
	`ptls_buffer_push64
(
buf
, 
ctx
->
get_time
->
	`cb
(ctx->get_time));

1270 
	`ptls_buffer_push_block
(
buf
, 2, {

1271 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
sched
->
hashes
[0].
algo
->
digest_size
)) != 0)

1272 goto 
Exit
;

1273 if ((
ret
 = 
	`derive_resumption_secret
(
sched
, 
buf
->
base
 + buf->
off
, 
ticket_nonce
)) != 0)

1274 goto 
Exit
;

1275 
buf
->
off
 += 
sched
->
hashes
[0].
algo
->
digest_size
;

1278 
	`ptls_buffer_push16
(
buf
, 
key_exchange_id
);

1280 
	`ptls_buffer_push16
(
buf
, 
csid
);

1282 
	`ptls_buffer_push32
(
buf
, 
ticket_age_add
);

1284 
	`ptls_buffer_push_block
(
buf
, 2, {

1285 if (
server_name
 != 
NULL
)

1286 
	`ptls_buffer_pushv
(
buf
, 
server_name
, 
	`strlen
(server_name));

1289 
	`ptls_buffer_push_block
(
buf
, 1, {

1290 if (
negotiated_protocol
 != 
NULL
)

1291 
	`ptls_buffer_pushv
(
buf
, 
negotiated_protocol
, 
	`strlen
(negotiated_protocol));

1295 
Exit
:

1296 return 
ret
;

1297 
	}
}

1299 int 
	$decode_session_identifier
(
uint64_t
 *
issued_at
, 
ptls_iovec_t
 *
psk
, 
uint32_t
 *
ticket_age_add
, ptls_iovec_t *
server_name
,

1300 
uint16_t
 *
key_exchange_id
, uint16_t *
csid
, 
ptls_iovec_t
 *
negotiated_protocol
, const 
uint8_t
 *
src
,

1301 const 
uint8_t
 *const 
end
)

1303 int 
ret
 = 0;

1305 
	`ptls_decode_block
(
src
, 
end
, 2, {

1306 if (
end
 - 
src
 < 
SESSION_IDENTIFIER_MAGIC_SIZE
 ||

1307 
	`memcmp
(
src
, 
SESSION_IDENTIFIER_MAGIC
, 
SESSION_IDENTIFIER_MAGIC_SIZE
) != 0) {

1308 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

1309 goto 
Exit
;

1311 
src
 += 
SESSION_IDENTIFIER_MAGIC_SIZE
;

1312 if ((
ret
 = 
	`ptls_decode64
(
issued_at
, &
src
, 
end
)) != 0)

1313 goto 
Exit
;

1314 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

1315 *
psk
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

1316 
src
 = 
end
;

1318 if ((
ret
 = 
	`ptls_decode16
(
key_exchange_id
, &
src
, 
end
)) != 0)

1319 goto 
Exit
;

1320 if ((
ret
 = 
	`ptls_decode16
(
csid
, &
src
, 
end
)) != 0)

1321 goto 
Exit
;

1322 if ((
ret
 = 
	`ptls_decode32
(
ticket_age_add
, &
src
, 
end
)) != 0)

1323 goto 
Exit
;

1324 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

1325 *
server_name
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

1326 
src
 = 
end
;

1328 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

1329 *
negotiated_protocol
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

1330 
src
 = 
end
;

1334 
Exit
:

1335 return 
ret
;

1336 
	}
}

1338 static 
size_t
 
	$build_certificate_verify_signdata
(
uint8_t
 *
data
, 
ptls_key_schedule_t
 *
sched
, const char *
context_string
)

1340 
size_t
 
datalen
 = 0;

1342 
	`memset
(
data
 + 
datalen
, 32, 64);

1343 
datalen
 += 64;

1344 
	`memcpy
(
data
 + 
datalen
, 
context_string
, 
	`strlen
(context_string) + 1);

1345 
datalen
 += 
	`strlen
(
context_string
) + 1;

1346 
sched
->
hashes
[0].
ctx
->
	`final
(sched->hashes[0].ctx, 
data
 + 
datalen
, 
PTLS_HASH_FINAL_MODE_SNAPSHOT
);

1347 
datalen
 += 
sched
->
hashes
[0].
algo
->
digest_size
;

1348 
	`assert
(
datalen
 <= 
PTLS_MAX_CERTIFICATE_VERIFY_SIGNDATA_SIZE
);

1350 return 
datalen
;

1351 
	}
}

1353 static int 
	$calc_verify_data
(void *
output
, 
ptls_key_schedule_t
 *
sched
, const void *
secret
)

1355 
ptls_hash_context_t
 *
hmac
;

1356 
uint8_t
 
digest
[
PTLS_MAX_DIGEST_SIZE
];

1357 int 
ret
;

1359 if ((
ret
 = 
	`hkdf_expand_label
(
sched
->
hashes
[0].
algo
, 
digest
, sched->hashes[0].algo->
digest_size
,

1360 
	`ptls_iovec_init
(
secret
, 
sched
->
hashes
[0].
algo
->
digest_size
), "finished", ptls_iovec_init(
NULL
, 0),

1361 
sched
->
hkdf_label_prefix
)) != 0)

1362 return 
ret
;

1363 if ((
hmac
 = 
	`ptls_hmac_create
(
sched
->
hashes
[0].
algo
, 
digest
, sched->hashes[0].algo->
digest_size
)) == 
NULL
) {

1364 
	`ptls_clear_memory
(
digest
, sizeof(digest));

1365 return 
PTLS_ERROR_NO_MEMORY
;

1368 
sched
->
hashes
[0].
ctx
->
	`final
(sched->hashes[0].ctx, 
digest
, 
PTLS_HASH_FINAL_MODE_SNAPSHOT
);

1369 
	`PTLS_DEBUGF
("%s: %02x%02x,%02x%02x\n", 
__FUNCTION__
, ((
uint8_t
 *)
secret
)[0], ((uint8_t *)secret)[1], 
digest
[0], digest[1]);

1370 
hmac
->
	`update
(hmac, 
digest
, 
sched
->
hashes
[0].
algo
->
digest_size
);

1371 
	`ptls_clear_memory
(
digest
, sizeof(digest));

1372 
hmac
->
	`final
(hmac, 
output
, 
PTLS_HASH_FINAL_MODE_FREE
);

1375 
	}
}

1377 static int 
	$verify_finished
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
)

1379 
uint8_t
 
verify_data
[
PTLS_MAX_DIGEST_SIZE
];

1380 int 
ret
;

1382 if (
PTLS_HANDSHAKE_HEADER_SIZE
 + 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
 != 
message
.
len
) {

1383 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

1384 goto 
Exit
;

1387 if ((
ret
 = 
	`calc_verify_data
(
verify_data
, 
tls
->
key_schedule
, tls->
traffic_protection
.
dec
.
secret
)) != 0)

1388 goto 
Exit
;

1389 if (!
	`ptls_mem_equal
(
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, 
verify_data
, 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
)) {

1390 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

1391 goto 
Exit
;

1394 
Exit
:

1395 
	`ptls_clear_memory
(
verify_data
, sizeof(verify_data));

1396 return 
ret
;

1397 
	}
}

1399 static int 
	$send_finished
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
)

1401 int 
ret
;

1403 
	`ptls_push_message
(
emitter
, 
tls
->
key_schedule
, 
PTLS_HANDSHAKE_TYPE_FINISHED
, {

1404 if ((
ret
 = 
	`ptls_buffer_reserve
(
emitter
->
buf
, 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
)) != 0)

1405 goto 
Exit
;

1406 if ((
ret
 = 
	`calc_verify_data
(
emitter
->
buf
->
base
 + emitter->buf->
off
, 
tls
->
key_schedule
,

1407 
tls
->
traffic_protection
.
enc
.
secret
)) != 0)

1408 goto 
Exit
;

1409 
emitter
->
buf
->
off
 += 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
;

1412 
Exit
:

1413 return 
ret
;

1414 
	}
}

1416 static int 
	$send_session_ticket
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
)

1418 
ptls_hash_context_t
 *
msghash_backup
 = 
tls
->
key_schedule
->
hashes
[0].
ctx
->
	`clone_
(tls->key_schedule->hashes[0].ctx);

1419 
ptls_buffer_t
 
session_id
;

1420 char 
session_id_smallbuf
[128];

1421 
uint32_t
 
ticket_age_add
;

1422 int 
ret
 = 0;

1424 
	`assert
(
tls
->
ctx
->
ticket_lifetime
 != 0);

1425 
	`assert
(
tls
->
ctx
->
encrypt_ticket
 != 
NULL
);

1428 
size_t
 
orig_off
 = 
emitter
->
buf
->
off
;

1429 if (
tls
->
pending_handshake_secret
 != 
NULL
 && !tls->
ctx
->
omit_end_of_early_data
) {

1430 
	`assert
(
tls
->
state
 == 
PTLS_STATE_SERVER_EXPECT_END_OF_EARLY_DATA
);

1431 
	`ptls_buffer_push_message_body
(
emitter
->
buf
, 
tls
->
key_schedule
, 
PTLS_HANDSHAKE_TYPE_END_OF_EARLY_DATA
, {});

1432 
emitter
->
buf
->
off
 = 
orig_off
;

1434 
	`ptls_buffer_push_message_body
(
emitter
->
buf
, 
tls
->
key_schedule
, 
PTLS_HANDSHAKE_TYPE_FINISHED
, {

1435 if ((
ret
 = 
	`ptls_buffer_reserve
(
emitter
->
buf
, 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
)) != 0)

1436 goto 
Exit
;

1437 if ((
ret
 = 
	`calc_verify_data
(
emitter
->
buf
->
base
 + emitter->buf->
off
, 
tls
->
key_schedule
,

1438 
tls
->
pending_handshake_secret
 != 
NULL
 ? tls->pending_handshake_secret

1439 : 
tls
->
traffic_protection
.
dec
.
secret
)) != 0)

1440 goto 
Exit
;

1441 
emitter
->
buf
->
off
 += 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
;

1443 
emitter
->
buf
->
off
 = 
orig_off
;

1446 
tls
->
ctx
->
	`random_bytes
(&
ticket_age_add
, sizeof(ticket_age_add));

1449 
	`ptls_buffer_init
(&
session_id
, 
session_id_smallbuf
, sizeof(session_id_smallbuf));

1450 
ret
 = 
	`encode_session_identifier
(
tls
->
ctx
, &
session_id
, 
ticket_age_add
, 
	`ptls_iovec_init
(
NULL
, 0), tls->
key_schedule
,

1451 
tls
->
server_name
, tls->
key_share
->
id
, tls->
cipher_suite
->id, tls->
negotiated_protocol
);

1452 if (
ret
 != 0)

1453 goto 
Exit
;

1456 
	`ptls_push_message
(
emitter
, 
tls
->
key_schedule
, 
PTLS_HANDSHAKE_TYPE_NEW_SESSION_TICKET
, {

1457 
	`ptls_buffer_push32
(
emitter
->
buf
, 
tls
->
ctx
->
ticket_lifetime
);

1458 
	`ptls_buffer_push32
(
emitter
->
buf
, 
ticket_age_add
);

1459 
	`ptls_buffer_push_block
(
emitter
->
buf
, 1, {});

1460 
	`ptls_buffer_push_block
(
emitter
->
buf
, 2, {

1461 if ((
ret
 = 
tls
->
ctx
->
encrypt_ticket
->
	`cb
(tls->ctx->encrypt_ticket, tls, 1, 
emitter
->
buf
,

1462 
	`ptls_iovec_init
(
session_id
.
base
, session_id.
off
))) != 0)

1463 goto 
Exit
;

1465 
	`ptls_buffer_push_block
(
emitter
->
buf
, 2, {

1466 if (
tls
->
ctx
->
max_early_data_size
 != 0)

1467 
	`buffer_push_extension
(
emitter
->
buf
, 
PTLS_EXTENSION_TYPE_EARLY_DATA
,

1468 { 
	`ptls_buffer_push32
(
emitter
->
buf
, 
tls
->
ctx
->
max_early_data_size
); });

1472 
Exit
:

1473 
	`ptls_buffer_dispose
(&
session_id
);

1476 
tls
->
key_schedule
->
hashes
[0].
ctx
->
	`final
(tls->key_schedule->hashes[0].ctx, 
NULL
, 
PTLS_HASH_FINAL_MODE_FREE
);

1477 
tls
->
key_schedule
->
hashes
[0].
ctx
 = 
msghash_backup
;

1479 return 
ret
;

1480 
	}
}

1482 static int 
	$push_change_cipher_spec
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
)

1484 int 
ret
;

1487 if (!
tls
->
send_change_cipher_spec
) {

1488 
ret
 = 0;

1489 goto 
Exit
;

1493 if (
emitter
->
begin_message
 != 
begin_record_message
) {

1494 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

1495 goto 
Exit
;

1499 
	`buffer_push_record
(
emitter
->
buf
, 
PTLS_CONTENT_TYPE_CHANGE_CIPHER_SPEC
, { 
	`ptls_buffer_push
(emitter->buf, 1); });

1501 
tls
->
send_change_cipher_spec
 = 0;

1502 
ret
 = 0;

1503 
Exit
:

1504 return 
ret
;

1505 
	}
}

1507 static int 
	$push_additional_extensions
(
ptls_handshake_properties_t
 *
properties
, 
ptls_buffer_t
 *
sendbuf
)

1509 int 
ret
;

1511 if (
properties
 != 
NULL
 && properties->
additional_extensions
 != NULL) {

1512 
ptls_raw_extension_t
 *
ext
;

1513 for (
ext
 = 
properties
->
additional_extensions
; ext->
type
 != 
UINT16_MAX
; ++ext) {

1514 
	`buffer_push_extension
(
sendbuf
, 
ext
->
type
, { 
	`ptls_buffer_pushv
(sendbuf, ext->
data
.
base
, ext->data.
len
); });

1517 
ret
 = 0;

1518 
Exit
:

1519 return 
ret
;

1520 
	}
}

1522 static int 
	$push_signature_algorithms
(
ptls_verify_certificate_t
 *
vc
, 
ptls_buffer_t
 *
sendbuf
)

1525 static const 
uint16_t
 
default_algos
[] = {
PTLS_SIGNATURE_RSA_PSS_RSAE_SHA256
, 
PTLS_SIGNATURE_ECDSA_SECP256R1_SHA256
,

1526 
PTLS_SIGNATURE_RSA_PKCS1_SHA256
, 
PTLS_SIGNATURE_RSA_PKCS1_SHA1
, 
UINT16_MAX
};

1527 int 
ret
;

1529 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

1530 for (const 
uint16_t
 *
p
 = 
vc
 != 
NULL
 ? vc->
algos
 : 
default_algos
; *p != 
UINT16_MAX
; ++p)

1531 
	`ptls_buffer_push16
(
sendbuf
, *
p
);

1534 
ret
 = 0;

1535 
Exit
:

1536 return 
ret
;

1537 
	}
}

1539 static int 
	$decode_signature_algorithms
(struct 
st_ptls_signature_algorithms_t
 *
sa
, const 
uint8_t
 **
src
, const uint8_t *
end
)

1541 int 
ret
;

1543 
	`ptls_decode_block
(*
src
, 
end
, 2, {

1545 
uint16_t
 
id
;

1546 if ((
ret
 = 
	`ptls_decode16
(&
id
, 
src
, 
end
)) != 0)

1547 goto 
Exit
;

1548 if (
sa
->
count
 < 
	`PTLS_ELEMENTSOF
(sa->
list
))

1549 
sa
->
list
[sa->
count
++] = 
id
;

1550 } while (*
src
 != 
end
);

1553 
ret
 = 0;

1554 
Exit
:

1555 return 
ret
;

1556 
	}
}

1558 static 
ptls_hash_context_t
 *
	$create_sha256_context
(
ptls_context_t
 *
ctx
)

1560 
ptls_cipher_suite_t
 **
cs
;

1562 for (
cs
 = 
ctx
->
cipher_suites
; *cs != 
NULL
; ++cs) {

1563 switch ((*
cs
)->
id
) {

1564 case 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
:

1565 case 
PTLS_CIPHER_SUITE_CHACHA20_POLY1305_SHA256
:

1566 return (*
cs
)->
hash
->
	`create
();

1570 return 
NULL
;

1571 
	}
}

1573 static int 
	$select_cipher
(
ptls_cipher_suite_t
 **
selected
, ptls_cipher_suite_t **
candidates
, const 
uint8_t
 *
src
,

1574 const 
uint8_t
 *const 
end
, int 
server_preference
)

1576 
size_t
 
found_index
 = 
SIZE_MAX
;

1577 int 
ret
;

1579 while (
src
 != 
end
) {

1580 
uint16_t
 
id
;

1581 if ((
ret
 = 
	`ptls_decode16
(&
id
, &
src
, 
end
)) != 0)

1582 goto 
Exit
;

1583 for (
size_t
 
i
 = 0; 
candidates
[i] != 
NULL
; ++i) {

1584 if (
candidates
[
i
]->
id
 == id) {

1585 if (
server_preference
) {

1587 if (
i
 < 
found_index
) {

1588 
found_index
 = 
i
;

1593 *
selected
 = 
candidates
[
i
];

1594 goto 
Exit
;

1599 if (
found_index
 != 
SIZE_MAX
) {

1600 *
selected
 = 
candidates
[
found_index
];

1601 
ret
 = 0;

1603 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

1606 
Exit
:

1607 return 
ret
;

1608 
	}
}

1610 static int 
	$push_key_share_entry
(
ptls_buffer_t
 *
buf
, 
uint16_t
 
group
, 
ptls_iovec_t
 
pubkey
)

1612 int 
ret
;

1614 
	`ptls_buffer_push16
(
buf
, 
group
);

1615 
	`ptls_buffer_push_block
(
buf
, 2, { 
	`ptls_buffer_pushv
(buf, 
pubkey
.
base
, pubkey.
len
); });

1616 
ret
 = 0;

1617 
Exit
:

1618 return 
ret
;

1619 
	}
}

1621 static int 
	$decode_key_share_entry
(
uint16_t
 *
group
, 
ptls_iovec_t
 *
key_exchange
, const 
uint8_t
 **
src
, const uint8_t *const 
end
)

1623 int 
ret
;

1625 if ((
ret
 = 
	`ptls_decode16
(
group
, 
src
, 
end
)) != 0)

1626 goto 
Exit
;

1627 
	`ptls_decode_open_block
(*
src
, 
end
, 2, {

1628 *
key_exchange
 = 
	`ptls_iovec_init
(*
src
, 
end
 - *src);

1629 *
src
 = 
end
;

1632 
Exit
:

1633 return 
ret
;

1634 
	}
}

1636 static int 
	$select_key_share
(
ptls_key_exchange_algorithm_t
 **
selected
, 
ptls_iovec_t
 *
peer_key
,

1637 
ptls_key_exchange_algorithm_t
 **
candidates
, const 
uint8_t
 **
src
, const uint8_t *const 
end
,

1638 int 
expect_one
)

1640 int 
ret
;

1642 *
selected
 = 
NULL
;

1644 if (
expect_one
 && *
src
 == 
end
) {

1645 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

1646 goto 
Exit
;

1649 while (*
src
 != 
end
) {

1650 
uint16_t
 
group
;

1651 
ptls_iovec_t
 
key
;

1652 if ((
ret
 = 
	`decode_key_share_entry
(&
group
, &
key
, 
src
, 
end
)) != 0)

1653 goto 
Exit
;

1654 
ptls_key_exchange_algorithm_t
 **
c
 = 
candidates
;

1655 for (; *
c
 != 
NULL
; ++c) {

1656 if (*
selected
 == 
NULL
 && (*
c
)->
id
 == 
group
) {

1657 *
selected
 = *
c
;

1658 *
peer_key
 = 
key
;

1661 if (
expect_one
) {

1662 
ret
 = *
selected
 != 
NULL
 ? 0 : 
PTLS_ALERT_ILLEGAL_PARAMETER
;

1663 goto 
Exit
;

1667 
ret
 = 0;

1669 
Exit
:

1670 return 
ret
;

1671 
	}
}

1673 static int 
	$emit_server_name_extension
(
ptls_buffer_t
 *
buf
, const char *
server_name
)

1675 int 
ret
;

1677 
	`ptls_buffer_push_block
(
buf
, 2, {

1678 
	`ptls_buffer_push
(
buf
, 
PTLS_SERVER_NAME_TYPE_HOSTNAME
);

1679 
	`ptls_buffer_push_block
(
buf
, 2, { 
	`ptls_buffer_pushv
(buf, 
server_name
, 
	`strlen
(server_name)); });

1682 
ret
 = 0;

1683 
Exit
:

1684 return 
ret
;

1685 
	}
}

1687 static int 
	$parse_esni_keys
(
ptls_context_t
 *
ctx
, 
uint16_t
 *
esni_version
, 
ptls_key_exchange_algorithm_t
 **
selected_key_share
,

1688 
ptls_cipher_suite_t
 **
selected_cipher
, 
ptls_iovec_t
 *
peer_key
, 
uint16_t
 *
padded_length
,

1689 char **
published_sni
, 
ptls_iovec_t
 
input
)

1691 const 
uint8_t
 *
src
 = 
input
.
base
, *const 
end
 = input.base + input.
len
;

1692 
uint16_t
 
version
;

1693 
uint64_t
 
not_before
, 
not_after
, 
now
;

1694 int 
ret
 = 0;

1697 if ((
ret
 = 
	`ptls_decode16
(&
version
, &
src
, 
end
)) != 0)

1698 goto 
Exit
;

1699 if (
version
 != 
PTLS_ESNI_VERSION_DRAFT03
) {

1700 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

1701 goto 
Exit
;

1705 
ptls_hash_context_t
 *
hctx
;

1706 
uint8_t
 
digest
[
PTLS_SHA256_DIGEST_SIZE
];

1707 if (
end
 - 
src
 < 4) {

1708 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

1709 goto 
Exit
;

1711 if ((
hctx
 = 
	`create_sha256_context
(
ctx
)) == 
NULL
) {

1712 
ret
 = 
PTLS_ERROR_LIBRARY
;

1713 goto 
Exit
;

1715 
hctx
->
	`update
(hctx, 
input
.
base
, 
src
 - input.base);

1716 
hctx
->
	`update
(hctx, "\0\0\0\0", 4);

1717 
hctx
->
	`update
(hctx, 
src
 + 4, 
end
 - (src + 4));

1718 
hctx
->
	`final
(hctx, 
digest
, 
PTLS_HASH_FINAL_MODE_FREE
);

1719 if (
	`memcmp
(
src
, 
digest
, 4) != 0) {

1720 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

1721 goto 
Exit
;

1723 
src
 += 4;

1725 *
esni_version
 = 
version
;

1727 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

1728 
size_t
 
len
 = 
end
 - 
src
;

1729 *
published_sni
 = 
	`malloc
(
len
 + 1);

1730 if (*
published_sni
 == 
NULL
) {

1731 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1732 goto 
Exit
;

1734 if (
len
 > 0) {

1735 
	`memcpy
(*
published_sni
, 
src
, 
len
);

1737 (*
published_sni
)[
len
] = 0;

1738 
src
 = 
end
;

1741 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

1742 if ((
ret
 = 
	`select_key_share
(
selected_key_share
, 
peer_key
, 
ctx
->
key_exchanges
, &
src
, 
end
, 0)) != 0)

1743 goto 
Exit
;

1746 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

1747 if ((
ret
 = 
	`select_cipher
(
selected_cipher
, 
ctx
->
cipher_suites
, 
src
, 
end
, ctx->
server_cipher_preference
)) != 0)

1748 goto 
Exit
;

1749 
src
 = 
end
;

1752 if ((
ret
 = 
	`ptls_decode16
(
padded_length
, &
src
, 
end
)) != 0)

1753 goto 
Exit
;

1754 if (
padded_length
 == 0)

1755 goto 
Exit
;

1757 if ((
ret
 = 
	`ptls_decode64
(&
not_before
, &
src
, 
end
)) != 0 || (ret = ptls_decode64(&
not_after
, &src, end)) != 0)

1758 goto 
Exit
;

1760 
	`ptls_decode_block
(
src
, 
end
, 2, {

1761 while (
src
 != 
end
) {

1762 
uint16_t
 
id
;

1763 if ((
ret
 = 
	`ptls_decode16
(&
id
, &
src
, 
end
)) != 0)

1764 goto 
Exit
;

1765 
	`ptls_decode_open_block
(
src
, 
end
, 2, { src = end; });

1770 
now
 = 
ctx
->
get_time
->
	`cb
(ctx->get_time);

1771 if (!(
not_before
 * 1000 <= 
now
 && now <= 
not_after
 * 1000)) {

1772 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

1773 goto 
Exit
;

1776 
ret
 = 0;

1777 
Exit
:

1778 return 
ret
;

1779 
	}
}

1781 static int 
	$create_esni_aead
(
ptls_aead_context_t
 **
aead_ctx
, int 
is_enc
, 
ptls_cipher_suite_t
 *
cipher
, 
ptls_iovec_t
 
ecdh_secret
,

1782 const 
uint8_t
 *
esni_contents_hash
)

1784 
uint8_t
 
aead_secret
[
PTLS_MAX_DIGEST_SIZE
];

1785 int 
ret
;

1787 if ((
ret
 = 
	`ptls_hkdf_extract
(
cipher
->
hash
, 
aead_secret
, 
	`ptls_iovec_init
(
NULL
, 0), 
ecdh_secret
)) != 0)

1788 goto 
Exit
;

1789 if ((*
aead_ctx
 = 
	`new_aead
(
cipher
->
aead
, cipher->
hash
, 
is_enc
, 
aead_secret
,

1790 
	`ptls_iovec_init
(
esni_contents_hash
, 
cipher
->
hash
->
digest_size
), "tls13 esni ")) == 
NULL
) {

1791 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

1792 goto 
Exit
;

1795 
ret
 = 0;

1796 
Exit
:

1797 
	`ptls_clear_memory
(
aead_secret
, sizeof(aead_secret));

1798 return 
ret
;

1799 
	}
}

1801 static int 
	$build_esni_contents_hash
(
ptls_hash_algorithm_t
 *
hash
, 
uint8_t
 *
digest
, const uint8_t *
record_digest
, 
uint16_t
 
group
,

1802 
ptls_iovec_t
 
pubkey
, const 
uint8_t
 *
client_random
)

1804 
ptls_buffer_t
 
buf
;

1805 
uint8_t
 
smallbuf
[256];

1806 int 
ret
;

1809 
	`ptls_buffer_init
(&
buf
, 
smallbuf
, sizeof(smallbuf));

1810 
	`ptls_buffer_push_block
(&
buf
, 2, { 
	`ptls_buffer_pushv
(&buf, 
record_digest
, 
hash
->
digest_size
); });

1811 if ((
ret
 = 
	`push_key_share_entry
(&
buf
, 
group
, 
pubkey
)) != 0)

1812 goto 
Exit
;

1813 
	`ptls_buffer_pushv
(&
buf
, 
client_random
, 
PTLS_HELLO_RANDOM_SIZE
);

1816 if ((
ret
 = 
	`ptls_calc_hash
(
hash
, 
digest
, 
buf
.
base
, buf.
off
)) != 0)

1817 goto 
Exit
;

1819 
ret
 = 0;

1820 
Exit
:

1821 
	`ptls_buffer_dispose
(&
buf
);

1822 return 
ret
;

1823 
	}
}

1825 static void 
	$free_esni_secret
(
ptls_esni_secret_t
 **
esni
, int 
is_server
)

1827 
	`assert
(*
esni
 != 
NULL
);

1828 if ((*
esni
)->
secret
.
base
 != 
NULL
) {

1829 
	`ptls_clear_memory
((*
esni
)->
secret
.
base
, (*esni)->secret.
len
);

1830 
	`free
((*
esni
)->
secret
.
base
);

1832 if (!
is_server
)

1833 
	`free
((*
esni
)->
client
.
pubkey
.
base
);

1834 
	`ptls_clear_memory
((*
esni
), sizeof(**esni));

1835 
	`free
(*
esni
);

1836 *
esni
 = 
NULL
;

1837 
	}
}

1839 static int 
	$client_setup_esni
(
ptls_context_t
 *
ctx
, 
ptls_esni_secret_t
 **
esni
, 
ptls_iovec_t
 
esni_keys
, char **
published_sni
,

1840 const 
uint8_t
 *
client_random
)

1842 
ptls_iovec_t
 
peer_key
;

1843 int 
ret
;

1845 if ((*
esni
 = 
	`malloc
(sizeof(**esni))) == 
NULL
)

1846 return 
PTLS_ERROR_NO_MEMORY
;

1847 
	`memset
(*
esni
, 0, sizeof(**esni));

1850 if (
	`parse_esni_keys
(
ctx
, &(*
esni
)->
version
, &(*esni)->
client
.
key_share
, &(*esni)->client.
cipher
, &
peer_key
,

1851 &(*
esni
)->
client
.
padded_length
, 
published_sni
, 
esni_keys
) != 0) {

1852 
	`free
(*
esni
);

1853 *
esni
 = 
NULL
;

1857 
ctx
->
	`random_bytes
((*
esni
)->
nonce
, sizeof((*esni)->nonce));

1860 if ((
ret
 = 
	`ptls_calc_hash
((*
esni
)->
client
.
cipher
->
hash
, (*esni)->client.
record_digest
, 
esni_keys
.
base
, esni_keys.
len
)) != 0)

1861 goto 
Exit
;

1863 if ((
ret
 = (*
esni
)->
client
.
key_share
->
	`exchange
((*esni)->client.key_share, &(*esni)->client.
pubkey
, &(*esni)->
secret
,

1864 
peer_key
)) != 0)

1865 goto 
Exit
;

1867 if ((
ret
 = 
	`build_esni_contents_hash
((*
esni
)->
client
.
cipher
->
hash
, (*esni)->
esni_contents_hash
, (*esni)->client.
record_digest
,

1868 (*
esni
)->
client
.
key_share
->
id
, (*esni)->client.
pubkey
, 
client_random
)) != 0)

1869 goto 
Exit
;

1871 
ret
 = 0;

1872 
Exit
:

1873 if (
ret
 != 0)

1874 
	`free_esni_secret
(
esni
, 0);

1875 return 
ret
;

1876 
	}
}

1878 static int 
	$emit_esni_extension
(
ptls_esni_secret_t
 *
esni
, 
ptls_buffer_t
 *
buf
, 
ptls_iovec_t
 
esni_keys
, const char *
server_name
,

1879 
size_t
 
key_share_ch_off
, size_t 
key_share_ch_len
)

1881 
ptls_aead_context_t
 *
aead
 = 
NULL
;

1882 int 
ret
;

1884 if ((
ret
 = 
	`create_esni_aead
(&
aead
, 1, 
esni
->
client
.
cipher
, esni->
secret
, esni->
esni_contents_hash
)) != 0)

1885 goto 
Exit
;

1888 
	`ptls_buffer_push16
(
buf
, 
esni
->
client
.
cipher
->
id
);

1890 if ((
ret
 = 
	`push_key_share_entry
(
buf
, 
esni
->
client
.
key_share
->
id
, esni->client.
pubkey
)) != 0)

1891 goto 
Exit
;

1893 
	`ptls_buffer_push_block
(
buf
, 2, { 
	`ptls_buffer_pushv
(buf, 
esni
->
client
.
record_digest
, esni->client.
cipher
->
hash
->
digest_size
); });

1895 
	`ptls_buffer_push_block
(
buf
, 2, {

1896 
size_t
 
start_off
 = 
buf
->
off
;

1898 
	`ptls_buffer_pushv
(
buf
, 
esni
->
nonce
, 
PTLS_ESNI_NONCE_SIZE
);

1900 if ((
ret
 = 
	`emit_server_name_extension
(
buf
, 
server_name
)) != 0)

1901 goto 
Exit
;

1903 if (
buf
->
off
 - 
start_off
 < (
size_t
)(
esni
->
client
.
padded_length
 + 
PTLS_ESNI_NONCE_SIZE
)) {

1904 
size_t
 
bytes_to_pad
 = 
esni
->
client
.
padded_length
 + 
PTLS_ESNI_NONCE_SIZE
 - (
buf
->
off
 - 
start_off
);

1905 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
bytes_to_pad
)) != 0)

1906 goto 
Exit
;

1907 
	`memset
(
buf
->
base
 + buf->
off
, 0, 
bytes_to_pad
);

1908 
buf
->
off
 += 
bytes_to_pad
;

1911 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
aead
->
algo
->
tag_size
)) != 0)

1912 goto 
Exit
;

1913 
	`ptls_aead_encrypt
(
aead
, 
buf
->
base
 + 
start_off
, buf->base + start_off, buf->
off
 - start_off, 0, buf->base + 
key_share_ch_off
,

1914 
key_share_ch_len
);

1915 
buf
->
off
 += 
aead
->
algo
->
tag_size
;

1918 
ret
 = 0;

1919 
Exit
:

1920 if (
aead
 != 
NULL
)

1921 
	`ptls_aead_free
(
aead
);

1922 return 
ret
;

1923 
	}
}

1925 static int 
	$send_client_hello
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_handshake_properties_t
 *
properties
,

1926 
ptls_iovec_t
 *
cookie
)

1928 
ptls_iovec_t
 
resumption_secret
 = {
NULL
}, 
resumption_ticket
;

1929 char *
published_sni
 = 
NULL
;

1930 
uint32_t
 
obfuscated_ticket_age
 = 0;

1931 
size_t
 
msghash_off
;

1932 
uint8_t
 
binder_key
[
PTLS_MAX_DIGEST_SIZE
];

1933 int 
ret
, 
is_second_flight
 = 
tls
->
key_schedule
 != 
NULL
,

1934 
send_sni
 = 
tls
->
server_name
 != 
NULL
 && !
	`ptls_server_name_is_ipaddr
(tls->server_name);

1936 if (
properties
 != 
NULL
) {

1938 if (!
is_second_flight
 && 
send_sni
 && 
properties
->
client
.
esni_keys
.
base
 != 
NULL
) {

1939 if ((
ret
 = 
	`client_setup_esni
(
tls
->
ctx
, &tls->
esni
, 
properties
->
client
.
esni_keys
, &
published_sni
, tls->
client_random
)) !=

1941 goto 
Exit
;

1943 if (
tls
->
ctx
->
update_esni_key
 != 
NULL
) {

1944 if ((
ret
 = 
tls
->
ctx
->
update_esni_key
->
	`cb
(tls->ctx->update_esni_key, tls, tls->
esni
->
secret
,

1945 
tls
->
esni
->
client
.
cipher
->
hash
, tls->esni->
esni_contents_hash
)) != 0)

1946 goto 
Exit
;

1950 if (
properties
->
client
.
session_ticket
.
base
 != 
NULL
) {

1951 
ptls_key_exchange_algorithm_t
 *
key_share
 = 
NULL
;

1952 
ptls_cipher_suite_t
 *
cipher_suite
 = 
NULL
;

1953 
uint32_t
 
max_early_data_size
;

1954 if (
	`decode_stored_session_ticket
(
tls
, &
key_share
, &
cipher_suite
, &
resumption_secret
, &
obfuscated_ticket_age
,

1955 &
resumption_ticket
, &
max_early_data_size
, 
properties
->
client
.
session_ticket
.
base
,

1956 
properties
->
client
.
session_ticket
.
base
 + properties->client.session_ticket.
len
) == 0) {

1957 
tls
->
client
.
offered_psk
 = 1;

1959 if (
tls
->
key_share
 == 
NULL
)

1960 
tls
->
key_share
 = key_share;

1961 
tls
->
cipher_suite
 = cipher_suite;

1962 if (!
is_second_flight
 && 
max_early_data_size
 != 0 && 
properties
->
client
.max_early_data_size != 
NULL
) {

1963 
tls
->
client
.
using_early_data
 = 1;

1964 *
properties
->
client
.
max_early_data_size
 = max_early_data_size;

1967 
resumption_secret
 = 
	`ptls_iovec_init
(
NULL
, 0);

1970 if (
tls
->
client
.
using_early_data
) {

1971 
properties
->
client
.
early_data_acceptance
 = 
PTLS_EARLY_DATA_ACCEPTANCE_UNKNOWN
;

1973 if (
properties
->
client
.
max_early_data_size
 != 
NULL
)

1974 *
properties
->
client
.
max_early_data_size
 = 0;

1975 
properties
->
client
.
early_data_acceptance
 = 
PTLS_EARLY_DATA_REJECTED
;

1980 if (
tls
->
key_share
 == 
NULL
 && !(
properties
 != NULL && properties->
client
.
negotiate_before_key_exchange
))

1981 
tls
->
key_share
 = tls->
ctx
->
key_exchanges
[0];

1983 if (!
is_second_flight
) {

1984 
tls
->
key_schedule
 = 
	`key_schedule_new
(tls->
cipher_suite
, tls->
ctx
->
cipher_suites
, tls->ctx->
hkdf_label_prefix__obsolete
);

1985 if ((
ret
 = 
	`key_schedule_extract
(
tls
->
key_schedule
, 
resumption_secret
)) != 0)

1986 goto 
Exit
;

1989 
msghash_off
 = 
emitter
->
buf
->
off
 + emitter->
record_header_length
;

1990 
	`ptls_push_message
(
emitter
, 
NULL
, 
PTLS_HANDSHAKE_TYPE_CLIENT_HELLO
, {

1991 
ptls_buffer_t
 *
sendbuf
 = 
emitter
->
buf
;

1993 
	`ptls_buffer_push16
(
sendbuf
, 0x0303);

1995 
	`ptls_buffer_pushv
(
sendbuf
, 
tls
->
client_random
, sizeof(tls->client_random));

1997 
	`ptls_buffer_push_block
(

1998 
sendbuf
, 1, { 
	`ptls_buffer_pushv
(sendbuf, 
tls
->
client
.
legacy_session_id
.
base
, tls->client.legacy_session_id.
len
); });

2000 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

2001 
ptls_cipher_suite_t
 **
cs
 = 
tls
->
ctx
->
cipher_suites
;

2002 for (; *
cs
 != 
NULL
; ++cs)

2003 
	`ptls_buffer_push16
(
sendbuf
, (*
cs
)->
id
);

2006 
	`ptls_buffer_push_block
(
sendbuf
, 1, { 
	`ptls_buffer_push
(sendbuf, 0); });

2008 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

2010 
size_t
 
off
;

2011 
size_t
 
len
;

2012 } 
key_share_client_hello
;

2013 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_KEY_SHARE
, {

2014 
key_share_client_hello
.
off
 = 
sendbuf
->off;

2015 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

2016 if (
tls
->
key_share
 != 
NULL
) {

2017 if ((
ret
 = 
tls
->
key_share
->
	`create
(tls->key_share, &tls->
client
.
key_share_ctx
)) != 0)

2018 goto 
Exit
;

2019 if ((
ret
 = 
	`push_key_share_entry
(
sendbuf
, 
tls
->
key_share
->
id
, tls->
client
.
key_share_ctx
->
pubkey
)) != 0)

2020 goto 
Exit
;

2023 
key_share_client_hello
.
len
 = 
sendbuf
->
off
 - key_share_client_hello.off;

2025 if (
send_sni
) {

2026 if (
tls
->
esni
 != 
NULL
) {

2027 if (
published_sni
 != 
NULL
) {

2028 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_SERVER_NAME
, {

2029 if ((
ret
 = 
	`emit_server_name_extension
(
sendbuf
, 
published_sni
)) != 0)

2030 goto 
Exit
;

2033 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_ENCRYPTED_SERVER_NAME
, {

2034 if ((
ret
 = 
	`emit_esni_extension
(
tls
->
esni
, 
sendbuf
, 
properties
->
client
.
esni_keys
, tls->
server_name
,

2035 
key_share_client_hello
.
off
, key_share_client_hello.
len
)) != 0)

2036 goto 
Exit
;

2039 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_SERVER_NAME
, {

2040 if ((
ret
 = 
	`emit_server_name_extension
(
sendbuf
, 
tls
->
server_name
)) != 0)

2041 goto 
Exit
;

2045 if (
properties
 != 
NULL
 && properties->
client
.
negotiated_protocols
.
count
 != 0) {

2046 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_ALPN
, {

2047 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

2048 
size_t
 
i
;

2049 for (
i
 = 0; i != 
properties
->
client
.
negotiated_protocols
.
count
; ++i) {

2050 
	`ptls_buffer_push_block
(
sendbuf
, 1, {

2051 
ptls_iovec_t
 
p
 = 
properties
->
client
.
negotiated_protocols
.
list
[
i
];

2052 
	`ptls_buffer_pushv
(
sendbuf
, 
p
.
base
, p.
len
);

2058 if (
tls
->
ctx
->
decompress_certificate
 != 
NULL
) {

2059 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_COMPRESS_CERTIFICATE
, {

2060 
	`ptls_buffer_push_block
(
sendbuf
, 1, {

2061 const 
uint16_t
 *
algo
 = 
tls
->
ctx
->
decompress_certificate
->
supported_algorithms
;

2062 
	`assert
(*
algo
 != 
UINT16_MAX
);

2063 for (; *
algo
 != 
UINT16_MAX
; ++algo)

2064 
	`ptls_buffer_push16
(
sendbuf
, *
algo
);

2068 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_SUPPORTED_VERSIONS
, {

2069 
	`ptls_buffer_push_block
(
sendbuf
, 1, {

2070 
size_t
 
i
;

2071 for (
i
 = 0; i != 
	`PTLS_ELEMENTSOF
(
supported_versions
); ++i)

2072 
	`ptls_buffer_push16
(
sendbuf
, 
supported_versions
[
i
]);

2075 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_SIGNATURE_ALGORITHMS
, {

2076 if ((
ret
 = 
	`push_signature_algorithms
(
tls
->
ctx
->
verify_certificate
, 
sendbuf
)) != 0)

2077 goto 
Exit
;

2079 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_SUPPORTED_GROUPS
, {

2080 
ptls_key_exchange_algorithm_t
 **
algo
 = 
tls
->
ctx
->
key_exchanges
;

2081 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

2082 for (; *
algo
 != 
NULL
; ++algo)

2083 
	`ptls_buffer_push16
(
sendbuf
, (*
algo
)->
id
);

2086 if (
cookie
 != 
NULL
 && cookie->
base
 != NULL) {

2087 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_COOKIE
, {

2088 
	`ptls_buffer_push_block
(
sendbuf
, 2, { 
	`ptls_buffer_pushv
(sendbuf, 
cookie
->
base
, cookie->
len
); });

2091 if (
tls
->
ctx
->
use_raw_public_keys
) {

2092 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_SERVER_CERTIFICATE_TYPE
, {

2093 
	`ptls_buffer_push_block
(
sendbuf
, 1, { 
	`ptls_buffer_push
(sendbuf, 
PTLS_CERTIFICATE_TYPE_RAW_PUBLIC_KEY
); });

2096 if ((
ret
 = 
	`push_additional_extensions
(
properties
, 
sendbuf
)) != 0)

2097 goto 
Exit
;

2098 if (
tls
->
ctx
->
save_ticket
 != 
NULL
 || 
resumption_secret
.
base
 != NULL) {

2099 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_PSK_KEY_EXCHANGE_MODES
, {

2100 
	`ptls_buffer_push_block
(
sendbuf
, 1, {

2101 if (!
tls
->
ctx
->
require_dhe_on_psk
)

2102 
	`ptls_buffer_push
(
sendbuf
, 
PTLS_PSK_KE_MODE_PSK
);

2103 
	`ptls_buffer_push
(
sendbuf
, 
PTLS_PSK_KE_MODE_PSK_DHE
);

2107 if (
resumption_secret
.
base
 != 
NULL
) {

2108 if (
tls
->
client
.
using_early_data
 && !
is_second_flight
)

2109 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_EARLY_DATA
, {});

2111 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_PRE_SHARED_KEY
, {

2112 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

2113 
	`ptls_buffer_push_block
(
sendbuf
, 2,

2114 { 
	`ptls_buffer_pushv
(
sendbuf
, 
resumption_ticket
.
base
, resumption_ticket.
len
); });

2115 
	`ptls_buffer_push32
(
sendbuf
, 
obfuscated_ticket_age
);

2118 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

2119 
	`ptls_buffer_push_block
(
sendbuf
, 1, {

2120 if ((
ret
 = 
	`ptls_buffer_reserve
(
sendbuf
, 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
)) != 0)

2121 goto 
Exit
;

2122 
sendbuf
->
off
 += 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
;

2131 if (
resumption_secret
.
base
 != 
NULL
) {

2132 
size_t
 
psk_binder_off
 = 
emitter
->
buf
->
off
 - (3 + 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
);

2133 if ((
ret
 = 
	`derive_secret_with_empty_digest
(
tls
->
key_schedule
, 
binder_key
, "res binder")) != 0)

2134 goto 
Exit
;

2135 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
emitter
->
buf
->
base
 + 
msghash_off
, 
psk_binder_off
 - msghash_off);

2136 
msghash_off
 = 
psk_binder_off
;

2137 if ((
ret
 = 
	`calc_verify_data
(
emitter
->
buf
->
base
 + 
psk_binder_off
 + 3, 
tls
->
key_schedule
, 
binder_key
)) != 0)

2138 goto 
Exit
;

2140 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
emitter
->
buf
->
base
 + 
msghash_off
, emitter->buf->
off
 - msghash_off);

2142 if (
tls
->
client
.
using_early_data
) {

2143 
	`assert
(!
is_second_flight
);

2144 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 1, "c e traffic", 1, 0)) != 0)

2145 goto 
Exit
;

2146 if ((
ret
 = 
	`push_change_cipher_spec
(
tls
, 
emitter
)) != 0)

2147 goto 
Exit
;

2149 if (
resumption_secret
.
base
 != 
NULL
 && !
is_second_flight
) {

2150 if ((
ret
 = 
	`derive_exporter_secret
(
tls
, 1)) != 0)

2151 goto 
Exit
;

2153 
tls
->
state
 = 
cookie
 == 
NULL
 ? 
PTLS_STATE_CLIENT_EXPECT_SERVER_HELLO
 : 
PTLS_STATE_CLIENT_EXPECT_SECOND_SERVER_HELLO
;

2154 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

2156 
Exit
:

2157 if (
published_sni
 != 
NULL
) {

2158 
	`free
(
published_sni
);

2160 
	`ptls_clear_memory
(
binder_key
, sizeof(binder_key));

2161 return 
ret
;

2162 
	}
}

2164 static 
ptls_cipher_suite_t
 *
	$find_cipher_suite
(
ptls_context_t
 *
ctx
, 
uint16_t
 
id
)

2166 
ptls_cipher_suite_t
 **
cs
;

2168 for (
cs
 = 
ctx
->
cipher_suites
; *cs != 
NULL
 && (*cs)->
id
 != id; ++cs)

2170 return *
cs
;

2171 
	}
}

2173 static int 
	$decode_server_hello
(
ptls_t
 *
tls
, struct 
st_ptls_server_hello_t
 *
sh
, const 
uint8_t
 *
src
, const uint8_t *const 
end
)

2175 int 
ret
;

2177 *
sh
 = (struct 
st_ptls_server_hello_t
){{0}};

2180 if (
end
 - 
src
 < 2) {

2181 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

2182 goto 
Exit
;

2184 
src
 += 2;

2187 if (
end
 - 
src
 < 
PTLS_HELLO_RANDOM_SIZE
) {

2188 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

2189 goto 
Exit
;

2191 
sh
->
is_retry_request
 = 
	`memcmp
(
src
, 
hello_retry_random
, 
PTLS_HELLO_RANDOM_SIZE
) == 0;

2192 
src
 += 
PTLS_HELLO_RANDOM_SIZE
;

2195 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

2196 if (
end
 - 
src
 > 32) {

2197 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

2198 goto 
Exit
;

2200 
sh
->
legacy_session_id
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

2201 
src
 = 
end
;

2205 
uint16_t
 
csid
;

2206 if ((
ret
 = 
	`ptls_decode16
(&
csid
, &
src
, 
end
)) != 0)

2207 goto 
Exit
;

2208 if ((
tls
->
cipher_suite
 = 
	`find_cipher_suite
(tls->
ctx
, 
csid
)) == 
NULL
) {

2209 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2210 goto 
Exit
;

2215 if (
src
 == 
end
 || *src++ != 0) {

2216 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2217 goto 
Exit
;

2220 if (
sh
->
is_retry_request
)

2221 
sh
->
retry_request
.
selected_group
 = 
UINT16_MAX
;

2223 
uint16_t
 
exttype
, 
found_version
 = 
UINT16_MAX
, 
selected_psk_identity
 = UINT16_MAX;

2224 
	`decode_extensions
(
src
, 
end
, 
PTLS_HANDSHAKE_TYPE_SERVER_HELLO
, &
exttype
, {

2225 if (
tls
->
ctx
->
on_extension
 != 
NULL
 &&

2226 (
ret
 = 
tls
->
ctx
->
on_extension
->
	`cb
(tls->ctx->on_extension, tls, 
PTLS_HANDSHAKE_TYPE_SERVER_HELLO
, 
exttype
,

2227 
	`ptls_iovec_init
(
src
, 
end
 - src)) != 0))

2228 goto 
Exit
;

2229 switch (
exttype
) {

2230 case 
PTLS_EXTENSION_TYPE_SUPPORTED_VERSIONS
:

2231 if ((
ret
 = 
	`ptls_decode16
(&
found_version
, &
src
, 
end
)) != 0)

2232 goto 
Exit
;

2234 case 
PTLS_EXTENSION_TYPE_KEY_SHARE
:

2235 if (
sh
->
is_retry_request
) {

2236 if ((
ret
 = 
	`ptls_decode16
(&
sh
->
retry_request
.
selected_group
, &
src
, 
end
)) != 0)

2237 goto 
Exit
;

2239 
uint16_t
 
group
;

2240 if ((
ret
 = 
	`decode_key_share_entry
(&
group
, &
sh
->
peerkey
, &
src
, 
end
)) != 0)

2241 goto 
Exit
;

2242 if (
src
 != 
end
) {

2243 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

2244 goto 
Exit
;

2246 if (
tls
->
key_share
 == 
NULL
 || tls->key_share->
id
 != 
group
) {

2247 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2248 goto 
Exit
;

2252 case 
PTLS_EXTENSION_TYPE_COOKIE
:

2253 if (
sh
->
is_retry_request
) {

2254 
	`ptls_decode_block
(
src
, 
end
, 2, {

2255 if (
src
 == 
end
) {

2256 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

2257 goto 
Exit
;

2259 
sh
->
retry_request
.
cookie
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

2260 
src
 = 
end
;

2263 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2264 goto 
Exit
;

2267 case 
PTLS_EXTENSION_TYPE_PRE_SHARED_KEY
:

2268 if (
sh
->
is_retry_request
) {

2269 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2270 goto 
Exit
;

2272 if ((
ret
 = 
	`ptls_decode16
(&
selected_psk_identity
, &
src
, 
end
)) != 0)

2273 goto 
Exit
;

2277 
src
 = 
end
;

2282 if (!
	`is_supported_version
(
found_version
)) {

2283 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2284 goto 
Exit
;

2286 if (!
sh
->
is_retry_request
) {

2287 if (
selected_psk_identity
 != 
UINT16_MAX
) {

2288 if (!
tls
->
client
.
offered_psk
) {

2289 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2290 goto 
Exit
;

2292 if (
selected_psk_identity
 != 0) {

2293 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2294 goto 
Exit
;

2296 
tls
->
is_psk_handshake
 = 1;

2298 if (
sh
->
peerkey
.
base
 == 
NULL
 && !
tls
->
is_psk_handshake
) {

2299 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2300 goto 
Exit
;

2304 
ret
 = 0;

2305 
Exit
:

2306 return 
ret
;

2307 
	}
}

2309 static int 
	$handle_hello_retry_request
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, struct 
st_ptls_server_hello_t
 *
sh
,

2310 
ptls_iovec_t
 
message
, 
ptls_handshake_properties_t
 *
properties
)

2312 int 
ret
;

2314 if (
tls
->
client
.
key_share_ctx
 != 
NULL
) {

2315 
tls
->
client
.
key_share_ctx
->
	`on_exchange
(&tls->client.key_share_ctx, 1, 
NULL
, 
	`ptls_iovec_init
(NULL, 0));

2316 
tls
->
client
.
key_share_ctx
 = 
NULL
;

2318 if (
tls
->
client
.
using_early_data
) {

2321 if (
tls
->
ctx
->
update_traffic_key
 == 
NULL
) {

2322 
	`assert
(
tls
->
traffic_protection
.
enc
.
aead
 != 
NULL
);

2323 
	`ptls_aead_free
(
tls
->
traffic_protection
.
enc
.
aead
);

2324 
tls
->
traffic_protection
.
enc
.
aead
 = 
NULL
;

2326 
tls
->
client
.
using_early_data
 = 0;

2329 if (
sh
->
retry_request
.
selected_group
 != 
UINT16_MAX
) {

2331 
ptls_key_exchange_algorithm_t
 **
cand
;

2332 for (
cand
 = 
tls
->
ctx
->
key_exchanges
; *cand != 
NULL
; ++cand)

2333 if ((*
cand
)->
id
 == 
sh
->
retry_request
.
selected_group
)

2335 if (*
cand
 == 
NULL
) {

2336 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2337 goto 
Exit
;

2339 
tls
->
key_share
 = *
cand
;

2340 } else if (
tls
->
key_share
 != 
NULL
) {

2343 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2344 goto 
Exit
;

2347 
	`key_schedule_transform_post_ch1hash
(
tls
->
key_schedule
);

2348 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

2349 
ret
 = 
	`send_client_hello
(
tls
, 
emitter
, 
properties
, &
sh
->
retry_request
.
cookie
);

2351 
Exit
:

2352 return 
ret
;

2353 
	}
}

2355 static int 
	$client_handle_hello
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_iovec_t
 
message
,

2356 
ptls_handshake_properties_t
 *
properties
)

2358 struct 
st_ptls_server_hello_t
 
sh
;

2359 
ptls_iovec_t
 
ecdh_secret
 = {
NULL
};

2360 int 
ret
;

2362 if ((
ret
 = 
	`decode_server_hello
(
tls
, &
sh
, 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, message.base + message.
len
)) != 0)

2363 goto 
Exit
;

2364 if (!(
sh
.
legacy_session_id
.
len
 == 
tls
->
client
.legacy_session_id.len &&

2365 
	`ptls_mem_equal
(
sh
.
legacy_session_id
.
base
, 
tls
->
client
.legacy_session_id.base, tls->client.legacy_session_id.
len
))) {

2366 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2367 goto 
Exit
;

2370 if (
sh
.
is_retry_request
) {

2371 if ((
ret
 = 
	`key_schedule_select_one
(
tls
->
key_schedule
, tls->
cipher_suite
, 0)) != 0)

2372 goto 
Exit
;

2373 return 
	`handle_hello_retry_request
(
tls
, 
emitter
, &
sh
, 
message
, 
properties
);

2376 if ((
ret
 = 
	`key_schedule_select_one
(
tls
->
key_schedule
, tls->
cipher_suite
, tls->
client
.
offered_psk
 && !tls->
is_psk_handshake
)) !=

2378 goto 
Exit
;

2380 if (
sh
.
peerkey
.
base
 != 
NULL
) {

2381 if ((
ret
 = 
tls
->
client
.
key_share_ctx
->
	`on_exchange
(&tls->client.key_share_ctx, 1, &
ecdh_secret
, 
sh
.
peerkey
)) != 0)

2382 goto 
Exit
;

2385 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

2387 if ((
ret
 = 
	`key_schedule_extract
(
tls
->
key_schedule
, 
ecdh_secret
)) != 0)

2388 goto 
Exit
;

2389 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 0, "s hs traffic", 2, 0)) != 0)

2390 goto 
Exit
;

2391 if (
tls
->
client
.
using_early_data
) {

2392 if ((
tls
->
pending_handshake_secret
 = 
	`malloc
(
PTLS_MAX_DIGEST_SIZE
)) == 
NULL
) {

2393 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

2394 goto 
Exit
;

2396 if ((
ret
 = 
	`derive_secret
(
tls
->
key_schedule
, tls->
pending_handshake_secret
, "c hs traffic")) != 0)

2397 goto 
Exit
;

2398 if (
tls
->
ctx
->
update_traffic_key
 != 
NULL
 &&

2399 (
ret
 = 
tls
->
ctx
->
update_traffic_key
->
	`cb
(tls->ctx->update_traffic_key, tls, 1, 2, tls->
pending_handshake_secret
)) != 0)

2400 goto 
Exit
;

2402 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 1, "c hs traffic", 2, 0)) != 0)

2403 goto 
Exit
;

2406 
tls
->
state
 = 
PTLS_STATE_CLIENT_EXPECT_ENCRYPTED_EXTENSIONS
;

2407 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

2409 
Exit
:

2410 if (
ecdh_secret
.
base
 != 
NULL
) {

2411 
	`ptls_clear_memory
(
ecdh_secret
.
base
, ecdh_secret.
len
);

2412 
	`free
(
ecdh_secret
.
base
);

2414 return 
ret
;

2415 
	}
}

2417 static int 
	$should_collect_unknown_extension
(
ptls_t
 *
tls
, 
ptls_handshake_properties_t
 *
properties
, 
uint16_t
 
type
)

2419 return 
properties
 != 
NULL
 && properties->
collect_extension
 != NULL && properties->
	`collect_extension
(
tls
, properties, 
type
);

2420 
	}
}

2422 static int 
	$collect_unknown_extension
(
ptls_t
 *
tls
, 
uint16_t
 
type
, const 
uint8_t
 *
src
, const uint8_t *const 
end
,

2423 
ptls_raw_extension_t
 *
slots
)

2425 
size_t
 
i
;

2426 for (
i
 = 0; 
slots
[i].
type
 != 
UINT16_MAX
; ++i) {

2427 
	`assert
(
i
 < 
MAX_UNKNOWN_EXTENSIONS
);

2428 if (
slots
[
i
].
type
 == type)

2429 return 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2431 if (
i
 < 
MAX_UNKNOWN_EXTENSIONS
) {

2432 
slots
[
i
].
type
 = type;

2433 
slots
[
i
].
data
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

2434 
slots
[
i
 + 1].
type
 = 
UINT16_MAX
;

2437 
	}
}

2439 static int 
	$report_unknown_extensions
(
ptls_t
 *
tls
, 
ptls_handshake_properties_t
 *
properties
, 
ptls_raw_extension_t
 *
slots
)

2441 if (
properties
 != 
NULL
 && properties->
collect_extension
 != NULL) {

2442 
	`assert
(
properties
->
collected_extensions
 != 
NULL
);

2443 return 
properties
->
	`collected_extensions
(
tls
, properties, 
slots
);

2447 
	}
}

2449 static int 
	$client_handle_encrypted_extensions
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
, 
ptls_handshake_properties_t
 *
properties
)

2451 const 
uint8_t
 *
src
 = 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, *const 
end
 = message.base + message.
len
, *
esni_nonce
 = 
NULL
;

2452 
uint16_t
 
type
;

2453 static const 
ptls_raw_extension_t
 
no_unknown_extensions
 = {
UINT16_MAX
};

2454 
ptls_raw_extension_t
 *
unknown_extensions
 = (ptls_raw_extension_t *)&
no_unknown_extensions
;

2455 int 
ret
, 
skip_early_data
 = 1;

2456 
uint8_t
 
server_offered_cert_type
 = 
PTLS_CERTIFICATE_TYPE_X509
;

2458 
	`decode_extensions
(
src
, 
end
, 
PTLS_HANDSHAKE_TYPE_ENCRYPTED_EXTENSIONS
, &
type
, {

2459 if (
tls
->
ctx
->
on_extension
 != 
NULL
 &&

2460 (
ret
 = 
tls
->
ctx
->
on_extension
->
	`cb
(tls->ctx->on_extension, tls, 
PTLS_HANDSHAKE_TYPE_ENCRYPTED_EXTENSIONS
, 
type
,

2461 
	`ptls_iovec_init
(
src
, 
end
 - src)) != 0))

2462 goto 
Exit
;

2463 switch (
type
) {

2464 case 
PTLS_EXTENSION_TYPE_SERVER_NAME
:

2465 if (
src
 != 
end
) {

2466 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

2467 goto 
Exit
;

2469 if (!(
tls
->
server_name
 != 
NULL
 && !
	`ptls_server_name_is_ipaddr
(tls->server_name))) {

2470 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2471 goto 
Exit
;

2474 case 
PTLS_EXTENSION_TYPE_ENCRYPTED_SERVER_NAME
:

2475 if (*
src
 == 
PTLS_ESNI_RESPONSE_TYPE_ACCEPT
) {

2476 if (
end
 - 
src
 != 
PTLS_ESNI_NONCE_SIZE
 + 1) {

2477 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2478 goto 
Exit
;

2480 
esni_nonce
 = 
src
 + 1;

2483 
ret
 = 
PTLS_ERROR_ESNI_RETRY
;

2484 goto 
Exit
;

2487 case 
PTLS_EXTENSION_TYPE_ALPN
:

2488 
	`ptls_decode_block
(
src
, 
end
, 2, {

2489 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

2490 if (
src
 == 
end
) {

2491 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

2492 goto 
Exit
;

2494 if ((
ret
 = 
	`ptls_set_negotiated_protocol
(
tls
, (const char *)
src
, 
end
 - src)) != 0)

2495 goto 
Exit
;

2496 
src
 = 
end
;

2498 if (
src
 != 
end
) {

2499 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

2500 goto 
Exit
;

2504 case 
PTLS_EXTENSION_TYPE_EARLY_DATA
:

2505 if (!
tls
->
client
.
using_early_data
) {

2506 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2507 goto 
Exit
;

2509 
skip_early_data
 = 0;

2511 case 
PTLS_EXTENSION_TYPE_SERVER_CERTIFICATE_TYPE
:

2512 if (
end
 - 
src
 != 1) {

2513 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

2514 goto 
Exit
;

2516 
server_offered_cert_type
 = *
src
;

2517 
src
 = 
end
;

2520 if (
	`should_collect_unknown_extension
(
tls
, 
properties
, 
type
)) {

2521 if (
unknown_extensions
 == &
no_unknown_extensions
) {

2522 if ((
unknown_extensions
 = 
	`malloc
(sizeof(*unknown_extensions) * (
MAX_UNKNOWN_EXTENSIONS
 + 1))) == 
NULL
) {

2523 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

2524 goto 
Exit
;

2526 
unknown_extensions
[0].
type
 = 
UINT16_MAX
;

2528 if ((
ret
 = 
	`collect_unknown_extension
(
tls
, 
type
, 
src
, 
end
, 
unknown_extensions
)) != 0)

2529 goto 
Exit
;

2533 
src
 = 
end
;

2536 if (
server_offered_cert_type
 !=

2537 (
tls
->
ctx
->
use_raw_public_keys
 ? 
PTLS_CERTIFICATE_TYPE_RAW_PUBLIC_KEY
 : 
PTLS_CERTIFICATE_TYPE_X509
)) {

2538 
ret
 = 
PTLS_ALERT_UNSUPPORTED_CERTIFICATE
;

2539 goto 
Exit
;

2542 if (
tls
->
esni
 != 
NULL
) {

2543 if (
esni_nonce
 == 
NULL
 || !
	`ptls_mem_equal
(esni_nonce, 
tls
->
esni
->
nonce
, 
PTLS_ESNI_NONCE_SIZE
)) {

2544 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2545 goto 
Exit
;

2547 
	`free_esni_secret
(&
tls
->
esni
, 0);

2549 if (
esni_nonce
 != 
NULL
) {

2550 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2551 goto 
Exit
;

2555 if (
tls
->
client
.
using_early_data
) {

2556 if (
skip_early_data
)

2557 
tls
->
client
.
using_early_data
 = 0;

2558 if (
properties
 != 
NULL
)

2559 
properties
->
client
.
early_data_acceptance
 = 
skip_early_data
 ? 
PTLS_EARLY_DATA_REJECTED
 : 
PTLS_EARLY_DATA_ACCEPTED
;

2561 if ((
ret
 = 
	`report_unknown_extensions
(
tls
, 
properties
, 
unknown_extensions
)) != 0)

2562 goto 
Exit
;

2564 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

2565 
tls
->
state
 =

2566 
tls
->
is_psk_handshake
 ? 
PTLS_STATE_CLIENT_EXPECT_FINISHED
 : 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE_REQUEST_OR_CERTIFICATE
;

2567 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

2569 
Exit
:

2570 if (
unknown_extensions
 != &
no_unknown_extensions
)

2571 
	`free
(
unknown_extensions
);

2572 return 
ret
;

2573 
	}
}

2575 static int 
	$decode_certificate_request
(
ptls_t
 *
tls
, struct 
st_ptls_certificate_request_t
 *
cr
, const 
uint8_t
 *
src
,

2576 const 
uint8_t
 *const 
end
)

2578 int 
ret
;

2579 
uint16_t
 
exttype
 = 0;

2582 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

2583 
size_t
 
len
 = 
end
 - 
src
;

2584 if (
len
 > 255) {

2585 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

2586 goto 
Exit
;

2588 if ((
cr
->
context
.
base
 = 
	`malloc
(
len
 != 0 ? len : 1)) == 
NULL
) {

2589 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

2590 goto 
Exit
;

2592 
cr
->
context
.
len
 = len;

2593 
	`memcpy
(
cr
->
context
.
base
, 
src
, 
len
);

2594 
src
 = 
end
;

2598 
	`decode_extensions
(
src
, 
end
, 
PTLS_HANDSHAKE_TYPE_CERTIFICATE_REQUEST
, &
exttype
, {

2599 if (
tls
->
ctx
->
on_extension
 != 
NULL
 &&

2600 (
ret
 = 
tls
->
ctx
->
on_extension
->
	`cb
(tls->ctx->on_extension, tls, 
PTLS_HANDSHAKE_TYPE_CERTIFICATE_REQUEST
, 
exttype
,

2601 
	`ptls_iovec_init
(
src
, 
end
 - src)) != 0))

2602 goto 
Exit
;

2603 switch (
exttype
) {

2604 case 
PTLS_EXTENSION_TYPE_SIGNATURE_ALGORITHMS
:

2605 if ((
ret
 = 
	`decode_signature_algorithms
(&
cr
->
signature_algorithms
, &
src
, 
end
)) != 0)

2606 goto 
Exit
;

2609 
src
 = 
end
;

2612 if (
cr
->
signature_algorithms
.
count
 == 0) {

2613 
ret
 = 
PTLS_ALERT_MISSING_EXTENSION
;

2614 goto 
Exit
;

2617 
ret
 = 0;

2618 
Exit
:

2619 return 
ret
;

2620 
	}
}

2622 int 
	$ptls_build_certificate_message
(
ptls_buffer_t
 *
buf
, 
ptls_iovec_t
 
context
, ptls_iovec_t *
certificates
, 
size_t
 
num_certificates
,

2623 
ptls_iovec_t
 
ocsp_status
)

2625 int 
ret
;

2627 
	`ptls_buffer_push_block
(
buf
, 1, { 
	`ptls_buffer_pushv
(buf, 
context
.
base
, context.
len
); });

2628 
	`ptls_buffer_push_block
(
buf
, 3, {

2629 
size_t
 
i
;

2630 for (
i
 = 0; i != 
num_certificates
; ++i) {

2631 
	`ptls_buffer_push_block
(
buf
, 3, { 
	`ptls_buffer_pushv
(buf, 
certificates
[
i
].
base
, certificates[i].
len
); });

2632 
	`ptls_buffer_push_block
(
buf
, 2, {

2633 if (
i
 == 0 && 
ocsp_status
.
len
 != 0) {

2634 
	`buffer_push_extension
(
buf
, 
PTLS_EXTENSION_TYPE_STATUS_REQUEST
, {

2635 
	`ptls_buffer_push
(
buf
, 1);

2636 
	`ptls_buffer_push_block
(
buf
, 3, { 
	`ptls_buffer_pushv
(buf, 
ocsp_status
.
base
, ocsp_status.
len
); });

2643 
ret
 = 0;

2644 
Exit
:

2645 return 
ret
;

2646 
	}
}

2648 static int 
	$default_emit_certificate_cb
(
ptls_emit_certificate_t
 *
_self
, 
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
,

2649 
ptls_key_schedule_t
 *
key_sched
, 
ptls_iovec_t
 
context
, int 
push_status_request
,

2650 const 
uint16_t
 *
compress_algos
, 
size_t
 
num_compress_algos
)

2652 int 
ret
;

2654 
	`ptls_push_message
(
emitter
, 
key_sched
, 
PTLS_HANDSHAKE_TYPE_CERTIFICATE
, {

2655 if ((
ret
 = 
	`ptls_build_certificate_message
(
emitter
->
buf
, 
context
, 
tls
->
ctx
->
certificates
.
list
, tls->ctx->certificates.
count
,

2656 
	`ptls_iovec_init
(
NULL
, 0))) != 0)

2657 goto 
Exit
;

2660 
ret
 = 0;

2661 
Exit
:

2662 return 
ret
;

2663 
	}
}

2665 static int 
	$send_certificate_and_certificate_verify
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
,

2666 struct 
st_ptls_signature_algorithms_t
 *
signature_algorithms
,

2667 
ptls_iovec_t
 
context
, const char *
context_string
, int 
push_status_request
,

2668 const 
uint16_t
 *
compress_algos
, 
size_t
 
num_compress_algos
)

2670 int 
ret
;

2672 if (
signature_algorithms
->
count
 == 0) {

2673 
ret
 = 
PTLS_ALERT_MISSING_EXTENSION
;

2674 goto 
Exit
;

2678 static 
ptls_emit_certificate_t
 
default_emit_certificate
 = {
default_emit_certificate_cb
};

2679 
ptls_emit_certificate_t
 *
emit_certificate
 =

2680 
tls
->
ctx
->
emit_certificate
 != 
NULL
 ? tls->ctx->emit_certificate : &
default_emit_certificate
;

2681 
Redo
:

2682 if ((
ret
 = 
emit_certificate
->
	`cb
(emit_certificate, 
tls
, 
emitter
, tls->
key_schedule
, 
context
, 
push_status_request
,

2683 
compress_algos
, 
num_compress_algos
)) != 0) {

2684 if (
ret
 == 
PTLS_ERROR_DELEGATE
) {

2685 
	`assert
(
emit_certificate
 != &
default_emit_certificate
);

2686 
emit_certificate
 = &
default_emit_certificate
;

2687 goto 
Redo
;

2689 goto 
Exit
;

2694 if (
tls
->
ctx
->
sign_certificate
 != 
NULL
) {

2695 
	`ptls_push_message
(
emitter
, 
tls
->
key_schedule
, 
PTLS_HANDSHAKE_TYPE_CERTIFICATE_VERIFY
, {

2696 
ptls_buffer_t
 *
sendbuf
 = 
emitter
->
buf
;

2697 
size_t
 
algo_off
 = 
sendbuf
->
off
;

2698 
	`ptls_buffer_push16
(
sendbuf
, 0);

2699 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

2700 
uint16_t
 
algo
;

2701 
uint8_t
 
data
[
PTLS_MAX_CERTIFICATE_VERIFY_SIGNDATA_SIZE
];

2702 
size_t
 
datalen
 = 
	`build_certificate_verify_signdata
(
data
, 
tls
->
key_schedule
, 
context_string
);

2703 if ((
ret
 = 
tls
->
ctx
->
sign_certificate
->
	`cb
(tls->ctx->sign_certificate, tls, &
algo
, 
sendbuf
,

2704 
	`ptls_iovec_init
(
data
, 
datalen
), 
signature_algorithms
->
list
,

2705 
signature_algorithms
->
count
)) != 0) {

2706 goto 
Exit
;

2708 
sendbuf
->
base
[
algo_off
] = (
uint8_t
)(
algo
 >> 8);

2709 
sendbuf
->
base
[
algo_off
 + 1] = (
uint8_t
)
algo
;

2714 
Exit
:

2715 return 
ret
;

2716 
	}
}

2718 static int 
	$client_handle_certificate_request
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
, 
ptls_handshake_properties_t
 *
properties
)

2720 const 
uint8_t
 *
src
 = 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, *const 
end
 = message.base + message.
len
;

2721 int 
ret
 = 0;

2723 if ((
ret
 = 
	`decode_certificate_request
(
tls
, &tls->
client
.
certificate_request
, 
src
, 
end
)) != 0)

2724 return 
ret
;

2727 if (
tls
->
client
.
certificate_request
.
context
.
len
 != 0)

2728 return 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2730 
tls
->
state
 = 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE
;

2731 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

2733 return 
PTLS_ERROR_IN_PROGRESS
;

2734 
	}
}

2736 static int 
	$handle_certificate
(
ptls_t
 *
tls
, const 
uint8_t
 *
src
, const uint8_t *
end
, int *
got_certs
)

2738 
ptls_iovec_t
 
certs
[16];

2739 
size_t
 
num_certs
 = 0;

2740 int 
ret
 = 0;

2743 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

2744 if (
src
 != 
end
) {

2745 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2746 goto 
Exit
;

2750 
	`ptls_decode_block
(
src
, 
end
, 3, {

2751 while (
src
 != 
end
) {

2752 
	`ptls_decode_open_block
(
src
, 
end
, 3, {

2753 if (
num_certs
 < 
	`PTLS_ELEMENTSOF
(
certs
))

2754 
certs
[
num_certs
++] = 
	`ptls_iovec_init
(
src
, 
end
 - src);

2755 
src
 = 
end
;

2757 
uint16_t
 
type
;

2758 
	`decode_open_extensions
(
src
, 
end
, 
PTLS_HANDSHAKE_TYPE_CERTIFICATE
, &
type
, {

2759 if (
tls
->
ctx
->
on_extension
 != 
NULL
 &&

2760 (
ret
 = 
tls
->
ctx
->
on_extension
->
	`cb
(tls->ctx->on_extension, tls, 
PTLS_HANDSHAKE_TYPE_CERTIFICATE
, 
type
,

2761 
	`ptls_iovec_init
(
src
, 
end
 - src)) != 0))

2762 goto 
Exit
;

2763 
src
 = 
end
;

2768 if (
num_certs
 != 0 && 
tls
->
ctx
->
verify_certificate
 != 
NULL
) {

2769 if ((
ret
 = 
tls
->
ctx
->
verify_certificate
->
	`cb
(tls->ctx->verify_certificate, tls, &tls->
certificate_verify
.
cb
,

2770 &
tls
->
certificate_verify
.
verify_ctx
, 
certs
, 
num_certs
)) != 0)

2771 goto 
Exit
;

2774 *
got_certs
 = 
num_certs
 != 0;

2776 
Exit
:

2777 return 
ret
;

2778 
	}
}

2780 static int 
	$client_do_handle_certificate
(
ptls_t
 *
tls
, const 
uint8_t
 *
src
, const uint8_t *
end
)

2782 int 
got_certs
, 
ret
;

2784 if ((
ret
 = 
	`handle_certificate
(
tls
, 
src
, 
end
, &
got_certs
)) != 0)

2785 return 
ret
;

2786 if (!
got_certs
)

2787 return 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2790 
	}
}

2792 static int 
	$client_handle_certificate
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
)

2794 int 
ret
;

2796 if ((
ret
 = 
	`client_do_handle_certificate
(
tls
, 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, message.base + message.
len
)) != 0)

2797 return 
ret
;

2799 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

2801 
tls
->
state
 = 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE_VERIFY
;

2802 return 
PTLS_ERROR_IN_PROGRESS
;

2803 
	}
}

2805 static int 
	$client_handle_compressed_certificate
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
)

2807 const 
uint8_t
 *
src
 = 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, *const 
end
 = message.base + message.
len
;

2808 
uint16_t
 
algo
;

2809 
uint32_t
 
uncompressed_size
;

2810 
uint8_t
 *
uncompressed
 = 
NULL
;

2811 int 
ret
;

2813 if (
tls
->
ctx
->
decompress_certificate
 == 
NULL
) {

2814 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

2815 goto 
Exit
;

2819 if ((
ret
 = 
	`ptls_decode16
(&
algo
, &
src
, 
end
)) != 0)

2820 goto 
Exit
;

2821 if ((
ret
 = 
	`ptls_decode24
(&
uncompressed_size
, &
src
, 
end
)) != 0)

2822 goto 
Exit
;

2823 if (
uncompressed_size
 > 65536) {

2824 
ret
 = 
PTLS_ALERT_BAD_CERTIFICATE
;

2825 goto 
Exit
;

2827 if ((
uncompressed
 = 
	`malloc
(
uncompressed_size
)) == 
NULL
) {

2828 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

2829 goto 
Exit
;

2831 
	`ptls_decode_block
(
src
, 
end
, 3, {

2832 if ((
ret
 = 
tls
->
ctx
->
decompress_certificate
->
	`cb
(tls->ctx->decompress_certificate, tls, 
algo
,

2833 
	`ptls_iovec_init
(
uncompressed
, 
uncompressed_size
),

2834 
	`ptls_iovec_init
(
src
, 
end
 - src))) != 0)

2835 goto 
Exit
;

2836 
src
 = 
end
;

2840 if ((
ret
 = 
	`client_do_handle_certificate
(
tls
, 
uncompressed
, uncompressed + 
uncompressed_size
)) != 0)

2841 goto 
Exit
;

2843 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

2844 
tls
->
state
 = 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE_VERIFY
;

2845 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

2847 
Exit
:

2848 
	`free
(
uncompressed
);

2849 return 
ret
;

2850 
	}
}

2852 static int 
	$server_handle_certificate
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
)

2854 int 
got_certs
, 
ret
;

2856 if ((
ret
 = 
	`handle_certificate
(
tls
, 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, message.base + message.
len
, &
got_certs
)) != 0)

2857 return 
ret
;

2858 if (!
got_certs
)

2859 return 
PTLS_ALERT_CERTIFICATE_REQUIRED
;

2861 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

2863 
tls
->
state
 = 
PTLS_STATE_SERVER_EXPECT_CERTIFICATE_VERIFY
;

2864 return 
PTLS_ERROR_IN_PROGRESS
;

2865 
	}
}

2867 static int 
	$handle_certificate_verify
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
, const char *
context_string
)

2869 const 
uint8_t
 *
src
 = 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, *const 
end
 = message.base + message.
len
;

2870 
uint16_t
 
algo
;

2871 
ptls_iovec_t
 
signature
;

2872 
uint8_t
 
signdata
[
PTLS_MAX_CERTIFICATE_VERIFY_SIGNDATA_SIZE
];

2873 
size_t
 
signdata_size
;

2874 int 
ret
;

2877 if ((
ret
 = 
	`ptls_decode16
(&
algo
, &
src
, 
end
)) != 0)

2878 goto 
Exit
;

2879 
	`ptls_decode_block
(
src
, 
end
, 2, {

2880 
signature
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

2881 
src
 = 
end
;

2884 
signdata_size
 = 
	`build_certificate_verify_signdata
(
signdata
, 
tls
->
key_schedule
, 
context_string
);

2885 if (
tls
->
certificate_verify
.
cb
 != 
NULL
) {

2886 
ret
 = 
tls
->
certificate_verify
.
	`cb
(tls->certificate_verify.
verify_ctx
, 
algo
, 
	`ptls_iovec_init
(
signdata
, 
signdata_size
),

2887 
signature
);

2889 
ret
 = 0;

2891 
	`ptls_clear_memory
(
signdata
, 
signdata_size
);

2892 
tls
->
certificate_verify
.
cb
 = 
NULL
;

2893 if (
ret
 != 0) {

2894 goto 
Exit
;

2897 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

2899 
Exit
:

2900 return 
ret
;

2901 
	}
}

2903 static int 
	$client_handle_certificate_verify
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
)

2905 int 
ret
 = 
	`handle_certificate_verify
(
tls
, 
message
, 
PTLS_SERVER_CERTIFICATE_VERIFY_CONTEXT_STRING
);

2907 if (
ret
 == 0) {

2908 
tls
->
state
 = 
PTLS_STATE_CLIENT_EXPECT_FINISHED
;

2909 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

2912 return 
ret
;

2913 
	}
}

2915 static int 
	$server_handle_certificate_verify
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
)

2917 int 
ret
 = 
	`handle_certificate_verify
(
tls
, 
message
, 
PTLS_CLIENT_CERTIFICATE_VERIFY_CONTEXT_STRING
);

2919 if (
ret
 == 0) {

2920 
tls
->
state
 = 
PTLS_STATE_SERVER_EXPECT_FINISHED
;

2921 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

2924 return 
ret
;

2925 
	}
}

2927 static int 
	$client_handle_finished
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_iovec_t
 
message
)

2929 
uint8_t
 
send_secret
[
PTLS_MAX_DIGEST_SIZE
];

2930 int 
ret
;

2932 if ((
ret
 = 
	`verify_finished
(
tls
, 
message
)) != 0)

2933 goto 
Exit
;

2934 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

2937 if ((
ret
 = 
	`key_schedule_extract
(
tls
->
key_schedule
, 
	`ptls_iovec_init
(
NULL
, 0))) != 0)

2938 goto 
Exit
;

2939 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 0, "s ap traffic", 3, 0)) != 0)

2940 goto 
Exit
;

2941 if ((
ret
 = 
	`derive_secret
(
tls
->
key_schedule
, 
send_secret
, "c ap traffic")) != 0)

2942 goto 
Exit
;

2943 if ((
ret
 = 
	`derive_exporter_secret
(
tls
, 0)) != 0)

2944 goto 
Exit
;

2947 if (
tls
->
pending_handshake_secret
 != 
NULL
) {

2948 
	`assert
(
tls
->
traffic_protection
.
enc
.
aead
 != 
NULL
 || tls->
ctx
->
update_traffic_key
 != NULL);

2949 if (
tls
->
client
.
using_early_data
 && !tls->
ctx
->
omit_end_of_early_data
)

2950 
	`ptls_push_message
(
emitter
, 
tls
->
key_schedule
, 
PTLS_HANDSHAKE_TYPE_END_OF_EARLY_DATA
, {});

2951 
tls
->
client
.
using_early_data
 = 0;

2952 if ((
ret
 = 
	`commission_handshake_secret
(
tls
)) != 0)

2953 goto 
Exit
;

2956 if ((
ret
 = 
	`push_change_cipher_spec
(
tls
, 
emitter
)) != 0)

2957 goto 
Exit
;

2959 if (
tls
->
client
.
certificate_request
.
context
.
base
 != 
NULL
) {

2961 if (
tls
->
is_psk_handshake
) {

2962 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

2963 goto 
Exit
;

2965 
ret
 = 
	`send_certificate_and_certificate_verify
(
tls
, 
emitter
, &tls->
client
.
certificate_request
.
signature_algorithms
,

2966 
tls
->
client
.
certificate_request
.
context
,

2967 
PTLS_CLIENT_CERTIFICATE_VERIFY_CONTEXT_STRING
, 0, 
NULL
, 0);

2968 
	`free
(
tls
->
client
.
certificate_request
.
context
.
base
);

2969 
tls
->
client
.
certificate_request
.
context
 = 
	`ptls_iovec_init
(
NULL
, 0);

2970 if (
ret
 != 0)

2971 goto 
Exit
;

2974 
ret
 = 
	`send_finished
(
tls
, 
emitter
);

2976 
	`memcpy
(
tls
->
traffic_protection
.
enc
.
secret
, 
send_secret
, sizeof(send_secret));

2977 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 1, 
NULL
, 3, 0)) != 0)

2978 goto 
Exit
;

2980 
tls
->
state
 = 
PTLS_STATE_CLIENT_POST_HANDSHAKE
;

2982 
Exit
:

2983 
	`ptls_clear_memory
(
send_secret
, sizeof(send_secret));

2984 return 
ret
;

2985 
	}
}

2987 static int 
	$client_handle_new_session_ticket
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
)

2989 const 
uint8_t
 *
src
 = 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, *const 
end
 = message.base + message.
len
;

2990 
ptls_iovec_t
 
ticket_nonce
;

2991 int 
ret
;

2994 
uint32_t
 
ticket_lifetime
, 
ticket_age_add
, 
max_early_data_size
;

2995 
ptls_iovec_t
 
ticket
;

2996 if ((
ret
 = 
	`decode_new_session_ticket
(
tls
, &
ticket_lifetime
, &
ticket_age_add
, &
ticket_nonce
, &
ticket
, &
max_early_data_size
,

2997 
src
, 
end
)) != 0)

2998 return 
ret
;

3002 if (
tls
->
ctx
->
save_ticket
 == 
NULL
)

3006 
ptls_buffer_t
 
ticket_buf
;

3007 
	`ptls_buffer_init
(&
ticket_buf
, "", 0);

3008 
	`ptls_buffer_push64
(&
ticket_buf
, 
tls
->
ctx
->
get_time
->
	`cb
(tls->ctx->get_time));

3009 
	`ptls_buffer_push16
(&
ticket_buf
, 
tls
->
key_share
->
id
);

3010 
	`ptls_buffer_push16
(&
ticket_buf
, 
tls
->
cipher_suite
->
id
);

3011 
	`ptls_buffer_push_block
(&
ticket_buf
, 3, { 
	`ptls_buffer_pushv
(&ticket_buf, 
src
, 
end
 - src); });

3012 
	`ptls_buffer_push_block
(&
ticket_buf
, 2, {

3013 if ((
ret
 = 
	`ptls_buffer_reserve
(&
ticket_buf
, 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
)) != 0)

3014 goto 
Exit
;

3015 if ((
ret
 = 
	`derive_resumption_secret
(
tls
->
key_schedule
, 
ticket_buf
.
base
 + ticket_buf.
off
, 
ticket_nonce
)) != 0)

3016 goto 
Exit
;

3017 
ticket_buf
.
off
 += 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
;

3020 if ((
ret
 = 
tls
->
ctx
->
save_ticket
->
	`cb
(tls->ctx->save_ticket, tls, 
	`ptls_iovec_init
(
ticket_buf
.
base
, ticket_buf.
off
))) != 0)

3021 goto 
Exit
;

3023 
ret
 = 0;

3024 
Exit
:

3025 
	`ptls_buffer_dispose
(&
ticket_buf
);

3026 return 
ret
;

3027 
	}
}

3029 static int 
	$client_hello_decode_server_name
(
ptls_iovec_t
 *
name
, const 
uint8_t
 **
src
, const uint8_t *const 
end
)

3031 int 
ret
 = 0;

3033 
	`ptls_decode_open_block
(*
src
, 
end
, 2, {

3034 if (*
src
 == 
end
) {

3035 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3036 goto 
Exit
;

3039 
uint8_t
 
type
 = *(*
src
)++;

3040 
	`ptls_decode_open_block
(*
src
, 
end
, 2, {

3041 switch (
type
) {

3042 case 
PTLS_SERVER_NAME_TYPE_HOSTNAME
:

3043 if (
	`memchr
(*
src
, '\0', 
end
 - *src) != 0) {

3044 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3045 goto 
Exit
;

3047 *
name
 = 
	`ptls_iovec_init
(*
src
, 
end
 - *src);

3052 *
src
 = 
end
;

3054 } while (*
src
 != 
end
);

3057 
Exit
:

3058 return 
ret
;

3059 
	}
}

3061 static int 
	$client_hello_decrypt_esni
(
ptls_context_t
 *
ctx
, 
ptls_iovec_t
 *
server_name
, 
ptls_esni_secret_t
 **
secret
,

3062 struct 
st_ptls_client_hello_t
 *
ch
)

3064 
ptls_esni_context_t
 **
esni
;

3065 
ptls_key_exchange_context_t
 **
key_share_ctx
;

3066 
uint8_t
 *
decrypted
 = 
NULL
;

3067 
ptls_aead_context_t
 *
aead
 = 
NULL
;

3068 int 
ret
;

3071 
	`assert
(*
secret
 == 
NULL
);

3072 if ((*
secret
 = 
	`malloc
(sizeof(**secret))) == 
NULL
)

3073 return 
PTLS_ERROR_NO_MEMORY
;

3074 
	`memset
(*
secret
, 0, sizeof(**secret));

3077 for (
esni
 = 
ctx
->esni; *esni != 
NULL
; ++esni) {

3078 
size_t
 
i
;

3079 for (
i
 = 0; (*
esni
)->
cipher_suites
[i].
cipher_suite
 != 
NULL
; ++i)

3080 if ((*
esni
)->
cipher_suites
[
i
].
cipher_suite
->
id
 == 
ch
->esni.
cipher
->id)

3082 if ((*
esni
)->
cipher_suites
[
i
].
cipher_suite
 == 
NULL
) {

3083 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3084 goto 
Exit
;

3086 if (
	`memcmp
((*
esni
)->
cipher_suites
[
i
].
record_digest
, 
ch
->esni.record_digest, ch->esni.
cipher
->
hash
->
digest_size
) == 0) {

3087 (*
secret
)->
version
 = (*
esni
)->version;

3091 if (*
esni
 == 
NULL
) {

3092 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3093 goto 
Exit
;

3097 for (
key_share_ctx
 = (*
esni
)->
key_exchanges
; *key_share_ctx != 
NULL
; ++key_share_ctx)

3098 if ((*
key_share_ctx
)->
algo
->
id
 == 
ch
->
esni
.
key_share
->id)

3100 if (*
key_share_ctx
 == 
NULL
) {

3101 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3102 goto 
Exit
;

3106 if ((
ret
 = 
	`build_esni_contents_hash
(
ch
->
esni
.
cipher
->
hash
, (*
secret
)->
esni_contents_hash
, ch->esni.
record_digest
,

3107 
ch
->
esni
.
key_share
->
id
, ch->esni.
peer_key
, ch->
random_bytes
)) != 0)

3108 goto 
Exit
;

3110 if ((
ret
 = (*
key_share_ctx
)->
	`on_exchange
(key_share_ctx, 0, &(*
secret
)->secret, 
ch
->
esni
.
peer_key
)) != 0)

3111 goto 
Exit
;

3113 if (
ch
->
esni
.
encrypted_sni
.
len
 - ch->esni.
cipher
->
aead
->
tag_size
 != (*esni)->
padded_length
 + 
PTLS_ESNI_NONCE_SIZE
) {

3114 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3115 goto 
Exit
;

3117 if ((
decrypted
 = 
	`malloc
((*
esni
)->
padded_length
 + 
PTLS_ESNI_NONCE_SIZE
)) == 
NULL
) {

3118 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

3119 goto 
Exit
;

3121 if ((
ret
 = 
	`create_esni_aead
(&
aead
, 0, 
ch
->
esni
.
cipher
, (*
secret
)->secret, (*secret)->
esni_contents_hash
)) != 0)

3122 goto 
Exit
;

3123 if (
	`ptls_aead_decrypt
(
aead
, 
decrypted
, 
ch
->
esni
.
encrypted_sni
.
base
, ch->esni.encrypted_sni.
len
, 0, ch->
key_shares
.base,

3124 
ch
->
key_shares
.
len
) != (*
esni
)->
padded_length
 + 
PTLS_ESNI_NONCE_SIZE
) {

3125 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

3126 goto 
Exit
;

3128 
	`ptls_aead_free
(
aead
);

3129 
aead
 = 
NULL
;

3132 const 
uint8_t
 *
src
 = 
decrypted
, *const 
end
 = src + (*
esni
)->
padded_length
;

3133 
ptls_iovec_t
 
found_name
;

3134 if (
end
 - 
src
 < 
PTLS_ESNI_NONCE_SIZE
) {

3135 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3136 goto 
Exit
;

3138 
	`memcpy
((*
secret
)->
nonce
, 
src
, 
PTLS_ESNI_NONCE_SIZE
);

3139 
src
 += 
PTLS_ESNI_NONCE_SIZE
;

3140 if ((
ret
 = 
	`client_hello_decode_server_name
(&
found_name
, &
src
, 
end
)) != 0)

3141 goto 
Exit
;

3142 for (; 
src
 != 
end
; ++src) {

3143 if (*
src
 != '\0') {

3144 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3145 goto 
Exit
;

3149 
	`memmove
(
decrypted
, 
found_name
.
base
, found_name.
len
);

3150 *
server_name
 = 
	`ptls_iovec_init
(
decrypted
, 
found_name
.
len
);

3151 
decrypted
 = 
NULL
;

3154 
ret
 = 0;

3155 
Exit
:

3156 if (
decrypted
 != 
NULL
)

3157 
	`free
(
decrypted
);

3158 if (
aead
 != 
NULL
)

3159 
	`ptls_aead_free
(
aead
);

3160 if (
ret
 != 0 && *
secret
 != 
NULL
)

3161 
	`free_esni_secret
(
secret
, 1);

3162 return 
ret
;

3163 
	}
}

3165 static int 
	$select_negotiated_group
(
ptls_key_exchange_algorithm_t
 **
selected
, ptls_key_exchange_algorithm_t **
candidates
,

3166 const 
uint8_t
 *
src
, const uint8_t *const 
end
)

3168 int 
ret
;

3170 
	`ptls_decode_block
(
src
, 
end
, 2, {

3171 while (
src
 != 
end
) {

3172 
uint16_t
 
group
;

3173 if ((
ret
 = 
	`ptls_decode16
(&
group
, &
src
, 
end
)) != 0)

3174 goto 
Exit
;

3175 
ptls_key_exchange_algorithm_t
 **
c
 = 
candidates
;

3176 for (; *
c
 != 
NULL
; ++c) {

3177 if ((*
c
)->
id
 == 
group
) {

3178 *
selected
 = *
c
;

3185 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

3187 
Exit
:

3188 return 
ret
;

3189 
	}
}

3191 static int 
	$decode_client_hello
(
ptls_t
 *
tls
, struct 
st_ptls_client_hello_t
 *
ch
, const 
uint8_t
 *
src
, const uint8_t *const 
end
,

3192 
ptls_handshake_properties_t
 *
properties
)

3194 
uint16_t
 
exttype
 = 0;

3195 int 
ret
;

3198 if ((
ret
 = 
	`ptls_decode16
(&
ch
->
legacy_version
, &
src
, 
end
)) != 0)

3199 goto 
Exit
;

3200 if (
ch
->
legacy_version
 < 0x0301) {

3201 
ret
 = 
PTLS_ALERT_PROTOCOL_VERSION
;

3202 goto 
Exit
;

3206 if (
end
 - 
src
 < 
PTLS_HELLO_RANDOM_SIZE
) {

3207 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3208 goto 
Exit
;

3210 
ch
->
random_bytes
 = 
src
;

3211 
src
 += 
PTLS_HELLO_RANDOM_SIZE
;

3214 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

3215 if (
end
 - 
src
 > 32) {

3216 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3217 goto 
Exit
;

3219 
ch
->
legacy_session_id
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3220 
src
 = 
end
;

3224 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

3225 
ch
->
cipher_suites
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3226 
uint16_t
 *
id
 = 
ch
->
client_ciphers
.
list
;

3228 if ((
ret
 = 
	`ptls_decode16
(
id
, &
src
, 
end
)) != 0)

3229 goto 
Exit
;

3230 
id
++;

3231 
ch
->
client_ciphers
.
count
++;

3232 if (
id
 >= 
ch
->
client_ciphers
.
list
 + 
MAX_CLIENT_CIPHERS
) {

3233 
src
 = 
end
;

3236 } while (
src
 != 
end
);

3240 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

3241 if (
src
 == 
end
) {

3242 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3243 goto 
Exit
;

3245 
ch
->
compression_methods
.
ids
 = 
src
;

3246 
ch
->
compression_methods
.
count
 = 
end
 - 
src
;

3247 
src
 = 
end
;

3251 
	`decode_extensions
(
src
, 
end
, 
PTLS_HANDSHAKE_TYPE_CLIENT_HELLO
, &
exttype
, {

3252 
ch
->
psk
.
is_last_extension
 = 0;

3253 if (
tls
->
ctx
->
on_extension
 != 
NULL
 &&

3254 (
ret
 = 
tls
->
ctx
->
on_extension
->
	`cb
(tls->ctx->on_extension, tls, 
PTLS_HANDSHAKE_TYPE_CLIENT_HELLO
, 
exttype
,

3255 
	`ptls_iovec_init
(
src
, 
end
 - src)) != 0))

3256 goto 
Exit
;

3257 switch (
exttype
) {

3258 case 
PTLS_EXTENSION_TYPE_SERVER_NAME
:

3259 if ((
ret
 = 
	`client_hello_decode_server_name
(&
ch
->
server_name
, &
src
, 
end
)) != 0)

3260 goto 
Exit
;

3261 if (
src
 != 
end
) {

3262 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3263 goto 
Exit
;

3266 case 
PTLS_EXTENSION_TYPE_ENCRYPTED_SERVER_NAME
: {

3267 
ptls_cipher_suite_t
 **
cipher
;

3268 if (
ch
->
esni
.
cipher
 != 
NULL
) {

3269 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3270 goto 
Exit
;

3273 
uint16_t
 
csid
;

3274 if ((
ret
 = 
	`ptls_decode16
(&
csid
, &
src
, 
end
)) != 0)

3275 goto 
Exit
;

3276 for (
cipher
 = 
tls
->
ctx
->
cipher_suites
; *cipher != 
NULL
; ++cipher)

3277 if ((*
cipher
)->
id
 == 
csid
)

3279 if (*
cipher
 == 
NULL
) {

3280 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3281 goto 
Exit
;

3285 if ((
ret
 = 
	`select_key_share
(&
ch
->
esni
.
key_share
, &ch->esni.
peer_key
, 
tls
->
ctx
->
key_exchanges
, &
src
, 
end
, 1)) != 0)

3286 goto 
Exit
;

3287 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

3288 
size_t
 
len
 = 
end
 - 
src
;

3289 if (
len
 != (*
cipher
)->
hash
->
digest_size
) {

3290 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3291 goto 
Exit
;

3293 
ch
->
esni
.
record_digest
 = 
src
;

3294 
src
 += 
len
;

3296 
	`ptls_decode_block
(
src
, 
end
, 2, {

3297 
size_t
 
len
 = 
end
 - 
src
;

3298 if (
len
 < (*
cipher
)->
aead
->
tag_size
) {

3299 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3300 goto 
Exit
;

3302 
ch
->
esni
.
encrypted_sni
 = 
	`ptls_iovec_init
(
src
, 
len
);

3303 
src
 += 
len
;

3305 
ch
->
esni
.
cipher
 = *cipher;

3307 case 
PTLS_EXTENSION_TYPE_ALPN
:

3308 
	`ptls_decode_block
(
src
, 
end
, 2, {

3310 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

3312 if (
src
 == 
end
) {

3313 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3314 goto 
Exit
;

3316 if (
ch
->
alpn
.
count
 < 
	`PTLS_ELEMENTSOF
(ch->alpn.
list
))

3317 
ch
->
alpn
.
list
[ch->alpn.
count
++] = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3318 
src
 = 
end
;

3320 } while (
src
 != 
end
);

3323 case 
PTLS_EXTENSION_TYPE_SERVER_CERTIFICATE_TYPE
:

3324 
	`ptls_decode_block
(
src
, 
end
, 1, {

3325 
size_t
 
list_size
 = 
end
 - 
src
;

3328 if (
list_size
 == 0 || (list_size == 1 && *
src
 == 
PTLS_CERTIFICATE_TYPE_X509
)) {

3329 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3330 goto 
Exit
;

3334 if (
ch
->
server_certificate_types
.
count
 < 
	`PTLS_ELEMENTSOF
(ch->server_certificate_types.
list
))

3335 
ch
->
server_certificate_types
.
list
[ch->server_certificate_types.
count
++] = *
src
;

3336 
src
++;

3337 } while (
src
 != 
end
);

3340 case 
PTLS_EXTENSION_TYPE_COMPRESS_CERTIFICATE
:

3341 
	`ptls_decode_block
(
src
, 
end
, 1, {

3343 
uint16_t
 
id
;

3344 if ((
ret
 = 
	`ptls_decode16
(&
id
, &
src
, 
end
)) != 0)

3345 goto 
Exit
;

3346 if (
ch
->
cert_compression_algos
.
count
 < 
	`PTLS_ELEMENTSOF
(ch->cert_compression_algos.
list
))

3347 
ch
->
cert_compression_algos
.
list
[ch->cert_compression_algos.
count
++] = 
id
;

3348 } while (
src
 != 
end
);

3351 case 
PTLS_EXTENSION_TYPE_SUPPORTED_GROUPS
:

3352 
ch
->
negotiated_groups
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3354 case 
PTLS_EXTENSION_TYPE_SIGNATURE_ALGORITHMS
:

3355 if ((
ret
 = 
	`decode_signature_algorithms
(&
ch
->
signature_algorithms
, &
src
, 
end
)) != 0)

3356 goto 
Exit
;

3358 case 
PTLS_EXTENSION_TYPE_KEY_SHARE
:

3359 
ch
->
key_shares
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3361 case 
PTLS_EXTENSION_TYPE_SUPPORTED_VERSIONS
:

3362 
	`ptls_decode_block
(
src
, 
end
, 1, {

3363 
size_t
 
selected_index
 = 
	`PTLS_ELEMENTSOF
(
supported_versions
);

3365 
size_t
 
i
;

3366 
uint16_t
 
v
;

3367 if ((
ret
 = 
	`ptls_decode16
(&
v
, &
src
, 
end
)) != 0)

3368 goto 
Exit
;

3369 for (
i
 = 0; i != 
selected_index
; ++i) {

3370 if (
supported_versions
[
i
] == 
v
) {

3371 
selected_index
 = 
i
;

3375 } while (
src
 != 
end
);

3376 if (
selected_index
 != 
	`PTLS_ELEMENTSOF
(
supported_versions
))

3377 
ch
->
selected_version
 = 
supported_versions
[
selected_index
];

3380 case 
PTLS_EXTENSION_TYPE_COOKIE
:

3381 if (
properties
 == 
NULL
 || properties->
server
.
cookie
.
key
 == NULL) {

3382 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3383 goto 
Exit
;

3385 
ch
->
cookie
.
all
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3386 
	`ptls_decode_block
(
src
, 
end
, 2, {

3387 
ch
->
cookie
.
tbs
.
base
 = (void *)
src
;

3388 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

3389 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

3390 
ch
->
cookie
.
ch1_hash
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3391 
src
 = 
end
;

3393 if (
src
 == 
end
) {

3394 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3395 goto 
Exit
;

3397 switch (*
src
++) {

3399 
	`assert
(!
ch
->
cookie
.
sent_key_share
);

3402 
ch
->
cookie
.
sent_key_share
 = 1;

3405 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3406 goto 
Exit
;

3409 
ch
->
cookie
.
tbs
.
len
 = 
src
 - ch->cookie.tbs.
base
;

3410 
	`ptls_decode_block
(
src
, 
end
, 1, {

3411 
ch
->
cookie
.
signature
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3412 
src
 = 
end
;

3416 case 
PTLS_EXTENSION_TYPE_PRE_SHARED_KEY
: {

3417 
size_t
 
num_identities
 = 0;

3418 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

3420 struct 
st_ptls_client_hello_psk_t
 
psk
 = {{
NULL
}};

3421 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

3422 
psk
.
identity
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3423 
src
 = 
end
;

3425 if ((
ret
 = 
	`ptls_decode32
(&
psk
.
obfuscated_ticket_age
, &
src
, 
end
)) != 0)

3426 goto 
Exit
;

3427 if (
ch
->
psk
.
identities
.
count
 < 
	`PTLS_ELEMENTSOF
(ch->psk.identities.
list
))

3428 
ch
->
psk
.
identities
.
list
[ch->psk.identities.
count
++] = psk;

3429 ++
num_identities
;

3430 } while (
src
 != 
end
);

3432 
ch
->
psk
.
hash_end
 = 
src
;

3433 
	`ptls_decode_block
(
src
, 
end
, 2, {

3434 
size_t
 
num_binders
 = 0;

3436 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

3437 if (
num_binders
 < 
ch
->
psk
.
identities
.
count
)

3438 
ch
->
psk
.
identities
.
list
[
num_binders
].
binder
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

3439 
src
 = 
end
;

3441 ++
num_binders
;

3442 } while (
src
 != 
end
);

3443 if (
num_identities
 != 
num_binders
) {

3444 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3445 goto 
Exit
;

3448 
ch
->
psk
.
is_last_extension
 = 1;

3450 case 
PTLS_EXTENSION_TYPE_PSK_KEY_EXCHANGE_MODES
:

3451 
	`ptls_decode_block
(
src
, 
end
, 1, {

3452 if (
src
 == 
end
) {

3453 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3454 goto 
Exit
;

3456 for (; 
src
 != 
end
; ++src) {

3457 if (*
src
 < sizeof(
ch
->
psk
.
ke_modes
) * 8)

3458 
ch
->
psk
.
ke_modes
 |= 1u << *
src
;

3462 case 
PTLS_EXTENSION_TYPE_EARLY_DATA
:

3463 
ch
->
psk
.
early_data_indication
 = 1;

3465 case 
PTLS_EXTENSION_TYPE_STATUS_REQUEST
:

3466 
ch
->
status_request
 = 1;

3469 if (
	`should_collect_unknown_extension
(
tls
, 
properties
, 
exttype
)) {

3470 if ((
ret
 = 
	`collect_unknown_extension
(
tls
, 
exttype
, 
src
, 
end
, 
ch
->
unknown_extensions
)) != 0)

3471 goto 
Exit
;

3475 
src
 = 
end
;

3478 
ret
 = 0;

3479 
Exit
:

3480 return 
ret
;

3481 
	}
}

3483 static int 
	$vec_is_string
(
ptls_iovec_t
 
x
, const char *
y
)

3485 return 
	`strncmp
((const char *)
x
.
base
, 
y
, x.
len
) == 0 && y[x.len] == '\0';

3486 
	}
}

3488 static int 
	$try_psk_handshake
(
ptls_t
 *
tls
, 
size_t
 *
psk_index
, int *
accept_early_data
, struct 
st_ptls_client_hello_t
 *
ch
,

3489 
ptls_iovec_t
 
ch_trunc
)

3491 
ptls_buffer_t
 
decbuf
;

3492 
ptls_iovec_t
 
ticket_psk
, 
ticket_server_name
, 
ticket_negotiated_protocol
;

3493 
uint64_t
 
issue_at
, 
now
 = 
tls
->
ctx
->
get_time
->
	`cb
(tls->ctx->get_time);

3494 
uint32_t
 
age_add
;

3495 
uint16_t
 
ticket_key_exchange_id
, 
ticket_csid
;

3496 
uint8_t
 
binder_key
[
PTLS_MAX_DIGEST_SIZE
];

3497 int 
ret
;

3499 
	`ptls_buffer_init
(&
decbuf
, "", 0);

3501 for (*
psk_index
 = 0; *psk_index < 
ch
->
psk
.
identities
.
count
; ++*psk_index) {

3502 struct 
st_ptls_client_hello_psk_t
 *
identity
 = 
ch
->
psk
.
identities
.
list
 + *
psk_index
;

3504 int 
can_accept_early_data
 = 1;

3505 
decbuf
.
off
 = 0;

3506 switch (
tls
->
ctx
->
encrypt_ticket
->
	`cb
(tls->ctx->encrypt_ticket, tls, 0, &
decbuf
, 
identity
->identity)) {

3509 case 
PTLS_ERROR_REJECT_EARLY_DATA
:

3510 
can_accept_early_data
 = 0;

3515 if (
	`decode_session_identifier
(&
issue_at
, &
ticket_psk
, &
age_add
, &
ticket_server_name
, &
ticket_key_exchange_id
, &
ticket_csid
,

3516 &
ticket_negotiated_protocol
, 
decbuf
.
base
, decbuf.base + decbuf.
off
) != 0)

3519 if (
now
 < 
issue_at
)

3521 if (
now
 - 
issue_at
 > (
uint64_t
)
tls
->
ctx
->
ticket_lifetime
 * 1000)

3523 *
accept_early_data
 = 0;

3524 if (
ch
->
psk
.
early_data_indication
 && 
can_accept_early_data
) {

3526 
int64_t
 
delta
 = (
now
 - 
issue_at
) - (
identity
->
obfuscated_ticket_age
 - 
age_add
);

3527 if (
delta
 < 0)

3528 
delta
 = -delta;

3529 if (
tls
->
ctx
->
max_early_data_size
 != 0 && 
delta
 <= 
PTLS_EARLY_DATA_MAX_DELAY
)

3530 *
accept_early_data
 = 1;

3533 if (
ticket_server_name
.
len
 != 0) {

3534 if (
tls
->
server_name
 == 
NULL
)

3536 if (!
	`vec_is_string
(
ticket_server_name
, 
tls
->
server_name
))

3539 if (
tls
->
server_name
 != 
NULL
)

3543 
ptls_key_exchange_algorithm_t
 **
a
;

3544 for (
a
 = 
tls
->
ctx
->
key_exchanges
; *a != 
NULL
 && (*a)->
id
 != 
ticket_key_exchange_id
; ++a)

3546 if (*
a
 == 
NULL
)

3548 
tls
->
key_share
 = *
a
;

3551 if (
ticket_csid
 != 
tls
->
cipher_suite
->
id
)

3554 if (
ticket_negotiated_protocol
.
len
 != 0) {

3555 if (
tls
->
negotiated_protocol
 == 
NULL
)

3557 if (!
	`vec_is_string
(
ticket_negotiated_protocol
, 
tls
->
negotiated_protocol
))

3561 if (
ticket_psk
.
len
 != 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
)

3563 if (
ch
->
psk
.
identities
.
list
[*
psk_index
].
binder
.
len
 != 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
)

3567 goto 
Found
;

3571 *
psk_index
 = 
SIZE_MAX
;

3572 *
accept_early_data
 = 0;

3573 
tls
->
key_share
 = 
NULL
;

3574 
ret
 = 0;

3575 goto 
Exit
;

3577 
Found
:

3578 if ((
ret
 = 
	`key_schedule_extract
(
tls
->
key_schedule
, 
ticket_psk
)) != 0)

3579 goto 
Exit
;

3580 if ((
ret
 = 
	`derive_secret
(
tls
->
key_schedule
, 
binder_key
, "res binder")) != 0)

3581 goto 
Exit
;

3582 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
ch_trunc
.
base
, ch_trunc.
len
);

3583 if ((
ret
 = 
	`calc_verify_data
(
binder_key
 , 
tls
->
key_schedule
,

3584 
binder_key
)) != 0)

3585 goto 
Exit
;

3586 if (!
	`ptls_mem_equal
(
ch
->
psk
.
identities
.
list
[*
psk_index
].
binder
.
base
, 
binder_key
,

3587 
tls
->
key_schedule
->
hashes
[0].
algo
->
digest_size
)) {

3588 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

3589 goto 
Exit
;

3591 
ret
 = 0;

3593 
Exit
:

3594 
	`ptls_buffer_dispose
(&
decbuf
);

3595 
	`ptls_clear_memory
(
binder_key
, sizeof(binder_key));

3596 return 
ret
;

3597 
	}
}

3599 static int 
	$calc_cookie_signature
(
ptls_t
 *
tls
, 
ptls_handshake_properties_t
 *
properties
,

3600 
ptls_key_exchange_algorithm_t
 *
negotiated_group
, 
ptls_iovec_t
 
tbs
, 
uint8_t
 *
sig
)

3602 
ptls_hash_algorithm_t
 *
algo
 = 
tls
->
ctx
->
cipher_suites
[0]->
hash
;

3603 
ptls_hash_context_t
 *
hctx
;

3605 if ((
hctx
 = 
	`ptls_hmac_create
(
algo
, 
properties
->
server
.
cookie
.
key
, algo->
digest_size
)) == 
NULL
)

3606 return 
PTLS_ERROR_NO_MEMORY
;

3608 #define 
	#UPDATE_BLOCK
(
p
, 
_len
) \

3610 
size_t
 
len
 = (
_len
); \

3611 
	`assert
(
len
 < 
UINT8_MAX
); \

3612 
uint8_t
 
len8
 = (uint8_t)
len
; \

3613 
hctx
->
	`update
(hctx, &
len8
, 1); \

3614 
hctx
->
	`update
(hctx, (
p
), 
len
); \

3615 } while (0)

	)

3616 #define 
	#UPDATE16
(
_v
) \

3618 
uint16_t
 
v
 = (
_v
); \

3619 
uint8_t
 
b
[2] = {
v
 >> 8, v & 0xff}; \

3620 
hctx
->
	`update
(hctx, 
b
, 2); \

3621 } while (0)

	)

3623 
	`UPDATE_BLOCK
(
tls
->
client_random
, sizeof(tls->client_random));

3624 
	`UPDATE_BLOCK
(
tls
->
server_name
, tls->server_name != 
NULL
 ? 
	`strlen
(tls->server_name) : 0);

3625 
	`UPDATE16
(
tls
->
cipher_suite
->
id
);

3626 
	`UPDATE16
(
negotiated_group
->
id
);

3627 
	`UPDATE_BLOCK
(
properties
->
server
.
cookie
.
additional_data
.
base
, properties->server.cookie.additional_data.
len
);

3629 
	`UPDATE_BLOCK
(
tbs
.
base
, tbs.
len
);

3631 #undef 
UPDATE_BLOCK


3632 #undef 
UPDATE16


3634 
hctx
->
	`final
(hctx, 
sig
, 
PTLS_HASH_FINAL_MODE_FREE
);

3636 
	}
}

3638 static int 
	$certificate_type_exists
(
uint8_t
 *
list
, 
size_t
 
count
, uint8_t 
desired_type
)

3641 if (
desired_type
 == 
PTLS_CERTIFICATE_TYPE_X509
 && 
count
 == 0)

3643 for (
size_t
 
i
 = 0; i < 
count
; i++) {

3644 if (
list
[
i
] == 
desired_type
)

3648 
	}
}

3650 static int 
	$server_handle_hello
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_iovec_t
 
message
,

3651 
ptls_handshake_properties_t
 *
properties
)

3653 #define 
	#EMIT_SERVER_HELLO
(
sched
, 
fill_rand
, 
extensions
) \

3654 
	`ptls_push_message
(
emitter
, (
sched
), 
PTLS_HANDSHAKE_TYPE_SERVER_HELLO
, { \

3655 
	`ptls_buffer_push16
(
emitter
->
buf
, 0x0303 ); \

3656 if ((
ret
 = 
	`ptls_buffer_reserve
(
emitter
->
buf
, 
PTLS_HELLO_RANDOM_SIZE
)) != 0) \

3657 goto 
Exit
; \

3659 
fill_rand
 \

3661 
emitter
->
buf
->
off
 += 
PTLS_HELLO_RANDOM_SIZE
; \

3662 
	`ptls_buffer_push_block
(
emitter
->
buf
, 1, \

3663 { 
	`ptls_buffer_pushv
(
emitter
->
buf
, 
ch
->
legacy_session_id
.
base
, ch->legacy_session_id.
len
); }); \

3664 
	`ptls_buffer_push16
(
emitter
->
buf
, 
tls
->
cipher_suite
->
id
); \

3665 
	`ptls_buffer_push
(
emitter
->
buf
, 0); \

3666 
	`ptls_buffer_push_block
(
emitter
->
buf
, 2, { \

3667 
	`buffer_push_extension
(
emitter
->
buf
, 
PTLS_EXTENSION_TYPE_SUPPORTED_VERSIONS
, \

3668 { 
	`ptls_buffer_push16
(
emitter
->
buf
, 
ch
->
selected_version
); }); \

3670 
extensions
 \

3673 });

	)

3675 #define 
	#EMIT_HELLO_RETRY_REQUEST
(
sched
, 
negotiated_group
, 
additional_extensions
) \

3676 
	`EMIT_SERVER_HELLO
((
sched
), { 
	`memcpy
(
emitter
->
buf
->
base
 + emitter->buf->
off
, 
hello_retry_random
, 
PTLS_HELLO_RANDOM_SIZE
); }, \

3678 
ptls_key_exchange_algorithm_t
 *
_negotiated_group
 = (
negotiated_group
); \

3679 if (
_negotiated_group
 != 
NULL
) { \

3680 
	`buffer_push_extension
(
emitter
->
buf
, 
PTLS_EXTENSION_TYPE_KEY_SHARE
, \

3681 { 
	`ptls_buffer_push16
(
emitter
->
buf
, 
_negotiated_group
->
id
); }); \

3684 
additional_extensions
 \

3686 })

	)

3687 struct 
st_ptls_client_hello_t
 *
ch
;

3689 
ptls_key_exchange_algorithm_t
 *
algorithm
;

3690 
ptls_iovec_t
 
peer_key
;

3691 } 
key_share
 = {
NULL
};

3692 enum { 
HANDSHAKE_MODE_FULL
, 
HANDSHAKE_MODE_PSK
, 
HANDSHAKE_MODE_PSK_DHE
 } 
mode
;

3693 
size_t
 
psk_index
 = 
SIZE_MAX
;

3694 
ptls_iovec_t
 
pubkey
 = {0}, 
ecdh_secret
 = {0};

3695 int 
accept_early_data
 = 0, 
is_second_flight
 = 
tls
->
state
 == 
PTLS_STATE_SERVER_EXPECT_SECOND_CLIENT_HELLO
, 
ret
;

3697 if ((
ch
 = 
	`malloc
(sizeof(*ch))) == 
NULL
) {

3698 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

3699 goto 
Exit
;

3702 *
ch
 = (struct 
st_ptls_client_hello_t
){0, 
NULL
, {NULL}, {NULL}, 0, {NULL}, {NULL}, {NULL}, {{0}},

3703 {
NULL
}, {NULL}, {{{NULL}}}, {{0}}, {{0}}, {{NULL}}, {NULL}, {{0}}, {{
UINT16_MAX
}}};

3706 if ((
ret
 = 
	`decode_client_hello
(
tls
, 
ch
, 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, message.base + message.
len
, 
properties
)) !=

3708 goto 
Exit
;

3711 if (!
	`is_supported_version
(
ch
->
selected_version
)) {

3712 if (!
is_second_flight
 && 
tls
->
ctx
->
on_client_hello
 != 
NULL
) {

3713 
ptls_on_client_hello_parameters_t
 
params
 = {

3714 .
server_name
 = 
ch
->server_name,

3715 .
raw_message
 = 
message
,

3716 .
negotiated_protocols
 = {
ch
->
alpn
.
list
, ch->alpn.
count
},

3717 .
incompatible_version
 = 1,

3719 if ((
ret
 = 
tls
->
ctx
->
on_client_hello
->
	`cb
(tls->ctx->on_client_hello, tls, &
params
)) != 0)

3720 goto 
Exit
;

3722 
ret
 = 
PTLS_ALERT_PROTOCOL_VERSION
;

3723 goto 
Exit
;

3728 if (
ch
->
legacy_version
 <= 0x0300) {

3731 
ret
 = 
PTLS_ALERT_PROTOCOL_VERSION
;

3732 goto 
Exit
;

3734 if (!(
ch
->
compression_methods
.
count
 == 1 && ch->compression_methods.
ids
[0] == 0)) {

3735 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3736 goto 
Exit
;

3739 if (
ch
->
esni
.
cipher
 != 
NULL
) {

3740 if (
ch
->
key_shares
.
base
 == 
NULL
) {

3741 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3742 goto 
Exit
;

3746 if (
ch
->
psk
.
hash_end
 != 
NULL
) {

3748 if (!
ch
->
psk
.
is_last_extension
) {

3749 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3750 goto 
Exit
;

3753 if (
ch
->
psk
.
early_data_indication
) {

3754 
ret
 = 
PTLS_ALERT_ILLEGAL_PARAMETER
;

3755 goto 
Exit
;

3759 if (
tls
->
ctx
->
require_dhe_on_psk
)

3760 
ch
->
psk
.
ke_modes
 &= ~(1u << 
PTLS_PSK_KE_MODE_PSK
);

3763 if (!
is_second_flight
) {

3764 
	`memcpy
(
tls
->
client_random
, 
ch
->
random_bytes
, sizeof(tls->client_random));

3765 
	`log_client_random
(
tls
);

3766 if (
ch
->
legacy_session_id
.
len
 != 0)

3767 
tls
->
send_change_cipher_spec
 = 1;

3768 
ptls_iovec_t
 
server_name
 = {
NULL
};

3769 int 
is_esni
 = 0;

3770 if (
ch
->
esni
.
cipher
 != 
NULL
 && 
tls
->
ctx
->esni != NULL) {

3771 if ((
ret
 = 
	`client_hello_decrypt_esni
(
tls
->
ctx
, &
server_name
, &tls->
esni
, 
ch
)) != 0)

3772 goto 
Exit
;

3773 if (
tls
->
ctx
->
update_esni_key
 != 
NULL
) {

3774 if ((
ret
 = 
tls
->
ctx
->
update_esni_key
->
	`cb
(tls->ctx->update_esni_key, tls, tls->
esni
->
secret
, 
ch
->esni.
cipher
->
hash
,

3775 
tls
->
esni
->
esni_contents_hash
)) != 0)

3776 goto 
Exit
;

3778 
is_esni
 = 1;

3779 } else if (
ch
->
server_name
.
base
 != 
NULL
) {

3780 
server_name
 = 
ch
->server_name;

3782 if (
tls
->
ctx
->
on_client_hello
 != 
NULL
) {

3783 
ptls_on_client_hello_parameters_t
 
params
 = {
server_name
,

3784 
message
,

3785 {
ch
->
alpn
.
list
, ch->alpn.
count
},

3786 {
ch
->
signature_algorithms
.
list
, ch->signature_algorithms.
count
},

3787 {
ch
->
cert_compression_algos
.
list
, ch->cert_compression_algos.
count
},

3788 {
ch
->
client_ciphers
.
list
, ch->client_ciphers.
count
},

3789 {
ch
->
server_certificate_types
.
list
, ch->server_certificate_types.
count
},

3790 
is_esni
};

3791 
ret
 = 
tls
->
ctx
->
on_client_hello
->
	`cb
(tls->ctx->on_client_hello, tls, &
params
);

3793 
ret
 = 0;

3796 if (
is_esni
)

3797 
	`free
(
server_name
.
base
);

3798 if (
ret
 != 0)

3799 goto 
Exit
;

3801 if (!
	`certificate_type_exists
(
ch
->
server_certificate_types
.
list
, ch->server_certificate_types.
count
,

3802 
tls
->
ctx
->
use_raw_public_keys
 ? 
PTLS_CERTIFICATE_TYPE_RAW_PUBLIC_KEY


3803 : 
PTLS_CERTIFICATE_TYPE_X509
)) {

3804 
ret
 = 
PTLS_ALERT_UNSUPPORTED_CERTIFICATE
;

3805 goto 
Exit
;

3808 if (
ch
->
psk
.
early_data_indication
) {

3809 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

3810 goto 
Exit
;

3814 if (!
	`ptls_mem_equal
(
tls
->
client_random
, 
ch
->
random_bytes
, sizeof(tls->client_random))) {

3815 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

3816 goto 
Exit
;

3820 if (
tls
->
server_name
 != 
NULL
) {

3821 
size_t
 
l
 = 
	`strlen
(
tls
->
server_name
);

3822 if (!(
ch
->
server_name
.
len
 == 
l
 && 
	`memcmp
(ch->server_name.
base
, 
tls
->server_name, l) == 0)) {

3823 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

3824 goto 
Exit
;

3830 
ptls_cipher_suite_t
 *
cs
;

3831 if ((
ret
 = 
	`select_cipher
(&
cs
, 
tls
->
ctx
->
cipher_suites
, 
ch
->cipher_suites.
base
,

3832 
ch
->
cipher_suites
.
base
 + ch->cipher_suites.
len
, 
tls
->
ctx
->
server_cipher_preference
)) != 0)

3833 goto 
Exit
;

3834 if (!
is_second_flight
) {

3835 
tls
->
cipher_suite
 = 
cs
;

3836 
tls
->
key_schedule
 = 
	`key_schedule_new
(
cs
, 
NULL
, tls->
ctx
->
hkdf_label_prefix__obsolete
);

3838 if (
tls
->
cipher_suite
 != 
cs
) {

3839 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

3840 goto 
Exit
;

3846 if (
key_share
.
algorithm
 == 
NULL
 && 
ch
->
key_shares
.
base
 != NULL) {

3847 const 
uint8_t
 *
src
 = 
ch
->
key_shares
.
base
, *const 
end
 = src + ch->key_shares.
len
;

3848 
	`ptls_decode_block
(
src
, 
end
, 2, {

3849 if ((
ret
 = 
	`select_key_share
(&
key_share
.
algorithm
, &key_share.
peer_key
, 
tls
->
ctx
->
key_exchanges
, &
src
, 
end
, 0)) != 0)

3850 goto 
Exit
;

3854 if (!
is_second_flight
) {

3855 if (
ch
->
cookie
.
all
.
len
 != 0 && 
key_share
.
algorithm
 != 
NULL
) {

3858 
size_t
 
sigsize
 = 
tls
->
ctx
->
cipher_suites
[0]->
hash
->
digest_size
;

3859 
uint8_t
 *
sig
 = 
	`alloca
(
sigsize
);

3860 if ((
ret
 = 
	`calc_cookie_signature
(
tls
, 
properties
, 
key_share
.
algorithm
, 
ch
->
cookie
.
tbs
, 
sig
)) != 0)

3861 goto 
Exit
;

3862 if (!(
ch
->
cookie
.
signature
.
len
 == 
sigsize
 && 
	`ptls_mem_equal
(ch->cookie.signature.
base
, 
sig
, sigsize))) {

3863 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

3864 goto 
Exit
;

3867 
	`key_schedule_update_ch1hash_prefix
(
tls
->
key_schedule
);

3868 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
ch
->
cookie
.
ch1_hash
.
base
, ch->cookie.ch1_hash.
len
);

3869 
	`key_schedule_extract
(
tls
->
key_schedule
, 
	`ptls_iovec_init
(
NULL
, 0));

3871 
size_t
 
hrr_start
 = 
emitter
->
buf
->
off
;

3872 
	`EMIT_HELLO_RETRY_REQUEST
(
tls
->
key_schedule
, 
ch
->
cookie
.
sent_key_share
 ? 
key_share
.
algorithm
 : 
NULL
, {

3873 
	`buffer_push_extension
(
emitter
->
buf
, 
PTLS_EXTENSION_TYPE_COOKIE
,

3874 { 
	`ptls_buffer_pushv
(
emitter
->
buf
, 
ch
->
cookie
.
all
.
base
, ch->cookie.all.
len
); });

3876 
emitter
->
buf
->
off
 = 
hrr_start
;

3877 
is_second_flight
 = 1;

3879 } else if (
key_share
.
algorithm
 == 
NULL
 || (
properties
 != NULL && properties->
server
.
enforce_retry
)) {

3882 if (
ch
->
negotiated_groups
.
base
 == 
NULL
) {

3883 
ret
 = 
PTLS_ALERT_MISSING_EXTENSION
;

3884 goto 
Exit
;

3886 
ptls_key_exchange_algorithm_t
 *
negotiated_group
;

3887 if ((
ret
 = 
	`select_negotiated_group
(&
negotiated_group
, 
tls
->
ctx
->
key_exchanges
, 
ch
->
negotiated_groups
.
base
,

3888 
ch
->
negotiated_groups
.
base
 + ch->negotiated_groups.
len
)) != 0)

3889 goto 
Exit
;

3890 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

3891 
	`assert
(
tls
->
key_schedule
->
generation
 == 0);

3892 if (
properties
 != 
NULL
 && properties->
server
.
retry_uses_cookie
) {

3895 
	`EMIT_HELLO_RETRY_REQUEST
(
NULL
, 
key_share
.
algorithm
 != NULL ? NULL : 
negotiated_group
, {

3896 
ptls_buffer_t
 *
sendbuf
 = 
emitter
->
buf
;

3897 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_COOKIE
, {

3898 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

3900 
size_t
 
tbs_start
 = 
sendbuf
->
off
;

3901 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

3903 
	`ptls_buffer_push_block
(
sendbuf
, 1, {

3904 
size_t
 
sz
 = 
tls
->
cipher_suite
->
hash
->
digest_size
;

3905 if ((
ret
 = 
	`ptls_buffer_reserve
(
sendbuf
, 
sz
)) != 0)

3906 goto 
Exit
;

3907 
	`key_schedule_extract_ch1hash
(
tls
->
key_schedule
, 
sendbuf
->
base
 + sendbuf->
off
);

3908 
sendbuf
->
off
 += 
sz
;

3911 
	`ptls_buffer_push
(
sendbuf
, 
key_share
.
algorithm
 == 
NULL
);

3914 
size_t
 
tbs_len
 = 
sendbuf
->
off
 - 
tbs_start
;

3916 
	`ptls_buffer_push_block
(
sendbuf
, 1, {

3917 
size_t
 
sz
 = 
tls
->
ctx
->
cipher_suites
[0]->
hash
->
digest_size
;

3918 if ((
ret
 = 
	`ptls_buffer_reserve
(
sendbuf
, 
sz
)) != 0)

3919 goto 
Exit
;

3920 if ((
ret
 = 
	`calc_cookie_signature
(
tls
, 
properties
, 
negotiated_group
,

3921 
	`ptls_iovec_init
(
sendbuf
->
base
 + 
tbs_start
, 
tbs_len
),

3922 
sendbuf
->
base
 + sendbuf->
off
)) != 0)

3923 goto 
Exit
;

3924 
sendbuf
->
off
 += 
sz
;

3929 if ((
ret
 = 
	`push_change_cipher_spec
(
tls
, 
emitter
)) != 0)

3930 goto 
Exit
;

3931 
ret
 = 
PTLS_ERROR_STATELESS_RETRY
;

3934 
	`key_schedule_transform_post_ch1hash
(
tls
->
key_schedule
);

3935 
	`key_schedule_extract
(
tls
->
key_schedule
, 
	`ptls_iovec_init
(
NULL
, 0));

3936 
	`EMIT_HELLO_RETRY_REQUEST
(
tls
->
key_schedule
, 
key_share
.
algorithm
 != 
NULL
 ? NULL : 
negotiated_group
, {});

3937 if ((
ret
 = 
	`push_change_cipher_spec
(
tls
, 
emitter
)) != 0)

3938 goto 
Exit
;

3939 
tls
->
state
 = 
PTLS_STATE_SERVER_EXPECT_SECOND_CLIENT_HELLO
;

3940 if (
ch
->
psk
.
early_data_indication
)

3941 
tls
->
server
.
early_data_skipped_bytes
 = 0;

3942 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

3944 goto 
Exit
;

3949 if ((
ret
 = 
	`report_unknown_extensions
(
tls
, 
properties
, 
ch
->
unknown_extensions
)) != 0)

3950 goto 
Exit
;

3953 if (!
is_second_flight
 && 
ch
->
psk
.
hash_end
 != 0 &&

3954 (
ch
->
psk
.
ke_modes
 & ((1u << 
PTLS_PSK_KE_MODE_PSK
) | (1u << 
PTLS_PSK_KE_MODE_PSK_DHE
))) != 0 &&

3955 
tls
->
ctx
->
encrypt_ticket
 != 
NULL
 && !tls->ctx->
require_client_authentication
) {

3956 if ((
ret
 = 
	`try_psk_handshake
(
tls
, &
psk_index
, &
accept_early_data
, 
ch
,

3957 
	`ptls_iovec_init
(
message
.
base
, 
ch
->
psk
.
hash_end
 - message.base))) != 0) {

3958 goto 
Exit
;

3968 if (
psk_index
 == 
SIZE_MAX
 || 
tls
->
ctx
->
require_client_authentication
) {

3969 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

3970 if (!
is_second_flight
) {

3971 
	`assert
(
tls
->
key_schedule
->
generation
 == 0);

3972 
	`key_schedule_extract
(
tls
->
key_schedule
, 
	`ptls_iovec_init
(
NULL
, 0));

3974 
mode
 = 
HANDSHAKE_MODE_FULL
;

3975 if (
properties
 != 
NULL
)

3976 
properties
->
server
.
selected_psk_binder
.
len
 = 0;

3978 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
ch
->
psk
.
hash_end
, 
message
.
base
 + message.
len
 - ch->psk.hash_end);

3979 if ((
ch
->
psk
.
ke_modes
 & (1u << 
PTLS_PSK_KE_MODE_PSK
)) != 0) {

3980 
mode
 = 
HANDSHAKE_MODE_PSK
;

3982 
	`assert
((
ch
->
psk
.
ke_modes
 & (1u << 
PTLS_PSK_KE_MODE_PSK_DHE
)) != 0);

3983 
mode
 = 
HANDSHAKE_MODE_PSK_DHE
;

3985 
tls
->
is_psk_handshake
 = 1;

3986 if (
properties
 != 
NULL
) {

3987 
ptls_iovec_t
 *
selected
 = &
ch
->
psk
.
identities
.
list
[
psk_index
].
binder
;

3988 
	`memcpy
(
properties
->
server
.
selected_psk_binder
.
base
, 
selected
->base, selected->
len
);

3989 
properties
->
server
.
selected_psk_binder
.
len
 = 
selected
->len;

3993 if (
accept_early_data
 && 
tls
->
ctx
->
max_early_data_size
 != 0 && 
psk_index
 == 0) {

3994 if ((
tls
->
pending_handshake_secret
 = 
	`malloc
(
PTLS_MAX_DIGEST_SIZE
)) == 
NULL
) {

3995 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

3996 goto 
Exit
;

3998 if ((
ret
 = 
	`derive_exporter_secret
(
tls
, 1)) != 0)

3999 goto 
Exit
;

4000 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 0, "c e traffic", 1, 0)) != 0)

4001 goto 
Exit
;

4005 if (
mode
 != 
HANDSHAKE_MODE_PSK
) {

4006 if (
key_share
.
algorithm
 == 
NULL
) {

4007 
ret
 = 
ch
->
key_shares
.
base
 != 
NULL
 ? 
PTLS_ALERT_HANDSHAKE_FAILURE
 : 
PTLS_ALERT_MISSING_EXTENSION
;

4008 goto 
Exit
;

4010 if ((
ret
 = 
key_share
.
algorithm
->
	`exchange
(key_share.algorithm, &
pubkey
, &
ecdh_secret
, key_share.
peer_key
)) != 0)

4011 goto 
Exit
;

4012 
tls
->
key_share
 = key_share.
algorithm
;

4016 
	`EMIT_SERVER_HELLO
(

4017 
tls
->
key_schedule
, { tls->
ctx
->
	`random_bytes
(
emitter
->
buf
->
base
 + emitter->buf->
off
, 
PTLS_HELLO_RANDOM_SIZE
); },

4019 
ptls_buffer_t
 *
sendbuf
 = 
emitter
->
buf
;

4020 if (
mode
 != 
HANDSHAKE_MODE_PSK
) {

4021 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_KEY_SHARE
, {

4022 
	`ptls_buffer_push16
(
sendbuf
, 
key_share
.
algorithm
->
id
);

4023 
	`ptls_buffer_push_block
(
sendbuf
, 2, { 
	`ptls_buffer_pushv
(sendbuf, 
pubkey
.
base
, pubkey.
len
); });

4026 if (
mode
 != 
HANDSHAKE_MODE_FULL
) {

4027 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_PRE_SHARED_KEY
,

4028 { 
	`ptls_buffer_push16
(
sendbuf
, (
uint16_t
)
psk_index
); });

4031 if ((
ret
 = 
	`push_change_cipher_spec
(
tls
, 
emitter
)) != 0)

4032 goto 
Exit
;

4035 
	`assert
(
tls
->
key_schedule
->
generation
 == 1);

4036 
	`key_schedule_extract
(
tls
->
key_schedule
, 
ecdh_secret
);

4037 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 1, "s hs traffic", 2, 0)) != 0)

4038 goto 
Exit
;

4039 if (
tls
->
pending_handshake_secret
 != 
NULL
) {

4040 if ((
ret
 = 
	`derive_secret
(
tls
->
key_schedule
, tls->
pending_handshake_secret
, "c hs traffic")) != 0)

4041 goto 
Exit
;

4042 if (
tls
->
ctx
->
update_traffic_key
 != 
NULL
 &&

4043 (
ret
 = 
tls
->
ctx
->
update_traffic_key
->
	`cb
(tls->ctx->update_traffic_key, tls, 0, 2, tls->
pending_handshake_secret
)) != 0)

4044 goto 
Exit
;

4046 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 0, "c hs traffic", 2, 0)) != 0)

4047 goto 
Exit
;

4048 if (
ch
->
psk
.
early_data_indication
)

4049 
tls
->
server
.
early_data_skipped_bytes
 = 0;

4053 
	`ptls_push_message
(
emitter
, 
tls
->
key_schedule
, 
PTLS_HANDSHAKE_TYPE_ENCRYPTED_EXTENSIONS
, {

4054 
ptls_buffer_t
 *
sendbuf
 = 
emitter
->
buf
;

4055 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

4056 if (
tls
->
esni
 != 
NULL
) {

4059 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_ENCRYPTED_SERVER_NAME
, {

4060 
uint8_t
 
response_type
 = 
PTLS_ESNI_RESPONSE_TYPE_ACCEPT
;

4061 
	`ptls_buffer_pushv
(
sendbuf
, &
response_type
, 1);

4062 
	`ptls_buffer_pushv
(
sendbuf
, 
tls
->
esni
->
nonce
, 
PTLS_ESNI_NONCE_SIZE
);

4064 
	`free_esni_secret
(&
tls
->
esni
, 1);

4065 } else if (
tls
->
server_name
 != 
NULL
) {

4068 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_SERVER_NAME
, {});

4070 if (
tls
->
ctx
->
use_raw_public_keys
) {

4071 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_SERVER_CERTIFICATE_TYPE
,

4072 { 
	`ptls_buffer_push
(
sendbuf
, 
PTLS_CERTIFICATE_TYPE_RAW_PUBLIC_KEY
); });

4074 if (
tls
->
negotiated_protocol
 != 
NULL
) {

4075 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_ALPN
, {

4076 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

4077 
	`ptls_buffer_push_block
(
sendbuf
, 1, {

4078 
	`ptls_buffer_pushv
(
sendbuf
, 
tls
->
negotiated_protocol
, 
	`strlen
(tls->negotiated_protocol));

4083 if (
tls
->
pending_handshake_secret
 != 
NULL
)

4084 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_EARLY_DATA
, {});

4085 if ((
ret
 = 
	`push_additional_extensions
(
properties
, 
sendbuf
)) != 0)

4086 goto 
Exit
;

4090 if (
mode
 == 
HANDSHAKE_MODE_FULL
) {

4092 if (
tls
->
ctx
->
require_client_authentication
) {

4093 
	`ptls_push_message
(
emitter
, 
tls
->
key_schedule
, 
PTLS_HANDSHAKE_TYPE_CERTIFICATE_REQUEST
, {

4097 
ptls_buffer_t
 *
sendbuf
 = 
emitter
->
buf
;

4098 
	`ptls_buffer_push
(
sendbuf
, 0);

4100 
	`ptls_buffer_push_block
(
sendbuf
, 2, {

4101 
	`buffer_push_extension
(
sendbuf
, 
PTLS_EXTENSION_TYPE_SIGNATURE_ALGORITHMS
, {

4102 if ((
ret
 = 
	`push_signature_algorithms
(
tls
->
ctx
->
verify_certificate
, 
sendbuf
)) != 0)

4103 goto 
Exit
;

4108 if (
ret
 != 0) {

4109 goto 
Exit
;

4113 
ret
 = 
	`send_certificate_and_certificate_verify
(
tls
, 
emitter
, &
ch
->
signature_algorithms
, 
	`ptls_iovec_init
(
NULL
, 0),

4114 
PTLS_SERVER_CERTIFICATE_VERIFY_CONTEXT_STRING
, 
ch
->
status_request
,

4115 
ch
->
cert_compression_algos
.
list
, ch->cert_compression_algos.
count
);

4117 if (
ret
 != 0) {

4118 goto 
Exit
;

4122 if ((
ret
 = 
	`send_finished
(
tls
, 
emitter
)) != 0)

4123 goto 
Exit
;

4125 
	`assert
(
tls
->
key_schedule
->
generation
 == 2);

4126 if ((
ret
 = 
	`key_schedule_extract
(
tls
->
key_schedule
, 
	`ptls_iovec_init
(
NULL
, 0))) != 0)

4127 goto 
Exit
;

4128 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 1, "s ap traffic", 3, 0)) != 0)

4129 goto 
Exit
;

4130 if ((
ret
 = 
	`derive_secret
(
tls
->
key_schedule
, tls->
server
.
pending_traffic_secret
, "c ap traffic")) != 0)

4131 goto 
Exit
;

4132 if ((
ret
 = 
	`derive_exporter_secret
(
tls
, 0)) != 0)

4133 goto 
Exit
;

4135 if (
tls
->
pending_handshake_secret
 != 
NULL
) {

4136 if (
tls
->
ctx
->
omit_end_of_early_data
) {

4137 if ((
ret
 = 
	`commission_handshake_secret
(
tls
)) != 0)

4138 goto 
Exit
;

4139 
tls
->
state
 = 
PTLS_STATE_SERVER_EXPECT_FINISHED
;

4141 
tls
->
state
 = 
PTLS_STATE_SERVER_EXPECT_END_OF_EARLY_DATA
;

4143 } else if (
tls
->
ctx
->
require_client_authentication
) {

4144 
tls
->
state
 = 
PTLS_STATE_SERVER_EXPECT_CERTIFICATE
;

4146 
tls
->
state
 = 
PTLS_STATE_SERVER_EXPECT_FINISHED
;

4150 if (
ch
->
psk
.
ke_modes
 != 0 && 
tls
->
ctx
->
ticket_lifetime
 != 0) {

4151 if ((
ret
 = 
	`send_session_ticket
(
tls
, 
emitter
)) != 0)

4152 goto 
Exit
;

4155 if (
tls
->
ctx
->
require_client_authentication
) {

4156 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

4158 
ret
 = 0;

4161 
Exit
:

4162 
	`free
(
pubkey
.
base
);

4163 if (
ecdh_secret
.
base
 != 
NULL
) {

4164 
	`ptls_clear_memory
(
ecdh_secret
.
base
, ecdh_secret.
len
);

4165 
	`free
(
ecdh_secret
.
base
);

4167 
	`free
(
ch
);

4168 return 
ret
;

4170 #undef 
EMIT_SERVER_HELLO


4171 #undef 
EMIT_HELLO_RETRY_REQUEST


4172 
	}
}

4174 static int 
	$server_handle_end_of_early_data
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
)

4176 int 
ret
;

4178 if ((
ret
 = 
	`commission_handshake_secret
(
tls
)) != 0)

4179 goto 
Exit
;

4181 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

4182 
tls
->
state
 = 
PTLS_STATE_SERVER_EXPECT_FINISHED
;

4183 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

4185 
Exit
:

4186 return 
ret
;

4187 
	}
}

4189 static int 
	$server_handle_finished
(
ptls_t
 *
tls
, 
ptls_iovec_t
 
message
)

4191 int 
ret
;

4193 if ((
ret
 = 
	`verify_finished
(
tls
, 
message
)) != 0)

4194 return 
ret
;

4196 
	`memcpy
(
tls
->
traffic_protection
.
dec
.
secret
, tls->
server
.
pending_traffic_secret
, sizeof(tls->server.pending_traffic_secret));

4197 
	`ptls_clear_memory
(
tls
->
server
.
pending_traffic_secret
, sizeof(tls->server.pending_traffic_secret));

4198 if ((
ret
 = 
	`setup_traffic_protection
(
tls
, 0, 
NULL
, 3, 0)) != 0)

4199 return 
ret
;

4201 
	`ptls__key_schedule_update_hash
(
tls
->
key_schedule
, 
message
.
base
, message.
len
);

4203 
tls
->
state
 = 
PTLS_STATE_SERVER_POST_HANDSHAKE
;

4205 
	}
}

4207 static int 
	$update_traffic_key
(
ptls_t
 *
tls
, int 
is_enc
)

4209 struct 
st_ptls_traffic_protection_t
 *
tp
 = 
is_enc
 ? &
tls
->
traffic_protection
.
enc
 : &tls->traffic_protection.
dec
;

4210 
uint8_t
 
secret
[
PTLS_MAX_DIGEST_SIZE
];

4211 int 
ret
;

4213 
ptls_hash_algorithm_t
 *
hash
 = 
tls
->
key_schedule
->
hashes
[0].
algo
;

4214 if ((
ret
 = 
	`hkdf_expand_label
(
hash
, 
secret
, hash->
digest_size
, 
	`ptls_iovec_init
(
tp
->secret, hash->digest_size), "traffic upd",

4215 
	`ptls_iovec_init
(
NULL
, 0), 
tls
->
key_schedule
->
hkdf_label_prefix
)) != 0)

4216 goto 
Exit
;

4217 
	`memcpy
(
tp
->
secret
, secret, sizeof(secret));

4218 
ret
 = 
	`setup_traffic_protection
(
tls
, 
is_enc
, 
NULL
, 3, 1);

4220 
Exit
:

4221 
	`ptls_clear_memory
(
secret
, sizeof(secret));

4222 return 
ret
;

4223 
	}
}

4225 static int 
	$handle_key_update
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_iovec_t
 
message
)

4227 const 
uint8_t
 *
src
 = 
message
.
base
 + 
PTLS_HANDSHAKE_HEADER_SIZE
, *const 
end
 = message.base + message.
len
;

4228 int 
ret
;

4231 if (
end
 - 
src
 != 1 || *src > 1)

4232 return 
PTLS_ALERT_DECODE_ERROR
;

4235 if ((
ret
 = 
	`update_traffic_key
(
tls
, 0)) != 0)

4236 return 
ret
;

4238 if (*
src
) {

4239 if (
tls
->
ctx
->
update_traffic_key
 != 
NULL
)

4240 return 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4241 
tls
->
needs_key_update
 = 1;

4245 
	}
}

4247 static int 
	$parse_record_header
(struct 
st_ptls_record_t
 *
rec
, const 
uint8_t
 *
src
)

4249 
rec
->
type
 = 
src
[0];

4250 
rec
->
version
 = 
	`ntoh16
(
src
 + 1);

4251 
rec
->
length
 = 
	`ntoh16
(
src
 + 3);

4253 if (
rec
->
length
 >

4254 (
size_t
)(
rec
->
type
 == 
PTLS_CONTENT_TYPE_APPDATA
 ? 
PTLS_MAX_ENCRYPTED_RECORD_SIZE
 : 
PTLS_MAX_PLAINTEXT_RECORD_SIZE
))

4255 return 
PTLS_ALERT_DECODE_ERROR
;

4258 
	}
}

4260 static int 
	$parse_record
(
ptls_t
 *
tls
, struct 
st_ptls_record_t
 *
rec
, const 
uint8_t
 *
src
, 
size_t
 *
len
)

4262 int 
ret
;

4264 if (
tls
->
recvbuf
.
rec
.
base
 == 
NULL
 && *
len
 >= 5) {

4266 if ((
ret
 = 
	`parse_record_header
(
rec
, 
src
)) != 0)

4267 return 
ret
;

4268 if (5 + 
rec
->
length
 <= *
len
) {

4269 
rec
->
fragment
 = 
src
 + 5;

4270 *
len
 = 
rec
->
length
 + 5;

4276 const 
uint8_t
 *const 
end
 = 
src
 + *
len
;

4277 *
rec
 = (struct 
st_ptls_record_t
){0};

4279 if (
tls
->
recvbuf
.
rec
.
base
 == 
NULL
) {

4280 
	`ptls_buffer_init
(&
tls
->
recvbuf
.
rec
, "", 0);

4281 if ((
ret
 = 
	`ptls_buffer_reserve
(&
tls
->
recvbuf
.
rec
, 5)) != 0)

4282 return 
ret
;

4286 while (
tls
->
recvbuf
.
rec
.
off
 < 5) {

4287 if (
src
 == 
end
)

4288 return 
PTLS_ERROR_IN_PROGRESS
;

4289 
tls
->
recvbuf
.
rec
.
base
[tls->recvbuf.rec.
off
++] = *
src
++;

4291 if ((
ret
 = 
	`parse_record_header
(
rec
, 
tls
->
recvbuf
.rec.
base
)) != 0)

4292 return 
ret
;

4295 
size_t
 
addlen
 = 
rec
->
length
 + 5 - 
tls
->
recvbuf
.rec.
off
;

4296 if (
addlen
 != 0) {

4297 if ((
ret
 = 
	`ptls_buffer_reserve
(&
tls
->
recvbuf
.
rec
, 
addlen
)) != 0)

4298 return 
ret
;

4299 if (
addlen
 > (
size_t
)(
end
 - 
src
))

4300 
addlen
 = 
end
 - 
src
;

4301 if (
addlen
 != 0) {

4302 
	`memcpy
(
tls
->
recvbuf
.
rec
.
base
 + tls->recvbuf.rec.
off
, 
src
, 
addlen
);

4303 
tls
->
recvbuf
.
rec
.
off
 += 
addlen
;

4304 
src
 += 
addlen
;

4309 if (
tls
->
recvbuf
.
rec
.
off
 == rec->
length
 + 5) {

4310 
rec
->
fragment
 = 
tls
->
recvbuf
.rec.
base
 + 5;

4311 
ret
 = 0;

4313 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

4316 *
len
 -= 
end
 - 
src
;

4317 return 
ret
;

4318 
	}
}

4320 static void 
	$update_open_count
(
ptls_context_t
 *
ctx
, 
ssize_t
 
delta
)

4322 if (
ctx
->
update_open_count
 != 
NULL
)

4323 
ctx
->
update_open_count
->
	`cb
(ctx->update_open_count, 
delta
);

4324 
	}
}

4326 static 
ptls_t
 *
	$new_instance
(
ptls_context_t
 *
ctx
, int 
is_server
)

4328 
ptls_t
 *
tls
;

4330 
	`assert
(
ctx
->
get_time
 != 
NULL
 && "please set ctx->get_time to `&ptls_get_time`; see #92");

4332 if ((
tls
 = 
	`malloc
(sizeof(*tls))) == 
NULL
)

4333 return 
NULL
;

4335 
	`update_open_count
(
ctx
, 1);

4336 *
tls
 = (
ptls_t
){
ctx
};

4337 
tls
->
is_server
 = is_server;

4338 
tls
->
send_change_cipher_spec
 = 
ctx
->send_change_cipher_spec;

4339 
tls
->
skip_tracing
 = 
ptls_default_skip_tracing
;

4340 return 
tls
;

4341 
	}
}

4343 
ptls_t
 *
	$ptls_client_new
(
ptls_context_t
 *
ctx
)

4345 
ptls_t
 *
tls
 = 
	`new_instance
(
ctx
, 0);

4346 
tls
->
state
 = 
PTLS_STATE_CLIENT_HANDSHAKE_START
;

4347 
tls
->
ctx
->
	`random_bytes
(tls->
client_random
, sizeof(tls->client_random));

4348 
	`log_client_random
(
tls
);

4349 if (
tls
->
send_change_cipher_spec
) {

4350 
tls
->
client
.
legacy_session_id
 =

4351 
	`ptls_iovec_init
(
tls
->
client
.
legacy_session_id_buf
, sizeof(tls->client.legacy_session_id_buf));

4352 
tls
->
ctx
->
	`random_bytes
(tls->
client
.
legacy_session_id
.
base
, tls->client.legacy_session_id.
len
);

4355 
	`PTLS_PROBE
(
NEW
, 
tls
, 0);

4356 return 
tls
;

4357 
	}
}

4359 
ptls_t
 *
	$ptls_server_new
(
ptls_context_t
 *
ctx
)

4361 
ptls_t
 *
tls
 = 
	`new_instance
(
ctx
, 1);

4362 
tls
->
state
 = 
PTLS_STATE_SERVER_EXPECT_CLIENT_HELLO
;

4363 
tls
->
server
.
early_data_skipped_bytes
 = 
UINT32_MAX
;

4365 
	`PTLS_PROBE
(
NEW
, 
tls
, 1);

4366 return 
tls
;

4367 
	}
}

4369 void 
	$ptls_free
(
ptls_t
 *
tls
)

4371 
	`PTLS_PROBE0
(
FREE
, 
tls
);

4372 
	`ptls_buffer_dispose
(&
tls
->
recvbuf
.
rec
);

4373 
	`ptls_buffer_dispose
(&
tls
->
recvbuf
.
mess
);

4374 
	`free_exporter_master_secret
(
tls
, 1);

4375 
	`free_exporter_master_secret
(
tls
, 0);

4376 if (
tls
->
esni
 != 
NULL
)

4377 
	`free_esni_secret
(&
tls
->
esni
, tls->
is_server
);

4378 if (
tls
->
key_schedule
 != 
NULL
)

4379 
	`key_schedule_free
(
tls
->
key_schedule
);

4380 if (
tls
->
traffic_protection
.
dec
.
aead
 != 
NULL
)

4381 
	`ptls_aead_free
(
tls
->
traffic_protection
.
dec
.
aead
);

4382 if (
tls
->
traffic_protection
.
enc
.
aead
 != 
NULL
)

4383 
	`ptls_aead_free
(
tls
->
traffic_protection
.
enc
.
aead
);

4384 
	`free
(
tls
->
server_name
);

4385 
	`free
(
tls
->
negotiated_protocol
);

4386 if (
tls
->
is_server
) {

4389 if (
tls
->
client
.
key_share_ctx
 != 
NULL
)

4390 
tls
->
client
.
key_share_ctx
->
	`on_exchange
(&tls->client.key_share_ctx, 1, 
NULL
, 
	`ptls_iovec_init
(NULL, 0));

4391 if (
tls
->
client
.
certificate_request
.
context
.
base
 != 
NULL
)

4392 
	`free
(
tls
->
client
.
certificate_request
.
context
.
base
);

4394 if (
tls
->
certificate_verify
.
cb
 != 
NULL
) {

4395 
tls
->
certificate_verify
.
	`cb
(tls->certificate_verify.
verify_ctx
, 0, 
	`ptls_iovec_init
(
NULL
, 0), ptls_iovec_init(NULL, 0));

4397 if (
tls
->
pending_handshake_secret
 != 
NULL
) {

4398 
	`ptls_clear_memory
(
tls
->
pending_handshake_secret
, 
PTLS_MAX_DIGEST_SIZE
);

4399 
	`free
(
tls
->
pending_handshake_secret
);

4401 
	`update_open_count
(
tls
->
ctx
, -1);

4402 
	`ptls_clear_memory
(
tls
, sizeof(*tls));

4403 
	`free
(
tls
);

4404 
	}
}

4406 
ptls_context_t
 *
	$ptls_get_context
(
ptls_t
 *
tls
)

4408 return 
tls
->
ctx
;

4409 
	}
}

4411 void 
	$ptls_set_context
(
ptls_t
 *
tls
, 
ptls_context_t
 *
ctx
)

4413 
	`update_open_count
(
ctx
, 1);

4414 
	`update_open_count
(
tls
->
ctx
, -1);

4415 
tls
->
ctx
 = ctx;

4416 
	}
}

4418 
ptls_iovec_t
 
	$ptls_get_client_random
(
ptls_t
 *
tls
)

4420 return 
	`ptls_iovec_init
(
tls
->
client_random
, 
PTLS_HELLO_RANDOM_SIZE
);

4421 
	}
}

4423 
ptls_cipher_suite_t
 *
	$ptls_get_cipher
(
ptls_t
 *
tls
)

4425 return 
tls
->
cipher_suite
;

4426 
	}
}

4428 const char *
	$ptls_get_server_name
(
ptls_t
 *
tls
)

4430 return 
tls
->
server_name
;

4431 
	}
}

4433 int 
	$ptls_set_server_name
(
ptls_t
 *
tls
, const char *
server_name
, 
size_t
 
server_name_len
)

4435 char *
duped
 = 
NULL
;

4437 if (
server_name
 != 
NULL
) {

4438 if (
server_name_len
 == 0)

4439 
server_name_len
 = 
	`strlen
(
server_name
);

4440 if ((
duped
 = 
	`malloc
(
server_name_len
 + 1)) == 
NULL
)

4441 return 
PTLS_ERROR_NO_MEMORY
;

4442 
	`memcpy
(
duped
, 
server_name
, 
server_name_len
);

4443 
duped
[
server_name_len
] = '\0';

4446 
	`free
(
tls
->
server_name
);

4447 
tls
->
server_name
 = 
duped
;

4450 
	}
}

4452 const char *
	$ptls_get_negotiated_protocol
(
ptls_t
 *
tls
)

4454 return 
tls
->
negotiated_protocol
;

4455 
	}
}

4457 int 
	$ptls_set_negotiated_protocol
(
ptls_t
 *
tls
, const char *
protocol
, 
size_t
 
protocol_len
)

4459 char *
duped
 = 
NULL
;

4461 if (
protocol
 != 
NULL
) {

4462 if (
protocol_len
 == 0)

4463 
protocol_len
 = 
	`strlen
(
protocol
);

4464 if ((
duped
 = 
	`malloc
(
protocol_len
 + 1)) == 
NULL
)

4465 return 
PTLS_ERROR_NO_MEMORY
;

4466 
	`memcpy
(
duped
, 
protocol
, 
protocol_len
);

4467 
duped
[
protocol_len
] = '\0';

4470 
	`free
(
tls
->
negotiated_protocol
);

4471 
tls
->
negotiated_protocol
 = 
duped
;

4474 
	}
}

4476 int 
	$ptls_handshake_is_complete
(
ptls_t
 *
tls
)

4478 return 
tls
->
state
 >= 
PTLS_STATE_POST_HANDSHAKE_MIN
;

4479 
	}
}

4481 int 
	$ptls_is_psk_handshake
(
ptls_t
 *
tls
)

4483 return 
tls
->
is_psk_handshake
;

4484 
	}
}

4486 void **
	$ptls_get_data_ptr
(
ptls_t
 *
tls
)

4488 return &
tls
->
data_ptr
;

4489 
	}
}

4491 int 
	$ptls_skip_tracing
(
ptls_t
 *
tls
)

4493 return 
tls
->
skip_tracing
;

4494 
	}
}

4496 void 
	$ptls_set_skip_tracing
(
ptls_t
 *
tls
, int 
skip_tracing
)

4498 
tls
->
skip_tracing
 = skip_tracing;

4499 
	}
}

4501 static int 
	$handle_client_handshake_message
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_iovec_t
 
message
, int 
is_end_of_record
,

4502 
ptls_handshake_properties_t
 *
properties
)

4504 
uint8_t
 
type
 = 
message
.
base
[0];

4505 int 
ret
;

4507 switch (
tls
->
state
) {

4508 case 
PTLS_STATE_CLIENT_EXPECT_SERVER_HELLO
:

4509 case 
PTLS_STATE_CLIENT_EXPECT_SECOND_SERVER_HELLO
:

4510 if (
type
 == 
PTLS_HANDSHAKE_TYPE_SERVER_HELLO
 && 
is_end_of_record
) {

4511 
ret
 = 
	`client_handle_hello
(
tls
, 
emitter
, 
message
, 
properties
);

4513 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4516 case 
PTLS_STATE_CLIENT_EXPECT_ENCRYPTED_EXTENSIONS
:

4517 if (
type
 == 
PTLS_HANDSHAKE_TYPE_ENCRYPTED_EXTENSIONS
) {

4518 
ret
 = 
	`client_handle_encrypted_extensions
(
tls
, 
message
, 
properties
);

4520 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4523 case 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE_REQUEST_OR_CERTIFICATE
:

4524 if (
type
 == 
PTLS_HANDSHAKE_TYPE_CERTIFICATE_REQUEST
) {

4525 
ret
 = 
	`client_handle_certificate_request
(
tls
, 
message
, 
properties
);

4529 case 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE
:

4530 switch (
type
) {

4531 case 
PTLS_HANDSHAKE_TYPE_CERTIFICATE
:

4532 
ret
 = 
	`client_handle_certificate
(
tls
, 
message
);

4534 case 
PTLS_HANDSHAKE_TYPE_COMPRESSED_CERTIFICATE
:

4535 
ret
 = 
	`client_handle_compressed_certificate
(
tls
, 
message
);

4538 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4542 case 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE_VERIFY
:

4543 if (
type
 == 
PTLS_HANDSHAKE_TYPE_CERTIFICATE_VERIFY
) {

4544 
ret
 = 
	`client_handle_certificate_verify
(
tls
, 
message
);

4546 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4549 case 
PTLS_STATE_CLIENT_EXPECT_FINISHED
:

4550 if (
type
 == 
PTLS_HANDSHAKE_TYPE_FINISHED
 && 
is_end_of_record
) {

4551 
ret
 = 
	`client_handle_finished
(
tls
, 
emitter
, 
message
);

4553 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4556 case 
PTLS_STATE_CLIENT_POST_HANDSHAKE
:

4557 switch (
type
) {

4558 case 
PTLS_HANDSHAKE_TYPE_NEW_SESSION_TICKET
:

4559 
ret
 = 
	`client_handle_new_session_ticket
(
tls
, 
message
);

4561 case 
PTLS_HANDSHAKE_TYPE_KEY_UPDATE
:

4562 
ret
 = 
	`handle_key_update
(
tls
, 
emitter
, 
message
);

4565 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4570 
	`assert
(!"unexpected state");

4571 
ret
 = 
PTLS_ALERT_INTERNAL_ERROR
;

4575 
	`PTLS_PROBE
(
RECEIVE_MESSAGE
, 
tls
, 
message
.
base
[0], message.base + 
PTLS_HANDSHAKE_HEADER_SIZE
,

4576 
message
.
len
 - 
PTLS_HANDSHAKE_HEADER_SIZE
, 
ret
);

4578 return 
ret
;

4579 
	}
}

4581 static int 
	$handle_server_handshake_message
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_iovec_t
 
message
, int 
is_end_of_record
,

4582 
ptls_handshake_properties_t
 *
properties
)

4584 
uint8_t
 
type
 = 
message
.
base
[0];

4585 int 
ret
;

4587 switch (
tls
->
state
) {

4588 case 
PTLS_STATE_SERVER_EXPECT_CLIENT_HELLO
:

4589 case 
PTLS_STATE_SERVER_EXPECT_SECOND_CLIENT_HELLO
:

4590 if (
type
 == 
PTLS_HANDSHAKE_TYPE_CLIENT_HELLO
 && 
is_end_of_record
) {

4591 
ret
 = 
	`server_handle_hello
(
tls
, 
emitter
, 
message
, 
properties
);

4593 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

4596 case 
PTLS_STATE_SERVER_EXPECT_CERTIFICATE
:

4597 if (
type
 == 
PTLS_HANDSHAKE_TYPE_CERTIFICATE
) {

4598 
ret
 = 
	`server_handle_certificate
(
tls
, 
message
);

4600 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4603 case 
PTLS_STATE_SERVER_EXPECT_CERTIFICATE_VERIFY
:

4604 if (
type
 == 
PTLS_HANDSHAKE_TYPE_CERTIFICATE_VERIFY
) {

4605 
ret
 = 
	`server_handle_certificate_verify
(
tls
, 
message
);

4607 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4610 case 
PTLS_STATE_SERVER_EXPECT_END_OF_EARLY_DATA
:

4611 
	`assert
(!
tls
->
ctx
->
omit_end_of_early_data
);

4612 if (
type
 == 
PTLS_HANDSHAKE_TYPE_END_OF_EARLY_DATA
) {

4613 
ret
 = 
	`server_handle_end_of_early_data
(
tls
, 
message
);

4615 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4618 case 
PTLS_STATE_SERVER_EXPECT_FINISHED
:

4619 if (
type
 == 
PTLS_HANDSHAKE_TYPE_FINISHED
 && 
is_end_of_record
) {

4620 
ret
 = 
	`server_handle_finished
(
tls
, 
message
);

4622 
ret
 = 
PTLS_ALERT_HANDSHAKE_FAILURE
;

4625 case 
PTLS_STATE_SERVER_POST_HANDSHAKE
:

4626 switch (
type
) {

4627 case 
PTLS_HANDSHAKE_TYPE_KEY_UPDATE
:

4628 
ret
 = 
	`handle_key_update
(
tls
, 
emitter
, 
message
);

4631 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4636 
	`assert
(!"unexpected state");

4637 
ret
 = 
PTLS_ALERT_INTERNAL_ERROR
;

4641 
	`PTLS_PROBE
(
RECEIVE_MESSAGE
, 
tls
, 
message
.
base
[0], message.base + 
PTLS_HANDSHAKE_HEADER_SIZE
,

4642 
message
.
len
 - 
PTLS_HANDSHAKE_HEADER_SIZE
, 
ret
);

4644 return 
ret
;

4645 
	}
}

4647 static int 
	$handle_alert
(
ptls_t
 *
tls
, const 
uint8_t
 *
src
, 
size_t
 
len
)

4649 if (
len
 != 2)

4650 return 
PTLS_ALERT_DECODE_ERROR
;

4652 
uint8_t
 
desc
 = 
src
[1];

4655 return 
	`PTLS_ALERT_TO_PEER_ERROR
(
desc
);

4656 
	}
}

4658 static int 
	$message_buffer_is_overflow
(
ptls_context_t
 *
ctx
, 
size_t
 
size
)

4660 if (
ctx
->
max_buffer_size
 == 0)

4662 if (
size
 <= 
ctx
->
max_buffer_size
)

4665 
	}
}

4667 static int 
	$handle_handshake_record
(
ptls_t
 *
tls
,

4668 int (*
cb
)(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_iovec_t
 
message
,

4669 int 
is_end_of_record
, 
ptls_handshake_properties_t
 *
properties
),

4670 
ptls_message_emitter_t
 *
emitter
, struct 
st_ptls_record_t
 *
rec
,

4671 
ptls_handshake_properties_t
 *
properties
)

4673 int 
ret
;

4676 if (
rec
->
type
 != 
PTLS_CONTENT_TYPE_HANDSHAKE
)

4677 return 
PTLS_ALERT_DECODE_ERROR
;

4680 const 
uint8_t
 *
src
, *
src_end
;

4681 if (
tls
->
recvbuf
.
mess
.
base
 == 
NULL
) {

4682 
src
 = 
rec
->
fragment
;

4683 
src_end
 = 
src
 + 
rec
->
length
;

4685 if (
	`message_buffer_is_overflow
(
tls
->
ctx
, tls->
recvbuf
.
mess
.
off
 + 
rec
->
length
))

4686 return 
PTLS_ALERT_HANDSHAKE_FAILURE
;

4687 if ((
ret
 = 
	`ptls_buffer_reserve
(&
tls
->
recvbuf
.
mess
, 
rec
->
length
)) != 0)

4688 return 
ret
;

4689 
	`memcpy
(
tls
->
recvbuf
.
mess
.
base
 + tls->recvbuf.mess.
off
, 
rec
->
fragment
, rec->
length
);

4690 
tls
->
recvbuf
.
mess
.
off
 += 
rec
->
length
;

4691 
src
 = 
tls
->
recvbuf
.
mess
.
base
;

4692 
src_end
 = 
src
 + 
tls
->
recvbuf
.
mess
.
off
;

4696 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

4697 while (
src_end
 - 
src
 >= 4) {

4698 
size_t
 
mess_len
 = 4 + 
	`ntoh24
(
src
 + 1);

4699 if (
src_end
 - 
src
 < (int)
mess_len
)

4701 
ret
 = 
	`cb
(
tls
, 
emitter
, 
	`ptls_iovec_init
(
src
, 
mess_len
), 
src_end
 - src == mess_len, 
properties
);

4702 switch (
ret
) {

4704 case 
PTLS_ERROR_IN_PROGRESS
:

4707 
	`ptls_buffer_dispose
(&
tls
->
recvbuf
.
mess
);

4708 return 
ret
;

4710 
src
 += 
mess_len
;

4714 if (
src
 != 
src_end
) {

4715 
size_t
 
new_size
 = 
src_end
 - 
src
;

4716 if (
	`message_buffer_is_overflow
(
tls
->
ctx
, 
new_size
))

4717 return 
PTLS_ALERT_HANDSHAKE_FAILURE
;

4718 if (
tls
->
recvbuf
.
mess
.
base
 == 
NULL
) {

4719 
	`ptls_buffer_init
(&
tls
->
recvbuf
.
mess
, "", 0);

4720 if ((
ret
 = 
	`ptls_buffer_reserve
(&
tls
->
recvbuf
.
mess
, 
new_size
)) != 0)

4721 return 
ret
;

4722 
	`memcpy
(
tls
->
recvbuf
.
mess
.
base
, 
src
, 
new_size
);

4724 
	`memmove
(
tls
->
recvbuf
.
mess
.
base
, 
src
, 
new_size
);

4726 
tls
->
recvbuf
.
mess
.
off
 = 
new_size
;

4727 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

4729 
	`ptls_buffer_dispose
(&
tls
->
recvbuf
.
mess
);

4732 return 
ret
;

4733 
	}
}

4735 static int 
	$handle_input
(
ptls_t
 *
tls
, 
ptls_message_emitter_t
 *
emitter
, 
ptls_buffer_t
 *
decryptbuf
, const void *
input
, 
size_t
 *
inlen
,

4736 
ptls_handshake_properties_t
 *
properties
)

4738 struct 
st_ptls_record_t
 
rec
;

4739 int 
ret
;

4742 if ((
ret
 = 
	`parse_record
(
tls
, &
rec
, 
input
, 
inlen
)) != 0)

4743 return 
ret
;

4744 
	`assert
(
rec
.
fragment
 != 
NULL
);

4747 if (
rec
.
type
 == 
PTLS_CONTENT_TYPE_CHANGE_CIPHER_SPEC
) {

4748 if (
tls
->
state
 < 
PTLS_STATE_POST_HANDSHAKE_MIN
) {

4749 if (!(
rec
.
length
 == 1 && rec.
fragment
[0] == 0x01))

4750 return 
PTLS_ALERT_ILLEGAL_PARAMETER
;

4752 return 
PTLS_ALERT_HANDSHAKE_FAILURE
;

4754 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

4755 goto 
NextRecord
;

4757 if (
tls
->
traffic_protection
.
dec
.
aead
 != 
NULL
 && 
rec
.
type
 != 
PTLS_CONTENT_TYPE_ALERT
) {

4758 
size_t
 
decrypted_length
;

4759 if (
rec
.
type
 != 
PTLS_CONTENT_TYPE_APPDATA
)

4760 return 
PTLS_ALERT_HANDSHAKE_FAILURE
;

4761 if ((
ret
 = 
	`ptls_buffer_reserve
(
decryptbuf
, 5 + 
rec
.
length
)) != 0)

4762 return 
ret
;

4763 if ((
ret
 = 
	`aead_decrypt
(&
tls
->
traffic_protection
.
dec
, 
decryptbuf
->
base
 + decryptbuf->
off
, &
decrypted_length
, 
rec
.
fragment
,

4764 
rec
.
length
)) != 0) {

4765 if (
tls
->
is_server
 && tls->
server
.
early_data_skipped_bytes
 != 
UINT32_MAX
)

4766 goto 
ServerSkipEarlyData
;

4767 return 
ret
;

4769 
rec
.
length
 = 
decrypted_length
;

4770 
rec
.
fragment
 = 
decryptbuf
->
base
 + decryptbuf->
off
;

4772 for (; 
rec
.
length
 != 0; --rec.length)

4773 if (
rec
.
fragment
[rec.
length
 - 1] != 0)

4775 if (
rec
.
length
 == 0)

4776 return 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4777 
rec
.
type
 = rec.
fragment
[--rec.
length
];

4778 } else if (
rec
.
type
 == 
PTLS_CONTENT_TYPE_APPDATA
 && 
tls
->
is_server
 && tls->
server
.
early_data_skipped_bytes
 != 
UINT32_MAX
) {

4779 goto 
ServerSkipEarlyData
;

4782 if (
tls
->
recvbuf
.
mess
.
base
 != 
NULL
 || 
rec
.
type
 == 
PTLS_CONTENT_TYPE_HANDSHAKE
) {

4784 
ret
 = 
	`handle_handshake_record
(
tls
, tls->
is_server
 ? 
handle_server_handshake_message
 : 
handle_client_handshake_message
,

4785 
emitter
, &
rec
, 
properties
);

4788 switch (
rec
.
type
) {

4789 case 
PTLS_CONTENT_TYPE_APPDATA
:

4790 if (
tls
->
state
 >= 
PTLS_STATE_POST_HANDSHAKE_MIN
) {

4791 
decryptbuf
->
off
 += 
rec
.
length
;

4792 
ret
 = 0;

4793 } else if (
tls
->
state
 == 
PTLS_STATE_SERVER_EXPECT_END_OF_EARLY_DATA
) {

4794 if (
tls
->
traffic_protection
.
dec
.
aead
 != 
NULL
)

4795 
decryptbuf
->
off
 += 
rec
.
length
;

4796 
ret
 = 0;

4798 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4801 case 
PTLS_CONTENT_TYPE_ALERT
:

4802 
ret
 = 
	`handle_alert
(
tls
, 
rec
.
fragment
, rec.
length
);

4805 
ret
 = 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

4810 
NextRecord
:

4811 
	`ptls_buffer_dispose
(&
tls
->
recvbuf
.
rec
);

4812 return 
ret
;

4814 
ServerSkipEarlyData
:

4815 
tls
->
server
.
early_data_skipped_bytes
 += (
uint32_t
)
rec
.
length
;

4816 if (
tls
->
server
.
early_data_skipped_bytes
 > 
PTLS_MAX_EARLY_DATA_SKIP_SIZE
)

4817 return 
PTLS_ALERT_HANDSHAKE_FAILURE
;

4818 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

4819 goto 
NextRecord
;

4820 
	}
}

4822 static void 
	$init_record_message_emitter
(
ptls_t
 *
tls
, struct 
st_ptls_record_message_emitter_t
 *
emitter
, 
ptls_buffer_t
 *
sendbuf
)

4824 *
emitter
 = (struct 
st_ptls_record_message_emitter_t
){

4825 {
sendbuf
, &
tls
->
traffic_protection
.
enc
, 5, 
begin_record_message
, 
commit_record_message
}};

4826 
	}
}

4828 int 
	$ptls_handshake
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
_sendbuf
, const void *
input
, 
size_t
 *
inlen
, 
ptls_handshake_properties_t
 *
properties
)

4830 struct 
st_ptls_record_message_emitter_t
 
emitter
;

4831 int 
ret
;

4833 
	`assert
(
tls
->
state
 < 
PTLS_STATE_POST_HANDSHAKE_MIN
);

4835 
	`init_record_message_emitter
(
tls
, &
emitter
, 
_sendbuf
);

4836 
size_t
 
sendbuf_orig_off
 = 
emitter
.
super
.
buf
->
off
;

4839 switch (
tls
->
state
) {

4840 case 
PTLS_STATE_CLIENT_HANDSHAKE_START
: {

4841 
	`assert
(
input
 == 
NULL
 || *
inlen
 == 0);

4842 
	`assert
(
tls
->
ctx
->
key_exchanges
[0] != 
NULL
);

4843 return 
	`send_client_hello
(
tls
, &
emitter
.
super
, 
properties
, 
NULL
);

4849 const 
uint8_t
 *
src
 = 
input
, *const 
src_end
 = src + *
inlen
;

4850 
ptls_buffer_t
 
decryptbuf
;

4852 
	`ptls_buffer_init
(&
decryptbuf
, "", 0);

4855 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

4856 while (
ret
 == 
PTLS_ERROR_IN_PROGRESS
 && 
src
 != 
src_end
) {

4857 
size_t
 
consumed
 = 
src_end
 - 
src
;

4858 
ret
 = 
	`handle_input
(
tls
, &
emitter
.
super
, &
decryptbuf
, 
src
, &
consumed
, 
properties
);

4859 
src
 += 
consumed
;

4860 
	`assert
(
decryptbuf
.
off
 == 0);

4863 
	`ptls_buffer_dispose
(&
decryptbuf
);

4865 switch (
ret
) {

4867 case 
PTLS_ERROR_IN_PROGRESS
:

4868 case 
PTLS_ERROR_STATELESS_RETRY
:

4872 
	`ptls_clear_memory
(
emitter
.
super
.
buf
->
base
 + 
sendbuf_orig_off
, emitter.super.buf->
off
 - sendbuf_orig_off);

4873 
emitter
.
super
.
buf
->
off
 = 
sendbuf_orig_off
;

4875 if (
	`PTLS_ERROR_GET_CLASS
(
ret
) != 
PTLS_ERROR_CLASS_PEER_ALERT
)

4876 if (
	`ptls_send_alert
(
tls
, 
emitter
.
super
.
buf
, 
PTLS_ALERT_LEVEL_FATAL
,

4877 
	`PTLS_ERROR_GET_CLASS
(
ret
) == 
PTLS_ERROR_CLASS_SELF_ALERT
 ? ret : 
PTLS_ALERT_INTERNAL_ERROR
) != 0)

4878 
emitter
.
super
.
buf
->
off
 = 
sendbuf_orig_off
;

4882 *
inlen
 -= 
src_end
 - 
src
;

4883 return 
ret
;

4884 
	}
}

4886 int 
	$ptls_receive
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
decryptbuf
, const void *
_input
, 
size_t
 *
inlen
)

4888 const 
uint8_t
 *
input
 = (const uint8_t *)
_input
, *const 
end
 = input + *
inlen
;

4889 
size_t
 
decryptbuf_orig_size
 = 
decryptbuf
->
off
;

4890 int 
ret
 = 0;

4892 
	`assert
(
tls
->
state
 >= 
PTLS_STATE_SERVER_EXPECT_END_OF_EARLY_DATA
);

4895 while (
ret
 == 0 && 
input
 != 
end
 && 
decryptbuf_orig_size
 == 
decryptbuf
->
off
) {

4896 
size_t
 
consumed
 = 
end
 - 
input
;

4897 
ret
 = 
	`handle_input
(
tls
, 
NULL
, 
decryptbuf
, 
input
, &
consumed
, NULL);

4898 
input
 += 
consumed
;

4900 switch (
ret
) {

4903 case 
PTLS_ERROR_IN_PROGRESS
:

4904 
ret
 = 0;

4906 case 
PTLS_ERROR_CLASS_PEER_ALERT
 + 
PTLS_ALERT_CLOSE_NOTIFY
:

4910 if (
	`PTLS_ERROR_GET_CLASS
(
ret
) == 
PTLS_ERROR_CLASS_SELF_ALERT
) {

4917 *
inlen
 -= 
end
 - 
input
;

4919 return 
ret
;

4920 
	}
}

4922 static int 
	$update_send_key
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
_sendbuf
, int 
request_update
)

4924 struct 
st_ptls_record_message_emitter_t
 
emitter
;

4925 int 
ret
;

4927 
	`init_record_message_emitter
(
tls
, &
emitter
, 
_sendbuf
);

4928 
size_t
 
sendbuf_orig_off
 = 
emitter
.
super
.
buf
->
off
;

4930 
	`ptls_push_message
(&
emitter
.
super
, 
NULL
, 
PTLS_HANDSHAKE_TYPE_KEY_UPDATE
,

4931 { 
	`ptls_buffer_push
(
emitter
.
super
.
buf
, !!
request_update
); });

4932 if ((
ret
 = 
	`update_traffic_key
(
tls
, 1)) != 0)

4933 goto 
Exit
;

4934 
ret
 = 0;

4936 
Exit
:

4937 if (
ret
 != 0)

4938 
emitter
.
super
.
buf
->
off
 = 
sendbuf_orig_off
;

4939 return 
ret
;

4940 
	}
}

4942 int 
	$ptls_send
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, const void *
input
, 
size_t
 
inlen
)

4944 
	`assert
(
tls
->
traffic_protection
.
enc
.
aead
 != 
NULL
);

4949 if (
tls
->
traffic_protection
.
enc
.
seq
 >= 16777216)

4950 
tls
->
needs_key_update
 = 1;

4952 if (
tls
->
needs_key_update
) {

4953 int 
ret
;

4954 if ((
ret
 = 
	`update_send_key
(
tls
, 
sendbuf
, tls->
key_update_send_request
)) != 0)

4955 return 
ret
;

4956 
tls
->
needs_key_update
 = 0;

4957 
tls
->
key_update_send_request
 = 0;

4960 return 
	`buffer_push_encrypted_records
(
sendbuf
, 
PTLS_CONTENT_TYPE_APPDATA
, 
input
, 
inlen
, &
tls
->
traffic_protection
.
enc
);

4961 
	}
}

4963 int 
	$ptls_update_key
(
ptls_t
 *
tls
, int 
request_update
)

4965 
	`assert
(
tls
->
ctx
->
update_traffic_key
 == 
NULL
);

4966 
tls
->
needs_key_update
 = 1;

4967 
tls
->
key_update_send_request
 = 
request_update
;

4969 
	}
}

4971 
size_t
 
	$ptls_get_record_overhead
(
ptls_t
 *
tls
)

4973 return 6 + 
tls
->
traffic_protection
.
enc
.
aead
->
algo
->
tag_size
;

4974 
	}
}

4976 int 
	$ptls_send_alert
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, 
uint8_t
 
level
, uint8_t 
description
)

4978 
size_t
 
rec_start
 = 
sendbuf
->
off
;

4979 int 
ret
 = 0;

4981 
	`buffer_push_record
(
sendbuf
, 
PTLS_CONTENT_TYPE_ALERT
, { 
	`ptls_buffer_push
(sendbuf, 
level
, 
description
); });

4983 if (
tls
->
traffic_protection
.
enc
.
aead
 != 
NULL
 && !(tls->
state
 <= 
PTLS_STATE_CLIENT_EXPECT_FINISHED
)) {

4984 if ((
ret
 = 
	`buffer_encrypt_record
(
sendbuf
, 
rec_start
, &
tls
->
traffic_protection
.
enc
)) != 0)

4985 goto 
Exit
;

4988 
Exit
:

4989 return 
ret
;

4990 
	}
}

4992 int 
	$ptls_export_secret
(
ptls_t
 *
tls
, void *
output
, 
size_t
 
outlen
, const char *
label
, 
ptls_iovec_t
 
context_value
, int 
is_early
)

4994 
ptls_hash_algorithm_t
 *
algo
 = 
tls
->
key_schedule
->
hashes
[0].algo;

4995 
uint8_t
 *
master_secret
 = 
is_early
 ? 
tls
->
exporter_master_secret
.
early
 : tls->exporter_master_secret.
one_rtt
,

4996 
derived_secret
[
PTLS_MAX_DIGEST_SIZE
], 
context_value_hash
[PTLS_MAX_DIGEST_SIZE];

4997 int 
ret
;

4999 if (
master_secret
 == 
NULL
) {

5000 if (
is_early
) {

5001 switch (
tls
->
state
) {

5002 case 
PTLS_STATE_CLIENT_HANDSHAKE_START
:

5003 case 
PTLS_STATE_SERVER_EXPECT_CLIENT_HELLO
:

5004 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

5007 
ret
 = 
PTLS_ERROR_NOT_AVAILABLE
;

5011 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

5013 return 
ret
;

5016 if ((
ret
 = 
	`ptls_calc_hash
(
algo
, 
context_value_hash
, 
context_value
.
base
, context_value.
len
)) != 0)

5017 return 
ret
;

5019 if ((
ret
 = 
	`hkdf_expand_label
(
algo
, 
derived_secret
, algo->
digest_size
, 
	`ptls_iovec_init
(
master_secret
, algo->digest_size), 
label
,

5020 
	`ptls_iovec_init
(
algo
->
empty_digest
, algo->
digest_size
), 
tls
->
key_schedule
->
hkdf_label_prefix
)) !=

5022 goto 
Exit
;

5023 
ret
 = 
	`hkdf_expand_label
(
algo
, 
output
, 
outlen
, 
	`ptls_iovec_init
(
derived_secret
, algo->
digest_size
), "exporter",

5024 
	`ptls_iovec_init
(
context_value_hash
, 
algo
->
digest_size
), 
tls
->
key_schedule
->
hkdf_label_prefix
);

5026 
Exit
:

5027 
	`ptls_clear_memory
(
derived_secret
, sizeof(derived_secret));

5028 
	`ptls_clear_memory
(
context_value_hash
, sizeof(context_value_hash));

5029 return 
ret
;

5030 
	}
}

5032 struct 
	sst_picotls_hmac_context_t
 {

5033 
ptls_hash_context_t
 
	msuper
;

5034 
ptls_hash_algorithm_t
 *
	malgo
;

5035 
ptls_hash_context_t
 *
	mhash
;

5036 
uint8_t
 
	mkey
[1];

5039 static void 
	$hmac_update
(
ptls_hash_context_t
 *
_ctx
, const void *
src
, 
size_t
 
len
)

5041 struct 
st_picotls_hmac_context_t
 *
ctx
 = (struct st_picotls_hmac_context_t *)
_ctx
;

5042 
ctx
->
hash
->
	`update
(ctx->hash, 
src
, 
len
);

5043 
	}
}

5045 static void 
	$hmac_apply_key
(struct 
st_picotls_hmac_context_t
 *
ctx
, 
uint8_t
 
pad
)

5047 
size_t
 
i
;

5049 for (
i
 = 0; i != 
ctx
->
algo
->
block_size
; ++i)

5050 
ctx
->
key
[
i
] ^= 
pad
;

5051 
ctx
->
hash
->
	`update
(ctx->hash, ctx->
key
, ctx->
algo
->
block_size
);

5052 for (
i
 = 0; i != 
ctx
->
algo
->
block_size
; ++i)

5053 
ctx
->
key
[
i
] ^= 
pad
;

5054 
	}
}

5056 static void 
	$hmac_final
(
ptls_hash_context_t
 *
_ctx
, void *
md
, 
ptls_hash_final_mode_t
 
mode
)

5058 struct 
st_picotls_hmac_context_t
 *
ctx
 = (struct st_picotls_hmac_context_t *)
_ctx
;

5060 
	`assert
(
mode
 != 
PTLS_HASH_FINAL_MODE_SNAPSHOT
 || !"not supported");

5062 if (
md
 != 
NULL
) {

5063 
ctx
->
hash
->
	`final
(ctx->hash, 
md
, 
PTLS_HASH_FINAL_MODE_RESET
);

5064 
	`hmac_apply_key
(
ctx
, 0x5c);

5065 
ctx
->
hash
->
	`update
(ctx->hash, 
md
, ctx->
algo
->
digest_size
);

5067 
ctx
->
hash
->
	`final
(ctx->hash, 
md
, 
mode
);

5069 switch (
mode
) {

5070 case 
PTLS_HASH_FINAL_MODE_FREE
:

5071 
	`ptls_clear_memory
(
ctx
->
key
, ctx->
algo
->
block_size
);

5072 
	`free
(
ctx
);

5074 case 
PTLS_HASH_FINAL_MODE_RESET
:

5075 
	`hmac_apply_key
(
ctx
, 0x36);

5078 
	`assert
(!"FIXME");

5081 
	}
}

5083 int 
	$ptls_calc_hash
(
ptls_hash_algorithm_t
 *
algo
, void *
output
, const void *
src
, 
size_t
 
len
)

5085 
ptls_hash_context_t
 *
ctx
;

5087 if ((
ctx
 = 
algo
->
	`create
()) == 
NULL
)

5088 return 
PTLS_ERROR_NO_MEMORY
;

5089 
ctx
->
	`update
(ctx, 
src
, 
len
);

5090 
ctx
->
	`final
(ctx, 
output
, 
PTLS_HASH_FINAL_MODE_FREE
);

5092 
	}
}

5094 
ptls_hash_context_t
 *
	$ptls_hmac_create
(
ptls_hash_algorithm_t
 *
algo
, const void *
key
, 
size_t
 
key_size
)

5096 struct 
st_picotls_hmac_context_t
 *
ctx
;

5098 
	`assert
(
key_size
 <= 
algo
->
block_size
);

5100 if ((
ctx
 = 
	`malloc
(
	`offsetof
(struct 
st_picotls_hmac_context_t
, 
key
) + 
algo
->
block_size
)) == 
NULL
)

5101 return 
NULL
;

5103 *
ctx
 = (struct 
st_picotls_hmac_context_t
){{
hmac_update
, 
hmac_final
}, 
algo
};

5104 if ((
ctx
->
hash
 = 
algo
->
	`create
()) == 
NULL
) {

5105 
	`free
(
ctx
);

5106 return 
NULL
;

5108 
	`memset
(
ctx
->
key
, 0, 
algo
->
block_size
);

5109 
	`memcpy
(
ctx
->
key
, key, 
key_size
);

5111 
	`hmac_apply_key
(
ctx
, 0x36);

5113 return &
ctx
->
super
;

5114 
	}
}

5116 int 
	$ptls_hkdf_extract
(
ptls_hash_algorithm_t
 *
algo
, void *
output
, 
ptls_iovec_t
 
salt
, ptls_iovec_t 
ikm
)

5118 
ptls_hash_context_t
 *
hash
;

5120 if (
salt
.
len
 == 0)

5121 
salt
 = 
	`ptls_iovec_init
(
zeroes_of_max_digest_size
, 
algo
->
digest_size
);

5123 if ((
hash
 = 
	`ptls_hmac_create
(
algo
, 
salt
.
base
, salt.
len
)) == 
NULL
)

5124 return 
PTLS_ERROR_NO_MEMORY
;

5125 
hash
->
	`update
(hash, 
ikm
.
base
, ikm.
len
);

5126 
hash
->
	`final
(hash, 
output
, 
PTLS_HASH_FINAL_MODE_FREE
);

5128 
	}
}

5130 int 
	$ptls_hkdf_expand
(
ptls_hash_algorithm_t
 *
algo
, void *
output
, 
size_t
 
outlen
, 
ptls_iovec_t
 
prk
, ptls_iovec_t 
info
)

5132 
ptls_hash_context_t
 *
hmac
 = 
NULL
;

5133 
size_t
 
i
;

5134 
uint8_t
 
digest
[
PTLS_MAX_DIGEST_SIZE
];

5136 for (
i
 = 0; (i * 
algo
->
digest_size
) < 
outlen
; ++i) {

5137 if (
hmac
 == 
NULL
) {

5138 if ((
hmac
 = 
	`ptls_hmac_create
(
algo
, 
prk
.
base
, prk.
len
)) == 
NULL
)

5139 return 
PTLS_ERROR_NO_MEMORY
;

5141 
hmac
->
	`update
(hmac, 
digest
, 
algo
->
digest_size
);

5143 
hmac
->
	`update
(hmac, 
info
.
base
, info.
len
);

5144 
uint8_t
 
gen
 = (uint8_t)(
i
 + 1);

5145 
hmac
->
	`update
(hmac, &
gen
, 1);

5146 
hmac
->
	`final
(hmac, 
digest
, 1);

5148 
size_t
 
off_start
 = 
i
 * 
algo
->
digest_size
, 
off_end
 = off_start + algo->digest_size;

5149 if (
off_end
 > 
outlen
)

5150 
off_end
 = 
outlen
;

5151 
	`memcpy
((
uint8_t
 *)
output
 + 
off_start
, 
digest
, 
off_end
 - off_start);

5154 if (
hmac
 != 
NULL
)

5155 
hmac
->
	`final
(hmac, 
NULL
, 
PTLS_HASH_FINAL_MODE_FREE
);

5157 
	`ptls_clear_memory
(
digest
, 
algo
->
digest_size
);

5160 
	}
}

5162 int 
	$hkdf_expand_label
(
ptls_hash_algorithm_t
 *
algo
, void *
output
, 
size_t
 
outlen
, 
ptls_iovec_t
 
secret
, const char *
label
,

5163 
ptls_iovec_t
 
hash_value
, const char *
label_prefix
)

5165 
ptls_buffer_t
 
hkdf_label
;

5166 
uint8_t
 
hkdf_label_buf
[80];

5167 int 
ret
;

5169 
	`assert
(
label_prefix
 != 
NULL
);

5171 
	`ptls_buffer_init
(&
hkdf_label
, 
hkdf_label_buf
, sizeof(hkdf_label_buf));

5173 
	`ptls_buffer_push16
(&
hkdf_label
, (
uint16_t
)
outlen
);

5174 
	`ptls_buffer_push_block
(&
hkdf_label
, 1, {

5175 
	`ptls_buffer_pushv
(&
hkdf_label
, 
label_prefix
, 
	`strlen
(label_prefix));

5176 
	`ptls_buffer_pushv
(&
hkdf_label
, 
label
, 
	`strlen
(label));

5178 
	`ptls_buffer_push_block
(&
hkdf_label
, 1, { 
	`ptls_buffer_pushv
(&hkdf_label, 
hash_value
.
base
, hash_value.
len
); });

5180 
ret
 = 
	`ptls_hkdf_expand
(
algo
, 
output
, 
outlen
, 
secret
, 
	`ptls_iovec_init
(
hkdf_label
.
base
, hkdf_label.
off
));

5182 
Exit
:

5183 
	`ptls_buffer_dispose
(&
hkdf_label
);

5184 return 
ret
;

5185 
	}
}

5187 int 
	$ptls_hkdf_expand_label
(
ptls_hash_algorithm_t
 *
algo
, void *
output
, 
size_t
 
outlen
, 
ptls_iovec_t
 
secret
, const char *
label
,

5188 
ptls_iovec_t
 
hash_value
, const char *
label_prefix
)

5192 if (
label_prefix
 == 
NULL
)

5193 
label_prefix
 = 
PTLS_HKDF_EXPAND_LABEL_PREFIX
;

5194 return 
	`hkdf_expand_label
(
algo
, 
output
, 
outlen
, 
secret
, 
label
, 
hash_value
, 
label_prefix
);

5195 
	}
}

5197 
ptls_cipher_context_t
 *
	$ptls_cipher_new
(
ptls_cipher_algorithm_t
 *
algo
, int 
is_enc
, const void *
key
)

5199 
ptls_cipher_context_t
 *
ctx
;

5201 if ((
ctx
 = (
ptls_cipher_context_t
 *)
	`malloc
(
algo
->
context_size
)) == 
NULL
)

5202 return 
NULL
;

5203 *
ctx
 = (
ptls_cipher_context_t
){
algo
};

5204 if (
algo
->
	`setup_crypto
(
ctx
, 
is_enc
, 
key
) != 0) {

5205 
	`free
(
ctx
);

5206 
ctx
 = 
NULL
;

5208 return 
ctx
;

5209 
	}
}

5211 void 
	$ptls_cipher_free
(
ptls_cipher_context_t
 *
ctx
)

5213 
ctx
->
	`do_dispose
(ctx);

5214 
	`free
(
ctx
);

5215 
	}
}

5217 
ptls_aead_context_t
 *
	$new_aead
(
ptls_aead_algorithm_t
 *
aead
, 
ptls_hash_algorithm_t
 *
hash
, int 
is_enc
, const void *
secret
,

5218 
ptls_iovec_t
 
hash_value
, const char *
label_prefix
)

5220 
ptls_aead_context_t
 *
ctx
 = 
NULL
;

5221 
uint8_t
 
key_iv
[
PTLS_MAX_SECRET_SIZE
 + 
PTLS_MAX_IV_SIZE
];

5222 int 
ret
;

5224 if ((
ret
 = 
	`get_traffic_key
(
hash
, 
key_iv
, 
aead
->
key_size
, 0, 
secret
, 
hash_value
, 
label_prefix
)) != 0)

5225 goto 
Exit
;

5226 if ((
ret
 = 
	`get_traffic_key
(
hash
, 
key_iv
 + 
aead
->
key_size
, aead->
iv_size
, 1, 
secret
, 
hash_value
, 
label_prefix
)) != 0)

5227 goto 
Exit
;

5228 
ctx
 = 
	`ptls_aead_new_direct
(
aead
, 
is_enc
, 
key_iv
, key_iv + aead->
key_size
);

5230 
Exit
:

5231 
	`ptls_clear_memory
(
key_iv
, sizeof(key_iv));

5232 return 
ctx
;

5233 
	}
}

5235 
ptls_aead_context_t
 *
	$ptls_aead_new
(
ptls_aead_algorithm_t
 *
aead
, 
ptls_hash_algorithm_t
 *
hash
, int 
is_enc
, const void *
secret
,

5236 const char *
label_prefix
)

5238 return 
	`new_aead
(
aead
, 
hash
, 
is_enc
, 
secret
, 
	`ptls_iovec_init
(
NULL
, 0), 
label_prefix
);

5239 
	}
}

5241 
ptls_aead_context_t
 *
	$ptls_aead_new_direct
(
ptls_aead_algorithm_t
 *
aead
, int 
is_enc
, const void *
key
, const void *
iv
)

5243 
ptls_aead_context_t
 *
ctx
;

5245 if ((
ctx
 = (
ptls_aead_context_t
 *)
	`malloc
(
aead
->
context_size
)) == 
NULL
)

5246 return 
NULL
;

5248 *
ctx
 = (
ptls_aead_context_t
){
aead
};

5250 if (
aead
->
	`setup_crypto
(
ctx
, 
is_enc
, 
key
, 
iv
) != 0) {

5251 
	`free
(
ctx
);

5252 return 
NULL
;

5255 return 
ctx
;

5256 
	}
}

5258 void 
	$ptls_aead_free
(
ptls_aead_context_t
 *
ctx
)

5260 
ctx
->
	`dispose_crypto
(ctx);

5261 
	`free
(
ctx
);

5262 
	}
}

5264 void 
	$ptls_aead__build_iv
(
ptls_aead_algorithm_t
 *
algo
, 
uint8_t
 *
iv
, const uint8_t *
static_iv
, 
uint64_t
 
seq
)

5266 
size_t
 
iv_size
 = 
algo
->iv_size, 
i
;

5267 const 
uint8_t
 *
s
 = 
static_iv
;

5268 
uint8_t
 *
d
 = 
iv
;

5271 for (
i
 = 
iv_size
 - 8; i != 0; --i)

5272 *
d
++ = *
s
++;

5273 
i
 = 64;

5275 
i
 -= 8;

5276 *
d
++ = *
s
++ ^ (
uint8_t
)(
seq
 >> 
i
);

5277 } while (
i
 != 0);

5278 
	}
}

5280 static void 
	$clear_memory
(void *
p
, 
size_t
 
len
)

5282 if (
len
 != 0)

5283 
	`memset
(
p
, 0, 
len
);

5284 
	}
}

5286 void (*volatile 
ptls_clear_memory
)(void *
p
, 
size_t
 
len
) = 
clear_memory
;

5288 static int 
	$mem_equal
(const void *
_x
, const void *
_y
, 
size_t
 
len
)

5290 const volatile 
uint8_t
 *
x
 = 
_x
, *
y
 = 
_y
;

5291 
uint8_t
 
t
 = 0;

5293 for (; 
len
 != 0; --len)

5294 
t
 |= *
x
++ ^ *
y
++;

5296 return 
t
 == 0;

5297 
	}
}

5299 int (*volatile 
ptls_mem_equal
)(const void *
x
, const void *
y
, 
size_t
 
len
) = 
mem_equal
;

5301 static 
uint64_t
 
	$get_time
(
ptls_get_time_t
 *
self
)

5303 struct 
timeval
 
tv
;

5304 
	`gettimeofday
(&
tv
, 
NULL
);

5305 return (
uint64_t
)
tv
.
tv_sec
 * 1000 + tv.
tv_usec
 / 1000;

5306 
	}
}

5308 
ptls_get_time_t
 
	gptls_get_time
 = {
get_time
};

5309 #if 
PICOTLS_USE_DTRACE


5310 
PTLS_THREADLOCAL
 unsigned 
	gptls_default_skip_tracing
 = 0;

5313 int 
	$ptls_is_server
(
ptls_t
 *
tls
)

5315 return 
tls
->
is_server
;

5316 
	}
}

5318 struct 
	sst_ptls_raw_message_emitter_t
 {

5319 
ptls_message_emitter_t
 
	msuper
;

5320 
size_t
 
	mstart_off
;

5321 
size_t
 *
	mepoch_offsets
;

5324 static int 
	$begin_raw_message
(
ptls_message_emitter_t
 *
_self
)

5326 struct 
st_ptls_raw_message_emitter_t
 *
self
 = (void *)
_self
;

5328 
self
->
start_off
 = self->
super
.
buf
->
off
;

5330 
	}
}

5332 static int 
	$commit_raw_message
(
ptls_message_emitter_t
 *
_self
)

5334 struct 
st_ptls_raw_message_emitter_t
 *
self
 = (void *)
_self
;

5335 
size_t
 
epoch
;

5338 
epoch
 = 
self
->
super
.
enc
->epoch;

5339 if (
epoch
 == 1 && 
self
->
super
.
buf
->
base
[self->
start_off
] == 
PTLS_HANDSHAKE_TYPE_CLIENT_HELLO
)

5340 
epoch
 = 0;

5342 for (++
epoch
; epoch < 5; ++epoch) {

5343 
	`assert
(
self
->
epoch_offsets
[
epoch
] == self->
start_off
);

5344 
self
->
epoch_offsets
[
epoch
] = self->
super
.
buf
->
off
;

5347 
self
->
start_off
 = 
SIZE_MAX
;

5350 
	}
}

5352 
size_t
 
	$ptls_get_read_epoch
(
ptls_t
 *
tls
)

5354 switch (
tls
->
state
) {

5355 case 
PTLS_STATE_CLIENT_HANDSHAKE_START
:

5356 case 
PTLS_STATE_CLIENT_EXPECT_SERVER_HELLO
:

5357 case 
PTLS_STATE_CLIENT_EXPECT_SECOND_SERVER_HELLO
:

5358 case 
PTLS_STATE_SERVER_EXPECT_CLIENT_HELLO
:

5359 case 
PTLS_STATE_SERVER_EXPECT_SECOND_CLIENT_HELLO
:

5361 case 
PTLS_STATE_SERVER_EXPECT_END_OF_EARLY_DATA
:

5362 
	`assert
(!
tls
->
ctx
->
omit_end_of_early_data
);

5364 case 
PTLS_STATE_CLIENT_EXPECT_ENCRYPTED_EXTENSIONS
:

5365 case 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE_REQUEST_OR_CERTIFICATE
:

5366 case 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE
:

5367 case 
PTLS_STATE_CLIENT_EXPECT_CERTIFICATE_VERIFY
:

5368 case 
PTLS_STATE_CLIENT_EXPECT_FINISHED
:

5369 case 
PTLS_STATE_SERVER_EXPECT_CERTIFICATE
:

5370 case 
PTLS_STATE_SERVER_EXPECT_CERTIFICATE_VERIFY
:

5371 case 
PTLS_STATE_SERVER_EXPECT_FINISHED
:

5373 case 
PTLS_STATE_CLIENT_POST_HANDSHAKE
:

5374 case 
PTLS_STATE_SERVER_POST_HANDSHAKE
:

5377 
	`assert
(!"invalid state");

5378 return 
SIZE_MAX
;

5380 
	}
}

5382 int 
	$ptls_handle_message
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, 
size_t
 
epoch_offsets
[5], size_t 
in_epoch
, const void *
input
,

5383 
size_t
 
inlen
, 
ptls_handshake_properties_t
 *
properties
)

5385 return 
tls
->
is_server
 ? 
	`ptls_server_handle_message
(tls, 
sendbuf
, 
epoch_offsets
, 
in_epoch
, 
input
, 
inlen
, 
properties
)

5386 : 
	`ptls_client_handle_message
(
tls
, 
sendbuf
, 
epoch_offsets
, 
in_epoch
, 
input
, 
inlen
, 
properties
);

5387 
	}
}

5389 int 
	$ptls_client_handle_message
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, 
size_t
 
epoch_offsets
[5], size_t 
in_epoch
, const void *
input
,

5390 
size_t
 
inlen
, 
ptls_handshake_properties_t
 *
properties
)

5392 
	`assert
(!
tls
->
is_server
);

5394 struct 
st_ptls_raw_message_emitter_t
 
emitter
 = {

5395 {
sendbuf
, &
tls
->
traffic_protection
.
enc
, 0, 
begin_raw_message
, 
commit_raw_message
}, 
SIZE_MAX
, 
epoch_offsets
};

5396 struct 
st_ptls_record_t
 
rec
 = {
PTLS_CONTENT_TYPE_HANDSHAKE
, 0, 
inlen
, 
input
};

5398 if (
input
 == 
NULL
)

5399 return 
	`send_client_hello
(
tls
, &
emitter
.
super
, 
properties
, 
NULL
);

5401 if (
	`ptls_get_read_epoch
(
tls
) != 
in_epoch
)

5402 return 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

5404 return 
	`handle_handshake_record
(
tls
, 
handle_client_handshake_message
, &
emitter
.
super
, &
rec
, 
properties
);

5405 
	}
}

5407 int 
	$ptls_server_handle_message
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
sendbuf
, 
size_t
 
epoch_offsets
[5], size_t 
in_epoch
, const void *
input
,

5408 
size_t
 
inlen
, 
ptls_handshake_properties_t
 *
properties
)

5410 
	`assert
(
tls
->
is_server
);

5412 struct 
st_ptls_raw_message_emitter_t
 
emitter
 = {

5413 {
sendbuf
, &
tls
->
traffic_protection
.
enc
, 0, 
begin_raw_message
, 
commit_raw_message
}, 
SIZE_MAX
, 
epoch_offsets
};

5414 struct 
st_ptls_record_t
 
rec
 = {
PTLS_CONTENT_TYPE_HANDSHAKE
, 0, 
inlen
, 
input
};

5416 
	`assert
(
input
);

5418 if (
	`ptls_get_read_epoch
(
tls
) != 
in_epoch
)

5419 return 
PTLS_ALERT_UNEXPECTED_MESSAGE
;

5421 return 
	`handle_handshake_record
(
tls
, 
handle_server_handshake_message
, &
emitter
.
super
, &
rec
, 
properties
);

5422 
	}
}

5424 int 
	$ptls_esni_init_context
(
ptls_context_t
 *
ctx
, 
ptls_esni_context_t
 *
esni
, 
ptls_iovec_t
 
esni_keys
,

5425 
ptls_key_exchange_context_t
 **
key_exchanges
)

5427 const 
uint8_t
 *
src
 = 
esni_keys
.
base
, *const 
end
 = src + esni_keys.
len
;

5428 
size_t
 
num_key_exchanges
, 
num_cipher_suites
 = 0;

5429 int 
ret
;

5431 for (
num_key_exchanges
 = 0; 
key_exchanges
[num_key_exchanges] != 
NULL
; ++num_key_exchanges)

5434 
	`memset
(
esni
, 0, sizeof(*esni));

5435 if ((
esni
->
key_exchanges
 = 
	`malloc
(sizeof(*esni->key_exchanges) * (
num_key_exchanges
 + 1))) == 
NULL
) {

5436 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

5437 goto 
Exit
;

5439 
	`memcpy
(
esni
->
key_exchanges
, key_exchanges, sizeof(*esni->key_exchanges) * (
num_key_exchanges
 + 1));

5442 if ((
ret
 = 
	`ptls_decode16
(&
esni
->
version
, &
src
, 
end
)) != 0)

5443 goto 
Exit
;

5445 if (
end
 - 
src
 < 4) {

5446 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

5447 goto 
Exit
;

5449 
src
 += 4;

5451 
	`ptls_decode_open_block
(
src
, 
end
, 2, { src = end; });

5454 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

5457 
uint16_t
 
id
;

5458 if ((
ret
 = 
	`ptls_decode16
(&
id
, &
src
, 
end
)) != 0)

5459 goto 
Exit
;

5460 
	`ptls_decode_open_block
(
src
, 
end
, 2, { src = end; });

5462 
ptls_key_exchange_context_t
 **
found
;

5463 for (
found
 = 
key_exchanges
; *found != 
NULL
; ++found)

5464 if ((*
found
)->
algo
->
id
 == id)

5466 if (
found
 == 
NULL
) {

5467 
ret
 = 
PTLS_ERROR_INCOMPATIBLE_KEY
;

5468 goto 
Exit
;

5470 } while (
src
 != 
end
);

5473 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

5474 void *
newp
;

5476 
uint16_t
 
id
;

5477 if ((
ret
 = 
	`ptls_decode16
(&
id
, &
src
, 
end
)) != 0)

5478 goto 
Exit
;

5479 
size_t
 
i
;

5480 for (
i
 = 0; 
ctx
->
cipher_suites
[i] != 
NULL
; ++i)

5481 if (
ctx
->
cipher_suites
[
i
]->
id
 == id)

5483 if (
ctx
->
cipher_suites
[
i
] != 
NULL
) {

5484 if ((
newp
 = 
	`realloc
(
esni
->
cipher_suites
, sizeof(*esni->cipher_suites) * (
num_cipher_suites
 + 1))) == 
NULL
) {

5485 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

5486 goto 
Exit
;

5488 
esni
->
cipher_suites
 = 
newp
;

5489 
esni
->
cipher_suites
[
num_cipher_suites
++].
cipher_suite
 = 
ctx
->cipher_suites[
i
];

5491 } while (
src
 != 
end
);

5492 if ((
newp
 = 
	`realloc
(
esni
->
cipher_suites
, sizeof(*esni->cipher_suites) * (
num_cipher_suites
 + 1))) == 
NULL
) {

5493 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

5494 goto 
Exit
;

5496 
esni
->
cipher_suites
 = 
newp
;

5497 
esni
->
cipher_suites
[
num_cipher_suites
].
cipher_suite
 = 
NULL
;

5500 if ((
ret
 = 
	`ptls_decode16
(&
esni
->
padded_length
, &
src
, 
end
)) != 0)

5501 goto 
Exit
;

5502 if ((
ret
 = 
	`ptls_decode64
(&
esni
->
not_before
, &
src
, 
end
)) != 0)

5503 goto 
Exit
;

5504 if ((
ret
 = 
	`ptls_decode64
(&
esni
->
not_after
, &
src
, 
end
)) != 0)

5505 goto 
Exit
;

5507 
	`ptls_decode_block
(
src
, 
end
, 2, {

5508 while (
src
 != 
end
) {

5509 
uint16_t
 
ext_type
;

5510 if ((
ret
 = 
	`ptls_decode16
(&
ext_type
, &
src
, 
end
)) != 0)

5511 goto 
Exit
;

5512 
	`ptls_decode_open_block
(
src
, 
end
, 2, { src = end; });

5517 
size_t
 
i
;

5518 for (
i
 = 0; 
esni
->
cipher_suites
[i].
cipher_suite
 != 
NULL
; ++i) {

5519 if ((
ret
 = 
	`ptls_calc_hash
(
esni
->
cipher_suites
[
i
].
cipher_suite
->
hash
, esni->cipher_suites[i].
record_digest
,

5520 
esni_keys
.
base
, esni_keys.
len
)) != 0)

5521 goto 
Exit
;

5525 
ret
 = 0;

5526 
Exit
:

5527 if (
ret
 != 0)

5528 
	`ptls_esni_dispose_context
(
esni
);

5529 return 
ret
;

5530 
	}
}

5532 void 
	$ptls_esni_dispose_context
(
ptls_esni_context_t
 *
esni
)

5534 
size_t
 
i
;

5536 if (
esni
->
key_exchanges
 != 
NULL
) {

5537 for (
i
 = 0; 
esni
->
key_exchanges
[i] != 
NULL
; ++i)

5538 
esni
->
key_exchanges
[
i
]->
	`on_exchange
(esni->key_exchanges + i, 1, 
NULL
, 
	`ptls_iovec_init
(NULL, 0));

5539 
	`free
(
esni
->
key_exchanges
);

5541 
	`free
(
esni
->
cipher_suites
);

5542 
	}
}

5547 
ptls_esni_secret_t
 *
	$ptls_get_esni_secret
(
ptls_t
 *
ctx
)

5549 return 
ctx
->
esni
;

5550 
	}
}

5555 int 
	$ptls_server_name_is_ipaddr
(const char *
name
)

5557 #ifdef 
AF_INET


5558 struct 
sockaddr_in
 
sin
;

5559 if (
	`inet_pton
(
AF_INET
, 
name
, &
sin
) == 1)

5562 #ifdef 
AF_INET6


5563 struct 
sockaddr_in6
 
sin6
;

5564 if (
	`inet_pton
(
AF_INET6
, 
name
, &
sin6
) == 1)

5568 
	}
}

5570 char *
	$ptls_hexdump
(char *
buf
, const void *
_src
, 
size_t
 
len
)

5572 char *
dst
 = 
buf
;

5573 const 
uint8_t
 *
src
 = 
_src
;

5574 
size_t
 
i
;

5576 for (
i
 = 0; i != 
len
; ++i) {

5577 *
dst
++ = "0123456789abcdef"[
src
[
i
] >> 4];

5578 *
dst
++ = "0123456789abcdef"[
src
[
i
] & 0xf];

5580 *
dst
++ = '\0';

5581 return 
buf
;

5582 
	}
}

	@deps/picotls/lib/ptlsbcrypt.c

23 #ifndef 
_WINDOWS


28 int 
	$ptls_bcrypt_init
()

31 
	}
}

33 void 
	$ptlc_bcrypt_dispose
()

35 
	}
}

39 #include 
	~"wincompat.h
"

40 #include 
	~<bcrypt.h
>

41 #include 
	~"picotls.h
"

46 int 
	$ptls_bcrypt_init
()

49 
	}
}

54 void 
	$ptlc_bcrypt_dispose
()

56 
	}
}

61 void 
	$ptls_bcrypt_random_bytes
(void *
buf
, 
size_t
 
len
)

64 
	}
}

70 struct 
	sptls_bcrypt_symmetric_param_t
 {

71 
HANDLE
 
	mhKey
;

72 
DWORD
 
	mdwFlags
;

73 
ULONG
 
	mcbKeyObject
;

74 
uint8_t
 
	miv
[
PTLS_MAX_IV_SIZE
];

75 
uint8_t
 *
	mkey_object
;

76 int 
	mis_enc
;

79 struct 
	sptls_bcrypt_symmetric_context_t
 {

80 
ptls_cipher_context_t
 
	msuper
;

81 struct 
ptls_bcrypt_symmetric_param_t
 
	mbctx
;

84 static void 
	$ptls_bcrypt_cipher_init_ctr
(
ptls_cipher_context_t
 *
_ctx
, const void *
iv
)

86 struct 
ptls_bcrypt_symmetric_context_t
 *
ctx
 = (struct ptls_bcrypt_symmetric_context_t *)
_ctx
;

88 if (
iv
 != 
NULL
) {

89 
	`memcpy
(
ctx
->
bctx
.
iv
, iv, ctx->
super
.
algo
->
block_size
);

91 
	`memset
(
ctx
->
bctx
.
iv
, 0, ctx->
super
.
algo
->
block_size
);

93 
	}
}

95 static void 
	$ptls_bcrypt_cipher_dispose
(
ptls_cipher_context_t
 *
_ctx
)

97 struct 
ptls_bcrypt_symmetric_context_t
 *
ctx
 = (struct ptls_bcrypt_symmetric_context_t *)
_ctx
;

99 if (
ctx
->
bctx
.
hKey
 != 
NULL
) {

100 (void)
	`BCryptDestroyKey
(
ctx
->
bctx
.
hKey
);

103 if (
ctx
->
bctx
.
key_object
 != 
NULL
) {

104 
	`free
(
ctx
->
bctx
.
key_object
);

107 
	`memset
(&
ctx
->
bctx
, 0, sizeof(struct 
ptls_bcrypt_symmetric_param_t
));

108 
	}
}

110 static void 
	$ptls_bcrypt_cipher_transform_ecb
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
len
)

112 struct 
ptls_bcrypt_symmetric_context_t
 *
ctx
 = (struct ptls_bcrypt_symmetric_context_t *)
_ctx
;

113 
ULONG
 
cbResult
;

114 
NTSTATUS
 
ret
;

116 
	`assert
((
len
 % 
ctx
->
super
.
algo
->
block_size
) == 0);

119 if (
ctx
->
bctx
.
is_enc
) {

120 
ret
 = 
	`BCryptEncrypt
(
ctx
->
bctx
.
hKey
, (
PUCHAR
)
input
, (
ULONG
)
len
, 
NULL
, NULL, 0, 
output
, (ULONG)len, &
cbResult
, 0);

122 
ret
 = 
	`BCryptDecrypt
(
ctx
->
bctx
.
hKey
, (
PUCHAR
)
input
, (
ULONG
)
len
, 
NULL
, NULL, 0, 
output
, (ULONG)len, &
cbResult
, 0);

125 
	`assert
(
	`BCRYPT_SUCCESS
(
ret
));

127 if (!
	`BCRYPT_SUCCESS
(
ret
)) {

128 
	`memset
(
output
, 0, 
cbResult
);

130 
	}
}

132 static void 
	$ptls_bcrypt_cipher_transform_ctr
(
ptls_cipher_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
len
)

134 struct 
ptls_bcrypt_symmetric_context_t
 *
ctx
 = (struct ptls_bcrypt_symmetric_context_t *)
_ctx
;

135 
ULONG
 
cbResult
;

136 
NTSTATUS
 
ret
;

137 
uint8_t
 
eiv
[
PTLS_MAX_IV_SIZE
];

138 
size_t
 
i
;

139 
uint64_t
 
seq
 = 0;

140 
size_t
 
processed
 = 0;

141 
uint8_t
 const *
v_in
 = 
input
;

142 
uint8_t
 *
v_out
 = 
output
;

144 
	`assert
(
ctx
->
super
.
algo
->
block_size
 > 0);

145 
	`assert
(
ctx
->
super
.
algo
->
block_size
 <= 
PTLS_MAX_IV_SIZE
);

147 while (
processed
 < 
len
) {

149 
ret
 = 
	`BCryptEncrypt
(
ctx
->
bctx
.
hKey
, (
PUCHAR
)ctx->bctx.
iv
, (
ULONG
)ctx->
super
.
algo
->
block_size
, 
NULL
, NULL, 0, 
eiv
,

150 (
ULONG
)(ULONG)
ctx
->
super
.
algo
->
block_size
, &
cbResult
, 0);

151 
	`assert
(
	`BCRYPT_SUCCESS
(
ret
));

153 if (
	`BCRYPT_SUCCESS
(
ret
)) {

154 for (
i
 = 0; 
processed
 < 
len
 && i < 
ctx
->
super
.
algo
->
block_size
; i++, processed++) {

155 
v_out
[
processed
] = 
v_in
[processed] ^ 
eiv
[
i
];

159 
i
 = (int)
ctx
->
super
.
algo
->
block_size
 - 1;

160 while (
i
 >= 0) {

161 
ctx
->
bctx
.
iv
[
i
] += 1;

162 if (
ctx
->
bctx
.
iv
[
i
] > 0) {

165 
i
--;

169 
	}
}

171 static int 
	$ptls_bcrypt_cipher_setup_crypto
(
ptls_cipher_context_t
 *
_ctx
, int 
is_enc
, const void *
key
, 
wchar_t
 const *
bcrypt_name
,

172 int 
is_ctr
)

174 struct 
ptls_bcrypt_symmetric_context_t
 *
ctx
 = (struct ptls_bcrypt_symmetric_context_t *)
_ctx
;

175 
HANDLE
 
hAlgorithm
 = 
NULL
;

176 
NTSTATUS
 
ret
;

178 
	`memset
(&
ctx
->
bctx
, 0, sizeof(struct 
ptls_bcrypt_symmetric_param_t
));

180 
ret
 = 
	`BCryptOpenAlgorithmProvider
(&
hAlgorithm
, 
bcrypt_name
, 
NULL
, 0);

182 if (
	`BCRYPT_SUCCESS
(
ret
)) {

183 
DWORD
 
ko_size
 = 0;

184 
ULONG
 
cbResult
 = 0;

186 
ret
 = 
	`BCryptGetProperty
(
hAlgorithm
, 
BCRYPT_OBJECT_LENGTH
, (
PUCHAR
)&
ko_size
, (
ULONG
)sizeof(ko_size), &
cbResult
, 0);

188 if (
	`BCRYPT_SUCCESS
(
ret
)) {

189 
ctx
->
bctx
.
key_object
 = (
uint8_t
 *)
	`malloc
(
ko_size
);

190 if (
ctx
->
bctx
.
key_object
 == 
NULL
) {

191 
ret
 = 
STATUS_NO_MEMORY
;

193 
ctx
->
bctx
.
cbKeyObject
 = 
ko_size
;

198 if (
	`BCRYPT_SUCCESS
(
ret
)) {

199 
ret
 = 
	`BCryptSetProperty
(
hAlgorithm
, 
BCRYPT_CHAINING_MODE
, (
PBYTE
)
BCRYPT_CHAIN_MODE_ECB
, sizeof(BCRYPT_CHAIN_MODE_ECB), 0);

202 if (
	`BCRYPT_SUCCESS
(
ret
)) {

203 
ret
 = 
	`BCryptGenerateSymmetricKey
(
hAlgorithm
, &
ctx
->
bctx
.
hKey
, ctx->bctx.
key_object
, ctx->bctx.
cbKeyObject
, (
PUCHAR
)
key
,

204 (
ULONG
)
ctx
->
super
.
algo
->
key_size
, 0);

207 if (
hAlgorithm
 != 
NULL
) {

208 
	`BCryptCloseAlgorithmProvider
(
hAlgorithm
, 0);

211 if (
	`BCRYPT_SUCCESS
(
ret
)) {

213 
ctx
->
super
.
do_dispose
 = 
ptls_bcrypt_cipher_dispose
;

214 if (
is_ctr
) {

215 
ctx
->
super
.
do_init
 = 
ptls_bcrypt_cipher_init_ctr
;

216 
ctx
->
super
.
do_transform
 = 
ptls_bcrypt_cipher_transform_ctr
;

218 
ctx
->
super
.
do_init
 = 
NULL
;

219 
ctx
->
super
.
do_transform
 = 
ptls_bcrypt_cipher_transform_ecb
;

221 
ctx
->
bctx
.
is_enc
 = is_enc;

224 
	`ptls_bcrypt_cipher_dispose
(
_ctx
);

225 return 
PTLS_ERROR_LIBRARY
;

227 
	}
}

229 static int 
	$ptls_bcrypt_cipher_setup_crypto_aes_ecb
(
ptls_cipher_context_t
 *
_ctx
, int 
is_enc
, const void *
key
)

231 return 
	`ptls_bcrypt_cipher_setup_crypto
(
_ctx
, 
is_enc
, 
key
, 
BCRYPT_AES_ALGORITHM
, 0);

232 
	}
}

234 static int 
	$ptls_bcrypt_cipher_setup_crypto_aes_ctr
(
ptls_cipher_context_t
 *
_ctx
, int 
is_enc
, const void *
key
)

236 return 
	`ptls_bcrypt_cipher_setup_crypto
(
_ctx
, 
is_enc
, 
key
, 
BCRYPT_AES_ALGORITHM
, 1);

237 
	}
}

289 struct 
	sptls_bcrypt_aead_param_t
 {

290 
HANDLE
 
	mhKey
;

291 
ULONG
 
	mcbKeyObject
;

292 
ULONG
 
	mmaxTagLength
;

293 
ULONG
 
	mnbExtraBytes
;

294 
uint8_t
 *
	mkey_object
;

295 
uint8_t
 
	miv_static
[
PTLS_MAX_IV_SIZE
];

296 
uint8_t
 
	mextraBytes
[
PTLS_MAX_DIGEST_SIZE
];

297 
uint8_t
 
	miv
[
PTLS_MAX_IV_SIZE
];

298 
uint8_t
 
	mivbuf
[
PTLS_MAX_IV_SIZE
];

299 
uint8_t
 
	mtag
[
PTLS_MAX_DIGEST_SIZE
];

300 
uint8_t
 
	mauth_tag
[
PTLS_MAX_DIGEST_SIZE
];

301 
BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
 
	maead_params
;

304 struct 
	sptls_bcrypt_aead_context_t
 {

305 struct 
st_ptls_aead_context_t
 
	msuper
;

306 struct 
ptls_bcrypt_aead_param_t
 
	mbctx
;

309 static void 
	$ptls_bcrypt_aead_dispose_crypto
(struct 
st_ptls_aead_context_t
 *
_ctx
)

311 struct 
ptls_bcrypt_aead_context_t
 *
ctx
 = (struct ptls_bcrypt_aead_context_t *)
_ctx
;

313 if (
ctx
->
bctx
.
hKey
 != 
NULL
) {

314 (void)
	`BCryptDestroyKey
(
ctx
->
bctx
.
hKey
);

317 if (
ctx
->
bctx
.
key_object
 != 
NULL
) {

318 
	`free
(
ctx
->
bctx
.
key_object
);

321 
	`memset
(&
ctx
->
bctx
, 0, sizeof(struct 
ptls_bcrypt_aead_param_t
));

322 
	}
}

324 static void 
	$ptls_bcrypt_aead_do_encrypt_init
(struct 
st_ptls_aead_context_t
 *
_ctx
, 
uint64_t
 
seq
, const void *
aad
, 
size_t
 
aadlen
)

326 struct 
ptls_bcrypt_aead_context_t
 *
ctx
 = (struct ptls_bcrypt_aead_context_t *)
_ctx
;

329 
	`ptls_aead__build_iv
(
ctx
->
super
.
algo
, ctx->
bctx
.
iv
, ctx->bctx.
iv_static
, 
seq
);

331 
	`memset
(
ctx
->
bctx
.
tag
, 0, sizeof(ctx->
super
.
algo
->
tag_size
));

332 
	`BCRYPT_INIT_AUTH_MODE_INFO
(
ctx
->
bctx
.
aead_params
);

334 
	`assert
(
ctx
->
super
.
algo
->
iv_size
 <= sizeof(ctx->
bctx
.
ivbuf
));

335 
	`assert
(
ctx
->
super
.
algo
->
tag_size
 <= sizeof(ctx->
bctx
.
tag
));

336 
	`assert
(
ctx
->
bctx
.
maxTagLength
 <= sizeof(ctx->bctx.
auth_tag
));

338 
	`memset
(
ctx
->
bctx
.
ivbuf
, 0, ctx->
super
.
algo
->
iv_size
);

339 
	`memset
(
ctx
->
bctx
.
tag
, 0, ctx->
super
.
algo
->
tag_size
);

340 
	`memset
(
ctx
->
bctx
.
auth_tag
, 0, sizeof(ctx->bctx.auth_tag));

342 
ctx
->
bctx
.
nbExtraBytes
 = 0;

344 
ctx
->
bctx
.
aead_params
.
pbNonce
 = (
PUCHAR
)&ctx->bctx.
iv
;

345 
ctx
->
bctx
.
aead_params
.
cbNonce
 = (
ULONG
)ctx->
super
.
algo
->
iv_size
;

346 
ctx
->
bctx
.
aead_params
.
pbAuthData
 = (
PUCHAR
)
aad
;

347 
ctx
->
bctx
.
aead_params
.
cbAuthData
 = (
ULONG
)
aadlen
;

348 
ctx
->
bctx
.
aead_params
.
pbTag
 = (
PUCHAR
)ctx->bctx.
tag
;

349 
ctx
->
bctx
.
aead_params
.
cbTag
 = (
ULONG
)ctx->
super
.
algo
->
tag_size
;

351 
ctx
->
bctx
.
aead_params
.
pbMacContext
 = (
PUCHAR
)ctx->bctx.
auth_tag
;

352 
ctx
->
bctx
.
aead_params
.
cbMacContext
 = (
ULONG
)ctx->bctx.
maxTagLength
;

353 
ctx
->
bctx
.
aead_params
.
dwFlags
 = 
BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG
;

354 
	}
}

356 static 
size_t
 
	$ptls_bcrypt_aead_do_encrypt_update
(struct 
st_ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
)

358 struct 
ptls_bcrypt_aead_context_t
 *
ctx
 = (struct ptls_bcrypt_aead_context_t *)
_ctx
;

359 
size_t
 
outlenMax
 = 
inlen
 + 
ctx
->
super
.
algo
->
tag_size
 + ctx->
bctx
.
nbExtraBytes
;

360 
ULONG
 
cbResult1
 = 0;

361 
ULONG
 
cbResult2
 = 0;

362 
NTSTATUS
 
ret
;

365 if (
ctx
->
bctx
.
nbExtraBytes
 > 0) {

366 
ULONG
 
requiredBytes
 = (ULONG)(
ctx
->
super
.
algo
->
ecb_cipher
->
block_size
 - ctx->
bctx
.
nbExtraBytes
);

368 if (
inlen
 < 
requiredBytes
) {

369 
	`memcpy
(&
ctx
->
bctx
.
extraBytes
[ctx->bctx.
nbExtraBytes
], 
input
, 
inlen
);

370 
ctx
->
bctx
.
nbExtraBytes
 += (
ULONG
)
inlen
;

371 
inlen
 = 0;

373 
	`memcpy
(&
ctx
->
bctx
.
extraBytes
[ctx->bctx.
nbExtraBytes
], 
input
, 
requiredBytes
);

374 
inlen
 -= 
requiredBytes
;

375 
input
 = (void *)(((
uint8_t
 *)input) + 
requiredBytes
);

376 
ret
 = 
	`BCryptEncrypt
(
ctx
->
bctx
.
hKey
, (
PUCHAR
)ctx->bctx.
extraBytes
, (
ULONG
)ctx->
super
.
algo
->
ecb_cipher
->
block_size
,

377 (void *)&
ctx
->
bctx
.
aead_params
, ctx->bctx.
ivbuf
, (
ULONG
)ctx->
super
.
algo
->
iv_size
, 
output
,

378 (
ULONG
)
outlenMax
, &
cbResult1
, 0);

380 
	`assert
(
	`BCRYPT_SUCCESS
(
ret
));

381 if (!
	`BCRYPT_SUCCESS
(
ret
)) {

382 
	`memset
(
output
, 0, 
cbResult1
);

384 
outlenMax
 -= 
cbResult1
;

385 
output
 = (void *)(((
uint8_t
 *)output) + 
cbResult1
);

390 
ctx
->
bctx
.
nbExtraBytes
 = (
ULONG
)(
inlen
 % ctx->
super
.
algo
->
ecb_cipher
->
block_size
);

391 if (
ctx
->
bctx
.
nbExtraBytes
 > 0) {

392 
inlen
 -= 
ctx
->
bctx
.
nbExtraBytes
;

393 
	`memcpy
(&
ctx
->
bctx
.
extraBytes
, (void *)(((
uint8_t
 *)
input
) + 
inlen
), ctx->bctx.
nbExtraBytes
);

396 if (
inlen
 > 0) {

397 
ret
 = 
	`BCryptEncrypt
(
ctx
->
bctx
.
hKey
, (
PUCHAR
)
input
, (
ULONG
)
inlen
, (void *)&ctx->bctx.
aead_params
, ctx->bctx.
ivbuf
,

398 (
ULONG
)
ctx
->
super
.
algo
->
iv_size
, 
output
, (ULONG)
outlenMax
, &
cbResult2
, 0);

399 
	`assert
(
	`BCRYPT_SUCCESS
(
ret
));

401 if (!
	`BCRYPT_SUCCESS
(
ret
)) {

402 
	`memset
(
output
, 0, 
cbResult2
);

405 return (
size_t
)
cbResult1
 + 
cbResult2
;

406 
	}
}

408 static 
size_t
 
	$ptls_bcrypt_aead_do_encrypt_final
(struct 
st_ptls_aead_context_t
 *
_ctx
, void *
output
)

410 struct 
ptls_bcrypt_aead_context_t
 *
ctx
 = (struct ptls_bcrypt_aead_context_t *)
_ctx
;

411 
size_t
 
outlenMax
 = 
ctx
->
super
.
algo
->
tag_size
 + ctx->
bctx
.
nbExtraBytes
;

412 
ULONG
 
cbResult
 = 0;

413 
NTSTATUS
 
ret
;

415 
ctx
->
bctx
.
aead_params
.
dwFlags
 &= ~
BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG
;

417 
ret
 = 
	`BCryptEncrypt
(
ctx
->
bctx
.
hKey
, (
PUCHAR
)ctx->bctx.
extraBytes
, (
ULONG
)ctx->bctx.
nbExtraBytes
, (void *)&ctx->bctx.
aead_params
,

418 
ctx
->
bctx
.
ivbuf
, (
ULONG
)ctx->
super
.
algo
->
iv_size
, 
output
, (ULONG)
outlenMax
, &
cbResult
, 0);

419 
	`assert
(
	`BCRYPT_SUCCESS
(
ret
));

421 if (
	`BCRYPT_SUCCESS
(
ret
)) {

423 
	`assert
(
cbResult
 + 
ctx
->
bctx
.
aead_params
.
cbTag
 <= 
outlenMax
);

424 
	`memcpy
(((
uint8_t
 *)
output
) + 
cbResult
, 
ctx
->
bctx
.
aead_params
.
pbTag
, ctx->bctx.aead_params.
cbTag
);

425 
cbResult
 += 
ctx
->
bctx
.
aead_params
.
cbTag
;

427 return 
cbResult
;

428 
	}
}

430 void 
	$ptls_bcrypt_do_encrypt
(
ptls_aead_context_t
 *
ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
, 
uint64_t
 
seq
, const void *
aad
,

431 
size_t
 
aadlen
, 
ptls_aead_supplementary_encryption_t
 *
supp
)

433 
size_t
 
after_update
;

435 
ctx
->
	`do_encrypt_init
(ctx, 
seq
, 
aad
, 
aadlen
);

436 
after_update
 = 
ctx
->
	`do_encrypt_update
(ctx, 
output
, 
input
, 
inlen
);

437 
ctx
->
	`do_encrypt_final
(ctx, (
uint8_t
 *)
output
 + 
after_update
);

439 if (
supp
 != 
NULL
) {

440 
	`ptls_cipher_init
(
supp
->
ctx
, supp->
input
);

441 
	`memset
(
supp
->
output
, 0, sizeof(supp->output));

442 
	`ptls_cipher_encrypt
(
supp
->
ctx
, supp->
output
, supp->output, sizeof(supp->output));

444 
	}
}

446 static 
size_t
 
	$ptls_bcrypt_aead_do_decrypt
(struct 
st_ptls_aead_context_t
 *
_ctx
, void *
output
, const void *
input
, 
size_t
 
inlen
,

447 
uint64_t
 
seq
, const void *
aad
, 
size_t
 
aadlen
)

449 struct 
ptls_bcrypt_aead_context_t
 *
ctx
 = (struct ptls_bcrypt_aead_context_t *)
_ctx
;

450 
ULONG
 
cbResult
;

451 
size_t
 
textLen
 = 
inlen
 - 
ctx
->
super
.
algo
->
tag_size
;

452 
NTSTATUS
 
ret
;

455 
	`ptls_aead__build_iv
(
ctx
->
super
.
algo
, ctx->
bctx
.
iv
, ctx->bctx.
iv_static
, 
seq
);

458 
	`BCRYPT_INIT_AUTH_MODE_INFO
(
ctx
->
bctx
.
aead_params
);

460 
	`memset
(
ctx
->
bctx
.
tag
, 0, sizeof(ctx->
super
.
algo
->
tag_size
));

461 
ctx
->
bctx
.
aead_params
.
pbNonce
 = (
PUCHAR
)&ctx->bctx.
iv
;

462 
ctx
->
bctx
.
aead_params
.
cbNonce
 = (
ULONG
)ctx->
super
.
algo
->
iv_size
;

463 
ctx
->
bctx
.
aead_params
.
pbAuthData
 = (
PUCHAR
)
aad
;

464 
ctx
->
bctx
.
aead_params
.
cbAuthData
 = (
ULONG
)
aadlen
;

465 
ctx
->
bctx
.
aead_params
.
pbTag
 = (
PUCHAR
)(((
uint8_t
 *)
input
) + 
textLen
);

466 
ctx
->
bctx
.
aead_params
.
cbTag
 = (
ULONG
)(ULONG)ctx->
super
.
algo
->
tag_size
;

469 
ret
 = 
	`BCryptDecrypt
(
ctx
->
bctx
.
hKey
, (
PUCHAR
)
input
, (
ULONG
)
textLen
, (void *)&ctx->bctx.
aead_params
, 
NULL
, 0, (PUCHAR)
output
,

470 (
ULONG
)
textLen
, &
cbResult
, 0);

472 if (
	`BCRYPT_SUCCESS
(
ret
)) {

473 return (
size_t
)
cbResult
;

475 return 
SIZE_MAX
;

477 
	}
}

479 static void 
	$ptls_bcrypt_aead_xor_iv
(
ptls_aead_context_t
 *
_ctx
, const void *
_bytes
, 
size_t
 
len
)

481 struct 
ptls_bcrypt_aead_context_t
 *
ctx
 = (struct ptls_bcrypt_aead_context_t *)
_ctx
;

482 const 
uint8_t
 *
bytes
 = 
_bytes
;

484 for (
size_t
 
i
 = 0; i < 
len
; ++i)

485 
ctx
->
bctx
.
iv
[
i
] ^= 
bytes
[i];

486 
	}
}

488 static int 
	$ptls_bcrypt_aead_setup_crypto
(
ptls_aead_context_t
 *
_ctx
, int 
is_enc
, const void *
key
, const void *
iv
,

489 
wchar_t
 const *
bcrypt_name
, wchar_t const *
bcrypt_mode
, 
size_t
 
bcrypt_mode_size
)

491 struct 
ptls_bcrypt_aead_context_t
 *
ctx
 = (struct ptls_bcrypt_aead_context_t *)
_ctx
;

492 
HANDLE
 
hAlgorithm
 = 
NULL
;

493 
NTSTATUS
 
ret
;

495 
	`memset
(&
ctx
->
bctx
, 0, sizeof(struct 
ptls_bcrypt_symmetric_param_t
));

497 
ret
 = 
	`BCryptOpenAlgorithmProvider
(&
hAlgorithm
, 
bcrypt_name
, 
NULL
, 0);

499 if (
	`BCRYPT_SUCCESS
(
ret
)) {

500 
ret
 = 
	`BCryptSetProperty
(
hAlgorithm
, 
BCRYPT_CHAINING_MODE
, (
PBYTE
)
bcrypt_mode
, (
ULONG
)
bcrypt_mode_size
, 0);

503 if (
	`BCRYPT_SUCCESS
(
ret
)) {

504 
DWORD
 
ko_size
 = 0;

505 
ULONG
 
cbResult
 = 0;

507 
ret
 = 
	`BCryptGetProperty
(
hAlgorithm
, 
BCRYPT_OBJECT_LENGTH
, (
PUCHAR
)&
ko_size
, (
ULONG
)sizeof(ko_size), &
cbResult
, 0);

509 if (
	`BCRYPT_SUCCESS
(
ret
)) {

510 
ctx
->
bctx
.
key_object
 = (
uint8_t
 *)
	`malloc
(
ko_size
);

511 if (
ctx
->
bctx
.
key_object
 == 
NULL
) {

512 
ret
 = 
STATUS_NO_MEMORY
;

514 
ctx
->
bctx
.
cbKeyObject
 = 
ko_size
;

519 if (
	`BCRYPT_SUCCESS
(
ret
)) {

520 
BCRYPT_KEY_LENGTHS_STRUCT
 
atl_st
;

521 
ULONG
 
cbResult
 = 0;

523 
ret
 = 
	`BCryptGetProperty
(
hAlgorithm
, 
BCRYPT_AUTH_TAG_LENGTH
, (
PUCHAR
)&
atl_st
, (
ULONG
)sizeof(atl_st), &
cbResult
, 0);

524 if (
	`BCRYPT_SUCCESS
(
ret
)) {

525 
ctx
->
bctx
.
maxTagLength
 = 
atl_st
.
dwMaxLength
;

529 if (
	`BCRYPT_SUCCESS
(
ret
)) {

530 
ret
 = 
	`BCryptGenerateSymmetricKey
(
hAlgorithm
, &
ctx
->
bctx
.
hKey
, ctx->bctx.
key_object
, ctx->bctx.
cbKeyObject
, (
PUCHAR
)
key
,

531 (
ULONG
)
ctx
->
super
.
algo
->
key_size
, 0);

534 if (
hAlgorithm
 != 
NULL
) {

535 
	`BCryptCloseAlgorithmProvider
(
hAlgorithm
, 0);

538 if (
	`BCRYPT_SUCCESS
(
ret
)) {

539 
	`memcpy
(
ctx
->
bctx
.
iv_static
, 
iv
, ctx->
super
.
algo
->
iv_size
);

540 if (
is_enc
) {

541 
ctx
->
super
.
dispose_crypto
 = 
ptls_bcrypt_aead_dispose_crypto
;

542 
ctx
->
super
.
do_xor_iv
 = 
ptls_bcrypt_aead_xor_iv
;

543 
ctx
->
super
.
do_decrypt
 = 
NULL
;

544 
ctx
->
super
.
do_encrypt_init
 = 
ptls_bcrypt_aead_do_encrypt_init
;

545 
ctx
->
super
.
do_encrypt_update
 = 
ptls_bcrypt_aead_do_encrypt_update
;

546 
ctx
->
super
.
do_encrypt_final
 = 
ptls_bcrypt_aead_do_encrypt_final
;

547 
ctx
->
super
.
do_encrypt
 = 
ptls_bcrypt_do_encrypt
;

549 
ctx
->
super
.
dispose_crypto
 = 
ptls_bcrypt_aead_dispose_crypto
;

550 
ctx
->
super
.
do_decrypt
 = 
ptls_bcrypt_aead_do_decrypt
;

551 
ctx
->
super
.
do_encrypt_init
 = 
NULL
;

552 
ctx
->
super
.
do_encrypt_update
 = 
NULL
;

553 
ctx
->
super
.
do_encrypt_final
 = 
NULL
;

557 
	`ptls_bcrypt_aead_dispose_crypto
(
_ctx
);

558 return 
PTLS_ERROR_LIBRARY
;

560 
	}
}

562 static int 
	$ptls_bcrypt_aead_setup_crypto_aesgcm
(
ptls_aead_context_t
 *
_ctx
, int 
is_enc
, const void *
key
, const void *
iv
)

564 return 
	`ptls_bcrypt_aead_setup_crypto
(
_ctx
, 
is_enc
, 
key
, 
iv
, 
BCRYPT_AES_ALGORITHM
, 
BCRYPT_CHAIN_MODE_GCM
,

565 sizeof(
BCRYPT_CHAIN_MODE_GCM
));

566 
	}
}

570 struct 
	sst_ptls_bcrypt_hash_param_t
 {

571 
wchar_t
 const *
	mbcrypt_name
;

572 
BCRYPT_HASH_HANDLE
 
	mhHash
;

573 
PUCHAR
 
	mpbHashObject
;

574 
ULONG
 
	mcbHashObject
;

575 
ULONG
 
	mhash_size
;

576 int 
	mhas_error
;

579 struct 
	sst_ptls_bcrypt_hash_context_t
 {

580 
ptls_hash_context_t
 
	msuper
;

581 struct 
st_ptls_bcrypt_hash_param_t
 
	mctx
;

584 static void 
	$ptls_bcrypt_hash_update
(struct 
st_ptls_hash_context_t
 *
_ctx
, const void *
src
, 
size_t
 
len
)

586 struct 
st_ptls_bcrypt_hash_context_t
 *
ctx
 = (struct st_ptls_bcrypt_hash_context_t *)
_ctx
;

587 
NTSTATUS
 
ret
 = 
	`BCryptHashData
(
ctx
->ctx.
hHash
, (
PUCHAR
)
src
, (
ULONG
)
len
, 0);

588 
	`assert
(
	`BCRYPT_SUCCESS
(
ret
));

590 if (!
	`BCRYPT_SUCCESS
(
ret
)) {

591 
ctx
->ctx.
has_error
 = 1;

593 
	}
}

595 static struct 
st_ptls_bcrypt_hash_context_t
 *
	$ptls_bcrypt_hash_context_free
(struct 
st_ptls_bcrypt_hash_context_t
 *
ctx
)

597 if (
ctx
->ctx.
pbHashObject
 != 
NULL
) {

598 
	`ptls_clear_memory
(
ctx
->ctx.
pbHashObject
, ctx->ctx.
cbHashObject
);

599 
	`free
(
ctx
->ctx.
pbHashObject
);

601 
	`ptls_clear_memory
(&
ctx
->ctx, sizeof(ctx->ctx));

603 return 
NULL
;

604 
	}
}

606 static 
ptls_hash_context_t
 *
ptls_bcrypt_hash_clone
(struct 
st_ptls_hash_context_t
 *
_ctx
);

608 static void 
	$ptls_bcrypt_hash_final
(struct 
st_ptls_hash_context_t
 *
_ctx
, void *
md
, 
ptls_hash_final_mode_t
 
mode
)

610 if (
mode
 == 
PTLS_HASH_FINAL_MODE_SNAPSHOT
) {

612 struct 
st_ptls_hash_context_t
 *
clone_ctx
 = 
	`ptls_bcrypt_hash_clone
(
_ctx
);

614 if (
clone_ctx
 != 
NULL
) {

615 
	`ptls_bcrypt_hash_final
(
clone_ctx
, 
md
, 
PTLS_HASH_FINAL_MODE_FREE
);

617 
	`assert
(
clone_ctx
 != 
NULL
);

620 
NTSTATUS
 
ret
;

621 struct 
st_ptls_bcrypt_hash_context_t
 *
ctx
 = (struct st_ptls_bcrypt_hash_context_t *)
_ctx
;

623 if (
md
 != 
NULL
) {

624 
ret
 = 
	`BCryptFinishHash
(
ctx
->ctx.
hHash
, 
md
, ctx->ctx.
hash_size
, 0);

625 
	`assert
(
	`BCRYPT_SUCCESS
(
ret
));

626 if (!
	`BCRYPT_SUCCESS
(
ret
) || 
ctx
->ctx.
has_error
) {

627 
	`memset
(
md
, 0, 
ctx
->ctx.
hash_size
);

631 
ret
 = 
	`BCryptDestroyHash
(
ctx
->ctx.
hHash
);

632 
	`assert
(
	`BCRYPT_SUCCESS
(
ret
));

634 switch (
mode
) {

635 case 
PTLS_HASH_FINAL_MODE_FREE
:

636 
ctx
 = 
	`ptls_bcrypt_hash_context_free
(ctx);

638 case 
PTLS_HASH_FINAL_MODE_RESET
: {

639 
BCRYPT_ALG_HANDLE
 
hAlgorithm
 = 
NULL
;

640 
ret
 = 
	`BCryptOpenAlgorithmProvider
(&
hAlgorithm
, 
ctx
->ctx.
bcrypt_name
, 
NULL
, 0);

641 if (
	`BCRYPT_SUCCESS
(
ret
)) {

642 
ctx
->ctx.
hHash
 = 
NULL
;

643 
ret
 = 
	`BCryptCreateHash
(
hAlgorithm
, &
ctx
->ctx.
hHash
, ctx->ctx.
pbHashObject
, ctx->ctx.
cbHashObject
, 
NULL
, 0, 0);

644 
	`BCryptCloseAlgorithmProvider
(
hAlgorithm
, 0);

646 
	`assert
(
	`BCRYPT_SUCCESS
(
ret
));

647 if (!
	`BCRYPT_SUCCESS
(
ret
)) {

648 
ctx
->ctx.
hHash
 = 
NULL
;

653 
	`assert
(!"FIXME");

657 
	}
}

659 static 
ptls_hash_context_t
 *
	$ptls_bcrypt_hash_clone
(struct 
st_ptls_hash_context_t
 *
_ctx
)

661 struct 
st_ptls_bcrypt_hash_context_t
 *
ctx
 = (struct st_ptls_bcrypt_hash_context_t *)
_ctx
;

662 struct 
st_ptls_bcrypt_hash_context_t
 *
clone_ctx
;

664 if ((
clone_ctx
 = (struct 
st_ptls_bcrypt_hash_context_t
 *)
	`malloc
(sizeof(*
ctx
))) != 
NULL
) {

665 
NTSTATUS
 
ret
;

667 
	`ptls_clear_memory
(&
clone_ctx
->
ctx
, sizeof(clone_ctx->ctx));

668 
clone_ctx
->
super
 = (
ptls_hash_context_t
){
ptls_bcrypt_hash_update
, 
ptls_bcrypt_hash_final
, 
ptls_bcrypt_hash_clone
};

669 
clone_ctx
->
ctx
.
pbHashObject
 = (
uint8_t
 *)
	`malloc
(ctx->ctx.
cbHashObject
);

670 
clone_ctx
->
ctx
.
cbHashObject
 = ctx->ctx.cbHashObject;

671 
clone_ctx
->
ctx
.
bcrypt_name
 = ctx->ctx.bcrypt_name;

672 
clone_ctx
->
ctx
.
hash_size
 = ctx->ctx.hash_size;

673 
clone_ctx
->
ctx
.
has_error
 = ctx->ctx.has_error;

675 if (
clone_ctx
->
ctx
.
pbHashObject
 == 
NULL
) {

676 
ret
 = 
STATUS_NO_MEMORY
;

678 
clone_ctx
->
ctx
.
hHash
 = 
NULL
;

679 
	`ptls_clear_memory
(&
clone_ctx
->
ctx
.
pbHashObject
, clone_ctx->ctx.
cbHashObject
);

680 
ret
 = 
	`BCryptDuplicateHash
(
ctx
->ctx.
hHash
, &
clone_ctx
->ctx.hHash, clone_ctx->ctx.
pbHashObject
,

681 
clone_ctx
->
ctx
.
cbHashObject
, 0);

684 if (!
	`BCRYPT_SUCCESS
(
ret
)) {

685 
clone_ctx
 = 
	`ptls_bcrypt_hash_context_free
(clone_ctx);

689 return (
ptls_hash_context_t
 *)
clone_ctx
;

690 
	}
}

692 static 
ptls_hash_context_t
 *
	$ptls_bcrypt_hash_create
(
wchar_t
 const *
bcrypt_name
, 
ULONG
 
hash_size
)

694 
BCRYPT_ALG_HANDLE
 
hAlgorithm
 = 
NULL
;

695 
NTSTATUS
 
ret
;

696 struct 
st_ptls_bcrypt_hash_context_t
 *
ctx
;

698 if ((
ctx
 = (struct 
st_ptls_bcrypt_hash_context_t
 *)
	`malloc
(sizeof(*ctx))) != 
NULL
) {

699 
ctx
->
super
 = (
ptls_hash_context_t
){
ptls_bcrypt_hash_update
, 
ptls_bcrypt_hash_final
, 
ptls_bcrypt_hash_clone
};

700 
	`memset
(&
ctx
->ctx, 0, sizeof(struct 
st_ptls_bcrypt_hash_param_t
));

701 
ctx
->ctx.
hash_size
 = hash_size;

702 
ctx
->ctx.
bcrypt_name
 = bcrypt_name;

704 
ret
 = 
	`BCryptOpenAlgorithmProvider
(&
hAlgorithm
, 
bcrypt_name
, 
NULL
, 0);

706 if (
	`BCRYPT_SUCCESS
(
ret
)) {

707 
DWORD
 
hb_length
 = 0;

708 
ULONG
 
cbResult
 = 0;

710 
ret
 = 
	`BCryptGetProperty
(
hAlgorithm
, 
BCRYPT_OBJECT_LENGTH
, (
PUCHAR
)&
hb_length
, (
ULONG
)sizeof(hb_length), &
cbResult
, 0);

712 if (
	`BCRYPT_SUCCESS
(
ret
)) {

713 
ctx
->ctx.
pbHashObject
 = (
uint8_t
 *)
	`malloc
(
hb_length
);

714 if (
ctx
->ctx.
pbHashObject
 == 
NULL
) {

715 
ret
 = 
STATUS_NO_MEMORY
;

717 
ctx
->ctx.
cbHashObject
 = 
hb_length
;

722 if (
	`BCRYPT_SUCCESS
(
ret
)) {

723 
ret
 = 
	`BCryptCreateHash
(
hAlgorithm
, &
ctx
->ctx.
hHash
, ctx->ctx.
pbHashObject
, ctx->ctx.
cbHashObject
, 
NULL
, 0, 0);

726 if (!
	`BCRYPT_SUCCESS
(
ret
)) {

727 
ctx
 = 
	`ptls_bcrypt_hash_context_free
(ctx);

731 if (
hAlgorithm
 != 
NULL
) {

732 
	`BCryptCloseAlgorithmProvider
(
hAlgorithm
, 0);

735 return (
ptls_hash_context_t
 *)
ctx
;

736 
	}
}

738 static 
ptls_hash_context_t
 *
	$ptls_bcrypt_sha256_create
(void)

740 return 
	`ptls_bcrypt_hash_create
(
BCRYPT_SHA256_ALGORITHM
, 
PTLS_SHA256_DIGEST_SIZE
);

741 
	}
}

743 static 
ptls_hash_context_t
 *
	$ptls_bcrypt_sha384_create
(void)

745 return 
	`ptls_bcrypt_hash_create
(
BCRYPT_SHA384_ALGORITHM
, 
PTLS_SHA384_DIGEST_SIZE
);

746 
	}
}

751 
ptls_cipher_algorithm_t
 
	gptls_bcrypt_aes128ecb
 = {"AES128-ECB",

752 
PTLS_AES128_KEY_SIZE
,

753 
PTLS_AES_BLOCK_SIZE
,

755 sizeof(struct 
ptls_bcrypt_symmetric_context_t
),

756 
ptls_bcrypt_cipher_setup_crypto_aes_ecb
};

757 
ptls_cipher_algorithm_t
 
	gptls_bcrypt_aes256ecb
 = {"AES256-ECB",

758 
PTLS_AES256_KEY_SIZE
,

759 
PTLS_AES_BLOCK_SIZE
,

761 sizeof(struct 
ptls_bcrypt_symmetric_context_t
),

762 
ptls_bcrypt_cipher_setup_crypto_aes_ecb
};

764 
ptls_cipher_algorithm_t
 
	gptls_bcrypt_aes128ctr
 = {"AES128-CTR",

765 
PTLS_AES128_KEY_SIZE
,

766 
PTLS_AES_BLOCK_SIZE
,

768 sizeof(struct 
ptls_bcrypt_symmetric_context_t
),

769 
ptls_bcrypt_cipher_setup_crypto_aes_ctr
};

771 
ptls_cipher_algorithm_t
 
	gptls_bcrypt_aes256ctr
 = {"AES256-CTR",

772 
PTLS_AES256_KEY_SIZE
,

773 
PTLS_AES_BLOCK_SIZE
,

775 sizeof(struct 
ptls_bcrypt_symmetric_context_t
),

776 
ptls_bcrypt_cipher_setup_crypto_aes_ctr
};

778 
ptls_aead_algorithm_t
 
	gptls_bcrypt_aes128gcm
 = {"AES128-GCM",

779 
PTLS_AESGCM_CONFIDENTIALITY_LIMIT
,

780 
PTLS_AESGCM_INTEGRITY_LIMIT
,

781 &
ptls_bcrypt_aes128ecb
,

782 &
ptls_bcrypt_aes128ctr
,

783 
PTLS_AES128_KEY_SIZE
,

784 
PTLS_AESGCM_IV_SIZE
,

785 
PTLS_AESGCM_TAG_SIZE
,

786 sizeof(struct 
ptls_bcrypt_aead_context_t
),

787 
ptls_bcrypt_aead_setup_crypto_aesgcm
};

789 
ptls_aead_algorithm_t
 
	gptls_bcrypt_aes256gcm
 = {"AES256-GCM",

790 
PTLS_AESGCM_CONFIDENTIALITY_LIMIT
,

791 
PTLS_AESGCM_INTEGRITY_LIMIT
,

792 &
ptls_bcrypt_aes256ecb
,

793 &
ptls_bcrypt_aes256ctr
,

794 
PTLS_AES256_KEY_SIZE
,

795 
PTLS_AESGCM_IV_SIZE
,

796 
PTLS_AESGCM_TAG_SIZE
,

797 sizeof(struct 
ptls_bcrypt_aead_context_t
),

798 
ptls_bcrypt_aead_setup_crypto_aesgcm
};

800 
ptls_hash_algorithm_t
 
	gptls_bcrypt_sha256
 = {
PTLS_SHA256_BLOCK_SIZE
, 
PTLS_SHA256_DIGEST_SIZE
, 
ptls_bcrypt_sha256_create
,

801 
PTLS_ZERO_DIGEST_SHA256
};

802 
ptls_hash_algorithm_t
 
	gptls_bcrypt_sha384
 = {
PTLS_SHA384_BLOCK_SIZE
, 
PTLS_SHA384_DIGEST_SIZE
, 
ptls_bcrypt_sha384_create
,

803 
PTLS_ZERO_DIGEST_SHA384
};

805 
ptls_cipher_suite_t
 
	gptls_bcrypt_aes128gcmsha256
 = {.
id
 = 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
,

806 .
	gname
 = 
PTLS_CIPHER_SUITE_NAME_AES_128_GCM_SHA256
,

807 .
	gaead
 = &
ptls_bcrypt_aes128gcm
,

808 .
	ghash
 = &
ptls_bcrypt_sha256
};

809 
ptls_cipher_suite_t
 
	gptls_bcrypt_aes256gcmsha384
 = {.
id
 = 
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
,

810 .
	gname
 = 
PTLS_CIPHER_SUITE_NAME_AES_256_GCM_SHA384
,

811 .
	gaead
 = &
ptls_bcrypt_aes256gcm
,

812 .
	ghash
 = &
ptls_bcrypt_sha384
};

814 #ifdef 
PRLS_BCRYPT_TODO


816 
ptls_key_exchange_algorithm_t
 
	gptls_bcrypt_secp256r1
 = {
PTLS_GROUP_SECP256R1
, 
x9_62_create_key_exchange
, 
secp_key_exchange
,

817 
NID_X9_62_prime256v1
};

818 #if 
ptls_bcrypt_HAVE_SECP384R1


819 
ptls_key_exchange_algorithm_t
 
	gptls_bcrypt_secp384r1
 = {
PTLS_GROUP_SECP384R1
, 
x9_62_create_key_exchange
, 
secp_key_exchange
,

820 
NID_secp384r1
};

822 #if 
ptls_bcrypt_HAVE_SECP521R1


823 
ptls_key_exchange_algorithm_t
 
	gptls_bcrypt_secp521r1
 = {
PTLS_GROUP_SECP521R1
, 
x9_62_create_key_exchange
, 
secp_key_exchange
,

824 
NID_secp521r1
};

826 #if 
ptls_bcrypt_HAVE_X25519


827 
ptls_key_exchange_algorithm_t
 
	gptls_bcrypt_x25519
 = {
PTLS_GROUP_X25519
, 
evp_keyex_create
, 
evp_keyex_exchange
, 
NID_X25519
};

830 
ptls_key_exchange_algorithm_t
 *
	gptls_bcrypt_key_exchanges
[] = {&
ptls_bcrypt_secp256r1
, 
NULL
};

	@deps/picotls/lib/uecc.c

22 #include 
	~<fcntl.h
>

23 #include 
	~<stdio.h
>

24 #include 
	~<stdlib.h
>

25 #include 
	~<string.h
>

26 #ifdef 
_WINDOWS


27 #include 
	~"wincompat.h
"

29 #include 
	~<unistd.h
>

31 #include 
	~"sha2.h
"

32 #include 
	~"uECC.h
"

33 #include 
	~"uECC_vli.h
"

34 #include 
	~"picotls.h
"

35 #include 
	~"picotls/minicrypto.h
"

37 #define 
	#TYPE_UNCOMPRESSED_PUBLIC_KEY
 4

	)

39 struct 
	sst_secp256r1_key_exhchange_t
 {

40 
ptls_key_exchange_context_t
 
	msuper
;

41 
uint8_t
 
	mpriv
[
SECP256R1_PRIVATE_KEY_SIZE
];

42 
uint8_t
 
	mpub
[
SECP256R1_PUBLIC_KEY_SIZE
];

45 static int 
	$secp256r1_on_exchange
(
ptls_key_exchange_context_t
 **
_ctx
, int 
release
, 
ptls_iovec_t
 *
secret
, ptls_iovec_t 
peerkey
)

47 struct 
st_secp256r1_key_exhchange_t
 *
ctx
 = (struct st_secp256r1_key_exhchange_t *)*
_ctx
;

48 
uint8_t
 *
secbytes
 = 
NULL
;

49 int 
ret
;

51 if (
secret
 == 
NULL
) {

52 
ret
 = 0;

53 goto 
Exit
;

56 if (
peerkey
.
len
 != 
SECP256R1_PUBLIC_KEY_SIZE
 || peerkey.
base
[0] != 
TYPE_UNCOMPRESSED_PUBLIC_KEY
) {

57 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

58 goto 
Exit
;

60 if ((
secbytes
 = (
uint8_t
 *)
	`malloc
(
SECP256R1_SHARED_SECRET_SIZE
)) == 
NULL
) {

61 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

62 goto 
Exit
;

64 if (!
	`uECC_shared_secret
(
peerkey
.
base
 + 1, 
ctx
->
priv
, 
secbytes
, 
	`uECC_secp256r1
())) {

65 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

66 goto 
Exit
;

68 *
secret
 = 
	`ptls_iovec_init
(
secbytes
, 
SECP256R1_SHARED_SECRET_SIZE
);

69 
ret
 = 0;

71 
Exit
:

72 if (
ret
 != 0)

73 
	`free
(
secbytes
);

74 if (
release
) {

75 
	`ptls_clear_memory
(
ctx
->
priv
, sizeof(ctx->priv));

76 
	`free
(
ctx
);

77 *
_ctx
 = 
NULL
;

79 return 
ret
;

80 
	}
}

82 static int 
	$secp256r1_create_key_exchange
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_key_exchange_context_t
 **
_ctx
)

84 struct 
st_secp256r1_key_exhchange_t
 *
ctx
;

86 if ((
ctx
 = (struct 
st_secp256r1_key_exhchange_t
 *)
	`malloc
(sizeof(*ctx))) == 
NULL
)

87 return 
PTLS_ERROR_NO_MEMORY
;

88 
ctx
->
super
 = (
ptls_key_exchange_context_t
){
algo
, 
	`ptls_iovec_init
(ctx->
pub
, sizeof(ctx->pub)), 
secp256r1_on_exchange
};

89 
ctx
->
pub
[0] = 
TYPE_UNCOMPRESSED_PUBLIC_KEY
;

90 
	`uECC_make_key
(
ctx
->
pub
 + 1, ctx->
priv
, 
	`uECC_secp256r1
());

92 *
_ctx
 = &
ctx
->
super
;

94 
	}
}

96 static int 
	$secp256r1_key_exchange
(
ptls_key_exchange_algorithm_t
 *
algo
, 
ptls_iovec_t
 *
pubkey
, ptls_iovec_t *
secret
,

97 
ptls_iovec_t
 
peerkey
)

99 
uint8_t
 
priv
[
SECP256R1_PRIVATE_KEY_SIZE
], *
pub
 = 
NULL
, *
secbytes
 = NULL;

100 int 
ret
;

102 if (
peerkey
.
len
 != 
SECP256R1_PUBLIC_KEY_SIZE
 || peerkey.
base
[0] != 
TYPE_UNCOMPRESSED_PUBLIC_KEY
) {

103 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

104 goto 
Exit
;

106 if ((
pub
 = 
	`malloc
(
SECP256R1_PUBLIC_KEY_SIZE
)) == 
NULL
) {

107 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

108 goto 
Exit
;

110 if ((
secbytes
 = 
	`malloc
(
SECP256R1_SHARED_SECRET_SIZE
)) == 
NULL
) {

111 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

112 goto 
Exit
;

115 
pub
[0] = 
TYPE_UNCOMPRESSED_PUBLIC_KEY
;

116 
	`uECC_make_key
(
pub
 + 1, 
priv
, 
	`uECC_secp256r1
());

117 if (!
	`uECC_shared_secret
(
peerkey
.
base
 + 1, 
priv
, 
secbytes
, 
	`uECC_secp256r1
())) {

118 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

119 goto 
Exit
;

121 *
pubkey
 = 
	`ptls_iovec_init
(
pub
, 
SECP256R1_PUBLIC_KEY_SIZE
);

122 *
secret
 = 
	`ptls_iovec_init
(
secbytes
, 
SECP256R1_SHARED_SECRET_SIZE
);

123 
ret
 = 0;

125 
Exit
:

126 
	`ptls_clear_memory
(
priv
, sizeof(priv));

127 if (
ret
 != 0) {

128 
	`free
(
secbytes
);

129 
	`free
(
pub
);

131 return 
ret
;

132 
	}
}

134 static int 
	$secp256r1sha256_sign
(
ptls_sign_certificate_t
 *
_self
, 
ptls_t
 *
tls
, 
uint16_t
 *
selected_algorithm
, 
ptls_buffer_t
 *
outbuf
,

135 
ptls_iovec_t
 
input
, const 
uint16_t
 *
algorithms
, 
size_t
 
num_algorithms
)

137 
ptls_minicrypto_secp256r1sha256_sign_certificate_t
 *
self
 = (ptls_minicrypto_secp256r1sha256_sign_certificate_t *)
_self
;

138 
uint8_t
 
hash
[32], 
sig
[64];

139 
size_t
 
i
;

140 int 
ret
;

143 for (
i
 = 0; i != 
num_algorithms
; ++i)

144 if (
algorithms
[
i
] == 
PTLS_SIGNATURE_ECDSA_SECP256R1_SHA256
)

146 if (
i
 == 
num_algorithms
)

147 return 
PTLS_ALERT_HANDSHAKE_FAILURE
;

150 
cf_sha256_context
 
ctx
;

151 
	`cf_sha256_init
(&
ctx
);

152 
	`cf_sha256_update
(&
ctx
, 
input
.
base
, input.
len
);

153 
	`cf_sha256_digest_final
(&
ctx
, 
hash
);

154 
	`ptls_clear_memory
(&
ctx
, sizeof(ctx));

158 
	`uECC_sign
(
self
->
key
, 
hash
, sizeof(hash), 
sig
, 
	`uECC_secp256r1
());

161 
	`ptls_buffer_push_asn1_sequence
(
outbuf
, {

162 if ((
ret
 = 
	`ptls_buffer_push_asn1_ubigint
(
outbuf
, 
sig
, 32)) != 0)

163 goto 
Exit
;

164 if ((
ret
 = 
	`ptls_buffer_push_asn1_ubigint
(
outbuf
, 
sig
 + 32, 32)) != 0)

165 goto 
Exit
;

168 *
selected_algorithm
 = 
PTLS_SIGNATURE_ECDSA_SECP256R1_SHA256
;

169 
ret
 = 0;

171 
Exit
:

172 
	`ptls_clear_memory
(
hash
, sizeof(hash));

173 
	`ptls_clear_memory
(
sig
, sizeof(sig));

174 return 
ret
;

175 
	}
}

177 int 
	$ptls_minicrypto_init_secp256r1sha256_sign_certificate
(
ptls_minicrypto_secp256r1sha256_sign_certificate_t
 *
self
,

178 
ptls_iovec_t
 
key
)

180 if (
key
.
len
 != sizeof(
self
->key))

181 return 
PTLS_ERROR_INCOMPATIBLE_KEY
;

183 
self
->
super
.
cb
 = 
secp256r1sha256_sign
;

184 
	`memcpy
(
self
->
key
, key.
base
, sizeof(self->key));

187 
	}
}

189 
ptls_key_exchange_algorithm_t
 
	gptls_minicrypto_secp256r1
 = {.
id
 = 
PTLS_GROUP_SECP256R1
,

190 .
	gname
 = 
PTLS_GROUP_NAME_SECP256R1
,

191 .
	gcreate
 = 
secp256r1_create_key_exchange
,

192 .
	gexchange
 = 
secp256r1_key_exchange
};

193 
ptls_key_exchange_algorithm_t
 *
	gptls_minicrypto_key_exchanges
[] = {&
ptls_minicrypto_secp256r1
, 
NULL
};

	@deps/picotls/picotlsvs/bcrypt-test/bcrypt-test.c

3 #include 
	~<wincompat.h
>

4 #include 
	~<bcrypt.h
>

5 #include 
	~<stdio.h
>

6 #include 
	~"picotls/ptlsbcrypt.h
"

7 #include 
	~"picotls/minicrypto.h
"

9 int 
	$KeyInit
(
BCRYPT_KEY_HANDLE
 *
hKey
, 
wchar_t
 *
name
, wchar_t *
chain_mode
, 
size_t
 
chain_mode_sz
, const 
BYTE
 *
proposedKey
,

10 
DWORD
 
proposedKeyLength
, 
BYTE
 **
ko
, 
ULONG
 *
ko_length
)

12 
DWORD
 
cbData
 = 0;

13 
HANDLE
 
hAlgo
 = 
NULL
;

16 
NTSTATUS
 
ret
 = 
	`BCryptOpenAlgorithmProvider
(&
hAlgo
, 
name
, 
NULL
, 0);

18 if (
	`BCRYPT_SUCCESS
(
ret
)) {

20 
ret
 = 
	`BCryptSetProperty
(
hAlgo
, 
BCRYPT_CHAINING_MODE
, (
PBYTE
)
chain_mode
, (
ULONG
)
chain_mode_sz
, 0);

23 *
ko
 = 
NULL
;

24 *
ko_length
 = 0;

26 if (
	`BCRYPT_SUCCESS
(
ret
)) {

27 
DWORD
 
ko_size
 = 0;

28 
ULONG
 
cbResult
 = 0;

30 
ret
 = 
	`BCryptGetProperty
(
hAlgo
, 
BCRYPT_OBJECT_LENGTH
, (
PUCHAR
)&
ko_size
, (
ULONG
)sizeof(ko_size), &
cbResult
, 0);

32 if (
	`BCRYPT_SUCCESS
(
ret
)) {

33 *
ko
 = (
uint8_t
 *)
	`malloc
(
ko_size
);

34 if (*
ko
 == 
NULL
) {

35 
ret
 = 
STATUS_NO_MEMORY
;

37 *
ko_length
 = 
ko_size
;

38 
	`memset
(*
ko
, 0, *
ko_length
);

43 if (
	`BCRYPT_SUCCESS
(
ret
)) {

45 
ret
 = 
	`BCryptGenerateSymmetricKey
(
hAlgo
, 
hKey
, *
ko
, *
ko_length
, (
PBYTE
)
proposedKey
, 
proposedKeyLength
, 0);

47 if (*
ko
 != 
NULL
) {

48 
	`free
(*
ko
);

49 *
ko
 = 
NULL
;

50 *
ko_length
 = 0;

54 if (
hAlgo
 != 
NULL
) {

55 
	`BCryptCloseAlgorithmProvider
(
hAlgo
, 0);

58 return 
	`BCRYPT_SUCCESS
(
ret
) ? 0 : -1;

59 
	}
}

61 void 
	$KeyRelease
(
BCRYPT_KEY_HANDLE
 *
hKey
, 
BYTE
 **
ko
, 
ULONG
 *
ko_length
)

63 
	`BCryptDestroyKey
(*
hKey
);

64 *
hKey
 = 
NULL
;

65 if (*
ko
) {

66 
	`free
(*
ko
);

68 *
ko
 = 
NULL
;

69 *
ko_length
 = 0;

70 
	}
}

72 int 
	$EncodeOneShot
(
ptls_aead_algorithm_t
 *
aead
, 
wchar_t
 *
name
, wchar_t *
chain_mode
, 
size_t
 
chain_mode_sz
, 
BYTE
 *
key
,

73 
ULONG
 
key_length
,

74 
BYTE
* 
iv
, 
ULONG
 
iv_length
,

75 
BYTE
 *
data
, 
ULONG
 
dataLength
, 
uint64_t
 
seq
, BYTE *
authData
, ULONG 
authDataLength
, ULONG 
authTagLength
,

76 
BYTE
 *
encrypted
, 
ULONG
 
encryptedLengthMax
, ULONG *
encryptedLength
)

79 
BCRYPT_KEY_HANDLE
 
hKey
 = 
NULL
;

80 
BYTE
 *
authTag
 = 
encrypted
 + 
dataLength
;

81 
BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
 
bacmi
;

82 
BYTE
 
iv_nonce
[
PTLS_MAX_IV_SIZE
];

83 
BYTE
 *
ko
 = 
NULL
;

84 
ULONG
 
ko_length
 = 0;

85 int 
ret
 = 0;

87 *
encryptedLength
 = 0;

89 if (
	`KeyInit
(&
hKey
, 
name
, 
chain_mode
, 
chain_mode_sz
, 
key
, 
key_length
, &
ko
, &
ko_length
) != 0) {

93 
	`memset
(
authTag
, 0, 
authTagLength
);

95 
	`BCRYPT_INIT_AUTH_MODE_INFO
(
bacmi
);

96 
	`ptls_aead__build_iv
(
aead
, 
iv_nonce
, 
iv
, 
seq
);

97 
bacmi
.
pbNonce
 = 
iv_nonce
;

98 
bacmi
.
cbNonce
 = 
iv_length
;

99 
bacmi
.
pbAuthData
 = 
authData
;

100 
bacmi
.
cbAuthData
 = 
authDataLength
;

101 
bacmi
.
pbTag
 = 
authTag
;

102 
bacmi
.
cbTag
 = 
authTagLength
;

106 
DWORD
 
cbCipherText
 = 0;

107 
NTSTATUS
 
status
 = 
	`BCryptEncrypt
(
hKey
, 
data
, 
dataLength
, &
bacmi
, 
NULL
, 0, 
encrypted
, 
encryptedLengthMax
, &
cbCipherText
, 0);

109 
	`KeyRelease
(&
hKey
, &
ko
, &
ko_length
);

111 if (
	`BCRYPT_SUCCESS
(
status
)) {

112 *
encryptedLength
 = 
cbCipherText
 + 
authTagLength
;

114 
ret
 = -1;

117 return 
ret
;

118 
	}
}

120 int 
	$DecodeOneShot
(
ptls_aead_algorithm_t
 *
aead
, 
wchar_t
 *
name
, wchar_t *
chain_mode
, 
size_t
 
chain_mode_sz
,

121 
BYTE
 *
key
, 
ULONG
 
key_length
, BYTE * 
iv
, ULONG 
iv_length
, BYTE *
encrypted
,

122 
ULONG
 
encryptedLength
, 
uint64_t
 
seq
, 
BYTE
 *
authData
, ULONG 
authDataLength
,

123 
ULONG
 
authTagLength
, 
BYTE
 *
decrypted
, ULONG 
decryptedLengthMax
, ULONG *
decryptedLength
)

126 
BCRYPT_KEY_HANDLE
 
hKey
 = 
NULL
;

127 
BYTE
 *
authTag
 = 
encrypted
 + (
encryptedLength
 - 
authTagLength
);

128 
BYTE
 
iv_nonce
[
PTLS_MAX_IV_SIZE
];

129 
BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
 
bacmi
;

130 
BYTE
 *
ko
 = 
NULL
;

131 
ULONG
 
ko_length
 = 0;

132 int 
ret
 = 0;

134 *
decryptedLength
 = 0;

136 if (
	`KeyInit
(&
hKey
, 
name
, 
chain_mode
, 
chain_mode_sz
, 
key
, 
key_length
, &
ko
, &
ko_length
) != 0) {

141 
	`BCRYPT_INIT_AUTH_MODE_INFO
(
bacmi
);

142 
	`ptls_aead__build_iv
(
aead
, 
iv_nonce
, 
iv
, 
seq
);

143 
bacmi
.
pbNonce
 = 
iv_nonce
;

144 
bacmi
.
cbNonce
 = 
iv_length
;

145 
bacmi
.
pbAuthData
 = 
authData
;

146 
bacmi
.
cbAuthData
 = 
authDataLength
;

147 
bacmi
.
pbTag
 = 
authTag
;

148 
bacmi
.
cbTag
 = 
authTagLength
;

152 
DWORD
 
cbCipherText
 = 0;

153 
NTSTATUS
 
status
 = 
	`BCryptDecrypt
(
hKey
, 
encrypted
, 
encryptedLength
 - 
authTagLength
, &
bacmi
, 
NULL
, 0, 
decrypted
,

154 
decryptedLengthMax
, &
cbCipherText
, 0);

156 
	`KeyRelease
(&
hKey
, &
ko
, &
ko_length
);

158 if (
	`BCRYPT_SUCCESS
(
status
)) {

159 *
decryptedLength
 = 
cbCipherText
;

161 
ret
 = -1;

164 return 
ret
;

165 
	}
}

167 int 
	$test_oneshot
(
ptls_aead_algorithm_t
 *
aead
, 
wchar_t
 *
name
, wchar_t *
chain_mode
, 
size_t
 
chain_mode_sz
)

169 
BYTE
 
key
[32];

170 
BYTE
 
data
[123];

171 
BYTE
 
iv
[
PTLS_MAX_IV_SIZE
];

172 
uint64_t
 
nonce
;

173 
BYTE
 
authData
[9];

174 
BYTE
 
encrypted
[256];

175 
ULONG
 
encryptedLength
;

176 
BYTE
 
decrypted
[256];

177 
ULONG
 
decryptedLength
;

178 
ULONG
 
authTagLength
 = (ULONG)
aead
->
tag_size
;

179 int 
ret
 = 0;

181 
	`assert
(sizeof(
key
) >= 
aead
->
key_size
);

182 
	`assert
(sizeof(
iv
) >= 
aead
->
iv_size
);

183 
	`assert
(sizeof(
data
) + 
authTagLength
 <= sizeof(
encrypted
));

184 
	`assert
(sizeof(
decrypted
) >= sizeof(
encrypted
));

186 
	`memset
(
key
, 'k', sizeof(key));

187 
	`memset
(
data
, 'd', sizeof(data));

188 
	`memset
(
iv
, 'n', sizeof(iv));

189 
nonce
 = 0;

190 
	`memset
(
authData
, 'a', sizeof(authData));

192 
ret
 = 
	`EncodeOneShot
(
aead
, 
name
, 
chain_mode
, 
chain_mode_sz
, 
key
, (
ULONG
)aead->
key_size
, 
iv
, (ULONG)aead->
iv_size
, 
data
,

193 123, 
nonce
, 
authData
, 9, 
authTagLength
, 
encrypted
, 256, &
encryptedLength
);

195 
	`printf
("Encrypt one shot returns %d, l=%d\n", 
ret
, 
encryptedLength
);

197 if (
ret
 == 0) {

198 
ret
 = 
	`DecodeOneShot
(
aead
, 
name
, 
chain_mode
, 
chain_mode_sz
, 
key
, (
ULONG
)aead->
key_size
,

199 
iv
, (
ULONG
)
aead
->
iv_size
, 
encrypted
, 
encryptedLength
, 
nonce
, 
authData
, 9,

200 
authTagLength
, 
decrypted
, 256, &
decryptedLength
);

202 
	`printf
("Decrypt one shot returns %d, l=%d\n", 
ret
, 
decryptedLength
);

204 if (
ret
 == 0) {

205 if (
decryptedLength
 != 123) {

206 
	`printf
("Wrong length, not %d\n", 123);

207 
ret
 = -1;

208 } else if (
	`memcmp
(
data
, 
decrypted
, 123) != 0) {

209 
	`printf
("Data and decrypted don't match\n");

210 
ret
 = -1;

212 
	`printf
("One shot matches.\n");

217 return 
ret
;

218 
	}
}

220 void 
	$delete_test_aead_context
(
ptls_aead_context_t
 *
ctx
)

222 if (
ctx
 != 
NULL
) {

223 
ctx
->
	`dispose_crypto
(ctx);

224 
	`free
(
ctx
);

226 
	}
}

228 
ptls_aead_context_t
 *
	$new_test_aead_context
(
ptls_aead_algorithm_t
 *
aead
, int 
is_enc
, 
BYTE
 *
key
, BYTE *
iv
)

230 int 
ret
 = 0;

231 
ptls_aead_context_t
 *
ctx
 = (ptls_aead_context_t *)
	`malloc
(
aead
->
context_size
);

233 if (
ctx
 != 
NULL
) {

234 
	`memset
(
ctx
, 0, 
aead
->
context_size
);

235 *
ctx
 = (
ptls_aead_context_t
){
aead
};

236 if (
aead
->
	`setup_crypto
(
ctx
, 
is_enc
, 
key
, 
iv
) != 0) {

237 
	`printf
("For %s, setup returns %d\n", 
aead
->
name
, 
ret
);

238 
	`delete_test_aead_context
(
ctx
);

239 
ctx
 = 
NULL
;

242 
	`printf
("For %s, memory error during setup\n", 
aead
->
name
);

245 return (
ctx
);

246 
	}
}

248 int 
	$test_decrypt
(
ptls_aead_algorithm_t
 *
aead
, 
wchar_t
 *
name
, wchar_t *
chain_mode
, 
size_t
 
chain_mode_sz
)

250 
BYTE
 
key
[32];

251 
BYTE
 
iv
[
PTLS_MAX_IV_SIZE
];

252 
BYTE
 
data
[123];

253 
uint64_t
 
nonce
;

254 
BYTE
 
authData
[9];

255 
BYTE
 
encrypted
[256];

256 
ULONG
 
encryptedLength
;

257 
BYTE
 
decrypted
[256];

258 
size_t
 
decryptedLength
;

259 
ULONG
 
authTagLength
 = (ULONG)
aead
->
tag_size
;

260 
ptls_aead_context_t
 *
ctx
 = 
NULL
;

261 int 
ret
 = 0;

263 
	`assert
(sizeof(
key
) >= 
aead
->
key_size
);

264 
	`assert
(sizeof(
iv
) >= 
aead
->
iv_size
);

265 
	`assert
(sizeof(
data
) + 
authTagLength
 <= sizeof(
encrypted
));

266 
	`assert
(sizeof(
decrypted
) >= sizeof(
encrypted
));

268 
	`memset
(
key
, 'k', sizeof(key));

269 
	`memset
(
iv
, 'n', sizeof(iv));

270 
	`memset
(
data
, 'd', sizeof(data));

271 
nonce
 = 0;

272 
	`memset
(
authData
, 'a', sizeof(authData));

275 
ctx
 = 
	`new_test_aead_context
(
aead
, 0, 
key
, 
iv
);

276 if (
ctx
 == 
NULL
) {

277 
ret
 = -1;

281 if (
ret
 == 0) {

282 
ret
 = 
	`EncodeOneShot
(
aead
, 
name
, 
chain_mode
, 
chain_mode_sz
, 
key
, (
ULONG
)aead->
key_size
,

283 
iv
, (
ULONG
)
aead
->
iv_size
, 
data
, 123, 
nonce
,

284 
authData
, 9, 
authTagLength
, 
encrypted
, 256, &
encryptedLength
);

288 if (
ret
 == 0) {

289 
decryptedLength
 = 
ctx
->
	`do_decrypt
(ctx, 
decrypted
, 
encrypted
, 
encryptedLength
, 
nonce
, 
authData
, 9);

290 if (
decryptedLength
 >= 
encryptedLength
) {

291 
	`printf
("For %s, decrypt returns %d\n", 
aead
->
name
, (int)
decryptedLength
);

292 
ret
 = -1;

293 } else if (
decryptedLength
 != 123) {

294 
	`printf
("For %s, decrypt returns %d instead of %d\n", 
aead
->
name
, (int)
decryptedLength
, 123);

295 
ret
 = -1;

296 } else if (
	`memcmp
(
data
, 
decrypted
, 
decryptedLength
) != 0) {

297 
	`printf
("For %s, decrypted does not match clear text\n", 
aead
->
name
);

298 
ret
 = -1;

300 
	`printf
("For %s, decrypting test passes.\n", 
aead
->
name
);

304 
	`delete_test_aead_context
(
ctx
);

306 return 
ret
;

307 
	}
}

309 int 
	$test_encrypt
(
ptls_aead_algorithm_t
 *
aead
, 
wchar_t
 *
name
, wchar_t *
chain_mode
, 
size_t
 
chain_mode_sz
)

311 
BYTE
 
key
[32];

312 
BYTE
 
iv
[
PTLS_MAX_IV_SIZE
];

313 
BYTE
 
data
[123];

314 
uint64_t
 
nonce
;

315 
BYTE
 
authData
[9];

316 
BYTE
 
encryptedRef
[256];

317 
ULONG
 
encryptedRefLength
;

318 
BYTE
 
encrypted
[256];

319 
size_t
 
encryptedLength
;

320 
ULONG
 
authTagLength
 = (ULONG)
aead
->
tag_size
;

321 
ptls_aead_context_t
 *
ctx
 = 
NULL
;

322 int 
ret
 = 0;

324 
	`assert
(sizeof(
key
) >= 
aead
->
key_size
);

325 
	`assert
(sizeof(
iv
) >= 
aead
->
iv_size
);

326 
	`assert
(sizeof(
data
) + 
authTagLength
 <= sizeof(
encrypted
));

327 
	`assert
(sizeof(
data
) + 
authTagLength
 <= sizeof(
encryptedRef
));

329 
	`memset
(
key
, 'k', sizeof(key));

330 
	`memset
(
iv
, 'n', sizeof(iv));

331 
	`memset
(
data
, 'd', sizeof(data));

332 
nonce
 = 0;

333 
	`memset
(
authData
, 'a', sizeof(authData));

336 
ctx
 = 
	`new_test_aead_context
(
aead
, 1, 
key
, 
iv
);

337 if (
ctx
 == 
NULL
) {

338 
ret
 = -1;

342 if (
ret
 == 0) {

343 
ret
 = 
	`EncodeOneShot
(
aead
, 
name
, 
chain_mode
, 
chain_mode_sz
, 
key
, (
ULONG
)aead->
key_size
,

344 
iv
, (
ULONG
)
aead
->
iv_size
, 
data
, 123, 
nonce
,

345 
authData
, 9, 
authTagLength
, 
encryptedRef
, 256, &
encryptedRefLength
);

349 if (
ret
 == 0) {

350 
ctx
->
	`do_encrypt_init
(ctx, 
nonce
, 
authData
, 9);

351 
encryptedLength
 = 
ctx
->
	`do_encrypt_update
(ctx, 
encrypted
, 
data
, 123);

352 
encryptedLength
 += 
ctx
->
	`do_encrypt_final
(ctx, &
encrypted
[encryptedLength]);

354 if (
encryptedLength
 != 
encryptedRefLength
) {

355 
	`printf
("For %s, encrypt returns %d instead of %d\n", 
aead
->
name
, (int)
encryptedLength
, 
encryptedRefLength
);

356 
ret
 = -1;

357 } else if (
	`memcmp
(
encryptedRef
, 
encrypted
, 
encryptedRefLength
) != 0) {

358 
	`printf
("For %s, encrypted does not match ref\n", 
aead
->
name
);

359 for (
ULONG
 
i
 = 0; i < 
encryptedRefLength
; i++) {

360 if (
encryptedRef
[
i
] != 
encrypted
[i]) {

361 
	`printf
("For %s, encrypted[%d] = 0x%02x vs encryptedRef[%d] = 0x%02x\n", 
aead
->
name
, 
i
, 
encrypted
[i], i,

362 
encryptedRef
[
i
]);

366 
ret
 = -1;

368 
	`printf
("For %s, encrypting test passes.\n", 
aead
->
name
);

372 
	`delete_test_aead_context
(
ctx
);

374 return 
ret
;

375 
	}
}

377 int 
	$test_for_size
(
ptls_aead_algorithm_t
 *
aead
, 
wchar_t
 *
name
, wchar_t *
chain_mode
, 
size_t
 
chain_mode_sz
)

379 
BYTE
 
key
[32];

380 
BYTE
 
iv
[
PTLS_MAX_IV_SIZE
];

381 
uint64_t
 
nonce
;

382 
BYTE
 
authData
[9];

383 
BYTE
 *
data
 = 
NULL
;

384 
BYTE
 *
encrypted
 = 
NULL
;

385 
BYTE
 *
decrypted
 = 
NULL
;

386 
size_t
 
encryptedLength
;

387 
size_t
 
decryptedLength
;

388 
ULONG
 
authTagLength
 = (ULONG)
aead
->
tag_size
;

389 
ptls_aead_context_t
 *
ctx_e
 = 
NULL
;

390 
ptls_aead_context_t
 *
ctx_d
 = 
NULL
;

391 
ULONG
 
packet_size
[] = {1500, 128, 3, 0};

392 
ULONG
 
nb_packet_size
 = (ULONG)(sizeof(
packet_size
) / sizeof(ULONG));

393 int 
ret
 = 0;

395 
	`assert
(sizeof(
key
) >= 
aead
->
key_size
);

396 
	`assert
(sizeof(
iv
) >= 
aead
->
iv_size
);

398 
	`memset
(
key
, 'k', sizeof(key));

399 
	`memset
(
key
, 'n', sizeof(
iv
));

400 
nonce
 = 0;

401 
	`memset
(
authData
, 'a', sizeof(authData));

404 
ctx_e
 = 
	`new_test_aead_context
(
aead
, 1, 
key
, 
iv
);

405 
ctx_d
 = 
	`new_test_aead_context
(
aead
, 0, 
key
, 
iv
);

407 if (
ctx_e
 == 
NULL
 || 
ctx_d
 == NULL) {

408 
ret
 = -1;

412 for (
ULONG
 
i
 = 0; 
ret
 == 0 && i < 
nb_packet_size
; i++) {

413 
ULONG
 
data_size
 = (
packet_size
[
i
] > 0) ? packet_size[i] : 128;

414 
ULONG
 
encrypted_size
 = 
packet_size
[
i
] + 
authTagLength
;

416 
data
 = (
BYTE
 *)
	`malloc
(
data_size
);

417 
encrypted
 = (
BYTE
 *)
	`malloc
(
encrypted_size
);

418 
decrypted
 = (
BYTE
 *)
	`malloc
(
data_size
);

420 if (
data
 == 
NULL
 || 
encrypted
 == NULL || 
decrypted
 == NULL) {

421 
	`printf
("For %s: cannot allocate memory for packet size[%d] = %d\n", 
aead
->
name
, 
i
, 
packet_size
[i]);

423 
	`memset
(
data
, 'd', 
data_size
);

425 
ctx_e
->
	`do_encrypt_init
(ctx_e, 
nonce
, 
authData
, 9);

426 
encryptedLength
 = 
ctx_e
->
	`do_encrypt_update
(ctx_e, 
encrypted
, 
data
, 
packet_size
[
i
]);

427 
encryptedLength
 += 
ctx_e
->
	`do_encrypt_final
(ctx_e, &
encrypted
[encryptedLength]);

428 
decryptedLength
 = 
ctx_d
->
	`do_decrypt
(ctx_d, 
decrypted
, 
encrypted
, 
encryptedLength
, 
nonce
, 
authData
, 9);

430 if (
decryptedLength
 >= 
encryptedLength
) {

431 
	`printf
("For %s, decrypt returns %d\n", 
aead
->
name
, (int)
decryptedLength
);

432 
ret
 = -1;

433 } else if (
decryptedLength
 != 
packet_size
[
i
]) {

434 
	`printf
("For %s, decrypt returns %d instead of %d\n", 
aead
->
name
, (int)
decryptedLength
, 
packet_size
[
i
]);

435 
ret
 = -1;

436 } else if (
	`memcmp
(
data
, 
decrypted
, 
decryptedLength
) != 0) {

437 
	`printf
("For %s, decrypted does not match clear text\n", 
aead
->
name
);

438 
ret
 = -1;

440 
	`printf
("For %s, test packet size[%d] = %d passes.\n", 
aead
->
name
, 
i
, 
packet_size
[i]);

444 if (
data
 != 
NULL
) {

445 
	`free
(
data
);

446 
data
 = 
NULL
;

449 if (
encrypted
 != 
NULL
) {

450 
	`free
(
encrypted
);

451 
encrypted
 = 
NULL
;

454 if (
decrypted
 != 
NULL
) {

455 
	`free
(
decrypted
);

456 
decrypted
 = 
NULL
;

460 
	`delete_test_aead_context
(
ctx_e
);

461 
	`delete_test_aead_context
(
ctx_d
);

463 return 
ret
;

464 
	}
}

466 int 
	$test_one_aead
(
ptls_aead_algorithm_t
 *
aead
, 
wchar_t
 *
name
, wchar_t *
chain_mode
, 
size_t
 
chain_mode_sz
)

468 int 
ret
 = 
	`test_oneshot
(
aead
, 
name
, 
chain_mode
, 
chain_mode_sz
);

470 
	`printf
("For %s, test one shot returns %d\n", 
aead
->
name
, 
ret
);

472 if (
ret
 == 0) {

473 
ret
 = 
	`test_decrypt
(
aead
, 
name
, 
chain_mode
, 
chain_mode_sz
);

475 
	`printf
("For %s, test decrypt returns %d\n", 
aead
->
name
, 
ret
);

478 if (
ret
 == 0) {

479 
ret
 = 
	`test_encrypt
(
aead
, 
name
, 
chain_mode
, 
chain_mode_sz
);

481 
	`printf
("For %s, test encrypt returns %d\n", 
aead
->
name
, 
ret
);

484 if (
ret
 == 0) {

485 
ret
 = 
	`test_for_size
(
aead
, 
name
, 
chain_mode
, 
chain_mode_sz
);

487 
	`printf
("For %s, test packet sizes returns %d\n", 
aead
->
name
, 
ret
);

490 return 
ret
;

491 
	}
}

498 int 
	$test_cipher_one_way
(char const *
name1
, char const *
name2
, 
ptls_cipher_algorithm_t
 *
b1
, ptls_cipher_algorithm_t *
b2
,

499 unsigned int 
nb_blocks
)

501 
BYTE
 
key
[32];

502 
BYTE
 
nonce
[16];

503 
BYTE
 
data
[128];

504 
BYTE
 
encrypted
[128];

505 
BYTE
 
decrypted
[128];

506 
size_t
 
data_size
 = 
b1
->
block_size
 * 
nb_blocks
;

507 
ptls_cipher_context_t
 *
ctx1
 = 
NULL
;

508 
ptls_cipher_context_t
 *
ctx2
 = 
NULL
;

509 int 
ret
 = 0;

511 
	`assert
(sizeof(
key
) >= 
b1
->
key_size
);

512 
	`assert
(sizeof(
data
) >= 
data_size
);

513 
	`assert
(sizeof(
nonce
) >= 
b1
->
iv_size
);

515 
	`memset
(
key
, 'k', sizeof(key));

516 
	`memset
(
data
, 'd', 
data_size
);

518 
ctx1
 = 
	`ptls_cipher_new
(
b1
, 1, 
key
);

519 
ctx2
 = 
	`ptls_cipher_new
(
b2
, 0, 
key
);

521 if (
ctx1
 == 
NULL
 || 
ctx2
 == NULL) {

522 
ret
 = -1;

524 
	`memset
(
nonce
, 0, sizeof(nonce));

525 if (
ctx1
->
do_init
 != 
NULL
) {

526 
ctx1
->
	`do_init
(ctx1, 
nonce
);

529 if (
ctx2
->
do_init
 != 
NULL
) {

530 
ctx2
->
	`do_init
(ctx2, 
nonce
);

533 
ctx1
->
	`do_transform
(ctx1, 
encrypted
, 
data
, 
data_size
);

534 
ctx2
->
	`do_transform
(ctx2, 
decrypted
, 
encrypted
, 
data_size
);

536 if (
	`memcmp
(
data
, 
decrypted
, 
data_size
) != 0) {

537 
	`printf
("For %s -> %s, decrypted does not match clear text\n", 
name1
, 
name2
);

538 
ret
 = -1;

540 
	`printf
("For %s -> %s, test passes.\n", 
name1
, 
name2
);

544 if (
ctx1
 != 
NULL
) {

545 
	`ptls_cipher_free
(
ctx1
);

548 if (
ctx2
 != 
NULL
) {

549 
	`ptls_cipher_free
(
ctx2
);

552 return 
ret
;

553 
	}
}

555 int 
	$test_cipher_pair
(char const *
name1
, char const *
name2
, 
ptls_cipher_algorithm_t
 *
b1
, ptls_cipher_algorithm_t *
b2
,

556 unsigned int 
nb_blocks
)

558 int 
ret
 = 
	`test_cipher_one_way
(
name1
, 
name2
, 
b1
, 
b2
, 
nb_blocks
);

560 if (
ret
 == 0) {

561 
ret
 = 
	`test_cipher_one_way
(
name2
, 
name1
, 
b2
, 
b1
, 
nb_blocks
);

564 return 
ret
;

565 
	}
}

570 int 
	$test_hash_calc
(char const *
name1
, char const *
name2
, 
ptls_hash_algorithm_t
 *
h1
, ptls_hash_algorithm_t *
h2
)

572 
BYTE
 
data
[123];

573 
BYTE
 
tag1
[128];

574 
BYTE
 
tag2
[128];

575 
ptls_hash_context_t
 *
ctx1
 = 
NULL
;

576 
ptls_hash_context_t
 *
ctx2
 = 
NULL
;

577 int 
ret
 = 0;

579 
	`assert
(sizeof(
tag1
) >= 
h1
->
digest_size
);

580 
	`assert
(sizeof(
tag2
) >= 
h2
->
digest_size
);

581 
	`assert
(
h1
->
digest_size
 == 
h2
->digest_size);

583 
	`memset
(
data
, 'd', sizeof(data));

584 
	`memset
(
tag1
, '1', sizeof(tag1));

585 
	`memset
(
tag2
, '2', sizeof(tag2));

587 if (
h1
->
digest_size
 != 
h2
->digest_size) {

588 
ret
 = -1;

590 if (
ret
 == 0) {

591 
ret
 = 
	`ptls_calc_hash
(
h1
, 
tag1
, 
data
, sizeof(data));

594 if (
ret
 == 0) {

595 
ret
 = 
	`ptls_calc_hash
(
h2
, 
tag2
, 
data
, sizeof(data));

598 if (
ret
 == 0){

599 if (
	`memcmp
(
tag1
, 
tag2
, 
h1
->
digest_size
) != 0) {

600 
	`printf
("For %s -> %s, hash1 does not match hash2\n", 
name1
, 
name2
);

601 
ret
 = -1;

603 
	`printf
("For %s -> %s, hash test passes.\n", 
name1
, 
name2
);

607 return 
ret
;

608 
	}
}

614 int 
	$main
()

616 int 
ret
 = 0;

618 
ret
 |= 
	`test_cipher_pair
("bcrypt aes128ecb", "minicrypto aes128ecb", &
ptls_bcrypt_aes128ecb
, &
ptls_minicrypto_aes128ecb
, 1);

619 
ret
 |= 
	`test_cipher_pair
("bcrypt aes256ecb", "minicrypto aes256ecb", &
ptls_bcrypt_aes256ecb
, &
ptls_minicrypto_aes256ecb
, 1);

621 
ret
 |= 
	`test_cipher_pair
("bcrypt aes128ctr", "minicrypto aes128ctr", &
ptls_bcrypt_aes128ctr
, &
ptls_minicrypto_aes128ctr
, 4);

622 
ret
 |= 
	`test_cipher_pair
("bcrypt aes256ctr", "minicrypto aes256ctr", &
ptls_bcrypt_aes256ctr
, &
ptls_minicrypto_aes256ctr
, 4);

624 
ret
 |= 
	`test_one_aead
(&
ptls_bcrypt_aes128gcm
, 
BCRYPT_AES_ALGORITHM
, 
BCRYPT_CHAIN_MODE_GCM
, sizeof(BCRYPT_CHAIN_MODE_GCM));

626 
ret
 |= 
	`test_one_aead
(&
ptls_bcrypt_aes256gcm
, 
BCRYPT_AES_ALGORITHM
, 
BCRYPT_CHAIN_MODE_GCM
, sizeof(BCRYPT_CHAIN_MODE_GCM));

628 
ret
 |= 
	`test_hash_calc
("bcrypt sha256", "minicrypto sha256", &
ptls_bcrypt_sha256
, &
ptls_minicrypto_sha256
);

629 
ret
 |= 
	`test_hash_calc
("bcrypt sha384", "minicrypto sha384", &
ptls_bcrypt_sha384
, &
ptls_minicrypto_sha384
);

631 
	`exit
(
ret
);

632 
	}
}

	@deps/picotls/picotlsvs/picotls-core/targetver.h

1 #pragma 
once


8 #include 
	~<SDKDDKVer.h
>

	@deps/picotls/picotlsvs/picotls-esni/getopt.c

1 #include 
	~"getopt.h
"

36 #include 
	~<stdio.h
>

37 #include 
	~<string.h
>

39 int 
	gopterr
 = 1,

40 
	goptind
 = 1,

41 
	goptopt
,

42 
	goptreset
;

43 const char* 
	goptarg
;

45 #define 
	#BADCH
 (int)'?'

	)

46 #define 
	#BADARG
 (int)':'

	)

47 #define 
	#EMSG
 ""

	)

53 int 
	$getopt
(int 
nargc
, char* const 
nargv
[], const char* 
ostr
)

55 static const char* 
place
 = 
EMSG
;

56 const char* 
oli
;

58 if (
optreset
 || !*
place
) {

59 
optreset
 = 0;

60 if (
optind
 >= 
nargc
 || *(
place
 = 
nargv
[optind]) != '-') {

61 
place
 = 
EMSG
;

64 if (
place
[1] && *++place == '-') {

65 ++
optind
;

66 
place
 = 
EMSG
;

70 if ((
optopt
 = (int)*
place
++) == (int)':' || !(
oli
 = 
	`strchr
(
ostr
, optopt))) {

75 if (
optopt
 == (int)'-')

77 if (!*
place
)

78 ++
optind
;

79 if (
opterr
 && *
ostr
 != ':')

80 (void)
	`printf
("illegal option -- %c\n", 
optopt
);

81 return (
BADCH
);

83 if (*++
oli
 != ':') {

84 
optarg
 = 
NULL
;

85 if (!*
place
)

86 ++
optind
;

88 if (*
place
)

89 
optarg
 = 
place
;

90 else if (
nargc
 <= ++
optind
) {

91 
place
 = 
EMSG
;

92 if (*
ostr
 == ':')

93 return (
BADARG
);

94 if (
opterr
)

95 (void)
	`printf
("option requires an argument -- %c\n", 
optopt
);

96 return (
BADCH
);

98 
optarg
 = 
nargv
[
optind
];

99 
place
 = 
EMSG
;

100 ++
optind
;

102 return (
optopt
);

103 
	}
}

	@deps/picotls/picotlsvs/picotls-esni/getopt.h

1 #ifndef 
GETOPT_H


2 #ifndef 
__APPLE__


4 #define 
	#GETOPT_H


	)

6 #ifndef 
_GETOPT_H


7 #define 
	#_GETOPT_H


	)

10 extern int 
opterr
;

11 extern int 
optind
;

12 extern int 
optopt
;

13 extern int 
optreset
;

14 extern const char* 
optarg
;

16 int 
getopt
(int 
nargc
, char* const 
nargv
[], const char* 
ostr
);

	@deps/picotls/picotlsvs/picotls-minicrypto-deps/targetver.h

1 #pragma 
once


8 #include 
	~<SDKDDKVer.h
>

	@deps/picotls/picotlsvs/picotls-minicrypto/targetver.h

1 #pragma 
once


8 #include 
	~<SDKDDKVer.h
>

	@deps/picotls/picotlsvs/picotls-openssl/targetver.h

1 #pragma 
once


8 #include 
	~<SDKDDKVer.h
>

	@deps/picotls/picotlsvs/picotls/targetver.h

1 #pragma 
once


8 #include 
	~<SDKDDKVer.h
>

	@deps/picotls/picotlsvs/picotls/wincompat.h

1 #ifndef 
WINCOMPAT_H


2 #define 
	#WINCOMPAT_H


	)

4 #include 
	~<stdint.h
>

5 #define 
	#ssize_t
 int

	)

6 #include 
	~<Winsock2.h
>

7 #include 
	~<ws2tcpip.h
>

8 #include 
	~<malloc.h
>

10 #ifndef 
gettimeofday


11 #define 
	#gettimeofday
 
wintimeofday


	)

13 #ifndef 
__attribute__


14 #define 
	#__attribute__
(
X
)

	)

17 #ifdef 
__cplusplus


20 struct 
	stimezone
 {

21 int 
tz_minuteswest
;

22 int 
tz_dsttime
;

25 int 
wintimeofday
(struct 
timeval
 *
tv
, struct 
timezone
 *
tz
);

27 #ifndef 
strcasecmp


28 #define 
	#strcasecmp
 
_stricmp


	)

31 #ifdef 
__cplusplus


	@deps/picotls/picotlsvs/picotls/wintimeofday.c

17 #ifdef 
_WINDOWS


18 #include 
	~"wincompat.h
"

25 int 
	$wintimeofday
(struct 
timeval
* 
tv
, struct 
timezone
* 
tz
)

27 
FILETIME
 
ft
;

28 
uint64_t
 
now
 = 0;

35 
	`GetSystemTimePreciseAsFileTime
(&
ft
);

41 
now
 = 
ft
.
dwHighDateTime
;

42 
now
 <<= 32;

43 
now
 |= 
ft
.
dwLowDateTime
;

47 
now
 /= 10;

51 
now
 -= 11644473600000000ULL;

53 if (
tv
 != 
NULL
)

55 
uint64_t
 
sec
 = 
now
 / 1000000;

56 
uint64_t
 
usec
 = 
now
 % 1000000;

58 
tv
->
tv_sec
 = (long)
sec
;

59 
tv
->
tv_usec
 = (long)
usec
;

62 if (
tz
 != 
NULL
)

72 
	}
}

	@deps/picotls/picotlsvs/picotlsvs/picotlsvs.c

2 #include 
	~<stdio.h
>

3 #include 
	~<stdarg.h
>

4 #include 
	~<openssl/pem.h
>

5 #include 
	~"../picotls/wincompat.h
"

6 #include 
	~"../../include/picotls.h
"

7 #include 
	~"../../include/picotls/openssl.h
"

8 #include 
	~"../../include/picotls/minicrypto.h
"

9 #include 
	~"../../include/picotls/asn1.h
"

10 #include 
	~"../../include/picotls/pembase64.h
"

12 #ifdef 
_WINDOWS


13 #define 
	#PICOTLS_CERT_STORE
 "..\\..\\t\\assets\\test-ca.crt"

	)

15 #define 
	#PICOTLS_CERT_STORE
 "../../t/assets/test-ca.crt"

	)

18 void 
	$log_printf
(void * 
ctx
, const char * 
format
, ...)

20 
va_list
 
argptr
;

21 
	`va_start
(
argptr
, 
format
);

22 
	`vfprintf
(
stderr
, 
format
, 
argptr
);

23 
	}
}

25 
ptls_minicrypto_log_ctx_t
 
	glog_ctx
 = { 
NULL
, 
log_printf
 };

27 int 
ptls_export_secret
(
ptls_t
 *
tls
, void *
output
, 
size_t
 
outlen
, const char *
label
, 
ptls_iovec_t
 
context_value
, int 
is_early
);

36 
size_t
 
ptls_minicrypto_asn1_decode_private_key
(

37 
ptls_asn1_pkcs8_private_key_t
 * 
pkey
,

38 int * 
decode_error
, 
ptls_minicrypto_log_ctx_t
 * 
log_ctx
);

40 int 
	$openPemTest
(char const * 
filename
)

42 
ptls_iovec_t
 
buf
 = { 0 };

43 
size_t
 
count
 = 1;

44 
size_t
 
fuzz_index
 = 0;

45 
uint8_t
 
original_byte
 = 0;

46 
uint8_t
 
fuzz_byte
 = 0xAA;

47 
size_t
 
byte_index
 = 0;

48 int 
decode_error
;

50 int 
ret
 = 
	`ptls_load_pem_objects
(
filename
, "PRIVATE KEY", &
buf
, 1, &
count
);

53 if (
ret
 == 0)

55 for (
fuzz_index
 = 0; 
ret
 == 0 && fuzz_index < 
buf
.
len
; fuzz_index++)

57 
ptls_asn1_pkcs8_private_key_t
 
pkey
 = { {0} };

58 
original_byte
 = 
buf
.
base
[
fuzz_index
];

59 
decode_error
 = 0;

60 
buf
.
base
[
fuzz_index
] ^= 
fuzz_byte
;

62 
pkey
.
vec
.
base
 = 
buf
.base;

63 
pkey
.
vec
.
len
 = 
buf
.len;

65 
byte_index
 = 
	`ptls_minicrypto_asn1_decode_private_key
(

66 &
pkey
, &
decode_error
, 
NULL
);

68 if (
decode_error
 != 0)

70 if (
decode_error
 == 1)

72 
ret
 = -1;

76 
buf
.
base
[
fuzz_index
] = 
original_byte
;

80 if (
buf
.
base
 != 
NULL
)

82 
	`free
(
buf
.
base
);

85 return 
ret
;

86 
	}
}

92 
X509
* 
	$openPemFile
(char* 
filename
)

95 
X509
* 
cert
 = 
	`X509_new
();

96 
BIO
* 
bio_cert
 = 
	`BIO_new_file
(
filename
, "rb");

97 
	`PEM_read_bio_X509
(
bio_cert
, &
cert
, 
NULL
, NULL);

98 return 
cert
;

99 
	}
}

101 int 
	$get_certificates
(char * 
pem_fname
, 
ptls_iovec_t
 ** 
list
, int * 
nb_certs
)

103 int 
ret
 = 0;

104 
size_t
 
count
 = 0;

105 
X509
 *
cert
;

106 static 
ptls_iovec_t
 
certs
[16];

108 *
nb_certs
 = 0;

109 *
list
 = 
NULL
;

111 
cert
 = 
	`openPemFile
(
pem_fname
);

113 if (
cert
 == 
NULL
)

115 
	`fprintf
(
stderr
, "Could not read cert in %s\n", 
pem_fname
);

116 
ret
 = -1;

120 
ptls_iovec_t
 *
dst
 = 
certs
 + 
count
++;

121 
dst
->
len
 = 
	`i2d_X509
(
cert
, &dst->
base
);

124 *
nb_certs
 = (int) 
count
;

125 *
list
 = 
certs
;

127 return 
ret
;

128 
	}
}

130 void 
	$SetSignCertificate
(char const * 
keypem
, 
ptls_context_t
 * 
ctx
)

132 static 
ptls_openssl_sign_certificate_t
 
signer
;

134 
EVP_PKEY
 *
pkey
 = 
	`EVP_PKEY_new
();

135 
BIO
* 
bio_key
 = 
	`BIO_new_file
(
keypem
, "rb");

136 
	`PEM_read_bio_PrivateKey
(
bio_key
, &
pkey
, 
NULL
, NULL);

137 
	`ptls_openssl_init_sign_certificate
(&
signer
, 
pkey
);

138 
	`EVP_PKEY_free
(
pkey
);

139 
ctx
->
sign_certificate
 = &
signer
.
super
;

140 
	}
}

142 int 
	$handshake_init
(
ptls_t
 * 
tls
, 
ptls_buffer_t
 * 
sendbuf
, 
ptls_handshake_properties_t
 * 
ph_prop
)

144 
size_t
 
inlen
 = 0, 
roff
 = 0;

146 
	`ptls_buffer_init
(
sendbuf
, "", 0);

147 int 
ret
 = 
	`ptls_handshake
(
tls
, 
sendbuf
, 
NULL
, NULL, 
ph_prop
);

149 return 
ret
;

150 
	}
}

153 int 
	$handshake_progress
(
ptls_t
 * 
tls
, 
ptls_buffer_t
 * 
sendbuf
, ptls_buffer_t * 
recvbuf
, 
ptls_handshake_properties_t
 * 
ph_prop
)

155 
size_t
 
inlen
 = 0, 
roff
 = 0;

156 int 
ret
 = 0;

158 
	`ptls_buffer_init
(
sendbuf
, "", 0);

161 while (
roff
 < 
recvbuf
->
off
 && (
ret
 == 0 || ret == 
PTLS_ERROR_IN_PROGRESS
))

163 
inlen
 = 
recvbuf
->
off
 - 
roff
;

164 
ret
 = 
	`ptls_handshake
(
tls
, 
sendbuf
, 
recvbuf
->
base
 + 
roff
, &
inlen
, 
ph_prop
);

165 
roff
 += 
inlen
;

168 if (
roff
 < 
recvbuf
->
off
)

171 
	`fprintf
(
stderr
, "Could only process %d bytes out of %d\n", (int) 
roff
, (int) 
recvbuf
->
off
);

173 
	`ptls_buffer_dispose
(
recvbuf
);

175 return 
ret
;

176 
	}
}

183 int 
	$extract_1rtt_secret
(

184 
ptls_t
 *
tls
, const char *
label
,

185 
ptls_cipher_suite_t
 ** 
cipher
,

186 
uint8_t
 * 
secret
, 
size_t
 
secret_max
)

188 int 
ret
 = 0;

189 *
cipher
 = 
	`ptls_get_cipher
(
tls
);

191 if (*
cipher
 == 
NULL
)

193 
ret
 = -1;

195 else if ((*
cipher
)->
hash
->
digest_size
 > 
secret_max
)

197 
ret
 = -1;

201 
ret
 = 
	`ptls_export_secret
(
tls
, 
secret
, (*
cipher
)->
hash
->
digest_size
,

202 
label
, 
	`ptls_iovec_init
(
NULL
, 0), 1);

206 
	}
}

208 int 
	$verify_1rtt_secret_extraction
(
ptls_t
 *
tls_client
, ptls_t *
tls_server
)

210 int 
ret
 = 0;

211 
ptls_cipher_suite_t
 * 
cipher_client
;

212 
ptls_cipher_suite_t
 * 
cipher_server
;

213 
uint8_t
 
secret_client
[64];

214 
uint8_t
 
secret_server
[64];

215 char const * 
label
 = "This is just a test";

217 
ret
 = 
	`extract_1rtt_secret
(
tls_client
, 
label
, &
cipher_client
,

218 
secret_client
, sizeof(secret_client));

220 if (
ret
 != 0)

222 
	`fprintf
(
stderr
, "Cannot extract client 1RTT secret, ret=%d\n", 
ret
);

226 
ret
 = 
	`extract_1rtt_secret
(
tls_server
, 
label
, &
cipher_server
,

227 
secret_server
, sizeof(secret_server));

228 if (
ret
 != 0)

230 
	`fprintf
(
stderr
, "Cannot extract client 1RTT secret, ret=%d\n", 
ret
);

234 if (
ret
 == 0)

236 if (
	`strcmp
(
cipher_client
->
aead
->
name
, 
cipher_server
->aead->name) != 0)

238 
	`fprintf
(
stderr
, "AEAD differ, client:%s, server:%s\n",

239 
cipher_client
->
aead
->
name
, 
cipher_server
->aead->name);

240 
ret
 = -1;

242 else if (
cipher_client
->
hash
->
digest_size
 != 
cipher_server
->hash->digest_size)

244 
	`fprintf
(
stderr
, "Key length differ, client:%d, server:%d\n",

245 (int) 
cipher_client
->
hash
->
digest_size
, (int) 
cipher_server
->hash->digest_size);

246 
ret
 = -1;

248 else if (
	`memcmp
(
secret_client
, 
secret_server
, 
cipher_client
->
hash
->
digest_size
) != 0)

250 
	`fprintf
(
stderr
, "Key of client and server differ!\n");

251 
ret
 = -1;

255 return 
ret
;

256 
	}
}

258 
X509_STORE
 * 
	$openssl_init_cert_store
(char const * 
crt_file
)

260 int 
ret
 = 0;

261 
X509_STORE
 *
store
 = 
	`X509_STORE_new
();

263 if (
store
 != 
NULL
) {

264 
X509_LOOKUP
 *
lookup
 = 
	`X509_STORE_add_lookup
(
store
, 
	`X509_LOOKUP_file
());

265 
ret
 = 
	`X509_LOOKUP_load_file
(
lookup
, 
crt_file
, 
X509_FILETYPE_PEM
);

266 if (
ret
 != 1) {

267 
	`fprintf
(
stderr
, "Cannot load store (%s), ret = %d\n",

268 
crt_file
, 
ret
);

272 return 
store
;

273 
	}
}

276 int 
	$openssl_init_test_client
(
ptls_context_t
 *
ctx_client
, char const * 
crt_file
)

278 int 
ret
 = 0;

279 static 
ptls_openssl_verify_certificate_t
 
verifier
;

280 
X509_STORE
 *
store
 = 
NULL
;

283 
	`memset
(
ctx_client
, 0, sizeof(
ptls_context_t
));

284 
ctx_client
->
random_bytes
 = 
ptls_openssl_random_bytes
;

285 
ctx_client
->
get_time
 = &
ptls_get_time
;

286 
ctx_client
->
key_exchanges
 = 
ptls_openssl_key_exchanges
;

287 
ctx_client
->
cipher_suites
 = 
ptls_openssl_cipher_suites
;

288 
	`ptls_openssl_init_verify_certificate
(&
verifier
, 
	`openssl_init_cert_store
(
crt_file
));

289 
ctx_client
->
verify_certificate
 = &
verifier
.
super
;

291 return 
ret
;

292 
	}
}

294 int 
	$openssl_init_test_server
(
ptls_context_t
 *
ctx_server
,

295 char const * 
key_file
, char const * 
cert_file
)

297 int 
ret
 = 0;

299 
	`memset
(
ctx_server
, 0, sizeof(
ptls_context_t
));

300 
ctx_server
->
random_bytes
 = 
ptls_openssl_random_bytes
;

301 
ctx_server
->
get_time
 = &
ptls_get_time
;

302 
ctx_server
->
key_exchanges
 = 
ptls_openssl_key_exchanges
;

303 
ctx_server
->
cipher_suites
 = 
ptls_openssl_cipher_suites
;

305 
ret
 = 
	`ptls_load_certificates
(
ctx_server
, 
cert_file
);

306 if (
ret
 != 0)

308 
	`fprintf
(
stderr
, "Could not read the server certificates\n");

312 
	`SetSignCertificate
(
key_file
, 
ctx_server
);

315 return 
ret
;

316 
	}
}

318 int 
	$minicrypto_init_test_client
(
ptls_context_t
 *
ctx_client
)

320 int 
ret
 = 0;

322 
	`memset
(
ctx_client
, 0, sizeof(
ptls_context_t
));

323 
ctx_client
->
random_bytes
 = 
ptls_minicrypto_random_bytes
;

324 
ctx_client
->
get_time
 = &
ptls_get_time
;

325 
ctx_client
->
key_exchanges
 = 
ptls_minicrypto_key_exchanges
;

326 
ctx_client
->
cipher_suites
 = 
ptls_minicrypto_cipher_suites
;

327 
ctx_client
->
verify_certificate
 = 
NULL
;

329 return 
ret
;

330 
	}
}

332 int 
	$minicrypto_init_test_server
(
ptls_context_t
 *
ctx_server
, char const * 
key_file
, char const * 
cert_file
)

334 int 
ret
 = 0;

337 
	`memset
(
ctx_server
, 0, sizeof(
ptls_context_t
));

338 
ctx_server
->
random_bytes
 = 
ptls_minicrypto_random_bytes
;

339 
ctx_server
->
get_time
 = &
ptls_get_time
;

340 
ctx_server
->
key_exchanges
 = 
ptls_minicrypto_key_exchanges
;

341 
ctx_server
->
cipher_suites
 = 
ptls_minicrypto_cipher_suites
;

343 
ret
 = 
	`ptls_load_certificates
(
ctx_server
, 
cert_file
);

345 if (
ret
 != 0)

347 
	`fprintf
(
stderr
, "Could not read the server certificates\n");

351 
ret
 = 
	`ptls_minicrypto_load_private_key
(
ctx_server
, 
key_file
);

354 return 
ret
;

355 
	}
}

357 #define 
	#PICOTLS_VS_TEST_EXTENSION
 1234

	)

358 static 
uint8_t
 
	gtestExtensionClient
[] = { 1, 2, 3 };

359 static 
uint8_t
 
	gtestExtensionServer
[] = { 1, 2, 3, 4, 5, 6, 7, 8 };

360 char const 
	gtest_sni
[] = "test.example.com";

361 char const 
	gtest_alpn
[] = "picotls";

362 static const 
ptls_iovec_t
 
	gproposed_alpn
[] = {

363 { (
uint8_t
 *) "grease", 6},

364 { (
uint8_t
 *)
test_alpn
, sizeof(test_alpn) -1 }

368 struct 
	sst_picotls_vs_test_context_t


370 int 
	mclient_mode
;

371 
size_t
 
	mreceived_extension_length
;

372 
uint8_t
 
	mreceived_extension
[16];

373 
ptls_raw_extension_t
 
	mext
[2];

375 
ptls_handshake_properties_t
 
	mhandshake_properties
;

379 int 
	$collect_test_extension
(
ptls_t
 *
tls
, struct 
st_ptls_handshake_properties_t
 *
properties
, 
uint16_t
 
type
)

381 return 
type
 == 
PICOTLS_VS_TEST_EXTENSION
;

382 
	}
}

384 void 
	$set_test_extensions
(
ptls_raw_extension_t
 
ext
[2], 
uint8_t
 * 
data
, 
size_t
 
len
)

386 
ext
[0].
type
 = 
PICOTLS_VS_TEST_EXTENSION
;

387 
ext
[0].
data
.
base
 = data;

388 
ext
[0].
data
.
len
 = len;

389 
ext
[1].
type
 = 0xFFFF;

390 
ext
[1].
data
.
base
 = 
NULL
;

391 
ext
[1].
data
.
len
 = 0;

392 
	}
}

394 int 
	$collected_test_extensions
(
ptls_t
 *
tls
, 
ptls_handshake_properties_t
 *
properties
,

395 
ptls_raw_extension_t
 *
slots
)

397 struct 
st_picotls_vs_test_context_t
 * 
ctx
 = (struct st_picotls_vs_test_context_t *)

398 ((char *)
properties
 - 
	`offsetof
(struct 
st_picotls_vs_test_context_t
, 
handshake_properties
));

400 if (
slots
[0].
type
 == 
PICOTLS_VS_TEST_EXTENSION
 && slots[1].type == 0xFFFF)

402 
ctx
->
received_extension_length
 = 
slots
[0].
data
.
len
;

403 
	`memcpy
(
ctx
->
received_extension
, 
slots
[0].
data
.
base
,

404 (
slots
[0].
data
.
len
 < sizeof(
ctx
->
received_extension
)) ?

405 
slots
[0].
data
.
len
 : sizeof(
ctx
->
received_extension
));

407 if (
ctx
->
client_mode
 == 0)

409 
properties
->
additional_extensions
 = 
ctx
->
ext
;

410 
	`set_test_extensions
(
ctx
->
ext
, 
testExtensionServer
, sizeof(testExtensionServer));

415 
	}
}

417 int 
	$client_hello_call_back
(
ptls_on_client_hello_t
 *
on_hello_cb_ctx
, 
ptls_t
 *
tls
,

418 
ptls_on_client_hello_parameters_t
 *
params
)

421 
	`ptls_set_server_name
(
tls
, (const char *)
params
->
server_name
.
base
, params->server_name.
len
);

423 for (
size_t
 
i
 = 0; i < 
params
->
negotiated_protocols
.
count
; i++)

425 if (
params
->
negotiated_protocols
.
list
[
i
].
len
 == sizeof(
test_alpn
) - 1 &&

426 
	`memcmp
(
params
->
negotiated_protocols
.
list
[
i
].
base
, 
test_alpn
, sizeof(test_alpn) - 1) == 0)

428 
	`ptls_set_negotiated_protocol
(
tls
, 
test_alpn
, sizeof(test_alpn) - 1);

433 
	}
}

435 void 
	$set_handshake_context
(struct 
st_picotls_vs_test_context_t
 * 
ctx
, int 
client_mode
)

437 
	`memset
(
ctx
, 0, sizeof(struct 
st_picotls_vs_test_context_t
));

439 if ((
ctx
->
client_mode
 = client_mode) != 0)

441 
ctx
->
handshake_properties
.
client
.
negotiated_protocols
.
list
 = 
proposed_alpn
;

442 
ctx
->
handshake_properties
.
client
.
negotiated_protocols
.
count
 =

443 sizeof(
proposed_alpn
) / sizeof(
ptls_iovec_t
);

445 
ctx
->
handshake_properties
.
additional_extensions
 = ctx->
ext
;

446 
	`set_test_extensions
(
ctx
->
ext
, 
testExtensionClient
, sizeof(testExtensionClient));

449 
ctx
->
handshake_properties
.
collect_extension
 = 
collect_test_extension
;

450 
ctx
->
handshake_properties
.
collected_extensions
 = 
collected_test_extensions
;

451 
	}
}

453 int 
	$verify_handshake_extension
(struct 
st_picotls_vs_test_context_t
 * 
app_ctx_client
,

454 struct 
st_picotls_vs_test_context_t
 *
app_ctx_server
)

456 int 
ret
 = 0;

458 if (
app_ctx_server
->
received_extension_length
 == 0)

460 
	`fprintf
(
stderr
, "Server did not receive the client extension.\n");

461 
ret
 = -1;

463 else if (
app_ctx_server
->
received_extension_length
 != sizeof(
testExtensionClient
) ||

464 
	`memcmp
(
app_ctx_server
->
received_extension
, 
testExtensionClient
, sizeof(testExtensionClient)))

466 
	`fprintf
(
stderr
, "Server did not correctly receive the client extension.\n");

467 
ret
 = -1;

469 else if (
app_ctx_client
->
received_extension_length
 == 0)

471 
	`fprintf
(
stderr
, "Client did not receive the server extension.\n");

472 
ret
 = -1;

474 else if (
app_ctx_client
->
received_extension_length
 != sizeof(
testExtensionServer
) ||

475 
	`memcmp
(
app_ctx_client
->
received_extension
, 
testExtensionServer
, sizeof(testExtensionServer)))

477 
	`fprintf
(
stderr
, "Client did not correctly receive the server extension.\n");

478 
ret
 = -1;

481 return 
ret
;

482 
	}
}

484 int 
	$ptls_memory_loopback_test
(int 
openssl_client
, int 
openssl_server
, char const * 
key_file
, char const * 
cert_file
)

486 
ptls_context_t
 
ctx_client
, 
ctx_server
;

487 
ptls_t
 *
tls_client
 = 
NULL
, *
tls_server
 = NULL;

488 int 
ret
 = 0;

489 
ptls_buffer_t
 
client_buf
, 
server_buf
;

490 struct 
st_picotls_vs_test_context_t
 
app_ctx_client
, 
app_ctx_server
;

491 
ptls_on_client_hello_t
 
client_hello_cb
;

495 if (
ret
 == 0 && 
openssl_client
)

497 
ret
 = 
	`openssl_init_test_client
(&
ctx_client
, 
PICOTLS_CERT_STORE
);

501 
ret
 = 
	`minicrypto_init_test_client
(&
ctx_client
);

504 if (
ret
 == 0 && 
openssl_server
)

506 
ret
 = 
	`openssl_init_test_server
(&
ctx_server
, 
key_file
, 
cert_file
);

510 
ret
 = 
	`minicrypto_init_test_server
(&
ctx_server
, 
key_file
, 
cert_file
);

514 if (
ret
 == 0)

516 
tls_client
 = 
	`ptls_new
(&
ctx_client
, 0);

517 
tls_server
 = 
	`ptls_new
(&
ctx_server
, 1);

519 if (
tls_server
 == 
NULL
 || 
tls_client
 == NULL)

521 
	`fprintf
(
stderr
, "Could not create the TLS connection objects\n");

522 
ret
 = -1;

527 if (
ret
 == 0)

529 int 
nb_rounds
 = 0;

531 
	`set_handshake_context
(&
app_ctx_client
, 1);

532 
	`set_handshake_context
(&
app_ctx_server
, 0);

534 
client_hello_cb
.
cb
 = 
client_hello_call_back
;

535 
ctx_server
.
on_client_hello
 = &
client_hello_cb
;

537 
	`ptls_set_server_name
(
tls_client
, 
test_sni
, sizeof(test_sni) - 1);

539 
ret
 = 
	`handshake_init
(
tls_client
, &
client_buf
,

540 &
app_ctx_client
.
handshake_properties
);

541 
	`printf
("First message from client, ret = %d, %d bytes.\n", 
ret
, (int) 
client_buf
.
off
);

543 while ((
ret
 == 0 || ret == 
PTLS_ERROR_IN_PROGRESS
) && 
client_buf
.
off
 > 0 && 
nb_rounds
 < 12)

545 
nb_rounds
++;

547 
ret
 = 
	`handshake_progress
(
tls_server
, &
server_buf
, &
client_buf
,

548 &
app_ctx_server
.
handshake_properties
);

549 
app_ctx_server
.
handshake_properties
.
additional_extensions
 = 
NULL
;

551 
	`printf
("Message from server, ret = %d, %d bytes.\n", 
ret
, (int) 
server_buf
.
off
);

553 if ((
ret
 == 0 || ret == 
PTLS_ERROR_IN_PROGRESS
) && 
server_buf
.
off
 > 0)

555 
app_ctx_client
.
handshake_properties
.
additional_extensions
 = 
NULL
;

557 
ret
 = 
	`handshake_progress
(
tls_client
, &
client_buf
, &
server_buf
,

558 &
app_ctx_client
.
handshake_properties
);

560 
	`printf
("Message from client, ret = %d, %d bytes.\n", 
ret
, (int) 
client_buf
.
off
);

564 
	`printf
("Exit handshake after %d rounds, ret = %d.\n", 
nb_rounds
, 
ret
);

566 if (
ret
 == 0)

568 
ret
 = 
	`verify_1rtt_secret_extraction
(
tls_client
, 
tls_server
);

570 if (
ret
 == 0)

572 
	`printf
("Key extracted and matches!\n");

576 if (
ret
 == 0)

578 
ret
 = 
	`verify_handshake_extension
(&
app_ctx_client
, &
app_ctx_server
);

580 if (
ret
 == 0)

582 
	`printf
("Extensions received and match!\n");

586 if (
ret
 == 0)

588 const char * 
sni_received
 = 
	`ptls_get_server_name
(
tls_server
);

590 if (
sni_received
 == 
NULL
)

592 
	`fprintf
(
stderr
, "Server did not receive the SNI set by the client\n");

593 
ret
 = -1;

595 else if (
	`strcmp
(
sni_received
, 
test_sni
) != 0)

597 
	`fprintf
(
stderr
, "Server receives SNI: <%s>, does not match <%s>\n",

598 
sni_received
, 
test_sni
);

599 
ret
 = -1;

603 if (
ret
 == 0)

605 const char * 
alpn_received
 = 
	`ptls_get_negotiated_protocol
(
tls_server
);

607 if (
alpn_received
 == 
NULL
)

609 
	`fprintf
(
stderr
, "Server did not negotiate ALPN\n");

610 
ret
 = -1;

612 else if (
	`strcmp
(
alpn_received
, 
test_alpn
) != 0)

614 
	`fprintf
(
stderr
, "Server receives ALPN: <%s>, does not match <%s>\n",

615 
alpn_received
, 
test_alpn
);

616 
ret
 = -1;

620 if (
ret
 == 0)

622 
	`printf
("SNI and ALPN match.\n");

626 if (
tls_client
 != 
NULL
)

628 
	`ptls_free
(
tls_client
);

631 if (
tls_server
 != 
NULL
)

633 
	`ptls_free
(
tls_server
);

636 if (
openssl_server
 == 0 && 
ctx_server
.
sign_certificate
 != 
NULL
)

638 
	`free
(
ctx_server
.
sign_certificate
);

641 return 
ret
;

642 
	}
}

644 static char const * 
	gtest_keys
[] = {

652 static const 
size_t
 
	gnb_test_keys
 = sizeof(
test_keys
) / sizeof(char const *);

654 int 
	$main
()

656 int 
ret
 = 0;

661 for (
size_t
 
i
 = 0; 
ret
 == 0 && i < 
nb_test_keys
; i++)

663 
ret
 = 
	`openPemTest
(
test_keys
[
i
]);

667 if (
ret
 == 0)

669 
	`printf
("\nStarting the RSA test with OpenSSL\n");

670 
ret
 = 
	`ptls_memory_loopback_test
(1, 1, "key.pem", "cert.pem");

673 if (
ret
 == 0)

675 
	`printf
("\nStarting the P256R1 test with OpenSSL\n");

676 
ret
 = 
	`ptls_memory_loopback_test
(1, 1, "ec_key.pem", "ec_cert.pem");

679 if (
ret
 == 0)

681 
	`printf
("\nStarting the P256R1 test with OpenSSL server and Minicrypto client\n");

682 
ret
 = 
	`ptls_memory_loopback_test
(0, 1, "ec_key.pem", "ec_cert.pem");

685 if (
ret
 == 0)

687 
	`printf
("\nStarting the P256R1 test with Minicrypto\n");

688 
ret
 = 
	`ptls_memory_loopback_test
(0, 0, "ec_key.pem", "ec_cert.pem");

691 if (
ret
 == 0)

693 
	`printf
("\nStarting the P256R1 test with Minicrypto server and OpenSSL client\n");

694 
ret
 = 
	`ptls_memory_loopback_test
(1, 0, "ec_key.pem", "ec_cert.pem");

697 return 
ret
;

698 
	}
}

	@deps/picotls/picotlsvs/picotlsvs/targetver.h

1 #pragma 
once


8 #include 
	~<SDKDDKVer.h
>

	@deps/picotls/picotlsvs/pioctls-core/stdafx.cpp

1 #include 
	~"stdafx.h
"

	@deps/picotls/picotlsvs/pioctls-core/stdafx.h

6 #pragma 
once


8 #include 
	~"targetver.h
"

10 #define 
	#WIN32_LEAN_AND_MEAN


11 

	)

	@deps/picotls/picotlsvs/pioctls-core/targetver.h

1 #pragma 
once


8 #include 
	~<SDKDDKVer.h
>

	@deps/picotls/src/esni.c

22 #include 
	~<assert.h
>

23 #include 
	~<getopt.h
>

24 #include 
	~<inttypes.h
>

25 #include 
	~<stdio.h
>

26 #include 
	~<string.h
>

27 #ifdef 
_WINDOWS


28 #include 
	~"..\picotls\wincompat.h
"

29 #ifndef 
_CRT_SECURE_NO_WARNINGS


30 #define 
	#_CRT_SECURE_NO_WARNINGS


	)

32 #pragma 
warning
(
disable
 : 4996)

34 #include 
	~<strings.h
>

36 #include 
	~<time.h
>

37 #include 
	~<openssl/err.h
>

38 #include 
	~<openssl/engine.h
>

39 #include 
	~<openssl/pem.h
>

40 #include 
	~"picotls.h
"

41 #include 
	~"picotls/pembase64.h
"

42 #include 
	~"picotls/openssl.h
"

44 static int 
	$emit_esni
(
ptls_key_exchange_context_t
 **
key_exchanges
, 
ptls_cipher_suite_t
 **
cipher_suites
, 
uint16_t
 
padded_length
,

45 
uint64_t
 
not_before
, uint64_t 
lifetime
, char const *
published_sni
, char const *
file_output
)

47 
ptls_buffer_t
 
buf
;

48 
ptls_key_exchange_context_t
 *
ctx
[256] = {
NULL
};

49 int 
ret
;

51 
	`ptls_buffer_init
(&
buf
, "", 0);

53 
	`ptls_buffer_push16
(&
buf
, 
PTLS_ESNI_VERSION_DRAFT03
);

54 
	`ptls_buffer_push
(&
buf
, 0, 0, 0, 0);

55 if (
published_sni
 != 
NULL
) {

56 
	`ptls_buffer_push_block
(&
buf
, 2, { 
	`ptls_buffer_pushv
(&buf, 
published_sni
, 
	`strlen
(published_sni)); });

58 
	`ptls_buffer_push16
(&
buf
, 0);

60 
	`ptls_buffer_push_block
(&
buf
, 2, {

61 
size_t
 
i
;

62 for (
i
 = 0; 
key_exchanges
[i] != 
NULL
; ++i) {

63 
	`ptls_buffer_push16
(&
buf
, 
key_exchanges
[
i
]->
algo
->
id
);

64 
	`ptls_buffer_push_block
(&
buf
, 2,

65 { 
	`ptls_buffer_pushv
(&
buf
, 
key_exchanges
[
i
]->
pubkey
.
base
, key_exchanges[i]->pubkey.
len
); });

68 
	`ptls_buffer_push_block
(&
buf
, 2, {

69 
size_t
 
i
;

70 for (
i
 = 0; 
cipher_suites
[i] != 
NULL
; ++i)

71 
	`ptls_buffer_push16
(&
buf
, 
cipher_suites
[
i
]->
id
);

73 
	`ptls_buffer_push16
(&
buf
, 
padded_length
);

74 
	`ptls_buffer_push64
(&
buf
, 
not_before
);

75 
	`ptls_buffer_push64
(&
buf
, 
not_before
 + 
lifetime
 - 1);

76 
	`ptls_buffer_push_block
(&
buf
, 2, {});

78 
uint8_t
 
d
[
PTLS_SHA256_DIGEST_SIZE
];

79 
	`ptls_calc_hash
(&
ptls_openssl_sha256
, 
d
, 
buf
.
base
, buf.
off
);

80 
	`memcpy
(
buf
.
base
 + 2, 
d
, 4);

83 if (
file_output
 != 
NULL
) {

84 
FILE
 *
fo
 = 
	`fopen
(
file_output
, "wb");

85 if (
fo
 == 
NULL
) {

86 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
optarg
, 
	`strerror
(
errno
));

87 goto 
Exit
;

89 
	`fwrite
(
buf
.
base
, 1, buf.
off
, 
fo
);

90 
	`fclose
(
fo
);

94 
	`fwrite
(
buf
.
base
, 1, buf.
off
, 
stdout
);

95 
	`fflush
(
stdout
);

98 
ret
 = 0;

99 
Exit
 : {

100 
size_t
 
i
;

101 for (
i
 = 0; 
ctx
[i] != 
NULL
; ++i)

102 
ctx
[
i
]->
	`on_exchange
(ctx + i, 1, 
NULL
, 
	`ptls_iovec_init
(NULL, 0));

104 
	`ptls_buffer_dispose
(&
buf
);

105 return 
ret
;

106 
	}
}

108 static void 
	$usage
(const char *
cmd
, int 
status
)

110 
	`printf
("picotls-esni - generates an ESNI Resource Record\n"

126 
cmd
);

127 
	`exit
(
status
);

128 
	}
}

130 int 
	$main
(int 
argc
, char **
argv
)

132 char const *
published_sni
 = 
NULL
;

133 char const *
file_output
 = 
NULL
;

134 
	`ERR_load_crypto_strings
();

135 
	`OpenSSL_add_all_algorithms
();

136 #if !
	`defined
(
OPENSSL_NO_ENGINE
)

138 
	`ENGINE_load_builtin_engines
();

139 
	`ENGINE_register_all_ciphers
();

140 
	`ENGINE_register_all_digests
();

144 
ptls_key_exchange_context_t
 *
elements
[256];

145 
size_t
 
count
;

146 } 
key_exchanges
 = {{
NULL
}, 0};

148 
ptls_cipher_suite_t
 *
elements
[256];

149 
size_t
 
count
;

150 } 
cipher_suites
 = {{
NULL
}, 0};

151 
uint16_t
 
padded_length
 = 260;

152 
uint64_t
 
lifetime
 = 90 * 86400;

154 int 
ch
;

156 while ((
ch
 = 
	`getopt
(
argc
, 
argv
, "n:K:c:d:p:o:h")) != -1) {

157 switch (
ch
) {

159 
published_sni
 = 
optarg
;

162 
FILE
 *
fp
;

163 
EVP_PKEY
 *
pkey
;

165 if ((
fp
 = 
	`fopen
(
optarg
, "rt")) == 
NULL
) {

166 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
optarg
, 
	`strerror
(
errno
));

167 
	`exit
(1);

170 if ((
pkey
 = 
	`PEM_read_PrivateKey
(
fp
, 
NULL
, NULL, NULL)) == NULL) {

171 
	`fprintf
(
stderr
, "failed to read private key from file:%s:%s\n", 
optarg
, 
	`strerror
(
errno
));

172 
	`exit
(1);

174 
	`fclose
(
fp
);

175 if (
	`ptls_openssl_create_key_exchange
(
key_exchanges
.
elements
 + key_exchanges.
count
++, 
pkey
) != 0) {

176 
	`fprintf
(
stderr
, "unknown type of private key found in file:%s\n", 
optarg
);

177 
	`exit
(1);

179 
	`EVP_PKEY_free
(
pkey
);

182 
size_t
 
i
;

183 for (
i
 = 0; 
ptls_openssl_cipher_suites
[i] != 
NULL
; ++i)

184 if (
	`strcasecmp
(
ptls_openssl_cipher_suites
[
i
]->
aead
->
name
, 
optarg
) == 0)

186 if (
ptls_openssl_cipher_suites
[
i
] == 
NULL
) {

187 
	`fprintf
(
stderr
, "unknown cipher-suite: %s\n", 
optarg
);

188 
	`exit
(1);

190 
cipher_suites
.
elements
[cipher_suites.
count
++] = 
ptls_openssl_cipher_suites
[
i
];

193 if (
	`sscanf
(
optarg
, "%" 
SCNu64
, &
lifetime
) != 1 || lifetime == 0) {

194 
	`fprintf
(
stderr
, "lifetime must be a positive integer\n");

195 
	`exit
(1);

197 
lifetime
 *= 86400;

200 #ifdef 
_WINDOWS


201 if (
	`sscanf_s
(
optarg
, "%" 
SCNu16
, &
padded_length
) != 1 || padded_length == 0) {

202 
	`fprintf
(
stderr
, "padded length must be a positive integer\n");

203 
	`exit
(1);

206 if (
	`sscanf
(
optarg
, "%" 
SCNu16
, &
padded_length
) != 1 || padded_length == 0) {

207 
	`fprintf
(
stderr
, "padded length must be a positive integer\n");

208 
	`exit
(1);

213 
file_output
 = 
optarg
;

216 
	`usage
(
argv
[0], 0);

219 
	`usage
(
argv
[0], 1);

223 if (
cipher_suites
.
count
 == 0)

224 
cipher_suites
.
elements
[cipher_suites.
count
++] = &
ptls_openssl_aes128gcmsha256
;

225 if (
key_exchanges
.
count
 == 0) {

226 
	`fprintf
(
stderr
, "no private key specified\n");

227 
	`exit
(1);

230 
argc
 -= 
optind
;

231 
argv
 += 
optind
;

233 if (
	`emit_esni
(
key_exchanges
.
elements
, 
cipher_suites
.elements, 
padded_length
, 
	`time
(
NULL
), 
lifetime
, 
published_sni
,

234 
file_output
) != 0) {

235 
	`fprintf
(
stderr
, "failed to generate ESNI private structure.\n");

236 
	`exit
(1);

240 
	}
}

	@deps/picotls/t/cli.c

22 #include 
	~<sys/types.h
>

23 #include 
	~<netinet/in.h
>

24 #include 
	~<arpa/nameser.h
>

25 #include 
	~<resolv.h
>

27 #include 
	~<arpa/inet.h
>

28 #include 
	~<assert.h
>

29 #include 
	~<errno.h
>

30 #include 
	~<fcntl.h
>

31 #include 
	~<getopt.h
>

32 #include 
	~<inttypes.h
>

33 #include 
	~<stdio.h
>

34 #include 
	~<string.h
>

35 #include 
	~<strings.h
>

36 #include 
	~<sys/select.h
>

37 #include 
	~<sys/socket.h
>

38 #include 
	~<sys/stat.h
>

39 #include 
	~<sys/time.h
>

40 #include 
	~<sys/types.h
>

41 #include 
	~<unistd.h
>

42 #include 
	~<openssl/err.h
>

43 #include 
	~<openssl/evp.h
>

44 #include 
	~<openssl/engine.h
>

45 #include 
	~<openssl/pem.h
>

46 #if 
PICOTLS_USE_BROTLI


47 #include 
	~"brotli/decode.h
"

49 #include 
	~"picotls.h
"

50 #include 
	~"picotls/openssl.h
"

51 #if 
PICOTLS_USE_BROTLI


52 #include 
	~"picotls/certificate_compression.h
"

54 #include 
	~"util.h
"

57 static const char 
	ginput_file_is_benchmark
[] = "is:benchmark";

59 static void 
	$shift_buffer
(
ptls_buffer_t
 *
buf
, 
size_t
 
delta
)

61 if (
delta
 != 0) {

62 
	`assert
(
delta
 <= 
buf
->
off
);

63 if (
delta
 != 
buf
->
off
)

64 
	`memmove
(
buf
->
base
, buf->base + 
delta
, buf->
off
 - delta);

65 
buf
->
off
 -= 
delta
;

67 
	}
}

69 static int 
	$handle_connection
(int 
sockfd
, 
ptls_context_t
 *
ctx
, const char *
server_name
, const char *
input_file
,

70 
ptls_handshake_properties_t
 *
hsprop
, int 
request_key_update
, int 
keep_sender_open
)

72 static const int 
inputfd_is_benchmark
 = -2;

74 
ptls_t
 *
tls
 = 
	`ptls_new
(
ctx
, 
server_name
 == 
NULL
);

75 
ptls_buffer_t
 
rbuf
, 
encbuf
, 
ptbuf
;

76 enum { 
IN_HANDSHAKE
, 
IN_1RTT
, 
IN_SHUTDOWN
 } 
state
 = IN_HANDSHAKE;

77 int 
inputfd
 = 0, 
ret
 = 0;

78 
size_t
 
early_bytes_sent
 = 0;

79 
uint64_t
 
data_received
 = 0;

80 
ssize_t
 
ioret
;

82 
uint64_t
 
start_at
 = 
ctx
->
get_time
->
	`cb
(ctx->get_time);

84 
	`ptls_buffer_init
(&
rbuf
, "", 0);

85 
	`ptls_buffer_init
(&
encbuf
, "", 0);

86 
	`ptls_buffer_init
(&
ptbuf
, "", 0);

88 
	`fcntl
(
sockfd
, 
F_SETFL
, 
O_NONBLOCK
);

90 if (
input_file
 == 
input_file_is_benchmark
) {

91 if (!
	`ptls_is_server
(
tls
))

92 
inputfd
 = 
inputfd_is_benchmark
;

93 } else if (
input_file
 != 
NULL
) {

94 if ((
inputfd
 = 
	`open
(
input_file
, 
O_RDONLY
)) == -1) {

95 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
input_file
, 
	`strerror
(
errno
));

96 
ret
 = 1;

97 goto 
Exit
;

101 if (
server_name
 != 
NULL
) {

102 
	`ptls_set_server_name
(
tls
, 
server_name
, 0);

103 if ((
ret
 = 
	`ptls_handshake
(
tls
, &
encbuf
, 
NULL
, NULL, 
hsprop
)) != 
PTLS_ERROR_IN_PROGRESS
) {

104 
	`fprintf
(
stderr
, "ptls_handshake:%d\n", 
ret
);

105 
ret
 = 1;

106 goto 
Exit
;

112 
fd_set
 
readfds
, 
writefds
, 
exceptfds
;

113 int 
maxfd
 = 0;

114 struct 
timeval
 
timeout
;

116 
	`FD_ZERO
(&
readfds
);

117 
	`FD_ZERO
(&
writefds
);

118 
	`FD_ZERO
(&
exceptfds
);

119 
	`FD_SET
(
sockfd
, &
readfds
);

120 if (
encbuf
.
off
 != 0 || 
inputfd
 == 
inputfd_is_benchmark
)

121 
	`FD_SET
(
sockfd
, &
writefds
);

122 
	`FD_SET
(
sockfd
, &
exceptfds
);

123 
maxfd
 = 
sockfd
 + 1;

124 if (
inputfd
 >= 0) {

125 
	`FD_SET
(
inputfd
, &
readfds
);

126 
	`FD_SET
(
inputfd
, &
exceptfds
);

127 if (
maxfd
 <= 
inputfd
)

128 
maxfd
 = 
inputfd
 + 1;

130 
timeout
.
tv_sec
 = 
encbuf
.
off
 != 0 ? 0 : 3600;

131 
timeout
.
tv_usec
 = 0;

132 } while (
	`select
(
maxfd
, &
readfds
, &
writefds
, &
exceptfds
, &
timeout
) == -1);

135 if (
	`FD_ISSET
(
sockfd
, &
readfds
) || FD_ISSET(sockfd, &
exceptfds
)) {

136 char 
bytebuf
[16384];

137 
size_t
 
off
 = 0, 
leftlen
;

138 while ((
ioret
 = 
	`read
(
sockfd
, 
bytebuf
, sizeof(bytebuf))) == -1 && 
errno
 == 
EINTR
)

140 if (
ioret
 == -1 && (
errno
 == 
EWOULDBLOCK
 || errno == 
EAGAIN
)) {

142 
ioret
 = 0;

143 } else if (
ioret
 <= 0) {

144 goto 
Exit
;

146 while ((
leftlen
 = 
ioret
 - 
off
) != 0) {

147 if (
state
 == 
IN_HANDSHAKE
) {

148 if ((
ret
 = 
	`ptls_handshake
(
tls
, &
encbuf
, 
bytebuf
 + 
off
, &
leftlen
, 
hsprop
)) == 0) {

149 
state
 = 
IN_1RTT
;

150 
	`assert
(
	`ptls_is_server
(
tls
) || 
hsprop
->
client
.
early_data_acceptance
 != 
PTLS_EARLY_DATA_ACCEPTANCE_UNKNOWN
);

152 if (
hsprop
->
client
.
early_data_acceptance
 == 
PTLS_EARLY_DATA_ACCEPTED
)

153 
	`shift_buffer
(&
ptbuf
, 
early_bytes_sent
);

154 if (
request_key_update
)

155 
	`ptls_update_key
(
tls
, 1);

156 } else if (
ret
 == 
PTLS_ERROR_IN_PROGRESS
) {

159 if (
encbuf
.
off
 != 0)

160 (void)
	`write
(
sockfd
, 
encbuf
.
base
, encbuf.
off
);

161 
	`fprintf
(
stderr
, "ptls_handshake:%d\n", 
ret
);

162 goto 
Exit
;

165 if ((
ret
 = 
	`ptls_receive
(
tls
, &
rbuf
, 
bytebuf
 + 
off
, &
leftlen
)) == 0) {

166 if (
rbuf
.
off
 != 0) {

167 
data_received
 += 
rbuf
.
off
;

168 if (
input_file
 != 
input_file_is_benchmark
)

169 
	`write
(1, 
rbuf
.
base
, rbuf.
off
);

170 
rbuf
.
off
 = 0;

172 } else if (
ret
 == 
PTLS_ERROR_IN_PROGRESS
) {

175 
	`fprintf
(
stderr
, "ptls_receive:%d\n", 
ret
);

176 goto 
Exit
;

179 
off
 += 
leftlen
;

184 if (
encbuf
.
off
 == 0 || 
state
 == 
IN_HANDSHAKE
) {

185 static const 
size_t
 
block_size
 = 16384;

186 if (
inputfd
 >= 0 && (
	`FD_ISSET
(inputfd, &
readfds
) || FD_ISSET(inputfd, &
exceptfds
))) {

187 if ((
ret
 = 
	`ptls_buffer_reserve
(&
ptbuf
, 
block_size
)) != 0)

188 goto 
Exit
;

189 while ((
ioret
 = 
	`read
(
inputfd
, 
ptbuf
.
base
 + ptbuf.
off
, 
block_size
)) == -1 && 
errno
 == 
EINTR
)

191 if (
ioret
 > 0) {

192 
ptbuf
.
off
 += 
ioret
;

193 } else if (
ioret
 == 0) {

195 if (
input_file
 != 
NULL
)

196 
	`close
(
inputfd
);

197 
inputfd
 = -1;

199 } else if (
inputfd
 == 
inputfd_is_benchmark
) {

200 if (
ptbuf
.
capacity
 < 
block_size
) {

201 if ((
ret
 = 
	`ptls_buffer_reserve
(&
ptbuf
, 
block_size
 - ptbuf.
capacity
)) != 0)

202 goto 
Exit
;

203 
	`memset
(
ptbuf
.
base
 + ptbuf.
capacity
, 0, 
block_size
 - ptbuf.capacity);

205 
ptbuf
.
off
 = 
block_size
;

208 if (
ptbuf
.
off
 != 0) {

209 if (
state
 == 
IN_HANDSHAKE
) {

210 
size_t
 
send_amount
 = 0;

211 if (
server_name
 != 
NULL
 && 
hsprop
->
client
.
max_early_data_size
 != NULL) {

212 
size_t
 
max_can_be_sent
 = *
hsprop
->
client
.
max_early_data_size
;

213 if (
max_can_be_sent
 > 
ptbuf
.
off
)

214 
max_can_be_sent
 = 
ptbuf
.
off
;

215 
send_amount
 = 
max_can_be_sent
 - 
early_bytes_sent
;

217 if (
send_amount
 != 0) {

218 if ((
ret
 = 
	`ptls_send
(
tls
, &
encbuf
, 
ptbuf
.
base
, 
send_amount
)) != 0) {

219 
	`fprintf
(
stderr
, "ptls_send(early_data):%d\n", 
ret
);

220 goto 
Exit
;

222 
early_bytes_sent
 += 
send_amount
;

225 if ((
ret
 = 
	`ptls_send
(
tls
, &
encbuf
, 
ptbuf
.
base
, ptbuf.
off
)) != 0) {

226 
	`fprintf
(
stderr
, "ptls_send(1rtt):%d\n", 
ret
);

227 goto 
Exit
;

229 
ptbuf
.
off
 = 0;

234 if (
encbuf
.
off
 != 0) {

235 while ((
ioret
 = 
	`write
(
sockfd
, 
encbuf
.
base
, encbuf.
off
)) == -1 && 
errno
 == 
EINTR
)

237 if (
ioret
 == -1 && (
errno
 == 
EWOULDBLOCK
 || errno == 
EAGAIN
)) {

239 } else if (
ioret
 <= 0) {

240 goto 
Exit
;

242 
	`shift_buffer
(&
encbuf
, 
ioret
);

247 if (
state
 == 
IN_1RTT
 && 
inputfd
 == -1) {

248 if (!
keep_sender_open
) {

249 
ptls_buffer_t
 
wbuf
;

250 
uint8_t
 
wbuf_small
[32];

251 
	`ptls_buffer_init
(&
wbuf
, 
wbuf_small
, sizeof(wbuf_small));

252 if ((
ret
 = 
	`ptls_send_alert
(
tls
, &
wbuf
, 
PTLS_ALERT_LEVEL_WARNING
, 
PTLS_ALERT_CLOSE_NOTIFY
)) != 0) {

253 
	`fprintf
(
stderr
, "ptls_send_alert:%d\n", 
ret
);

255 if (
wbuf
.
off
 != 0)

256 (void)
	`write
(
sockfd
, 
wbuf
.
base
, wbuf.
off
);

257 
	`ptls_buffer_dispose
(&
wbuf
);

258 
	`shutdown
(
sockfd
, 
SHUT_WR
);

260 
state
 = 
IN_SHUTDOWN
;

264 
Exit
:

265 if (
input_file
 == 
input_file_is_benchmark
) {

266 double 
elapsed
 = (
ctx
->
get_time
->
	`cb
(ctx->get_time) - 
start_at
) / 1000.0;

267 
ptls_cipher_suite_t
 *
cipher_suite
 = 
	`ptls_get_cipher
(
tls
);

268 
	`fprintf
(
stderr
, "received %" 
PRIu64
 " bytes in %.3f seconds (%f.3Mbps); %s\n", 
data_received
, 
elapsed
,

269 
data_received
 * 8 / 
elapsed
 / 1000 / 1000, 
cipher_suite
 != 
NULL
 ? cipher_suite->
aead
->
name
 : "unknown cipher");

272 if (
sockfd
 != -1)

273 
	`close
(
sockfd
);

274 if (
input_file
 != 
NULL
 && input_file != 
input_file_is_benchmark
 && 
inputfd
 >= 0)

275 
	`close
(
inputfd
);

276 
	`ptls_buffer_dispose
(&
rbuf
);

277 
	`ptls_buffer_dispose
(&
encbuf
);

278 
	`ptls_buffer_dispose
(&
ptbuf
);

279 
	`ptls_free
(
tls
);

281 return 
ret
 != 0;

282 
	}
}

284 static int 
	$run_server
(struct 
sockaddr
 *
sa
, 
socklen_t
 
salen
, 
ptls_context_t
 *
ctx
, const char *
input_file
,

285 
ptls_handshake_properties_t
 *
hsprop
, int 
request_key_update
)

287 int 
listen_fd
, 
conn_fd
, 
on
 = 1;

289 if ((
listen_fd
 = 
	`socket
(
sa
->
sa_family
, 
SOCK_STREAM
, 0)) == -1) {

290 
	`perror
("socket(2) failed");

293 if (
	`setsockopt
(
listen_fd
, 
SOL_SOCKET
, 
SO_REUSEADDR
, &
on
, sizeof(on)) != 0) {

294 
	`perror
("setsockopt(SO_REUSEADDR) failed");

297 if (
	`bind
(
listen_fd
, 
sa
, 
salen
) != 0) {

298 
	`perror
("bind(2) failed");

301 if (
	`listen
(
listen_fd
, 
SOMAXCONN
) != 0) {

302 
	`perror
("listen(2) failed");

306 
	`fprintf
(
stderr
, "server started on port %d\n", 
	`ntohs
(((struct 
sockaddr_in
 *)
sa
)->
sin_port
));

308 
	`fprintf
(
stderr
, "waiting for connections\n");

309 if ((
conn_fd
 = 
	`accept
(
listen_fd
, 
NULL
, 0)) != -1)

310 
	`handle_connection
(
conn_fd
, 
ctx
, 
NULL
, 
input_file
, 
hsprop
, 
request_key_update
, 0);

314 
	}
}

316 static int 
	$run_client
(struct 
sockaddr
 *
sa
, 
socklen_t
 
salen
, 
ptls_context_t
 *
ctx
, const char *
server_name
, const char *
input_file
,

317 
ptls_handshake_properties_t
 *
hsprop
, int 
request_key_update
, int 
keep_sender_open
)

319 int 
fd
;

321 
hsprop
->
client
.
esni_keys
 = 
	`resolve_esni_keys
(
server_name
);

323 if ((
fd
 = 
	`socket
(
sa
->
sa_family
, 
SOCK_STREAM
, 0)) == 1) {

324 
	`perror
("socket(2) failed");

327 if (
	`connect
(
fd
, 
sa
, 
salen
) != 0) {

328 
	`perror
("connect(2) failed");

332 int 
ret
 = 
	`handle_connection
(
fd
, 
ctx
, 
server_name
, 
input_file
, 
hsprop
, 
request_key_update
, 
keep_sender_open
);

333 
	`free
(
hsprop
->
client
.
esni_keys
.
base
);

334 return 
ret
;

335 
	}
}

337 static void 
	$usage
(const char *
cmd
)

339 
	`printf
("Usage: %s [options] host port\n"

374 #if 
PTLS_OPENSSL_HAVE_SECP384R1


377 #if 
PTLS_OPENSSL_HAVE_SECP521R1


380 #if 
PTLS_OPENSSL_HAVE_X25519


385 #if 
PTLS_OPENSSL_HAVE_SECP384R1


388 #if 
PTLS_OPENSSL_HAVE_SECP521R1


391 #if 
PTLS_OPENSSL_HAVE_ED25519


395 
cmd
);

396 
	}
}

398 int 
	$main
(int 
argc
, char **
argv
)

400 
	`ERR_load_crypto_strings
();

401 
	`OpenSSL_add_all_algorithms
();

402 #if !
	`defined
(
OPENSSL_NO_ENGINE
)

404 
	`ENGINE_load_builtin_engines
();

405 
	`ENGINE_register_all_ciphers
();

406 
	`ENGINE_register_all_digests
();

409 
	`res_init
();

411 
ptls_key_exchange_algorithm_t
 *
key_exchanges
[128] = {
NULL
};

412 
ptls_cipher_suite_t
 *
cipher_suites
[128] = {
NULL
};

413 
ptls_context_t
 
ctx
 = {
ptls_openssl_random_bytes
, &
ptls_get_time
, 
key_exchanges
, 
cipher_suites
};

414 
ptls_handshake_properties_t
 
hsprop
 = {{{{
NULL
}}}};

415 const char *
host
, *
port
, *
input_file
 = 
NULL
, *
esni_file
 = NULL;

417 
ptls_key_exchange_context_t
 *
elements
[16];

418 
size_t
 
count
;

419 } 
esni_key_exchanges
;

420 int 
is_server
 = 0, 
use_early_data
 = 0, 
request_key_update
 = 0, 
keep_sender_open
 = 0, 
ch
;

421 struct 
sockaddr_storage
 
sa
;

422 
socklen_t
 
salen
;

423 int 
family
 = 0;

424 const char *
raw_pub_key_file
 = 
NULL
, *
cert_location
 = NULL;

426 while ((
ch
 = 
	`getopt
(
argc
, 
argv
, "46abBC:c:i:Ik:nN:es:Sr:E:K:l:y:vV:h")) != -1) {

427 switch (
ch
) {

429 
family
 = 
AF_INET
;

432 
family
 = 
AF_INET6
;

435 
ctx
.
require_client_authentication
 = 1;

438 #if 
PICOTLS_USE_BROTLI


439 
ctx
.
decompress_certificate
 = &
ptls_decompress_certificate
;

441 
	`fprintf
(
stderr
, "support for `-b` option was turned off during configuration\n");

442 
	`exit
(1);

446 
input_file
 = 
input_file_is_benchmark
;

450 if (
cert_location
 != 
NULL
) {

451 
	`fprintf
(
stderr
, "-C/-c can only be specified once\n");

454 
cert_location
 = 
optarg
;

455 
is_server
 = 
ch
 == 'c';

458 
input_file
 = 
optarg
;

461 
keep_sender_open
 = 1;

464 
	`load_private_key
(&
ctx
, 
optarg
);

467 
hsprop
.
client
.
negotiate_before_key_exchange
 = 1;

470 
use_early_data
 = 1;

473 
raw_pub_key_file
 = 
optarg
;

476 
	`setup_session_file
(&
ctx
, &
hsprop
, 
optarg
);

479 
ctx
.
require_dhe_on_psk
 = 1;

482 
esni_file
 = 
optarg
;

485 
FILE
 *
fp
;

486 
EVP_PKEY
 *
pkey
;

487 int 
ret
;

488 if ((
fp
 = 
	`fopen
(
optarg
, "rt")) == 
NULL
) {

489 
	`fprintf
(
stderr
, "failed to open ESNI private key file:%s:%s\n", 
optarg
, 
	`strerror
(
errno
));

492 if ((
pkey
 = 
	`PEM_read_PrivateKey
(
fp
, 
NULL
, NULL, NULL)) == NULL) {

493 
	`fprintf
(
stderr
, "failed to load private key from file:%s\n", 
optarg
);

496 if ((
ret
 = 
	`ptls_openssl_create_key_exchange
(
esni_key_exchanges
.
elements
 + esni_key_exchanges.
count
++, 
pkey
)) != 0) {

497 
	`fprintf
(
stderr
, "failed to load private key from file:%s:picotls-error:%d", 
optarg
, 
ret
);

500 
	`EVP_PKEY_free
(
pkey
);

501 
	`fclose
(
fp
);

504 
	`setup_log_event
(&
ctx
, 
optarg
);

507 
	`setup_verify_certificate
(&
ctx
, 
NULL
);

510 
	`setup_verify_certificate
(&
ctx
, 
optarg
);

513 
ptls_key_exchange_algorithm_t
 *
algo
 = 
NULL
;

514 #define 
	#MATCH
(
name
) \

515 if (
algo
 == 
NULL
 && 
	`strcasecmp
(
optarg
, #name) == 0) \

516 
algo
 = (&
ptls_openssl_
##
name
)

	)

517 
	`MATCH
(
secp256r1
);

518 #if 
PTLS_OPENSSL_HAVE_SECP384R1


519 
	`MATCH
(
secp384r1
);

521 #if 
PTLS_OPENSSL_HAVE_SECP521R1


522 
	`MATCH
(
secp521r1
);

524 #if 
PTLS_OPENSSL_HAVE_X25519


525 
	`MATCH
(
x25519
);

527 #undef 
MATCH


528 if (
algo
 == 
NULL
) {

529 
	`fprintf
(
stderr
, "could not find key exchange: %s\n", 
optarg
);

532 
size_t
 
i
;

533 for (
i
 = 0; 
key_exchanges
[i] != 
NULL
; ++i)

535 
key_exchanges
[
i
++] = 
algo
;

538 
request_key_update
 = 1;

541 
size_t
 
i
;

542 for (
i
 = 0; 
cipher_suites
[i] != 
NULL
; ++i)

544 #define 
	#MATCH
(
name
) \

545 if (
cipher_suites
[
i
] == 
NULL
 && 
	`strcasecmp
(
optarg
, #name) == 0) \

546 
cipher_suites
[
i
] = &
ptls_openssl_
##
name


	)

547 
	`MATCH
(
aes128gcmsha256
);

548 
	`MATCH
(
aes256gcmsha384
);

549 #if 
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305


550 
	`MATCH
(
chacha20poly1305sha256
);

552 #undef 
MATCH


553 if (
cipher_suites
[
i
] == 
NULL
) {

554 
	`fprintf
(
stderr
, "unknown cipher-suite: %s\n", 
optarg
);

555 
	`exit
(1);

559 
	`usage
(
argv
[0]);

560 
	`exit
(0);

562 
	`exit
(1);

565 
argc
 -= 
optind
;

566 
argv
 += 
optind
;

568 if (
raw_pub_key_file
 != 
NULL
) {

569 int 
is_dash
 = !
	`strcmp
(
raw_pub_key_file
, "-");

570 if (
is_server
) {

571 
ctx
.
certificates
.
list
 = 
	`malloc
(sizeof(*ctx.certificates.list));

572 
	`load_raw_public_key
(
ctx
.
certificates
.
list
, 
cert_location
);

573 
ctx
.
certificates
.
count
 = 1;

574 } else if (!
is_dash
) {

575 
ptls_iovec_t
 
raw_pub_key
;

576 
EVP_PKEY
 *
pubkey
;

577 
	`load_raw_public_key
(&
raw_pub_key
, 
raw_pub_key_file
);

578 
pubkey
 = 
	`d2i_PUBKEY
(
NULL
, (const unsigned char **)&
raw_pub_key
.
base
, raw_pub_key.
len
);

579 if (
pubkey
 == 
NULL
) {

580 
	`fprintf
(
stderr
, "Failed to create an EVP_PKEY from the key found in %s\n", 
raw_pub_key_file
);

583 
	`setup_raw_pubkey_verify_certificate
(&
ctx
, 
pubkey
);

584 
	`EVP_PKEY_free
(
pubkey
);

586 
ctx
.
use_raw_public_keys
 = 1;

588 if (
cert_location
)

589 
	`load_certificate_chain
(&
ctx
, 
cert_location
);

592 if ((
ctx
.
certificates
.
count
 == 0) != (ctx.
sign_certificate
 == 
NULL
)) {

593 
	`fprintf
(
stderr
, "-C/-c and -k options must be used together\n");

597 if (
is_server
) {

598 if (
ctx
.
certificates
.
count
 == 0) {

599 
	`fprintf
(
stderr
, "-c and -k options must be set\n");

602 #if 
PICOTLS_USE_BROTLI


603 if (
ctx
.
decompress_certificate
 != 
NULL
) {

604 static 
ptls_emit_compressed_certificate_t
 
ecc
;

605 if (
	`ptls_init_compressed_certificate
(&
ecc
, 
ctx
.
certificates
.
list
, ctx.certificates.
count
, 
	`ptls_iovec_init
(
NULL
, 0)) !=

607 
	`fprintf
(
stderr
, "failed to create a brotli-compressed version of the certificate chain.\n");

608 
	`exit
(1);

610 
ctx
.
emit_certificate
 = &
ecc
.
super
;

613 
	`setup_session_cache
(&
ctx
);

616 if (
use_early_data
) {

617 static 
size_t
 
max_early_data_size
;

618 
hsprop
.
client
.
max_early_data_size
 = &max_early_data_size;

620 
ctx
.
send_change_cipher_spec
 = 1;

622 if (
key_exchanges
[0] == 
NULL
)

623 
key_exchanges
[0] = &
ptls_openssl_secp256r1
;

624 if (
cipher_suites
[0] == 
NULL
) {

625 
size_t
 
i
;

626 for (
i
 = 0; 
ptls_openssl_cipher_suites
[i] != 
NULL
; ++i)

627 
cipher_suites
[
i
] = 
ptls_openssl_cipher_suites
[i];

629 if (
esni_file
 != 
NULL
) {

630 if (
esni_key_exchanges
.
count
 == 0) {

631 
	`fprintf
(
stderr
, "-E must be used together with -K\n");

634 
	`setup_esni
(&
ctx
, 
esni_file
, 
esni_key_exchanges
.
elements
);

636 if (
argc
 != 2) {

637 
	`fprintf
(
stderr
, "missing host and port\n");

640 
host
 = (--
argc
, *
argv
++);

641 
port
 = (--
argc
, *
argv
++);

643 if (
	`resolve_address
((struct 
sockaddr
 *)&
sa
, &
salen
, 
host
, 
port
, 
family
, 
SOCK_STREAM
, 
IPPROTO_TCP
) != 0)

644 
	`exit
(1);

646 if (
is_server
) {

647 return 
	`run_server
((struct 
sockaddr
 *)&
sa
, 
salen
, &
ctx
, 
input_file
, &
hsprop
, 
request_key_update
);

649 return 
	`run_client
((struct 
sockaddr
 *)&
sa
, 
salen
, &
ctx
, 
host
, 
input_file
, &
hsprop
, 
request_key_update
, 
keep_sender_open
);

651 
	}
}

	@deps/picotls/t/fusion.c

23 #include 
	~<assert.h
>

24 #include 
	~<stdio.h
>

25 #include 
	~<string.h
>

26 #include 
	~"picotls/fusion.h
"

27 #include 
	~"picotls/minicrypto.h
"

28 #include 
	~"../deps/picotest/picotest.h
"

29 #include 
	~"../lib/fusion.c
"

31 static const char *
	$tostr
(const void *
_p
, 
size_t
 
len
)

33 static char *
buf
;

35 if (
buf
 != 
NULL
)

36 
	`free
(
buf
);

37 
buf
 = 
	`malloc
(
len
 * 2 + 1);

39 const 
uint8_t
 *
s
 = 
_p
;

40 char *
d
 = 
buf
;

42 for (; 
len
 != 0; --len) {

43 *
d
++ = "0123456789abcdef"[*
s
 >> 4];

44 *
d
++ = "0123456789abcdef"[*
s
 & 0xf];

45 ++
s
;

47 *
d
 = '\0';

49 return 
buf
;

50 
	}
}

52 static void 
	$test_loadn
(void)

54 
uint8_t
 
buf
[8192] = {0};

56 for (
size_t
 
off
 = 0; off < 8192 - 15; ++off) {

57 
uint8_t
 *
src
 = 
buf
 + 
off
;

58 
	`memcpy
(
src
, "hello world12345", 16);

59 
__m128i
 
v
 = 
	`loadn
(
src
, 11);

60 if (
	`memcmp
(&
v
, "hello world\0\0\0\0\0", 16) != 0) {

61 
	`ok
(!"fail");

64 
	`memset
(
src
, 0, 11);

66 
	`ok
(!!"success");

67 
	}
}

69 static const 
uint8_t
 
	gzero
[16384] = {0};

71 static void 
	$test_ecb
(void)

73 
ptls_fusion_aesecb_context_t
 
ecb
;

74 
uint8_t
 
encrypted
[16];

76 
	`ptls_fusion_aesecb_init
(&
ecb
, 1, 
zero
, 16);

77 
	`ptls_fusion_aesecb_encrypt
(&
ecb
, 
encrypted
, "hello world!!!!!");

78 
	`ptls_fusion_aesecb_dispose
(&
ecb
);

79 
	`ok
(
	`strcmp
(
	`tostr
(
encrypted
, 16), "172afecb50b5f1237814b2f7cb51d0f7") == 0);

81 
	`ptls_fusion_aesecb_init
(&
ecb
, 1, 
zero
, 32);

82 
	`ptls_fusion_aesecb_encrypt
(&
ecb
, 
encrypted
, "hello world!!!!!");

83 
	`ptls_fusion_aesecb_dispose
(&
ecb
);

84 
	`ok
(
	`strcmp
(
	`tostr
(
encrypted
, 16), "2a033f0627b3554aa4fe5786550736ff") == 0);

85 
	}
}

87 static void 
	$gcm_basic
(void)

90 static const 
uint8_t
 
expected
[] = {0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 0xf3, 0x28, 0xc2,

93 
ptls_fusion_aesgcm_context_t
 *
ctx
 = 
	`ptls_fusion_aesgcm_new
(
zero
, 
PTLS_AES128_KEY_SIZE
, 5 + 16);

94 
uint8_t
 
encrypted
[sizeof(
expected
)], 
decrypted
[sizeof(expected) - 16];

95 
	`ptls_fusion_aesgcm_encrypt
(
ctx
, 
encrypted
, 
zero
, 16, 
	`_mm_setzero_si128
(), "hello", 5, 
NULL
);

96 
	`ok
(
	`memcmp
(
expected
, 
encrypted
, sizeof(expected)) == 0);

97 
	`memset
(
decrypted
, 0x55, sizeof(decrypted));

98 
	`ok
(
	`ptls_fusion_aesgcm_decrypt
(
ctx
, 
decrypted
, 
expected
, 16, 
	`_mm_setzero_si128
(), "hello", 5, expected + 16));

99 
	`ok
(
	`memcmp
(
decrypted
, 
zero
, sizeof(decrypted)) == 0);

100 
	`ptls_fusion_aesgcm_free
(
ctx
);

104 static const 
uint8_t
 
key
[16] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,

106 
aad
[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19},

107 
iv
[] = {20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31},

108 
plaintext
[] =

110 static const 
uint8_t
 
expected
[] = {0xd3, 0xa8, 0x1d, 0x96, 0x4c, 0x9b, 0x02, 0xd7, 0x9a, 0xb0, 0x41, 0x07, 0x4c, 0x8c, 0xe2,

117 
ptls_aead_context_t
 *
aead
 = 
	`ptls_aead_new_direct
(&
ptls_fusion_aes128gcm
, 0, 
key
, 
iv
);

118 
uint8_t
 
encrypted
[sizeof(
plaintext
) + 16], 
decrypted
[sizeof(plaintext)];

119 
	`ptls_aead_encrypt
(
aead
, 
encrypted
, 
plaintext
, sizeof(plaintext), 0, 
aad
, sizeof(aad));

120 
	`ok
(
	`memcmp
(
expected
, 
encrypted
, sizeof(
plaintext
)) == 0);

121 
	`ok
(
	`memcmp
(
expected
 + sizeof(
plaintext
), 
encrypted
 + sizeof(plaintext), 16) == 0);

122 
	`ok
(
	`ptls_aead_decrypt
(
aead
, 
decrypted
, 
encrypted
, sizeof(encrypted), 0, 
aad
, sizeof(aad)) == sizeof(
plaintext
));

123 
	`ok
(
	`memcmp
(
decrypted
, 
plaintext
, sizeof(plaintext)) == 0);

124 
	`ptls_aead_free
(
aead
);

126 
	}
}

128 static void 
	$gcm_capacity
(void)

130 static const 
uint8_t
 
expected
[17] = {0x5b, 0x27, 0x21, 0x5e, 0xd8, 0x1a, 0x70, 0x2e, 0x39,

132 
ptls_fusion_aesgcm_context_t
 *
ctx
 = 
	`ptls_fusion_aesgcm_new
(
zero
, 
PTLS_AES128_KEY_SIZE
, 2);

133 
uint8_t
 
encrypted
[17], 
decrypted
[1] = {0x55};

134 
	`ptls_fusion_aesgcm_encrypt
(
ctx
, 
encrypted
, "X", 1, 
	`_mm_setzero_si128
(), "a", 1, 
NULL
);

135 
	`ok
(
	`memcmp
(
expected
, 
encrypted
, 17) == 0);

136 
	`ok
(
	`ptls_fusion_aesgcm_decrypt
(
ctx
, 
decrypted
, 
expected
, 1, 
	`_mm_setzero_si128
(), "a", 1, expected + 1));

137 
	`ok
('X' == 
decrypted
[0]);

138 
	`ptls_fusion_aesgcm_free
(
ctx
);

139 
	}
}

141 static void 
	$gcm_test_vectors
(void)

143 static const 
uint8_t
 
one
[16] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

144 
ptls_fusion_aesgcm_context_t
 *
aead
 = 
	`ptls_fusion_aesgcm_new
(
zero
, 
PTLS_AES128_KEY_SIZE
, sizeof(zero));

145 
ptls_aead_supplementary_encryption_t
 *
supp
 = 
NULL
;

147 for (int 
i
 = 0; i < 2; ++i) {

148 
uint8_t
 
encrypted
[sizeof(
zero
) + 16], 
decrypted
[sizeof(zero)];

149 #define 
	#DOIT
(
aad
, 
aadlen
, 
ptlen
, 
expected_tag
, 
expected_supp
) \

151 
	`memset
(
encrypted
, 0xcc, sizeof(encrypted)); \

152 
	`ptls_fusion_aesgcm_encrypt
(
aead
, 
encrypted
, 
zero
, 
ptlen
, 
	`_mm_setzero_si128
(), 
aad
, 
aadlen
, 
supp
); \

153 
	`ok
(
	`strcmp
(
	`tostr
(
encrypted
 + 
ptlen
, 16), 
expected_tag
) == 0); \

154 if (
supp
 != 
NULL
) \

155 
	`ok
(
	`strcmp
(
	`tostr
(
supp
->
output
, sizeof(supp->output)), 
expected_supp
) == 0); \

156 
	`memset
(
decrypted
, 0x55, sizeof(decrypted)); \

157 
	`ok
(
	`ptls_fusion_aesgcm_decrypt
(
aead
, 
decrypted
, 
encrypted
, 
ptlen
, 
	`_mm_setzero_si128
(), 
aad
, 
aadlen
, encrypted + ptlen)); \

158 
	`ok
(
	`memcmp
(
decrypted
, 
zero
, 
ptlen
) == 0); \

159 } while (0)

	)

161 
	`DOIT
(
zero
, 13, 17, "1b4e515384e8aa5bb781ee12549a2ccf", "4576f18ef3ae9dfd37cf72c4592da874");

162 
	`DOIT
(
zero
, 13, 32, "84030586f55adf8ac3c145913c6fd0f8", "a062016e90dcc316d061fde5424cf34f");

163 
	`DOIT
(
zero
, 13, 64, "66165d39739c50c90727e7d49127146b", "a062016e90dcc316d061fde5424cf34f");

164 
	`DOIT
(
zero
, 13, 65, "eb3b75e1d4431e1bb67da46f6a1a0edd", "a062016e90dcc316d061fde5424cf34f");

165 
	`DOIT
(
zero
, 13, 79, "8f4a96c7390c26bb15b68865e6a861b9", "a062016e90dcc316d061fde5424cf34f");

166 
	`DOIT
(
zero
, 13, 80, "5cc2554857b19e7a9e18d015feac61fd", "a062016e90dcc316d061fde5424cf34f");

167 
	`DOIT
(
zero
, 13, 81, "5a65f0d4db36c981bf7babd11691fe78", "a062016e90dcc316d061fde5424cf34f");

168 
	`DOIT
(
zero
, 13, 95, "6a8a51152efe928999a610d8a7b1df9d", "a062016e90dcc316d061fde5424cf34f");

169 
	`DOIT
(
zero
, 13, 96, "6b9c468e24ed96010687f3880a044d42", "a062016e90dcc316d061fde5424cf34f");

170 
	`DOIT
(
zero
, 13, 97, "1b4eb785b884a7d4fdebaff81c1c12e8", "a062016e90dcc316d061fde5424cf34f");

172 
	`DOIT
(
zero
, 22, 1328, "0507baaece8d573774c94e8103821316", "a062016e90dcc316d061fde5424cf34f");

173 
	`DOIT
(
zero
, 21, 1329, "dd70d59030eadb6313e778046540a253", "a062016e90dcc316d061fde5424cf34f");

174 
	`DOIT
(
zero
, 20, 1330, "f1b456b955afde7603188af0124a32ef", "a062016e90dcc316d061fde5424cf34f");

176 
	`DOIT
(
zero
, 13, 1337, "a22deec51250a7eb1f4384dea5f2e890", "a062016e90dcc316d061fde5424cf34f");

177 
	`DOIT
(
zero
, 12, 1338, "42102b0a499b2efa89702ece4b0c5789", "a062016e90dcc316d061fde5424cf34f");

178 
	`DOIT
(
zero
, 11, 1339, "9827f0b34252160d0365ffaa9364bedc", "a062016e90dcc316d061fde5424cf34f");

180 
	`DOIT
(
zero
, 0, 80, "98885a3a22bd4742fe7b72172193b163", "a062016e90dcc316d061fde5424cf34f");

181 
	`DOIT
(
zero
, 0, 96, "afd649fc51e14f3966e4518ad53b9ddc", "a062016e90dcc316d061fde5424cf34f");

183 
	`DOIT
(
zero
, 20, 85, "afe8b727057c804a0525c2914ef856b0", "a062016e90dcc316d061fde5424cf34f");

185 #undef 
DOIT


187 
supp
 = 
	`malloc
(sizeof(*supp));

188 
supp
->
ctx
 = 
	`ptls_cipher_new
(&
ptls_fusion_aes128ctr
, 1, 
one
);

189 
supp
->
input
 = 
encrypted
 + 2;

192 
	`ptls_cipher_free
(
supp
->
ctx
);

193 
	`free
(
supp
);

194 
	`ptls_fusion_aesgcm_free
(
aead
);

195 
	}
}

197 static void 
	$gcm_iv96
(void)

199 static const 
uint8_t
 
key
[16] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff},

200 
aad
[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19},

201 
iv
[] = {20, 20, 20, 20, 24, 25, 26, 27, 28, 29, 30, 31},

202 
plaintext
[] =

204 static const 
uint8_t
 
expected
[] = {0xd3, 0xa8, 0x1d, 0x96, 0x4c, 0x9b, 0x02, 0xd7, 0x9a, 0xb0, 0x41, 0x07, 0x4c, 0x8c, 0xe2,

212 
ptls_aead_context_t
 *
aead
 = 
	`ptls_aead_new_direct
(&
ptls_fusion_aes128gcm
, 0, 
key
, 
iv
);

213 
uint8_t
 
encrypted
[sizeof(
plaintext
) + 16], 
decrypted
[sizeof(plaintext)];

214 
uint8_t
 
seq32
[4] = {0, 1, 2, 3};

215 
uint8_t
 
seq32_bad
[4] = {0x89, 0xab, 0xcd, 0xef};

217 
	`ptls_aead_xor_iv
(
aead
, 
seq32
, sizeof(seq32));

218 
	`ptls_aead_encrypt
(
aead
, 
encrypted
, 
plaintext
, sizeof(plaintext), 0, 
aad
, sizeof(aad));

219 
	`ok
(
	`memcmp
(
expected
, 
encrypted
, sizeof(
plaintext
)) == 0);

220 
	`ok
(
	`memcmp
(
expected
 + sizeof(
plaintext
), 
encrypted
 + sizeof(plaintext), 16) == 0);

221 
	`ok
(
	`ptls_aead_decrypt
(
aead
, 
decrypted
, 
encrypted
, sizeof(encrypted), 0, 
aad
, sizeof(aad)) == sizeof(
plaintext
));

222 
	`ok
(
	`memcmp
(
decrypted
, 
plaintext
, sizeof(plaintext)) == 0);

223 
	`ptls_aead_xor_iv
(
aead
, 
seq32
, sizeof(seq32));

224 
	`ptls_aead_xor_iv
(
aead
, 
seq32_bad
, sizeof(seq32_bad));

225 
	`ok
(
	`ptls_aead_decrypt
(
aead
, 
decrypted
, 
encrypted
, sizeof(encrypted), 0, 
aad
, sizeof(aad)) == 
SIZE_MAX
);

226 
	`ptls_aead_xor_iv
(
aead
, 
seq32_bad
, sizeof(seq32_bad));

227 
	`ptls_aead_xor_iv
(
aead
, 
seq32
, sizeof(seq32));

228 
	`ok
(
	`ptls_aead_decrypt
(
aead
, 
decrypted
, 
encrypted
, sizeof(encrypted), 0, 
aad
, sizeof(aad)) == sizeof(
plaintext
));

229 
	`ok
(
	`memcmp
(
decrypted
, 
plaintext
, sizeof(plaintext)) == 0);

230 
	`ptls_aead_free
(
aead
);

231 
	}
}

233 static void 
	$test_generated
(int 
aes256
, int 
iv96
)

235 
ptls_cipher_context_t
 *
rand
 = 
	`ptls_cipher_new
(&
ptls_minicrypto_aes128ctr
, 1, 
zero
);

236 
	`ptls_cipher_init
(
rand
, 
zero
);

237 int 
i
;

238 #ifdef 
_WINDOWS


239 const int 
nb_runs
 = 1000;

241 const int 
nb_runs
 = 10000;

243 for (
i
 = 0; i < 
nb_runs
; ++i) {

245 
uint8_t
 
key
[32], 
iv
[12], 
seq32
[4], 
aadlen
, 
textlen
;

246 
uint64_t
 
seq
;

247 
	`ptls_cipher_encrypt
(
rand
, 
key
, 
zero
, sizeof(key));

248 
	`ptls_cipher_encrypt
(
rand
, 
iv
, 
zero
, sizeof(iv));

249 
	`ptls_cipher_encrypt
(
rand
, &
aadlen
, 
zero
, sizeof(aadlen));

250 
	`ptls_cipher_encrypt
(
rand
, &
textlen
, 
zero
, sizeof(textlen));

251 
	`ptls_cipher_encrypt
(
rand
, &
seq
, 
zero
, sizeof(seq));

252 
	`ptls_cipher_encrypt
(
rand
, 
seq32
, 
zero
, sizeof(seq32));

254 
uint8_t
 
aad
[256], 
text
[256];

256 
	`ptls_cipher_encrypt
(
rand
, 
aad
, 
zero
, sizeof(aad));

257 
	`ptls_cipher_encrypt
(
rand
, 
text
, 
zero
, sizeof(text));

259 
uint8_t
 
encrypted
[272], 
decrypted
[256];

261 
	`memset
(
encrypted
, 0x55, sizeof(encrypted));

262 
	`memset
(
decrypted
, 0xcc, sizeof(decrypted));

265 
ptls_aead_context_t
 *
fusion
 =

266 
	`ptls_aead_new_direct
(
aes256
 ? &
ptls_fusion_aes256gcm
 : &
ptls_fusion_aes128gcm
, 1, 
key
, 
iv
);

267 if (
iv96
) {

268 
	`ptls_aead_xor_iv
(
fusion
, 
seq32
, sizeof(seq32));

270 
	`ptls_aead_encrypt
(
fusion
, 
encrypted
, 
text
, 
textlen
, 
seq
, 
aad
, 
aadlen
);

271 if (
	`ptls_aead_decrypt
(
fusion
, 
decrypted
, 
encrypted
, 
textlen
 + 16, 
seq
, 
aad
, 
aadlen
) != textlen)

272 goto 
Fail
;

273 if (
	`memcmp
(
decrypted
, 
text
, 
textlen
) != 0)

274 goto 
Fail
;

275 
	`ptls_aead_free
(
fusion
);

278 
	`memset
(
decrypted
, 0xcc, sizeof(decrypted));

281 
ptls_aead_context_t
 *
mc
 =

282 
	`ptls_aead_new_direct
(
aes256
 ? &
ptls_minicrypto_aes256gcm
 : &
ptls_minicrypto_aes128gcm
, 0, 
key
, 
iv
);

283 if (
iv96
) {

284 
	`ptls_aead_xor_iv
(
mc
, 
seq32
, sizeof(seq32));

286 if (
	`ptls_aead_decrypt
(
mc
, 
decrypted
, 
encrypted
, 
textlen
 + 16, 
seq
, 
aad
, 
aadlen
) != textlen)

287 goto 
Fail
;

288 if (
	`memcmp
(
decrypted
, 
text
, 
textlen
) != 0)

289 goto 
Fail
;

290 
	`ptls_aead_free
(
mc
);

294 
	`ok
(1);

295 
	`ptls_cipher_free
(
rand
);

298 
Fail
:

299 
	`note
("mismatch at index=%d", 
i
);

300 
	`ok
(0);

301 
	}
}

303 static void 
	$test_generated_aes128
(void)

305 
	`test_generated
(0, 0);

306 
	}
}

308 static void 
	$test_generated_aes256
(void)

310 
	`test_generated
(1, 0);

311 
	}
}

313 static void 
	$test_generated_aes128_iv96
(void)

315 
	`test_generated
(0, 1);

316 
	}
}

318 static void 
	$test_generated_aes256_iv96
(void)

320 
	`test_generated
(1, 1);

321 
	}
}

322 int 
	$main
(int 
argc
, char **
argv
)

324 if (!
	`ptls_fusion_is_supported_by_cpu
()) {

325 
	`note
("CPU does have the necessary features (avx2, aes, pclmul)\n");

326 return 
	`done_testing
();

329 
	`subtest
("loadn", 
test_loadn
);

330 
	`subtest
("ecb", 
test_ecb
);

331 
	`subtest
("gcm-basic", 
gcm_basic
);

332 
	`subtest
("gcm-capacity", 
gcm_capacity
);

333 
	`subtest
("gcm-test-vectors", 
gcm_test_vectors
);

334 
	`subtest
("gcm-iv96", 
gcm_iv96
);

335 
	`subtest
("generated-128", 
test_generated_aes128
);

336 
	`subtest
("generated-256", 
test_generated_aes256
);

337 
	`subtest
("generated-128-iv96", 
test_generated_aes128_iv96
);

338 
	`subtest
("generated-256-iv96", 
test_generated_aes256_iv96
);

340 return 
	`done_testing
();

341 
	}
}

	@deps/picotls/t/minicrypto.c

22 #ifndef 
_XOPEN_SOURCE


23 #define 
	#_XOPEN_SOURCE
 700

	)

25 #include 
	~<assert.h
>

26 #include 
	~<stdio.h
>

27 #include 
	~<string.h
>

28 #include 
	~"../deps/picotest/picotest.h
"

29 #include 
	~"../lib/cifra.c
"

30 #include 
	~"../lib/uecc.c
"

31 #include 
	~"test.h
"

33 static void 
	$test_secp256r1_key_exchange
(void)

35 
	`test_key_exchange
(&
ptls_minicrypto_secp256r1
, &ptls_minicrypto_secp256r1);

36 
	}
}

38 static void 
	$test_x25519_key_exchange
(void)

40 
	`test_key_exchange
(&
ptls_minicrypto_x25519
, &ptls_minicrypto_x25519);

41 
	}
}

43 static void 
	$test_secp256r1_sign
(void)

45 const char *
msg
 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef";

46 
ptls_minicrypto_secp256r1sha256_sign_certificate_t
 
signer
 = {{
secp256r1sha256_sign
}};

47 
uint8_t
 
pub
[
SECP256R1_PUBLIC_KEY_SIZE
];

48 
uint16_t
 
selected
;

49 
ptls_buffer_t
 
sigbuf
;

50 
uint32_t
 
sigbuf_small
[128];

52 
	`uECC_make_key
(
pub
, 
signer
.
key
, 
	`uECC_secp256r1
());

53 
	`ptls_buffer_init
(&
sigbuf
, 
sigbuf_small
, sizeof(sigbuf_small));

55 
	`ok
(
	`secp256r1sha256_sign
(&
signer
.
super
, 
NULL
, &
selected
, &
sigbuf
, 
	`ptls_iovec_init
(
msg
, 32),

56 (
uint16_t
[]){
PTLS_SIGNATURE_ECDSA_SECP256R1_SHA256
}, 1) == 0);

57 
	`ok
(
selected
 == 
PTLS_SIGNATURE_ECDSA_SECP256R1_SHA256
);

61 
	`ptls_buffer_dispose
(&
sigbuf
);

62 
	}
}

64 static void 
	$test_hrr
(void)

66 
ptls_key_exchange_algorithm_t
 *
client_keyex
[] = {&
ptls_minicrypto_x25519
, &
ptls_minicrypto_secp256r1
, 
NULL
};

67 
ptls_context_t
 
client_ctx
 = {
ptls_minicrypto_random_bytes
, &
ptls_get_time
, 
client_keyex
, 
ptls_minicrypto_cipher_suites
};

68 
ptls_t
 *
client
, *
server
;

69 
ptls_buffer_t
 
cbuf
, 
sbuf
, 
decbuf
;

70 
uint8_t
 
cbuf_small
[16384], 
sbuf_small
[16384], 
decbuf_small
[16384];

71 
size_t
 
consumed
;

72 int 
ret
;

74 
	`assert
(
ctx_peer
->
key_exchanges
[0] != 
NULL
 && ctx_peer->key_exchanges[0]->
id
 == 
PTLS_GROUP_SECP256R1
);

75 
	`assert
(
ctx_peer
->
key_exchanges
[1] == 
NULL
);

77 
client
 = 
	`ptls_new
(&
client_ctx
, 0);

78 
server
 = 
	`ptls_new
(
ctx_peer
, 1);

79 
	`ptls_buffer_init
(&
cbuf
, 
cbuf_small
, sizeof(cbuf_small));

80 
	`ptls_buffer_init
(&
sbuf
, 
sbuf_small
, sizeof(sbuf_small));

81 
	`ptls_buffer_init
(&
decbuf
, 
decbuf_small
, sizeof(decbuf_small));

83 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
NULL
, NULL, NULL);

84 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

86 
consumed
 = 
cbuf
.
off
;

87 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
consumed
, 
NULL
);

88 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

89 
	`ok
(
consumed
 == 
cbuf
.
off
);

90 
cbuf
.
off
 = 0;

92 
	`ok
(
sbuf
.
off
 > 5 + 4);

93 
	`ok
(
sbuf
.
base
[5] == 2 );

95 
consumed
 = 
sbuf
.
off
;

96 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
sbuf
.
base
, &
consumed
, 
NULL
);

97 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

98 
	`ok
(
consumed
 == 
sbuf
.
off
);

99 
sbuf
.
off
 = 0;

101 
	`ok
(
cbuf
.
off
 >= 5 + 4);

102 
	`ok
(
cbuf
.
base
[5] == 1 );

104 
consumed
 = 
cbuf
.
off
;

105 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
consumed
, 
NULL
);

106 
	`ok
(
ret
 == 0);

107 
	`ok
(
consumed
 == 
cbuf
.
off
);

108 
cbuf
.
off
 = 0;

110 
	`ok
(
sbuf
.
off
 >= 5 + 4);

111 
	`ok
(
sbuf
.
base
[5] == 2 );

113 
consumed
 = 
sbuf
.
off
;

114 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
sbuf
.
base
, &
consumed
, 
NULL
);

115 
	`ok
(
ret
 == 0);

116 
	`ok
(
consumed
 == 
sbuf
.
off
);

117 
sbuf
.
off
 = 0;

119 
ret
 = 
	`ptls_send
(
client
, &
cbuf
, "hello world", 11);

120 
	`ok
(
ret
 == 0);

122 
consumed
 = 
cbuf
.
off
;

123 
ret
 = 
	`ptls_receive
(
server
, &
decbuf
, 
cbuf
.
base
, &
consumed
);

124 
	`ok
(
ret
 == 0);

125 
	`ok
(
consumed
 == 
cbuf
.
off
);

126 
cbuf
.
off
 = 0;

128 
	`ok
(
decbuf
.
off
 == 11);

129 
	`ok
(
	`memcmp
(
decbuf
.
base
, "hello world", 11) == 0);

131 
	`ptls_buffer_dispose
(&
decbuf
);

132 
	`ptls_buffer_dispose
(&
sbuf
);

133 
	`ptls_buffer_dispose
(&
cbuf
);

134 
	`ptls_free
(
client
);

135 
	`ptls_free
(
server
);

136 
	}
}

138 
DEFINE_FFX_AES128_ALGORITHMS
(
minicrypto
);

139 
DEFINE_FFX_CHACHA20_ALGORITHMS
(
minicrypto
);

141 int 
	$main
(int 
argc
, char **
argv
)

143 
	`subtest
("secp256r1", 
test_secp256r1_key_exchange
);

144 
	`subtest
("x25519", 
test_x25519_key_exchange
);

145 
	`subtest
("secp256r1-sign", 
test_secp256r1_sign
);

147 
ptls_iovec_t
 
cert
 = 
	`ptls_iovec_init
(
SECP256R1_CERTIFICATE
, sizeof(SECP256R1_CERTIFICATE) - 1);

149 
ptls_minicrypto_secp256r1sha256_sign_certificate_t
 
sign_certificate
;

150 
	`ptls_minicrypto_init_secp256r1sha256_sign_certificate
(&
sign_certificate
,

151 
	`ptls_iovec_init
(
SECP256R1_PRIVATE_KEY
, 
SECP256R1_PRIVATE_KEY_SIZE
));

153 
ptls_context_t
 
ctxbuf
 = {
ptls_minicrypto_random_bytes
,

154 &
ptls_get_time
,

155 
ptls_minicrypto_key_exchanges
,

156 
ptls_minicrypto_cipher_suites
,

157 {&
cert
, 1},

158 
NULL
,

159 
NULL
,

160 
NULL
,

161 &
sign_certificate
.
super
};

162 
ctx
 = 
ctx_peer
 = &
ctxbuf
;

163 
	`ADD_FFX_AES128_ALGORITHMS
(
minicrypto
);

164 
	`ADD_FFX_CHACHA20_ALGORITHMS
(
minicrypto
);

166 
	`subtest
("picotls", 
test_picotls
);

167 
	`subtest
("hrr", 
test_hrr
);

169 return 
	`done_testing
();

170 
	}
}

	@deps/picotls/t/openssl.c

22 #ifdef 
_WINDOWS


23 #include 
	~"wincompat.h
"

25 #include 
	~<assert.h
>

26 #include 
	~<stdio.h
>

27 #include 
	~<string.h
>

28 #include 
	~<openssl/bio.h
>

29 #include 
	~<openssl/pem.h
>

30 #include 
	~<openssl/engine.h
>

31 #include 
	~"picotls.h
"

32 #include 
	~"picotls/minicrypto.h
"

33 #include 
	~"../deps/picotest/picotest.h
"

34 #include 
	~"../lib/openssl.c
"

35 #include 
	~"test.h
"

37 #define 
	#RSA_PRIVATE_KEY
 \

64 "-----END RSA PRIVATE KEY-----\n"

	)

66 #define 
	#RSA_CERTIFICATE
 \

85 "-----END CERTIFICATE-----\n"

	)

87 static void 
	$test_bf
(void)

89 #if 
PTLS_OPENSSL_HAVE_BF


91 static const 
uint8_t
 
key
[
PTLS_BLOWFISH_KEY_SIZE
] = {0},

92 
plaintext
[
PTLS_BLOWFISH_BLOCK_SIZE
] = {0x4e, 0xf9, 0x97, 0x45, 0x61, 0x98, 0xdd, 0x78},

93 
expected
[
PTLS_BLOWFISH_BLOCK_SIZE
] = {0xe1, 0xc0, 0x30, 0xe7, 0x4c, 0x14, 0xd2, 0x61};

94 
uint8_t
 
encrypted
[
PTLS_BLOWFISH_BLOCK_SIZE
], 
decrypted
[PTLS_BLOWFISH_BLOCK_SIZE];

97 
ptls_cipher_context_t
 *
ctx
 = 
	`ptls_cipher_new
(&
ptls_openssl_bfecb
, 1, 
key
);

98 
	`ptls_cipher_encrypt
(
ctx
, 
encrypted
, 
plaintext
, 
PTLS_BLOWFISH_BLOCK_SIZE
);

99 
	`ptls_cipher_free
(
ctx
);

100 
	`ok
(
	`memcmp
(
encrypted
, 
expected
, 
PTLS_BLOWFISH_BLOCK_SIZE
) == 0);

103 
ctx
 = 
	`ptls_cipher_new
(&
ptls_openssl_bfecb
, 0, 
key
);

104 
	`ptls_cipher_encrypt
(
ctx
, 
decrypted
, "deadbeef", 
PTLS_BLOWFISH_BLOCK_SIZE
);

105 
	`ptls_cipher_encrypt
(
ctx
, 
decrypted
, 
encrypted
, 
PTLS_BLOWFISH_BLOCK_SIZE
);

106 
	`ptls_cipher_free
(
ctx
);

107 
	`ok
(
	`memcmp
(
decrypted
, 
plaintext
, 
PTLS_BLOWFISH_BLOCK_SIZE
) == 0);

109 
	}
}

111 static void 
	$test_key_exchanges
(void)

113 
	`test_key_exchange
(&
ptls_openssl_secp256r1
, &ptls_openssl_secp256r1);

114 
	`test_key_exchange
(&
ptls_openssl_secp256r1
, &
ptls_minicrypto_secp256r1
);

115 
	`test_key_exchange
(&
ptls_minicrypto_secp256r1
, &
ptls_openssl_secp256r1
);

117 #if 
PTLS_OPENSSL_HAVE_SECP384R1


118 
	`test_key_exchange
(&
ptls_openssl_secp384r1
, &ptls_openssl_secp384r1);

121 #if 
PTLS_OPENSSL_HAVE_SECP521R1


122 
	`test_key_exchange
(&
ptls_openssl_secp521r1
, &ptls_openssl_secp521r1);

125 #if 
PTLS_OPENSSL_HAVE_X25519


126 
	`test_key_exchange
(&
ptls_openssl_x25519
, &ptls_openssl_x25519);

127 
	`test_key_exchange
(&
ptls_openssl_x25519
, &
ptls_minicrypto_x25519
);

128 
	`test_key_exchange
(&
ptls_minicrypto_x25519
, &
ptls_openssl_x25519
);

130 
	}
}

132 static void 
	$test_sign_verify
(
EVP_PKEY
 *
key
, const struct 
st_ptls_openssl_signature_scheme_t
 *
schemes
)

134 for (
size_t
 
i
 = 0; 
schemes
[i].
scheme_id
 != 
UINT16_MAX
; ++i) {

135 
	`note
("scheme 0x%04x", 
schemes
[
i
].
scheme_id
);

136 const void *
message
 = "hello world";

137 
ptls_buffer_t
 
sigbuf
;

138 
uint8_t
 
sigbuf_small
[1024];

140 
	`ptls_buffer_init
(&
sigbuf
, 
sigbuf_small
, sizeof(sigbuf_small));

141 
	`ok
(
	`do_sign
(
key
, 
schemes
 + 
i
, &
sigbuf
, 
	`ptls_iovec_init
(
message
, 
	`strlen
(message))) == 0);

142 
	`EVP_PKEY_up_ref
(
key
);

143 
	`ok
(
	`verify_sign
(
key
, 
schemes
[
i
].
scheme_id
, 
	`ptls_iovec_init
(
message
, 
	`strlen
(message)),

144 
	`ptls_iovec_init
(
sigbuf
.
base
, sigbuf.
off
)) == 0);

146 
	`ptls_buffer_dispose
(&
sigbuf
);

148 
	}
}

150 static void 
	$test_rsa_sign
(void)

152 
ptls_openssl_sign_certificate_t
 *
sc
 = (ptls_openssl_sign_certificate_t *)
ctx
->
sign_certificate
;

153 
	`test_sign_verify
(
sc
->
key
, sc->
schemes
);

154 
	}
}

156 static void 
	$do_test_ecdsa_sign
(int 
nid
, const struct 
st_ptls_openssl_signature_scheme_t
 *
schemes
)

158 
EVP_PKEY
 *
pkey
;

161 
EC_KEY
 *
eckey
 = 
	`EC_KEY_new_by_curve_name
(
nid
);

162 
	`EC_KEY_generate_key
(
eckey
);

163 
pkey
 = 
	`EVP_PKEY_new
();

164 
	`EVP_PKEY_set1_EC_KEY
(
pkey
, 
eckey
);

165 
	`EC_KEY_free
(
eckey
);

168 
	`test_sign_verify
(
pkey
, 
schemes
);

169 
	`EVP_PKEY_free
(
pkey
);

170 
	}
}

172 static void 
	$test_ecdsa_sign
(void)

174 
	`do_test_ecdsa_sign
(
NID_X9_62_prime256v1
, 
secp256r1_signature_schemes
);

175 #if 
PTLS_OPENSSL_HAVE_SECP384R1


176 
	`do_test_ecdsa_sign
(
NID_secp384r1
, 
secp384r1_signature_schemes
);

178 #if 
PTLS_OPENSSL_HAVE_SECP521R1


179 
	`do_test_ecdsa_sign
(
NID_secp521r1
, 
secp521r1_signature_schemes
);

181 
	}
}

183 static void 
	$test_ed25519_sign
(void)

185 #if 
PTLS_OPENSSL_HAVE_ED25519


186 
EVP_PKEY
 *
pkey
 = 
NULL
;

189 
EVP_PKEY_CTX
 *
pctx
 = 
	`EVP_PKEY_CTX_new_id
(
EVP_PKEY_ED25519
, 
NULL
);

190 
	`EVP_PKEY_keygen_init
(
pctx
);

191 
	`EVP_PKEY_keygen
(
pctx
, &
pkey
);

192 
	`EVP_PKEY_CTX_free
(
pctx
);

195 
	`test_sign_verify
(
pkey
, 
ed25519_signature_schemes
);

196 
	`EVP_PKEY_free
(
pkey
);

198 
	}
}

200 static 
X509
 *
	$x509_from_pem
(const char *
pem
)

202 
BIO
 *
bio
 = 
	`BIO_new_mem_buf
((void *)
pem
, (int)
	`strlen
(pem));

203 
X509
 *
cert
 = 
	`PEM_read_bio_X509
(
bio
, 
NULL
, NULL, NULL);

204 
	`assert
(
cert
 != 
NULL
 && "failed to load certificate");

205 
	`BIO_free
(
bio
);

206 return 
cert
;

207 
	}
}

209 static 
ptls_key_exchange_context_t
 *
	$key_from_pem
(const char *
pem
)

211 
BIO
 *
bio
 = 
	`BIO_new_mem_buf
((void *)
pem
, (int)
	`strlen
(pem));

212 
EVP_PKEY
 *
pkey
 = 
	`PEM_read_bio_PrivateKey
(
bio
, 
NULL
, NULL, NULL);

213 
	`assert
(
pkey
 != 
NULL
 && "failed to load private key");

214 
	`BIO_free
(
bio
);

216 
ptls_key_exchange_context_t
 *
ctx
;

217 int 
ret
 = 
	`ptls_openssl_create_key_exchange
(&
ctx
, 
pkey
);

218 
	`assert
(
ret
 == 0 && "failed to setup private key");

220 
	`EVP_PKEY_free
(
pkey
);

221 return 
ctx
;

222 
	}
}

224 static void 
	$test_cert_verify
(void)

226 
X509
 *
cert
 = 
	`x509_from_pem
(
RSA_CERTIFICATE
);

227 
	`STACK_OF
(
X509
) *
chain
 = 
	`sk_X509_new_null
();

228 
X509_STORE
 *
store
 = 
	`X509_STORE_new
();

229 int 
ret
;

232 
ret
 = 
	`verify_cert_chain
(
store
, 
cert
, 
chain
, 0, "test.example.com");

233 
	`ok
(
ret
 == 
PTLS_ALERT_UNKNOWN_CA
);

236 
X509_LOOKUP
 *
lookup
 = 
	`X509_STORE_add_lookup
(
store
, 
	`X509_LOOKUP_file
());

237 
ret
 = 
	`X509_LOOKUP_load_file
(
lookup
, "t/assets/test-ca.crt", 
X509_FILETYPE_PEM
);

238 
	`ok
(
ret
);

239 
ret
 = 
	`verify_cert_chain
(
store
, 
cert
, 
chain
, 0, "test.example.com");

240 
	`ok
(
ret
 == 0);

242 #ifdef 
X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS


244 
ret
 = 
	`verify_cert_chain
(
store
, 
cert
, 
chain
, 0, "test2.example.com");

245 
	`ok
(
ret
 == 
PTLS_ALERT_BAD_CERTIFICATE
);

247 
	`fprintf
(
stderr
, "**** skipping test for hostname validation failure ***\n");

250 
	`X509_free
(
cert
);

251 
	`sk_X509_free
(
chain
);

252 
	`X509_STORE_free
(
store
);

253 
	}
}

255 static void 
	$setup_certificate
(
ptls_iovec_t
 *
dst
)

257 
X509
 *
cert
 = 
	`x509_from_pem
(
RSA_CERTIFICATE
);

259 
dst
->
base
 = 
NULL
;

260 
dst
->
len
 = 
	`i2d_X509
(
cert
, &dst->
base
);

262 
	`X509_free
(
cert
);

263 
	}
}

265 static void 
	$setup_sign_certificate
(
ptls_openssl_sign_certificate_t
 *
sc
)

267 
BIO
 *
bio
 = 
	`BIO_new_mem_buf
(
RSA_PRIVATE_KEY
, (int)
	`strlen
(RSA_PRIVATE_KEY));

268 
EVP_PKEY
 *
pkey
 = 
	`PEM_read_bio_PrivateKey
(
bio
, 
NULL
, NULL, NULL);

269 
	`assert
(
pkey
 != 
NULL
 || !"failed to load private key");

270 
	`BIO_free
(
bio
);

272 
	`ptls_openssl_init_sign_certificate
(
sc
, 
pkey
);

274 
	`EVP_PKEY_free
(
pkey
);

275 
	}
}

277 static int 
	$verify_cert_cb
(int 
ok
, 
X509_STORE_CTX
 *
ctx
)

281 
	}
}

283 
DEFINE_FFX_AES128_ALGORITHMS
(
openssl
);

284 #if 
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305


285 
DEFINE_FFX_CHACHA20_ALGORITHMS
(
openssl
);

288 int 
	$main
(int 
argc
, char **
argv
)

290 
ptls_openssl_sign_certificate_t
 
openssl_sign_certificate
;

291 
ptls_openssl_verify_certificate_t
 
openssl_verify_certificate
;

293 
	`ERR_load_crypto_strings
();

294 
	`OpenSSL_add_all_algorithms
();

295 #if !
	`defined
(
OPENSSL_NO_ENGINE
)

297 
	`ENGINE_load_builtin_engines
();

298 
	`ENGINE_register_all_ciphers
();

299 
	`ENGINE_register_all_digests
();

302 
	`subtest
("bf", 
test_bf
);

304 
	`subtest
("key-exchange", 
test_key_exchanges
);

306 
ptls_iovec_t
 
cert
;

307 
	`setup_certificate
(&
cert
);

308 
	`setup_sign_certificate
(&
openssl_sign_certificate
);

309 
X509_STORE
 *
cert_store
 = 
	`X509_STORE_new
();

310 
	`X509_STORE_set_verify_cb
(
cert_store
, 
verify_cert_cb
);

311 
	`ptls_openssl_init_verify_certificate
(&
openssl_verify_certificate
, 
cert_store
);

313 
ptls_context_t
 
openssl_ctx
 = {
ptls_openssl_random_bytes
,

314 &
ptls_get_time
,

315 
ptls_openssl_key_exchanges
,

316 
ptls_openssl_cipher_suites
,

317 {&
cert
, 1},

318 
NULL
,

319 
NULL
,

320 
NULL
,

321 &
openssl_sign_certificate
.
super
};

322 
	`assert
(
openssl_ctx
.
cipher_suites
[0]->
hash
->
digest_size
 == 48);

323 
ptls_context_t
 
openssl_ctx_sha256only
 = 
openssl_ctx
;

324 ++
openssl_ctx_sha256only
.
cipher_suites
;

325 
	`assert
(
openssl_ctx_sha256only
.
cipher_suites
[0]->
hash
->
digest_size
 == 32);

327 
ptls_key_exchange_context_t
 *
esni_private_keys
[2] = {
	`key_from_pem
(
ESNI_SECP256R1KEY
), 
NULL
};

329 
ctx
 = 
ctx_peer
 = &
openssl_ctx
;

330 
verify_certificate
 = &
openssl_verify_certificate
.
super
;

331 
	`ADD_FFX_AES128_ALGORITHMS
(
openssl
);

332 #if 
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305


333 
	`ADD_FFX_CHACHA20_ALGORITHMS
(
openssl
);

336 
	`subtest
("rsa-sign", 
test_rsa_sign
);

337 
	`subtest
("ecdsa-sign", 
test_ecdsa_sign
);

338 
	`subtest
("ed25519-sign", 
test_ed25519_sign
);

339 
	`subtest
("cert-verify", 
test_cert_verify
);

340 
	`subtest
("picotls", 
test_picotls
);

341 
	`test_picotls_esni
(
esni_private_keys
);

343 
ctx
 = 
ctx_peer
 = &
openssl_ctx_sha256only
;

344 
	`subtest
("picotls", 
test_picotls
);

346 
ctx
 = &
openssl_ctx_sha256only
;

347 
ctx_peer
 = &
openssl_ctx
;

348 
	`subtest
("picotls", 
test_picotls
);

350 
ctx
 = &
openssl_ctx
;

351 
ctx_peer
 = &
openssl_ctx_sha256only
;

352 
	`subtest
("picotls", 
test_picotls
);

354 
ptls_minicrypto_secp256r1sha256_sign_certificate_t
 
minicrypto_sign_certificate
;

355 
ptls_iovec_t
 
minicrypto_certificate
 = 
	`ptls_iovec_init
(
SECP256R1_CERTIFICATE
, sizeof(SECP256R1_CERTIFICATE) - 1);

356 
	`ptls_minicrypto_init_secp256r1sha256_sign_certificate
(

357 &
minicrypto_sign_certificate
, 
	`ptls_iovec_init
(
SECP256R1_PRIVATE_KEY
, sizeof(SECP256R1_PRIVATE_KEY) - 1));

358 
ptls_context_t
 
minicrypto_ctx
 = {
ptls_minicrypto_random_bytes
,

359 &
ptls_get_time
,

360 
ptls_minicrypto_key_exchanges
,

361 
ptls_minicrypto_cipher_suites
,

362 {&
minicrypto_certificate
, 1},

363 
NULL
,

364 
NULL
,

365 
NULL
,

366 &
minicrypto_sign_certificate
.
super
};

367 
ctx
 = &
openssl_ctx
;

368 
ctx_peer
 = &
minicrypto_ctx
;

369 
	`subtest
("vs. minicrypto", 
test_picotls
);

371 
ctx
 = &
minicrypto_ctx
;

372 
ctx_peer
 = &
openssl_ctx
;

373 
	`subtest
("minicrypto vs.", 
test_picotls
);

375 
esni_private_keys
[0]->
	`on_exchange
(esni_private_keys, 1, 
NULL
, 
	`ptls_iovec_init
(NULL, 0));

376 return 
	`done_testing
();

377 
	}
}

	@deps/picotls/t/picotls.c

22 #ifdef 
_WINDOWS


23 #include 
	~"wincompat.h
"

25 #include 
	~<assert.h
>

26 #include 
	~<string.h
>

27 #include 
	~<stdio.h
>

28 #include 
	~"picotls.h
"

29 #include 
	~"picotls/ffx.h
"

30 #include 
	~"picotls/minicrypto.h
"

31 #include 
	~"picotls/pembase64.h
"

32 #include 
	~"../deps/picotest/picotest.h
"

33 #include 
	~"../lib/picotls.c
"

34 #include 
	~"test.h
"

36 static void 
	$test_is_ipaddr
(void)

38 
	`ok
(!
	`ptls_server_name_is_ipaddr
("www.google.com"));

39 
	`ok
(!
	`ptls_server_name_is_ipaddr
("www.google.com."));

40 
	`ok
(!
	`ptls_server_name_is_ipaddr
("www"));

41 
	`ok
(!
	`ptls_server_name_is_ipaddr
(""));

42 
	`ok
(!
	`ptls_server_name_is_ipaddr
("123"));

43 
	`ok
(
	`ptls_server_name_is_ipaddr
("1.1.1.1"));

44 
	`ok
(
	`ptls_server_name_is_ipaddr
("2001:db8::2:1"));

45 
	}
}

47 static void 
	$test_select_cipher
(void)

49 #define 
	#C
(
x
) ((x) >> 8) & 0xff, (x)&0xff

	)

51 
ptls_cipher_suite_t
 *
selected
,

52 *
candidates
[] = {&
ptls_minicrypto_chacha20poly1305sha256
, &
ptls_minicrypto_aes128gcmsha256
, 
NULL
};

55 static const 
uint8_t
 
input
;

56 
	`ok
(
	`select_cipher
(&
selected
, 
candidates
, &
input
, &input, 0) == 
PTLS_ALERT_HANDSHAKE_FAILURE
);

60 static const 
uint8_t
 
input
[] = {
	`C
(
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
), C(
PTLS_CIPHER_SUITE_CHACHA20_POLY1305_SHA256
)};

61 
	`ok
(
	`select_cipher
(&
selected
, 
candidates
, 
input
, input + sizeof(input), 0) == 0);

62 
	`ok
(
selected
 == &
ptls_minicrypto_aes128gcmsha256
);

63 
	`ok
(
	`select_cipher
(&
selected
, 
candidates
, 
input
, input + sizeof(input), 1) == 0);

64 
	`ok
(
selected
 == &
ptls_minicrypto_chacha20poly1305sha256
);

68 static const 
uint8_t
 
input
[] = {
	`C
(
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
), C(
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
)};

69 
	`ok
(
	`select_cipher
(&
selected
, 
candidates
, 
input
, input + sizeof(input), 0) == 0);

70 
	`ok
(
selected
 == &
ptls_minicrypto_aes128gcmsha256
);

71 
	`ok
(
	`select_cipher
(&
selected
, 
candidates
, 
input
, input + sizeof(input), 1) == 0);

72 
	`ok
(
selected
 == &
ptls_minicrypto_aes128gcmsha256
);

75 #undef 
C


76 
	}
}

78 
ptls_context_t
 *
	gctx
, *
	gctx_peer
;

79 
ptls_verify_certificate_t
 *
	gverify_certificate
;

80 struct 
st_ptls_ffx_test_variants_t
 
	gffx_variants
[7];

82 static 
ptls_cipher_suite_t
 *
	$find_cipher
(
ptls_context_t
 *
ctx
, 
uint16_t
 
id
)

84 
ptls_cipher_suite_t
 **
cs
;

85 for (
cs
 = 
ctx
->
cipher_suites
; *cs != 
NULL
; ++cs)

86 if ((*
cs
)->
id
 == id)

87 return *
cs
;

88 return 
NULL
;

89 
	}
}

91 static void 
	$test_hash
(
ptls_hash_algorithm_t
 *
hash
)

93 
uint8_t
 
digest
[
PTLS_MAX_DIGEST_SIZE
];

94 int 
ret
 = 
	`ptls_calc_hash
(
hash
, 
digest
, "", 0);

95 
	`ok
(
ret
 == 0);

96 
	`ok
(
	`memcmp
(
digest
, 
hash
->
empty_digest
, hash->
digest_size
) == 0);

97 
	}
}

99 static void 
	$test_sha256
(void)

101 
	`test_hash
(
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
)->
hash
);

102 
	}
}

104 static void 
	$test_sha384
(void)

106 
ptls_cipher_suite_t
 *
cs
 = 
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
);

107 if (
cs
 != 
NULL
)

108 
	`test_hash
(
cs
->
hash
);

109 
	}
}

111 static void 
	$test_hmac_sha256
(void)

114 const char *
secret
 = "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b", *
message
 = "Hi There",

115 *
expected
 =

118 
uint8_t
 
digest
[32];

120 
ptls_hash_context_t
 *
hctx
 =

121 
	`ptls_hmac_create
(
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
)->
hash
, 
secret
, 
	`strlen
(secret));

123 
	`memset
(
digest
, 0, sizeof(digest));

124 
hctx
->
	`update
(hctx, 
message
, 
	`strlen
(message));

125 
hctx
->
	`final
(hctx, 
digest
, 
PTLS_HASH_FINAL_MODE_RESET
);

126 
	`ok
(
	`memcmp
(
digest
, 
expected
, 32) == 0);

128 
	`memset
(
digest
, 0, sizeof(digest));

129 
hctx
->
	`update
(hctx, 
message
, 
	`strlen
(message));

130 
hctx
->
	`final
(hctx, 
digest
, 
PTLS_HASH_FINAL_MODE_RESET
);

131 
	`ok
(
	`memcmp
(
digest
, 
expected
, 32) == 0);

133 
	`memset
(
digest
, 0, sizeof(digest));

134 
hctx
->
	`update
(hctx, 
message
, 
	`strlen
(message));

135 
hctx
->
	`final
(hctx, 
digest
, 
PTLS_HASH_FINAL_MODE_FREE
);

136 
	`ok
(
	`memcmp
(
digest
, 
expected
, 32) == 0);

137 
	}
}

139 static void 
	$test_hkdf
(void)

141 
ptls_hash_algorithm_t
 *
sha256
 = 
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
)->
hash
;

142 const char 
salt
[] = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c";

143 const char 
ikm
[] = "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";

144 const char 
info
[] = "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9";

145 
uint8_t
 
prk
[
PTLS_MAX_DIGEST_SIZE
];

146 
uint8_t
 
okm
[42];

148 
	`ptls_hkdf_extract
(
sha256
, 
prk
, 
	`ptls_iovec_init
(
salt
, sizeof(salt) - 1), ptls_iovec_init(
ikm
, sizeof(ikm) - 1));

149 
	`ok
(
	`memcmp
(
prk
,

154 
	`ptls_hkdf_expand
(
sha256
, 
okm
, sizeof(okm), 
	`ptls_iovec_init
(
prk
, sha256->
digest_size
), ptls_iovec_init(
info
, sizeof(info) - 1));

155 
	`ok
(
	`memcmp
(
okm
,

158 sizeof(
okm
)) == 0);

159 
	}
}

161 static void 
	$test_ciphersuite
(
ptls_cipher_suite_t
 *
cs1
, ptls_cipher_suite_t *
cs2
)

163 const char *
traffic_secret
 = "012345678901234567890123456789012345678901234567", *
src1
 = "hello world", *
src2
 = "good bye, all";

164 
ptls_aead_context_t
 *
c
;

165 char 
enc1
[256], 
enc2
[256], 
dec1
[256], 
dec2
[256];

166 
size_t
 
enc1len
, 
enc2len
, 
dec1len
, 
dec2len
;

169 
c
 = 
	`ptls_aead_new
(
cs1
->
aead
, cs1->
hash
, 1, 
traffic_secret
, 
NULL
);

170 
	`assert
(
c
 != 
NULL
);

171 
	`ptls_aead_encrypt_init
(
c
, 0, 
NULL
, 0);

172 
enc1len
 = 
	`ptls_aead_encrypt_update
(
c
, 
enc1
, 
src1
, 
	`strlen
(src1));

173 
enc1len
 += 
	`ptls_aead_encrypt_final
(
c
, 
enc1
 + enc1len);

174 
	`ptls_aead_encrypt_init
(
c
, 1, 
NULL
, 0);

175 
enc2len
 = 
	`ptls_aead_encrypt_update
(
c
, 
enc2
, 
src2
, 
	`strlen
(src2));

176 
enc2len
 += 
	`ptls_aead_encrypt_final
(
c
, 
enc2
 + enc2len);

177 
	`ptls_aead_free
(
c
);

179 
c
 = 
	`ptls_aead_new
(
cs2
->
aead
, cs2->
hash
, 0, 
traffic_secret
, 
NULL
);

180 
	`assert
(
c
 != 
NULL
);

183 
dec1len
 = 
	`ptls_aead_decrypt
(
c
, 
dec1
, 
enc1
, 
enc1len
, 0, 
NULL
, 0);

184 
	`ok
(
dec1len
 != 
SIZE_MAX
);

185 
dec2len
 = 
	`ptls_aead_decrypt
(
c
, 
dec2
, 
enc2
, 
enc2len
, 1, 
NULL
, 0);

186 
	`ok
(
dec2len
 != 
SIZE_MAX
);

187 
	`ok
(
	`strlen
(
src1
) == 
dec1len
);

188 
	`ok
(
	`memcmp
(
src1
, 
dec1
, 
dec1len
) == 0);

189 
	`ok
(
	`strlen
(
src2
) == 
dec2len
);

190 
	`ok
(
	`memcmp
(
src2
, 
dec2
, 
dec2len
 - 1) == 0);

193 
enc1
[0] ^= 1;

194 
dec1len
 = 
	`ptls_aead_decrypt
(
c
, 
dec1
, 
enc1
, 
enc1len
, 0, 
NULL
, 0);

195 
	`ok
(
dec1len
 == 
SIZE_MAX
);

197 
	`ptls_aead_free
(
c
);

198 
	}
}

200 static void 
	$test_aad_ciphersuite
(
ptls_cipher_suite_t
 *
cs1
, ptls_cipher_suite_t *
cs2
)

202 const char *
traffic_secret
 = "012345678901234567890123456789012345678901234567", *
src
 = "hello world", *
aad
 = "my true aad";

203 
ptls_aead_context_t
 *
c
;

204 char 
enc
[256], 
dec
[256];

205 
size_t
 
enclen
, 
declen
;

208 
c
 = 
	`ptls_aead_new
(
cs1
->
aead
, cs1->
hash
, 1, 
traffic_secret
, 
NULL
);

209 
	`assert
(
c
 != 
NULL
);

210 
	`ptls_aead_encrypt_init
(
c
, 123, 
aad
, 
	`strlen
(aad));

211 
enclen
 = 
	`ptls_aead_encrypt_update
(
c
, 
enc
, 
src
, 
	`strlen
(src));

212 
enclen
 += 
	`ptls_aead_encrypt_final
(
c
, 
enc
 + enclen);

213 
	`ptls_aead_free
(
c
);

216 
c
 = 
	`ptls_aead_new
(
cs2
->
aead
, cs2->
hash
, 0, 
traffic_secret
, 
NULL
);

217 
	`assert
(
c
 != 
NULL
);

218 
declen
 = 
	`ptls_aead_decrypt
(
c
, 
dec
, 
enc
, 
enclen
, 123, 
aad
, 
	`strlen
(aad));

219 
	`ok
(
declen
 == 
	`strlen
(
src
));

220 
	`ok
(
	`memcmp
(
src
, 
dec
, 
declen
) == 0);

221 
declen
 = 
	`ptls_aead_decrypt
(
c
, 
dec
, 
enc
, 
enclen
, 123, "my fake aad", 
	`strlen
(
aad
));

222 
	`ok
(
declen
 == 
SIZE_MAX
);

223 
	`ptls_aead_free
(
c
);

224 
	}
}

226 static void 
	$test_aad96_ciphersuite
(
ptls_cipher_suite_t
 *
cs1
, ptls_cipher_suite_t *
cs2
)

228 const char *
traffic_secret
 = "012345678901234567890123456789012345678901234567", *
src
 = "hello world", *
aad
 = "my true aad";

229 
ptls_aead_context_t
 *
c
;

230 char 
enc
[256], 
dec
[256];

231 
uint8_t
 
seq32
[4] = {0xa1, 0xb2, 0xc3, 0xd4};

232 
uint8_t
 
seq32_bad
[4] = {0xa2, 0xb3, 0xc4, 0xe5};

233 
size_t
 
enclen
, 
declen
;

236 
c
 = 
	`ptls_aead_new
(
cs1
->
aead
, cs1->
hash
, 1, 
traffic_secret
, 
NULL
);

237 
	`assert
(
c
 != 
NULL
);

238 
	`ptls_aead_xor_iv
(
c
, 
seq32
, sizeof(seq32));

239 
	`ptls_aead_encrypt_init
(
c
, 123, 
aad
, 
	`strlen
(aad));

240 
enclen
 = 
	`ptls_aead_encrypt_update
(
c
, 
enc
, 
src
, 
	`strlen
(src));

241 
enclen
 += 
	`ptls_aead_encrypt_final
(
c
, 
enc
 + enclen);

242 
	`ptls_aead_free
(
c
);

245 
c
 = 
	`ptls_aead_new
(
cs2
->
aead
, cs2->
hash
, 0, 
traffic_secret
, 
NULL
);

246 
	`assert
(
c
 != 
NULL
);

248 
	`ptls_aead_xor_iv
(
c
, 
seq32
, sizeof(seq32));

249 
declen
 = 
	`ptls_aead_decrypt
(
c
, 
dec
, 
enc
, 
enclen
, 123, 
aad
, 
	`strlen
(aad));

250 
	`ptls_aead_xor_iv
(
c
, 
seq32
, sizeof(seq32));

251 
	`ok
(
declen
 == 
	`strlen
(
src
));

252 
	`ok
(
	`memcmp
(
src
, 
dec
, 
declen
) == 0);

254 
	`ptls_aead_xor_iv
(
c
, 
seq32_bad
, sizeof(seq32_bad));

255 
declen
 = 
	`ptls_aead_decrypt
(
c
, 
dec
, 
enc
, 
enclen
, 123, 
aad
, 
	`strlen
(aad));

256 
	`ptls_aead_xor_iv
(
c
, 
seq32_bad
, sizeof(seq32_bad));

257 
	`ok
(
declen
 == 
SIZE_MAX
);

259 
	`ptls_aead_xor_iv
(
c
, 
seq32
, sizeof(seq32));

260 
declen
 = 
	`ptls_aead_decrypt
(
c
, 
dec
, 
enc
, 
enclen
, 123, 
aad
, 
	`strlen
(aad));

261 
	`ok
(
declen
 == 
	`strlen
(
src
));

262 
	`ok
(
	`memcmp
(
src
, 
dec
, 
declen
) == 0);

263 
	`ptls_aead_free
(
c
);

264 
	}
}

266 static void 
	$test_ecb
(
ptls_cipher_algorithm_t
 *
algo
, const void *
expected
, 
size_t
 
expected_len
)

268 static const 
uint8_t
 
key
[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,

270 
plaintext
[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,

273 
uint8_t
 *
actual
 = 
	`malloc
(
expected_len
);

274 
	`assert
(
actual
 != 
NULL
);

276 
	`memset
(
actual
, 0, 
expected_len
);

277 
ptls_cipher_context_t
 *
ctx
 = 
	`ptls_cipher_new
(
algo
, 1, 
key
);

278 
	`ptls_cipher_encrypt
(
ctx
, 
actual
, 
plaintext
, 
expected_len
);

279 
	`ptls_cipher_free
(
ctx
);

280 
	`ok
(
	`memcmp
(
actual
, 
expected
, 
expected_len
) == 0);

283 
ctx
 = 
	`ptls_cipher_new
(
algo
, 0, 
key
);

284 
	`ptls_cipher_encrypt
(
ctx
, 
actual
, actual, 
expected_len
);

285 
	`ptls_cipher_free
(
ctx
);

286 
	`ok
(
	`memcmp
(
actual
, 
plaintext
, 
expected_len
) == 0);

288 
	`free
(
actual
);

289 
	}
}

291 static void 
	$test_aes128ecb
(void)

293 static const 
uint8_t
 
expected
[] = {0x69, 0xC4, 0xE0, 0xD8, 0x6A, 0x7B, 0x04, 0x30,

296 
	`test_ecb
(
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
)->
aead
->
ecb_cipher
, 
expected
, sizeof(expected));

297 
	}
}

299 static void 
	$test_aes256ecb
(void)

301 static const 
uint8_t
 
expected
[] = {0x8E, 0xA2, 0xB7, 0xCA, 0x51, 0x67, 0x45, 0xBF,

303 
ptls_cipher_suite_t
 *
cipher
 = 
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
);

305 if (
cipher
 != 
NULL
)

306 
	`test_ecb
(
cipher
->
aead
->
ecb_cipher
, 
expected
, sizeof(expected));

307 
	}
}

309 static void 
	$test_ctr
(
ptls_cipher_suite_t
 *
cs
, const 
uint8_t
 *
key
, 
size_t
 
key_len
, const void *
iv
, size_t 
iv_len
,

310 const void *
expected
, 
size_t
 
expected_len
)

312 static const 
uint8_t
 
zeroes
[64] = {0};

314 if (
cs
 == 
NULL
)

317 
ptls_cipher_algorithm_t
 *
algo
 = 
cs
->
aead
->
ctr_cipher
;

318 
uint8_t
 
buf
[sizeof(
zeroes
)];

320 
	`assert
(
expected_len
 <= sizeof(
zeroes
));

321 
	`ok
(
algo
->
key_size
 == 
key_len
);

322 
	`ok
(
algo
->
iv_size
 == 
iv_len
);

324 
ptls_cipher_context_t
 *
ctx
 = 
	`ptls_cipher_new
(
algo
, 1, 
key
);

325 
	`assert
(
ctx
 != 
NULL
);

326 
	`ptls_cipher_init
(
ctx
, 
iv
);

327 
	`ptls_cipher_encrypt
(
ctx
, 
buf
, 
zeroes
, 
expected_len
);

328 
	`ptls_cipher_free
(
ctx
);

330 
	`ok
(
	`memcmp
(
buf
, 
expected
, 
expected_len
) == 0);

331 
	}
}

333 static void 
	$test_aes128ctr
(void)

335 static const 
uint8_t
 
key
[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c},

336 
iv
[] = {0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},

337 
expected
[] = {0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,

340 
	`test_ctr
(
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
), 
key
, sizeof(key), 
iv
, sizeof(iv), 
expected
, sizeof(expected));

341 
	}
}

343 static void 
	$test_chacha20
(void)

345 static const 
uint8_t
 
key
[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,

347 
iv
[] = {1, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0x4a, 0, 0, 0, 0},

348 
expected
[] = {0x10, 0xf1, 0xe7, 0xe4, 0xd1, 0x3b, 0x59, 0x15, 0x50, 0x0f, 0xdd,

352 
	`test_ctr
(
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_CHACHA20_POLY1305_SHA256
), 
key
, sizeof(key), 
iv
, sizeof(iv), 
expected
,

353 sizeof(
expected
));

354 
	}
}

356 static void 
	$test_aes128gcm
(void)

358 
ptls_cipher_suite_t
 *
cs
 = 
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
),

359 *
cs_peer
 = 
	`find_cipher
(
ctx_peer
, 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
);

361 
	`test_ciphersuite
(
cs
, 
cs_peer
);

362 
	`test_aad_ciphersuite
(
cs
, 
cs_peer
);

363 
	`test_aad96_ciphersuite
(
cs
, 
cs_peer
);

364 
	}
}

366 static void 
	$test_aes256gcm
(void)

368 
ptls_cipher_suite_t
 *
cs
 = 
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
),

369 *
cs_peer
 = 
	`find_cipher
(
ctx_peer
, 
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
);

371 if (
cs
 != 
NULL
 && 
cs_peer
 != NULL) {

372 
	`test_ciphersuite
(
cs
, 
cs_peer
);

373 
	`test_aad_ciphersuite
(
cs
, 
cs_peer
);

374 
	`test_aad96_ciphersuite
(
cs
, 
cs_peer
);

376 
	}
}

378 static void 
	$test_chacha20poly1305
(void)

380 
ptls_cipher_suite_t
 *
cs
 = 
	`find_cipher
(
ctx
, 
PTLS_CIPHER_SUITE_CHACHA20_POLY1305_SHA256
),

381 *
cs_peer
 = 
	`find_cipher
(
ctx_peer
, 
PTLS_CIPHER_SUITE_CHACHA20_POLY1305_SHA256
);

383 if (
cs
 != 
NULL
 && 
cs_peer
 != NULL) {

384 
	`test_ciphersuite
(
cs
, 
cs_peer
);

385 
	`test_aad_ciphersuite
(
cs
, 
cs_peer
);

386 
	`test_aad96_ciphersuite
(
cs
, 
cs_peer
);

388 
	}
}

390 static void 
	$test_ffx
(void)

392 static 
uint8_t
 
ffx_test_source
[32] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',

395 static 
uint8_t
 
ffx_test_key
[32] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,

397 static 
uint8_t
 
ffx_test_bad_key
[32] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,

400 static 
uint8_t
 
ffx_test_iv
[16] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};

401 static 
uint8_t
 
ffx_test_bad_iv
[16] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26};

403 static 
uint8_t
 
ffx_test_mask
[8] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F};

404 
ptls_cipher_context_t
 *
ffx_enc
 = 
NULL
;

405 
ptls_cipher_context_t
 *
ffx_dec
 = 
NULL
;

406 
ptls_cipher_context_t
 *
ffx_dec_bad
 = 
NULL
;

407 
uint8_t
 
encrypted
[32];

408 
uint8_t
 
result
[32];

410 for (int 
i
 = 0; 
ffx_variants
[i].
algo
 != 
NULL
; i++) {

411 
ffx_enc
 = 
	`ptls_cipher_new
(
ffx_variants
[
i
].
algo
, 1, 
ffx_test_key
);

412 
ffx_dec
 = 
	`ptls_cipher_new
(
ffx_variants
[
i
].
algo
, 0, 
ffx_test_key
);

413 
ffx_dec_bad
 = 
	`ptls_cipher_new
(
ffx_variants
[
i
].
algo
, 0, 
ffx_test_bad_key
);

414 
	`ok
(
ffx_enc
 != 
NULL
 && 
ffx_dec
 != NULL && 
ffx_dec_bad
 != NULL);

415 if (
ffx_enc
 != 
NULL
 && 
ffx_dec
 != NULL && 
ffx_dec_bad
 != NULL) {

416 int 
bit_length
 = 
ffx_variants
[
i
].bit_length;

417 int 
len
 = (
bit_length
 + 7) / 8;

419 
	`ptls_cipher_init
(
ffx_enc
, 
ffx_test_iv
);

420 
	`ptls_cipher_encrypt
(
ffx_enc
, 
encrypted
, 
ffx_test_source
, 
len
);

421 
	`ok
((
encrypted
[
len
 - 1] & 
ffx_test_mask
[
bit_length
 % 8]) == (
ffx_test_source
[len - 1] & ffx_test_mask[bit_length % 8]));

423 
	`ptls_cipher_init
(
ffx_dec
, 
ffx_test_iv
);

424 
	`ptls_cipher_encrypt
(
ffx_dec
, 
result
, 
encrypted
, 
len
);

425 
	`ok
(
	`memcmp
(
ffx_test_source
, 
result
, 
len
) == 0);

427 
	`ptls_cipher_init
(
ffx_dec
, 
ffx_test_bad_iv
);

428 
	`ptls_cipher_encrypt
(
ffx_dec
, 
result
, 
encrypted
, 
len
);

429 
	`ok
(
	`memcmp
(
ffx_test_source
, 
result
, 
len
) != 0);

431 
	`ptls_cipher_init
(
ffx_dec_bad
, 
ffx_test_iv
);

432 
	`ptls_cipher_encrypt
(
ffx_dec_bad
, 
result
, 
encrypted
, 
len
);

433 
	`ok
(
	`memcmp
(
ffx_test_source
, 
result
, 
len
) != 0);

435 if (
ffx_enc
 != 
NULL
) {

436 
	`ptls_cipher_free
(
ffx_enc
);

438 if (
ffx_dec
 != 
NULL
) {

439 
	`ptls_cipher_free
(
ffx_dec
);

441 if (
ffx_dec_bad
 != 
NULL
) {

442 
	`ptls_cipher_free
(
ffx_dec_bad
);

450 
	`assert
(
ffx_variants
[2].
bit_length
 == 53);

451 
ffx_enc
 = 
	`ptls_ffx_new
(&
ptls_minicrypto_aes128ctr
, 1, 4, 53, 
ffx_test_key
);

452 
ffx_dec
 = 
	`ptls_cipher_new
(
ffx_variants
[2].
algo
, 0, 
ffx_test_key
);

453 
	`ok
(
ffx_enc
 != 
NULL
 && 
ffx_dec
 != NULL);

454 if (
ffx_enc
 != 
NULL
 && 
ffx_dec
 != NULL) {

455 
	`ptls_cipher_init
(
ffx_enc
, 
ffx_test_iv
);

456 
	`ptls_cipher_encrypt
(
ffx_enc
, 
encrypted
, 
ffx_test_source
, 7);

457 
	`ptls_cipher_init
(
ffx_dec
, 
ffx_test_iv
);

458 
	`ptls_cipher_encrypt
(
ffx_dec
, 
result
, 
encrypted
, 7);

459 
	`ok
(
	`memcmp
(
ffx_test_source
, 
result
, 7) == 0);

461 if (
ffx_enc
 != 
NULL
) {

462 
	`ptls_cipher_free
(
ffx_enc
);

464 if (
ffx_dec
 != 
NULL
) {

465 
	`ptls_cipher_free
(
ffx_dec
);

467 
	}
}

469 static void 
	$test_base64_decode
(void)

471 
ptls_base64_decode_state_t
 
state
;

472 
ptls_buffer_t
 
buf
;

473 int 
ret
;

475 
	`ptls_buffer_init
(&
buf
, "", 0);

477 
	`ptls_base64_decode_init
(&
state
);

478 
ret
 = 
	`ptls_base64_decode
("aGVsbG8gd29ybGQ=", &
state
, &
buf
);

479 
	`ok
(
ret
 == 0);

480 
	`ok
(
buf
.
off
 == 11);

481 
	`ok
(
	`memcmp
(
buf
.
base
, "hello world", 11) == 0);

483 
buf
.
off
 = 0;

485 
	`ptls_base64_decode_init
(&
state
);

486 
ret
 = 
	`ptls_base64_decode
("a$b", &
state
, &
buf
);

487 
	`ok
(
ret
 != 0);

489 
buf
.
off
 = 0;

491 
	`ptls_base64_decode_init
(&
state
);

492 
ret
 = 
	`ptls_base64_decode
("a\xFF"

494 &
state
, &
buf
);

495 
	`ok
(
ret
 != 0);

497 
	`ptls_buffer_dispose
(&
buf
);

498 
	}
}

502 
uint8_t
 
	mbuf
[32];

503 
size_t
 
	mlen
;

504 int 
	mis_end_of_record
;

505 } 
	mvec
[16];

506 
size_t
 
	mcount
;

507 } 
	gtest_fragmented_message_queue
 = {{{{0}}}};

509 static int 
	$test_fragmented_message_record
(
ptls_t
 *
tls
, struct 
st_ptls_message_emitter_t
 *
emitter
, 
ptls_iovec_t
 
message
,

510 int 
is_end_of_record
, 
ptls_handshake_properties_t
 *
properties
)

512 
	`memcpy
(
test_fragmented_message_queue
.
vec
[test_fragmented_message_queue.
count
].
buf
, 
message
.
base
, message.
len
);

513 
test_fragmented_message_queue
.
vec
[test_fragmented_message_queue.
count
].
len
 = 
message
.len;

514 
test_fragmented_message_queue
.
vec
[test_fragmented_message_queue.
count
].
is_end_of_record
 = is_end_of_record;

515 ++
test_fragmented_message_queue
.
count
;

518 
	}
}

520 static void 
	$test_fragmented_message
(void)

522 
ptls_context_t
 
tlsctx
 = {
NULL
};

523 
ptls_t
 
tls
 = {&
tlsctx
};

524 struct 
st_ptls_record_t
 
rec
 = {
PTLS_CONTENT_TYPE_HANDSHAKE
, 0x0301};

525 int 
ret
;

527 
tlsctx
.
max_buffer_size
 = 14;

529 #define 
	#SET_RECORD
(
lit
) \

531 
rec
.
length
 = sizeof(
lit
) - 1; \

532 
rec
.
fragment
 = (const 
uint8_t
 *)(
lit
); \

533 } while (0)

	)

536 
test_fragmented_message_queue
.
count
 = 0;

537 
	`SET_RECORD
("\x01\x00\x00\x03"

539 
ret
 = 
	`handle_handshake_record
(&
tls
, 
test_fragmented_message_record
, 
NULL
, &
rec
, NULL);

540 
	`ok
(
ret
 == 0);

541 
	`ok
(
test_fragmented_message_queue
.
count
 == 1);

542 
	`ok
(
test_fragmented_message_queue
.
vec
[0].
len
 == 
rec
.
length
);

543 
	`ok
(
	`memcmp
(
test_fragmented_message_queue
.
vec
[0].
buf
, 
rec
.
fragment
, rec.
length
) == 0);

544 
	`ok
(
test_fragmented_message_queue
.
vec
[0].
is_end_of_record
);

545 
	`ok
(
tls
.
recvbuf
.
mess
.
base
 == 
NULL
);

548 
test_fragmented_message_queue
.
count
 = 0;

549 
	`SET_RECORD
("\x01\x00\x00\x03"

551 
ret
 = 
	`handle_handshake_record
(&
tls
, 
test_fragmented_message_record
, 
NULL
, &
rec
, NULL);

552 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

553 
	`ok
(
tls
.
recvbuf
.
mess
.
base
 != 
NULL
);

554 
	`ok
(
test_fragmented_message_queue
.
count
 == 0);

555 
	`SET_RECORD
("bc\x02\x00\x00\x02"

558 
ret
 = 
	`handle_handshake_record
(&
tls
, 
test_fragmented_message_record
, 
NULL
, &
rec
, NULL);

559 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

560 
	`ok
(
test_fragmented_message_queue
.
count
 == 2);

561 
	`ok
(
test_fragmented_message_queue
.
vec
[0].
len
 == 7);

562 
	`ok
(
	`memcmp
(
test_fragmented_message_queue
.
vec
[0].
buf
,

566 
	`ok
(!
test_fragmented_message_queue
.
vec
[0].
is_end_of_record
);

567 
	`ok
(
test_fragmented_message_queue
.
vec
[1].
len
 == 6);

568 
	`ok
(
	`memcmp
(
test_fragmented_message_queue
.
vec
[1].
buf
,

572 
	`ok
(!
test_fragmented_message_queue
.
vec
[1].
is_end_of_record
);

573 
	`SET_RECORD
("\x00\x00\x03"

575 
ret
 = 
	`handle_handshake_record
(&
tls
, 
test_fragmented_message_record
, 
NULL
, &
rec
, NULL);

576 
	`ok
(
ret
 == 0);

577 
	`ok
(
tls
.
recvbuf
.
mess
.
base
 == 
NULL
);

578 
	`ok
(
test_fragmented_message_queue
.
count
 == 3);

579 
	`ok
(
test_fragmented_message_queue
.
vec
[2].
len
 == 7);

580 
	`ok
(
	`memcmp
(
test_fragmented_message_queue
.
vec
[2].
buf
,

584 
	`ok
(
test_fragmented_message_queue
.
vec
[2].
is_end_of_record
);

587 
test_fragmented_message_queue
.
count
 = 0;

588 
	`SET_RECORD
("\x01\x00\x00\xff"

590 
ret
 = 
	`handle_handshake_record
(&
tls
, 
test_fragmented_message_record
, 
NULL
, &
rec
, NULL);

591 
	`ok
(
ret
 == 
PTLS_ALERT_HANDSHAKE_FAILURE
);

592 
	`ok
(
test_fragmented_message_queue
.
count
 == 0);

595 
	`SET_RECORD
("\x01\x00\x00\xff"

597 
ret
 = 
	`handle_handshake_record
(&
tls
, 
test_fragmented_message_record
, 
NULL
, &
rec
, NULL);

598 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

599 
	`SET_RECORD
("abcdef");

600 
ret
 = 
	`handle_handshake_record
(&
tls
, 
test_fragmented_message_record
, 
NULL
, &
rec
, NULL);

601 
	`ok
(
ret
 == 
PTLS_ALERT_HANDSHAKE_FAILURE
);

602 
	`ok
(
test_fragmented_message_queue
.
count
 == 0);

604 #undef 
SET_RECORD


605 
	}
}

607 static int 
	gwas_esni
;

609 static int 
	$save_client_hello
(
ptls_on_client_hello_t
 *
self
, 
ptls_t
 *
tls
, 
ptls_on_client_hello_parameters_t
 *
params
)

611 
	`ptls_set_server_name
(
tls
, (const char *)
params
->
server_name
.
base
, params->server_name.
len
);

612 if (
params
->
negotiated_protocols
.
count
 != 0)

613 
	`ptls_set_negotiated_protocol
(
tls
, (const char *)
params
->
negotiated_protocols
.
list
[0].
base
,

614 
params
->
negotiated_protocols
.
list
[0].
len
);

615 if (
params
->
esni
)

616 ++
was_esni
;

618 
	}
}

621 
	mTEST_HANDSHAKE_1RTT
,

622 
	mTEST_HANDSHAKE_2RTT
,

623 
	mTEST_HANDSHAKE_HRR
,

624 
	mTEST_HANDSHAKE_HRR_STATELESS
,

625 
	mTEST_HANDSHAKE_EARLY_DATA
,

626 
	mTEST_HANDSHAKE_KEY_UPDATE


629 static int 
	$on_extension_cb
(
ptls_on_extension_t
 *
self
, 
ptls_t
 *
tls
, 
uint8_t
 
hstype
, 
uint16_t
 
exttype
, 
ptls_iovec_t
 
extdata
)

631 
	`assert
(
extdata
.
base
);

633 
	}
}

635 static void 
	$test_handshake
(
ptls_iovec_t
 
ticket
, int 
mode
, int 
expect_ticket
, int 
check_ch
, int 
require_client_authentication
)

637 
ptls_t
 *
client
, *
server
;

638 
ptls_handshake_properties_t
 
client_hs_prop
 = {{{{
NULL
}, 
ticket
}}}, 
server_hs_prop
 = {{{{NULL}}}};

639 
uint8_t
 
cbuf_small
[16384], 
sbuf_small
[16384], 
decbuf_small
[16384];

640 
ptls_buffer_t
 
cbuf
, 
sbuf
, 
decbuf
;

641 
size_t
 
consumed
, 
max_early_data_size
 = 0;

642 int 
ret
;

643 const char *
req
 = "GET / HTTP/1.0\r\n\r\n";

644 const char *
resp
 = "HTTP/1.0 200 OK\r\n\r\nhello world\n";

646 if (
check_ch
)

647 
ctx
->
verify_certificate
 = verify_certificate;

649 
client
 = 
	`ptls_new
(
ctx
, 0);

650 
server
 = 
	`ptls_new
(
ctx_peer
, 1);

651 
	`ptls_buffer_init
(&
cbuf
, 
cbuf_small
, sizeof(cbuf_small));

652 
	`ptls_buffer_init
(&
sbuf
, 
sbuf_small
, sizeof(sbuf_small));

653 
	`ptls_buffer_init
(&
decbuf
, 
decbuf_small
, sizeof(decbuf_small));

655 if (
check_ch
) {

656 static 
ptls_on_client_hello_t
 
cb
 = {
save_client_hello
};

657 
ctx_peer
->
on_client_hello
 = &
cb
;

658 static const 
ptls_iovec_t
 
protocols
[] = {{(
uint8_t
 *)"h2", 2}, {(uint8_t *)"http/1.1", 8}};

659 
client_hs_prop
.
client
.
negotiated_protocols
.
list
 = 
protocols
;

660 
client_hs_prop
.
client
.
negotiated_protocols
.
count
 = 
	`PTLS_ELEMENTSOF
(
protocols
);

661 
	`ptls_set_server_name
(
client
, "test.example.com", 0);

664 static 
ptls_on_extension_t
 
cb
 = {
on_extension_cb
};

665 
ctx_peer
->
on_extension
 = &
cb
;

667 if (
require_client_authentication
) {

668 
ctx_peer
->
require_client_authentication
 = 1;

671 if (
ctx_peer
->
esni
 != 
NULL
) {

672 
was_esni
 = 0;

673 
client_hs_prop
.
client
.
esni_keys
 = 
	`ptls_iovec_init
(
ESNIKEYS
, sizeof(ESNIKEYS) - 1);

676 switch (
mode
) {

677 case 
TEST_HANDSHAKE_HRR
:

678 
client_hs_prop
.
client
.
negotiate_before_key_exchange
 = 1;

680 case 
TEST_HANDSHAKE_HRR_STATELESS
:

681 
client_hs_prop
.
client
.
negotiate_before_key_exchange
 = 1;

682 
server_hs_prop
.
server
.
cookie
.
key
 = "0123456789abcdef0123456789abcdef0123456789abcdef";

683 
server_hs_prop
.
server
.
retry_uses_cookie
 = 1;

685 case 
TEST_HANDSHAKE_EARLY_DATA
:

686 
	`assert
(
ctx_peer
->
max_early_data_size
 != 0);

687 
client_hs_prop
.
client
.
max_early_data_size
 = &max_early_data_size;

691 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
NULL
, NULL, &
client_hs_prop
);

692 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

693 
	`ok
(
cbuf
.
off
 != 0);

695 switch (
mode
) {

696 case 
TEST_HANDSHAKE_2RTT
:

697 case 
TEST_HANDSHAKE_HRR
:

698 case 
TEST_HANDSHAKE_HRR_STATELESS
:

699 
consumed
 = 
cbuf
.
off
;

700 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
consumed
, &
server_hs_prop
);

701 if (
mode
 == 
TEST_HANDSHAKE_HRR_STATELESS
) {

702 
	`ok
(
ret
 == 
PTLS_ERROR_STATELESS_RETRY
);

703 
	`ptls_free
(
server
);

704 
server
 = 
	`ptls_new
(
ctx_peer
, 1);

706 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

708 
	`ok
(
cbuf
.
off
 == 
consumed
);

709 
	`ok
(
sbuf
.
off
 != 0);

710 
cbuf
.
off
 = 0;

711 
consumed
 = 
sbuf
.
off
;

712 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
sbuf
.
base
, &
consumed
, &
client_hs_prop
);

713 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

714 
	`ok
(
sbuf
.
off
 == 
consumed
);

715 
	`ok
(
cbuf
.
off
 != 0);

716 
sbuf
.
off
 = 0;

718 case 
TEST_HANDSHAKE_EARLY_DATA
:

719 
	`ok
(
max_early_data_size
 == 
ctx_peer
->max_early_data_size);

720 
ret
 = 
	`ptls_send
(
client
, &
cbuf
, 
req
, 
	`strlen
(req));

721 
	`ok
(
ret
 == 0);

725 
consumed
 = 
cbuf
.
off
;

726 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
consumed
, &
server_hs_prop
);

728 if (
require_client_authentication
 == 1) {

729 
	`ok
(
	`ptls_is_psk_handshake
(
server
) == 0);

730 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

732 
	`ok
(
ret
 == 0);

735 
	`ok
(
sbuf
.
off
 != 0);

736 if (
check_ch
) {

737 
	`ok
(
	`ptls_get_server_name
(
server
) != 
NULL
);

738 
	`ok
(
	`strcmp
(
	`ptls_get_server_name
(
server
), "test.example.com") == 0);

739 
	`ok
(
	`ptls_get_negotiated_protocol
(
server
) != 
NULL
);

740 
	`ok
(
	`strcmp
(
	`ptls_get_negotiated_protocol
(
server
), "h2") == 0);

741 
	`ok
(
was_esni
 == (
ctx_peer
->
esni
 != 
NULL
));

743 
	`ok
(
	`ptls_get_server_name
(
server
) == 
NULL
);

744 
	`ok
(
	`ptls_get_negotiated_protocol
(
server
) == 
NULL
);

747 if (
mode
 == 
TEST_HANDSHAKE_EARLY_DATA
 && 
require_client_authentication
 == 0) {

748 
	`ok
(
consumed
 < 
cbuf
.
off
);

749 
	`memmove
(
cbuf
.
base
, cbuf.base + 
consumed
, cbuf.
off
 - consumed);

750 
cbuf
.
off
 -= 
consumed
;

752 
consumed
 = 
cbuf
.
off
;

753 
ret
 = 
	`ptls_receive
(
server
, &
decbuf
, 
cbuf
.
base
, &
consumed
);

754 
	`ok
(
ret
 == 0);

755 
	`ok
(
consumed
 == 
cbuf
.
off
);

756 
	`ok
(
decbuf
.
off
 == 
	`strlen
(
req
));

757 
	`ok
(
	`memcmp
(
decbuf
.
base
, 
req
, decbuf.
off
) == 0);

758 
	`ok
(!
	`ptls_handshake_is_complete
(
server
));

759 
cbuf
.
off
 = 0;

760 
decbuf
.
off
 = 0;

762 
ret
 = 
	`ptls_send
(
server
, &
sbuf
, 
resp
, 
	`strlen
(resp));

763 
	`ok
(
ret
 == 0);

765 
	`ok
(
consumed
 == 
cbuf
.
off
);

766 
cbuf
.
off
 = 0;

769 
consumed
 = 
sbuf
.
off
;

770 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
sbuf
.
base
, &
consumed
, 
NULL
);

771 
	`ok
(
ret
 == 0);

772 
	`ok
(
cbuf
.
off
 != 0);

773 if (
check_ch
) {

774 
	`ok
(
	`ptls_get_server_name
(
client
) != 
NULL
);

775 
	`ok
(
	`strcmp
(
	`ptls_get_server_name
(
client
), "test.example.com") == 0);

776 
	`ok
(
	`ptls_get_negotiated_protocol
(
client
) != 
NULL
);

777 
	`ok
(
	`strcmp
(
	`ptls_get_negotiated_protocol
(
client
), "h2") == 0);

779 
	`ok
(
	`ptls_get_server_name
(
server
) == 
NULL
);

780 
	`ok
(
	`ptls_get_negotiated_protocol
(
server
) == 
NULL
);

783 if (
expect_ticket
) {

784 
	`ok
(
consumed
 < 
sbuf
.
off
);

785 
	`memmove
(
sbuf
.
base
, sbuf.base + 
consumed
, sbuf.
off
 - consumed);

786 
sbuf
.
off
 -= 
consumed
;

788 
	`ok
(
consumed
 == 
sbuf
.
off
);

789 
sbuf
.
off
 = 0;

792 if (
require_client_authentication
 == 1) {

793 
	`ok
(!
	`ptls_handshake_is_complete
(
server
));

794 
consumed
 = 
cbuf
.
off
;

795 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
consumed
, &
server_hs_prop
);

796 
	`ok
(
ret
 == 0);

797 
	`ok
(
	`ptls_handshake_is_complete
(
server
));

798 
cbuf
.
off
 = 0;

801 if (
mode
 != 
TEST_HANDSHAKE_EARLY_DATA
 || 
require_client_authentication
 == 1) {

802 
ret
 = 
	`ptls_send
(
client
, &
cbuf
, 
req
, 
	`strlen
(req));

803 
	`ok
(
ret
 == 0);

805 
consumed
 = 
cbuf
.
off
;

806 
ret
 = 
	`ptls_receive
(
server
, &
decbuf
, 
cbuf
.
base
, &
consumed
);

807 
	`ok
(
ret
 == 0);

808 
	`ok
(
consumed
 == 
cbuf
.
off
);

809 
	`ok
(
decbuf
.
off
 == 
	`strlen
(
req
));

810 
	`ok
(
	`memcmp
(
decbuf
.
base
, 
req
, 
	`strlen
(req)) == 0);

811 
	`ok
(
	`ptls_handshake_is_complete
(
server
));

812 
decbuf
.
off
 = 0;

813 
cbuf
.
off
 = 0;

815 
ret
 = 
	`ptls_send
(
server
, &
sbuf
, 
resp
, 
	`strlen
(resp));

816 
	`ok
(
ret
 == 0);

819 
consumed
 = 
sbuf
.
off
;

820 
ret
 = 
	`ptls_receive
(
client
, &
decbuf
, 
sbuf
.
base
, &
consumed
);

821 
	`ok
(
ret
 == 0);

822 
	`ok
(
consumed
 == 
sbuf
.
off
);

823 
	`ok
(
decbuf
.
off
 == 
	`strlen
(
resp
));

824 
	`ok
(
	`memcmp
(
decbuf
.
base
, 
resp
, 
	`strlen
(resp)) == 0);

825 
	`ok
(
	`ptls_handshake_is_complete
(
client
));

826 
decbuf
.
off
 = 0;

827 
sbuf
.
off
 = 0;

829 if (
mode
 == 
TEST_HANDSHAKE_EARLY_DATA
) {

830 
consumed
 = 
cbuf
.
off
;

831 
ret
 = 
	`ptls_receive
(
server
, &
decbuf
, 
cbuf
.
base
, &
consumed
);

832 
	`ok
(
ret
 == 0);

833 
	`ok
(
cbuf
.
off
 == 
consumed
);

834 
	`ok
(
decbuf
.
off
 == 0);

835 
	`ok
(
	`ptls_handshake_is_complete
(
client
));

836 
cbuf
.
off
 = 0;

839 if (
mode
 == 
TEST_HANDSHAKE_KEY_UPDATE
) {

841 
ret
 = 
	`ptls_update_key
(
server
, 1);

842 
	`ok
(
ret
 == 0);

843 
	`ok
(
server
->
needs_key_update
);

844 
	`ok
(
server
->
key_update_send_request
);

845 
ret
 = 
	`ptls_send
(
server
, &
sbuf
, "good bye", 8);

846 
	`ok
(
ret
 == 0);

847 
	`ok
(!
server
->
needs_key_update
);

848 
	`ok
(!
server
->
key_update_send_request
);

849 
consumed
 = 
sbuf
.
off
;

850 
ret
 = 
	`ptls_receive
(
client
, &
decbuf
, 
sbuf
.
base
, &
consumed
);

851 
	`ok
(
ret
 == 0);

852 
	`ok
(
sbuf
.
off
 == 
consumed
);

853 
	`ok
(
decbuf
.
off
 == 8);

854 
	`ok
(
	`memcmp
(
decbuf
.
base
, "good bye", 8) == 0);

855 
	`ok
(
client
->
needs_key_update
);

856 
	`ok
(!
client
->
key_update_send_request
);

857 
sbuf
.
off
 = 0;

858 
decbuf
.
off
 = 0;

859 
ret
 = 
	`ptls_send
(
client
, &
cbuf
, "hello", 5);

860 
	`ok
(
ret
 == 0);

861 
consumed
 = 
cbuf
.
off
;

862 
ret
 = 
	`ptls_receive
(
server
, &
decbuf
, 
cbuf
.
base
, &
consumed
);

863 
	`ok
(
ret
 == 0);

864 
	`ok
(
cbuf
.
off
 == 
consumed
);

865 
	`ok
(
decbuf
.
off
 == 5);

866 
	`ok
(
	`memcmp
(
decbuf
.
base
, "hello", 5) == 0);

867 
cbuf
.
off
 = 0;

868 
decbuf
.
off
 = 0;

871 
	`ptls_buffer_dispose
(&
cbuf
);

872 
	`ptls_buffer_dispose
(&
sbuf
);

873 
	`ptls_buffer_dispose
(&
decbuf
);

874 
	`ptls_free
(
client
);

875 
	`ptls_free
(
server
);

877 if (
check_ch
)

878 
ctx_peer
->
on_client_hello
 = 
NULL
;

880 
ctx
->
verify_certificate
 = 
NULL
;

881 if (
require_client_authentication
)

882 
ctx_peer
->
require_client_authentication
 = 0;

883 
	}
}

885 static 
ptls_sign_certificate_t
 *
	gsc_orig
;

886 
size_t
 
	gsc_callcnt
;

888 static int 
	$sign_certificate
(
ptls_sign_certificate_t
 *
self
, 
ptls_t
 *
tls
, 
uint16_t
 *
selected_algorithm
, 
ptls_buffer_t
 *
output
,

889 
ptls_iovec_t
 
input
, const 
uint16_t
 *
algorithms
, 
size_t
 
num_algorithms
)

891 ++
sc_callcnt
;

892 return 
sc_orig
->
	`cb
(sc_orig, 
tls
, 
selected_algorithm
, 
output
, 
input
, 
algorithms
, 
num_algorithms
);

893 
	}
}

895 static 
ptls_sign_certificate_t
 *
	gsecond_sc_orig
;

897 static int 
	$second_sign_certificate
(
ptls_sign_certificate_t
 *
self
, 
ptls_t
 *
tls
, 
uint16_t
 *
selected_algorithm
, 
ptls_buffer_t
 *
output
,

898 
ptls_iovec_t
 
input
, const 
uint16_t
 *
algorithms
, 
size_t
 
num_algorithms
)

900 ++
sc_callcnt
;

901 return 
second_sc_orig
->
	`cb
(second_sc_orig, 
tls
, 
selected_algorithm
, 
output
, 
input
, 
algorithms
, 
num_algorithms
);

902 
	}
}

904 static void 
	$test_full_handshake_impl
(int 
require_client_authentication
)

906 
sc_callcnt
 = 0;

908 
	`test_handshake
(
	`ptls_iovec_init
(
NULL
, 0), 
TEST_HANDSHAKE_1RTT
, 0, 0, 
require_client_authentication
);

909 if (
require_client_authentication
) {

910 
	`ok
(
sc_callcnt
 == 2);

912 
	`ok
(
sc_callcnt
 == 1);

915 
	`test_handshake
(
	`ptls_iovec_init
(
NULL
, 0), 
TEST_HANDSHAKE_1RTT
, 0, 0, 
require_client_authentication
);

916 if (
require_client_authentication
) {

917 
	`ok
(
sc_callcnt
 == 4);

919 
	`ok
(
sc_callcnt
 == 2);

922 
	`test_handshake
(
	`ptls_iovec_init
(
NULL
, 0), 
TEST_HANDSHAKE_1RTT
, 0, 1, 
require_client_authentication
);

923 if (
require_client_authentication
) {

924 
	`ok
(
sc_callcnt
 == 6);

926 
	`ok
(
sc_callcnt
 == 3);

928 
	}
}

930 static void 
	$test_full_handshake
(void)

932 
	`test_full_handshake_impl
(0);

933 
	}
}

935 static void 
	$test_full_handshake_with_client_authentication
(void)

937 
	`test_full_handshake_impl
(1);

938 
	}
}

940 static void 
	$test_key_update
(void)

942 
	`test_handshake
(
	`ptls_iovec_init
(
NULL
, 0), 
TEST_HANDSHAKE_KEY_UPDATE
, 0, 0, 0);

943 
	}
}

945 static void 
	$test_hrr_handshake
(void)

947 
sc_callcnt
 = 0;

948 
	`test_handshake
(
	`ptls_iovec_init
(
NULL
, 0), 
TEST_HANDSHAKE_HRR
, 0, 0, 0);

949 
	`ok
(
sc_callcnt
 == 1);

950 
	}
}

952 static void 
	$test_hrr_stateless_handshake
(void)

954 
sc_callcnt
 = 0;

955 
	`test_handshake
(
	`ptls_iovec_init
(
NULL
, 0), 
TEST_HANDSHAKE_HRR_STATELESS
, 0, 0, 0);

956 
	`ok
(
sc_callcnt
 == 1);

957 
	}
}

959 static int 
	$on_copy_ticket
(
ptls_encrypt_ticket_t
 *
self
, 
ptls_t
 *
tls
, int 
is_encrypt
, 
ptls_buffer_t
 *
dst
, 
ptls_iovec_t
 
src
)

961 int 
ret
;

963 if ((
ret
 = 
	`ptls_buffer_reserve
(
dst
, 
src
.
len
)) != 0)

964 return 
ret
;

965 
	`memcpy
(
dst
->
base
 + dst->
off
, 
src
.base, src.
len
);

966 
dst
->
off
 += 
src
.
len
;

969 
	}
}

971 static 
ptls_iovec_t
 
	gsaved_ticket
 = {
NULL
};

973 static int 
	$on_save_ticket
(
ptls_save_ticket_t
 *
self
, 
ptls_t
 *
tls
, 
ptls_iovec_t
 
src
)

975 
saved_ticket
.
base
 = 
	`malloc
(
src
.
len
);

976 
	`memcpy
(
saved_ticket
.
base
, 
src
.base, src.
len
);

977 
saved_ticket
.
len
 = 
src
.len;

979 
	}
}

981 static void 
	$test_resumption_impl
(int 
different_preferred_key_share
, int 
require_client_authentication
)

983 
	`assert
(
ctx
->
key_exchanges
[0]->
id
 == 
ctx_peer
->key_exchanges[0]->id);

984 
	`assert
(
ctx
->
key_exchanges
[1] == 
NULL
);

985 
	`assert
(
ctx_peer
->
key_exchanges
[1] == 
NULL
);

986 
	`assert
(
ctx
->
key_exchanges
[0]->
id
 != 
ptls_minicrypto_x25519
.id);

987 
ptls_key_exchange_algorithm_t
 *
different_key_exchanges
[] = {&
ptls_minicrypto_x25519
, 
ctx
->
key_exchanges
[0], 
NULL
},

988 **
key_exchanges_orig
 = 
ctx
->
key_exchanges
;

990 if (
different_preferred_key_share
)

991 
ctx
->
key_exchanges
 = 
different_key_exchanges
;

993 
ptls_encrypt_ticket_t
 
et
 = {
on_copy_ticket
};

994 
ptls_save_ticket_t
 
st
 = {
on_save_ticket
};

996 
	`assert
(
ctx_peer
->
ticket_lifetime
 == 0);

997 
	`assert
(
ctx_peer
->
max_early_data_size
 == 0);

998 
	`assert
(
ctx_peer
->
encrypt_ticket
 == 
NULL
);

999 
	`assert
(
ctx_peer
->
save_ticket
 == 
NULL
);

1000 
saved_ticket
 = 
	`ptls_iovec_init
(
NULL
, 0);

1002 
ctx_peer
->
ticket_lifetime
 = 86400;

1003 
ctx_peer
->
max_early_data_size
 = 8192;

1004 
ctx_peer
->
encrypt_ticket
 = &
et
;

1005 
ctx
->
save_ticket
 = &
st
;

1007 
sc_callcnt
 = 0;

1008 
	`test_handshake
(
saved_ticket
, 
different_preferred_key_share
 ? 
TEST_HANDSHAKE_2RTT
 : 
TEST_HANDSHAKE_1RTT
, 1, 0, 0);

1009 
	`ok
(
sc_callcnt
 == 1);

1010 
	`ok
(
saved_ticket
.
base
 != 
NULL
);

1013 
	`test_handshake
(
saved_ticket
, 
TEST_HANDSHAKE_1RTT
, 1, 0, 
require_client_authentication
);

1014 if (
require_client_authentication
 == 1) {

1015 
	`ok
(
sc_callcnt
 == 3);

1017 
	`ok
(
sc_callcnt
 == 1);

1021 
	`test_handshake
(
saved_ticket
, 
TEST_HANDSHAKE_EARLY_DATA
, 1, 0, 
require_client_authentication
);

1022 if (
require_client_authentication
 == 1) {

1023 
	`ok
(
sc_callcnt
 == 5);

1025 
	`ok
(
sc_callcnt
 == 1);

1028 
ctx
->
require_dhe_on_psk
 = 1;

1031 
	`test_handshake
(
saved_ticket
, 
TEST_HANDSHAKE_1RTT
, 1, 0, 
require_client_authentication
);

1032 if (
require_client_authentication
 == 1) {

1033 
	`ok
(
sc_callcnt
 == 7);

1035 
	`ok
(
sc_callcnt
 == 1);

1039 
	`test_handshake
(
saved_ticket
, 
TEST_HANDSHAKE_EARLY_DATA
, 1, 0, 
require_client_authentication
);

1040 if (
require_client_authentication
 == 1) {

1041 
	`ok
(
sc_callcnt
 == 9);

1043 
	`ok
(
sc_callcnt
 == 1);

1046 
ctx
->
require_dhe_on_psk
 = 0;

1047 
ctx_peer
->
ticket_lifetime
 = 0;

1048 
ctx_peer
->
max_early_data_size
 = 0;

1049 
ctx_peer
->
encrypt_ticket
 = 
NULL
;

1050 
ctx
->
save_ticket
 = 
NULL
;

1051 
ctx
->
key_exchanges
 = 
key_exchanges_orig
;

1052 
	}
}

1054 static void 
	$test_resumption
(void)

1056 
	`test_resumption_impl
(0, 0);

1057 
	}
}

1059 static void 
	$test_resumption_different_preferred_key_share
(void)

1061 if (
ctx
 == 
ctx_peer
)

1063 
	`test_resumption_impl
(1, 0);

1064 
	}
}

1066 static void 
	$test_resumption_with_client_authentication
(void)

1068 
	`test_resumption_impl
(0, 1);

1069 
	}
}

1071 static void 
	$test_enforce_retry
(int 
use_cookie
)

1073 
ptls_t
 *
client
, *
server
;

1074 
ptls_handshake_properties_t
 
server_hs_prop
 = {{{{
NULL
}}}};

1075 
ptls_buffer_t
 
cbuf
, 
sbuf
, 
decbuf
;

1076 
size_t
 
consumed
;

1077 int 
ret
;

1079 
server_hs_prop
.
server
.
cookie
.
key
 = "0123456789abcdef0123456789abcdef0123456789abcdef";

1080 
server_hs_prop
.
server
.
cookie
.
additional_data
 = 
	`ptls_iovec_init
("1.2.3.4:1234", 12);

1081 
server_hs_prop
.
server
.
enforce_retry
 = 1;

1082 
server_hs_prop
.
server
.
retry_uses_cookie
 = 
use_cookie
;

1084 
	`ptls_buffer_init
(&
cbuf
, "", 0);

1085 
	`ptls_buffer_init
(&
sbuf
, "", 0);

1086 
	`ptls_buffer_init
(&
decbuf
, "", 0);

1088 
client
 = 
	`ptls_new
(
ctx
, 0);

1090 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
NULL
, NULL, NULL);

1091 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1092 
	`ok
(
cbuf
.
off
 != 0);

1094 
server
 = 
	`ptls_new
(
ctx
, 1);

1096 
consumed
 = 
cbuf
.
off
;

1097 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
consumed
, &
server_hs_prop
);

1098 
cbuf
.
off
 = 0;

1100 if (
use_cookie
) {

1101 
	`ok
(
ret
 == 
PTLS_ERROR_STATELESS_RETRY
);

1102 
	`ptls_free
(
server
);

1103 
server
 = 
	`ptls_new
(
ctx
, 1);

1105 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1108 
consumed
 = 
sbuf
.
off
;

1109 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
sbuf
.
base
, &
consumed
, 
NULL
);

1110 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1111 
	`ok
(
sbuf
.
off
 == 
consumed
);

1112 
sbuf
.
off
 = 0;

1114 
consumed
 = 
cbuf
.
off
;

1115 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
consumed
, &
server_hs_prop
);

1116 
	`ok
(
ret
 == 0);

1117 
	`ok
(
cbuf
.
off
 == 
consumed
);

1118 
cbuf
.
off
 = 0;

1120 
consumed
 = 
sbuf
.
off
;

1121 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
sbuf
.
base
, &
consumed
, 
NULL
);

1122 
	`ok
(
ret
 == 0);

1123 
	`ok
(
sbuf
.
off
 == 
consumed
);

1124 
sbuf
.
off
 = 0;

1126 
ret
 = 
	`ptls_send
(
client
, &
cbuf
, "hello world", 11);

1127 
	`ok
(
ret
 == 0);

1129 
consumed
 = 
cbuf
.
off
;

1130 
ret
 = 
	`ptls_receive
(
server
, &
decbuf
, 
cbuf
.
base
, &
consumed
);

1131 
	`ok
(
ret
 == 0);

1132 
	`ok
(
cbuf
.
off
 == 
consumed
);

1133 
cbuf
.
off
 = 0;

1135 
	`ok
(
decbuf
.
off
 == 11);

1136 
	`ok
(
	`memcmp
(
decbuf
.
base
, "hello world", 11) == 0);

1137 
decbuf
.
off
 = 0;

1139 
	`ptls_free
(
client
);

1140 
	`ptls_free
(
server
);

1142 
	`ptls_buffer_dispose
(&
cbuf
);

1143 
	`ptls_buffer_dispose
(&
sbuf
);

1144 
	`ptls_buffer_dispose
(&
decbuf
);

1145 
	}
}

1147 static void 
	$test_enforce_retry_stateful
(void)

1149 
	`test_enforce_retry
(0);

1150 
	}
}

1152 static void 
	$test_enforce_retry_stateless
(void)

1154 
	`test_enforce_retry
(1);

1155 
	}
}

1157 static 
ptls_t
 *
	$stateless_hrr_prepare
(
ptls_buffer_t
 *
sbuf
, 
ptls_handshake_properties_t
 *
server_hs_prop
)

1159 
ptls_t
 *
client
 = 
	`ptls_new
(
ctx
, 0), *
server
 = ptls_new(
ctx_peer
, 1);

1160 
ptls_buffer_t
 
cbuf
;

1161 
size_t
 
consumed
;

1162 int 
ret
;

1164 
	`ptls_buffer_init
(&
cbuf
, "", 0);

1165 
	`ptls_buffer_init
(
sbuf
, "", 0);

1167 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
NULL
, NULL, NULL);

1168 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1170 
consumed
 = 
cbuf
.
off
;

1171 
ret
 = 
	`ptls_handshake
(
server
, 
sbuf
, 
cbuf
.
base
, &
consumed
, 
server_hs_prop
);

1172 
	`ok
(
ret
 == 
PTLS_ERROR_STATELESS_RETRY
);

1174 
	`ptls_buffer_dispose
(&
cbuf
);

1175 
	`ptls_free
(
server
);

1177 return 
client
;

1178 
	}
}

1180 static void 
	$test_stateless_hrr_aad_change
(void)

1182 
ptls_t
 *
client
, *
server
;

1183 
ptls_handshake_properties_t
 
server_hs_prop
 = {{{{
NULL
}}}};

1184 
ptls_buffer_t
 
cbuf
, 
sbuf
;

1185 
size_t
 
consumed
;

1186 int 
ret
;

1188 
server_hs_prop
.
server
.
cookie
.
key
 = "0123456789abcdef0123456789abcdef0123456789abcdef";

1189 
server_hs_prop
.
server
.
cookie
.
additional_data
 = 
	`ptls_iovec_init
("1.2.3.4:1234", 12);

1190 
server_hs_prop
.
server
.
enforce_retry
 = 1;

1191 
server_hs_prop
.
server
.
retry_uses_cookie
 = 1;

1193 
client
 = 
	`stateless_hrr_prepare
(&
sbuf
, &
server_hs_prop
);

1194 
	`ptls_buffer_init
(&
cbuf
, "", 0);

1196 
consumed
 = 
sbuf
.
off
;

1197 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
sbuf
.
base
, &
consumed
, 
NULL
);

1198 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1199 
	`ok
(
sbuf
.
off
 == 
consumed
);

1200 
sbuf
.
off
 = 0;

1202 
server
 = 
	`ptls_new
(
ctx_peer
, 1);

1203 
server_hs_prop
.
server
.
cookie
.
additional_data
 = 
	`ptls_iovec_init
("1.2.3.4:4321", 12);

1205 
consumed
 = 
cbuf
.
off
;

1206 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
consumed
, &
server_hs_prop
);

1207 
	`ok
(
ret
 == 
PTLS_ALERT_HANDSHAKE_FAILURE
);

1209 
	`ptls_free
(
client
);

1210 
	`ptls_free
(
server
);

1212 
	`ptls_buffer_dispose
(&
cbuf
);

1213 
	`ptls_buffer_dispose
(&
sbuf
);

1214 
	}
}

1216 typedef 
uint8_t
 
	ttraffic_secrets_t
[2 ][4 ][
PTLS_MAX_DIGEST_SIZE
 ];

1218 static int 
	$on_update_traffic_key
(
ptls_update_traffic_key_t
 *
self
, 
ptls_t
 *
tls
, int 
is_enc
, 
size_t
 
epoch
, const void *
secret
)

1220 
traffic_secrets_t
 *
secrets
 = *
	`ptls_get_data_ptr
(
tls
);

1221 
	`ok
(
	`memcmp
((*
secrets
)[
is_enc
][
epoch
], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) == 0);

1223 
size_t
 
size
 = 
	`ptls_get_cipher
(
tls
)->
hash
->
digest_size
;

1224 
	`memcpy
((*
secrets
)[
is_enc
][
epoch
], 
secret
, 
size
);

1226 
	}
}

1228 static int 
	$feed_messages
(
ptls_t
 *
tls
, 
ptls_buffer_t
 *
outbuf
, 
size_t
 *
out_epoch_offsets
, const 
uint8_t
 *
input
,

1229 const 
size_t
 *
in_epoch_offsets
, 
ptls_handshake_properties_t
 *
props
)

1231 
size_t
 
i
;

1232 int 
ret
 = 
PTLS_ERROR_IN_PROGRESS
;

1234 
outbuf
->
off
 = 0;

1235 
	`memset
(
out_epoch_offsets
, 0, sizeof(*out_epoch_offsets) * 5);

1237 for (
i
 = 0; i != 4; ++i) {

1238 
size_t
 
len
 = 
in_epoch_offsets
[
i
 + 1] - in_epoch_offsets[i];

1239 if (
len
 != 0) {

1240 
ret
 = 
	`ptls_handle_message
(
tls
, 
outbuf
, 
out_epoch_offsets
, 
i
, 
input
 + 
in_epoch_offsets
[i], 
len
, 
props
);

1241 if (!(
ret
 == 0 || ret == 
PTLS_ERROR_IN_PROGRESS
))

1246 return 
ret
;

1247 
	}
}

1249 static void 
	$test_handshake_api
(void)

1251 
ptls_t
 *
client
, *
server
;

1252 
traffic_secrets_t
 
client_secrets
 = {{{0}}}, 
server_secrets
 = {{{0}}};

1253 
ptls_buffer_t
 
cbuf
, 
sbuf
;

1254 
size_t
 
coffs
[5] = {0}, 
soffs
[5];

1255 
ptls_update_traffic_key_t
 
update_traffic_key
 = {
on_update_traffic_key
};

1256 
ptls_encrypt_ticket_t
 
encrypt_ticket
 = {
on_copy_ticket
};

1257 
ptls_save_ticket_t
 
save_ticket
 = {
on_save_ticket
};

1258 int 
ret
;

1260 
ctx
->
update_traffic_key
 = &update_traffic_key;

1261 
ctx
->
omit_end_of_early_data
 = 1;

1262 
ctx
->
save_ticket
 = &save_ticket;

1263 
ctx_peer
->
update_traffic_key
 = &update_traffic_key;

1264 
ctx_peer
->
omit_end_of_early_data
 = 1;

1265 
ctx_peer
->
encrypt_ticket
 = &encrypt_ticket;

1266 
ctx_peer
->
ticket_lifetime
 = 86400;

1267 
ctx_peer
->
max_early_data_size
 = 8192;

1269 
saved_ticket
 = 
	`ptls_iovec_init
(
NULL
, 0);

1271 
	`ptls_buffer_init
(&
cbuf
, "", 0);

1272 
	`ptls_buffer_init
(&
sbuf
, "", 0);

1274 
client
 = 
	`ptls_new
(
ctx
, 0);

1275 *
	`ptls_get_data_ptr
(
client
) = &
client_secrets
;

1276 
server
 = 
	`ptls_new
(
ctx_peer
, 1);

1277 *
	`ptls_get_data_ptr
(
server
) = &
server_secrets
;

1280 
ret
 = 
	`ptls_handle_message
(
client
, &
cbuf
, 
coffs
, 0, 
NULL
, 0, NULL);

1281 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1282 
ret
 = 
	`feed_messages
(
server
, &
sbuf
, 
soffs
, 
cbuf
.
base
, 
coffs
, 
NULL
);

1283 
	`ok
(
ret
 == 0);

1284 
	`ok
(
sbuf
.
off
 != 0);

1285 
	`ok
(!
	`ptls_handshake_is_complete
(
server
));

1286 
	`ok
(
	`memcmp
(
server_secrets
[1][2], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1287 
	`ok
(
	`memcmp
(
server_secrets
[1][3], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1288 
	`ok
(
	`memcmp
(
server_secrets
[0][2], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1289 
	`ok
(
	`memcmp
(
server_secrets
[0][3], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) == 0);

1290 
ret
 = 
	`feed_messages
(
client
, &
cbuf
, 
coffs
, 
sbuf
.
base
, 
soffs
, 
NULL
);

1291 
	`ok
(
ret
 == 0);

1292 
	`ok
(
cbuf
.
off
 != 0);

1293 
	`ok
(
	`ptls_handshake_is_complete
(
client
));

1294 
	`ok
(
	`memcmp
(
client_secrets
[0][2], 
server_secrets
[1][2], 
PTLS_MAX_DIGEST_SIZE
) == 0);

1295 
	`ok
(
	`memcmp
(
client_secrets
[1][2], 
server_secrets
[0][2], 
PTLS_MAX_DIGEST_SIZE
) == 0);

1296 
	`ok
(
	`memcmp
(
client_secrets
[0][3], 
server_secrets
[1][3], 
PTLS_MAX_DIGEST_SIZE
) == 0);

1297 
	`ok
(
	`memcmp
(
client_secrets
[1][3], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1298 
ret
 = 
	`feed_messages
(
server
, &
sbuf
, 
soffs
, 
cbuf
.
base
, 
coffs
, 
NULL
);

1299 
	`ok
(
ret
 == 0);

1300 
	`ok
(
sbuf
.
off
 == 0);

1301 
	`ok
(
	`ptls_handshake_is_complete
(
server
));

1302 
	`ok
(
	`memcmp
(
client_secrets
[1][3], 
server_secrets
[0][3], 
PTLS_MAX_DIGEST_SIZE
) == 0);

1304 
	`ptls_free
(
client
);

1305 
	`ptls_free
(
server
);

1307 
cbuf
.
off
 = 0;

1308 
sbuf
.
off
 = 0;

1309 
	`memset
(
client_secrets
, 0, sizeof(client_secrets));

1310 
	`memset
(
server_secrets
, 0, sizeof(server_secrets));

1311 
	`memset
(
coffs
, 0, sizeof(coffs));

1312 
	`memset
(
soffs
, 0, sizeof(soffs));

1314 
ctx
->
save_ticket
 = 
NULL
;

1317 
size_t
 
max_early_data_size
 = 0;

1318 
ptls_handshake_properties_t
 
client_hs_prop
 = {{{{
NULL
}, 
saved_ticket
, &
max_early_data_size
}}};

1319 
client
 = 
	`ptls_new
(
ctx
, 0);

1320 *
	`ptls_get_data_ptr
(
client
) = &
client_secrets
;

1321 
server
 = 
	`ptls_new
(
ctx_peer
, 1);

1322 *
	`ptls_get_data_ptr
(
server
) = &
server_secrets
;

1323 
ret
 = 
	`ptls_handle_message
(
client
, &
cbuf
, 
coffs
, 0, 
NULL
, 0, &
client_hs_prop
);

1324 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1325 
	`ok
(
max_early_data_size
 != 0);

1326 
	`ok
(
	`memcmp
(
client_secrets
[1][1], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1327 
ret
 = 
	`feed_messages
(
server
, &
sbuf
, 
soffs
, 
cbuf
.
base
, 
coffs
, 
NULL
);

1328 
	`ok
(
ret
 == 0);

1329 
	`ok
(
sbuf
.
off
 != 0);

1330 
	`ok
(!
	`ptls_handshake_is_complete
(
server
));

1331 
	`ok
(
	`memcmp
(
client_secrets
[1][1], 
server_secrets
[0][1], 
PTLS_MAX_DIGEST_SIZE
) == 0);

1332 
	`ok
(
	`memcmp
(
server_secrets
[0][2], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1333 
	`ok
(
	`memcmp
(
server_secrets
[1][2], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1334 
	`ok
(
	`memcmp
(
server_secrets
[1][3], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1335 
	`ok
(
	`memcmp
(
server_secrets
[0][3], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) == 0);

1336 
ret
 = 
	`feed_messages
(
client
, &
cbuf
, 
coffs
, 
sbuf
.
base
, 
soffs
, &
client_hs_prop
);

1337 
	`ok
(
ret
 == 0);

1338 
	`ok
(
cbuf
.
off
 != 0);

1339 
	`ok
(
	`ptls_handshake_is_complete
(
client
));

1340 
	`ok
(
	`memcmp
(
client_secrets
[0][3], 
server_secrets
[1][3], 
PTLS_MAX_DIGEST_SIZE
) == 0);

1341 
	`ok
(
	`memcmp
(
client_secrets
[1][3], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1342 
ret
 = 
	`feed_messages
(
server
, &
sbuf
, 
soffs
, 
cbuf
.
base
, 
coffs
, 
NULL
);

1343 
	`ok
(
ret
 == 0);

1344 
	`ok
(
sbuf
.
off
 == 0);

1345 
	`ok
(
	`ptls_handshake_is_complete
(
server
));

1346 
	`ok
(
	`memcmp
(
server_secrets
[0][3], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1348 
	`ptls_free
(
client
);

1349 
	`ptls_free
(
server
);

1351 
cbuf
.
off
 = 0;

1352 
sbuf
.
off
 = 0;

1353 
	`memset
(
client_secrets
, 0, sizeof(client_secrets));

1354 
	`memset
(
server_secrets
, 0, sizeof(server_secrets));

1355 
	`memset
(
coffs
, 0, sizeof(coffs));

1356 
	`memset
(
soffs
, 0, sizeof(soffs));

1359 
ctx_peer
->
max_early_data_size
 = 0;

1360 
client_hs_prop
 = (
ptls_handshake_properties_t
){{{{
NULL
}, 
saved_ticket
, &
max_early_data_size
}}};

1361 
client
 = 
	`ptls_new
(
ctx
, 0);

1362 *
	`ptls_get_data_ptr
(
client
) = &
client_secrets
;

1363 
server
 = 
	`ptls_new
(
ctx_peer
, 1);

1364 *
	`ptls_get_data_ptr
(
server
) = &
server_secrets
;

1365 
ret
 = 
	`ptls_handle_message
(
client
, &
cbuf
, 
coffs
, 0, 
NULL
, 0, &
client_hs_prop
);

1366 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1367 
	`ok
(
max_early_data_size
 != 0);

1368 
	`ok
(
	`memcmp
(
client_secrets
[1][1], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1369 
ret
 = 
	`feed_messages
(
server
, &
sbuf
, 
soffs
, 
cbuf
.
base
, 
coffs
, 
NULL
);

1370 
	`ok
(
ret
 == 0);

1371 
	`ok
(
sbuf
.
off
 != 0);

1372 
	`ok
(!
	`ptls_handshake_is_complete
(
server
));

1373 
ret
 = 
	`feed_messages
(
client
, &
cbuf
, 
coffs
, 
sbuf
.
base
, 
soffs
, &
client_hs_prop
);

1374 
	`ok
(
ret
 == 0);

1375 
	`ok
(
cbuf
.
off
 != 0);

1376 
	`ok
(
	`ptls_handshake_is_complete
(
client
));

1377 
	`ok
(
client_hs_prop
.
client
.
early_data_acceptance
 == 
PTLS_EARLY_DATA_REJECTED
);

1378 
	`ok
(
	`memcmp
(
server_secrets
[0][1], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) == 0);

1379 
ret
 = 
	`feed_messages
(
server
, &
sbuf
, 
soffs
, 
cbuf
.
base
, 
coffs
, 
NULL
);

1380 
	`ok
(
ret
 == 0);

1381 
	`ok
(
sbuf
.
off
 == 0);

1382 
	`ok
(
	`ptls_handshake_is_complete
(
server
));

1384 
	`ptls_free
(
client
);

1385 
	`ptls_free
(
server
);

1387 
cbuf
.
off
 = 0;

1388 
sbuf
.
off
 = 0;

1389 
	`memset
(
client_secrets
, 0, sizeof(client_secrets));

1390 
	`memset
(
server_secrets
, 0, sizeof(server_secrets));

1391 
	`memset
(
coffs
, 0, sizeof(coffs));

1392 
	`memset
(
soffs
, 0, sizeof(soffs));

1395 
ctx_peer
->
max_early_data_size
 = 8192;

1396 
ptls_handshake_properties_t
 
server_hs_prop
 = {{{{
NULL
}}}};

1397 
server_hs_prop
.
server
.
enforce_retry
 = 1;

1398 
client_hs_prop
 = (
ptls_handshake_properties_t
){{{{
NULL
}, 
saved_ticket
, &
max_early_data_size
}}};

1399 
client
 = 
	`ptls_new
(
ctx
, 0);

1400 *
	`ptls_get_data_ptr
(
client
) = &
client_secrets
;

1401 
server
 = 
	`ptls_new
(
ctx_peer
, 1);

1402 *
	`ptls_get_data_ptr
(
server
) = &
server_secrets
;

1403 
ret
 = 
	`ptls_handle_message
(
client
, &
cbuf
, 
coffs
, 0, 
NULL
, 0, &
client_hs_prop
);

1404 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1405 
	`ok
(
max_early_data_size
 != 0);

1406 
	`ok
(
	`memcmp
(
client_secrets
[1][1], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) != 0);

1407 
ret
 = 
	`feed_messages
(
server
, &
sbuf
, 
soffs
, 
cbuf
.
base
, 
coffs
, &
server_hs_prop
);

1408 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1409 
	`ok
(
sbuf
.
off
 != 0);

1410 
	`ok
(!
	`ptls_handshake_is_complete
(
server
));

1411 
ret
 = 
	`feed_messages
(
client
, &
cbuf
, 
coffs
, 
sbuf
.
base
, 
soffs
, &
client_hs_prop
);

1412 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1413 
	`ok
(
cbuf
.
off
 != 0);

1414 
	`ok
(!
	`ptls_handshake_is_complete
(
client
));

1415 
	`ok
(
client_hs_prop
.
client
.
early_data_acceptance
 == 
PTLS_EARLY_DATA_REJECTED
);

1416 
ret
 = 
	`feed_messages
(
server
, &
sbuf
, 
soffs
, 
cbuf
.
base
, 
coffs
, &
server_hs_prop
);

1417 
	`ok
(
ret
 == 0);

1418 
	`ok
(!
	`ptls_handshake_is_complete
(
server
));

1419 
	`ok
(
	`memcmp
(
server_secrets
[0][1], 
zeroes_of_max_digest_size
, 
PTLS_MAX_DIGEST_SIZE
) == 0);

1420 
	`ok
(
sbuf
.
off
 != 0);

1421 
ret
 = 
	`feed_messages
(
client
, &
cbuf
, 
coffs
, 
sbuf
.
base
, 
soffs
, &
client_hs_prop
);

1422 
	`ok
(
ret
 == 0);

1423 
	`ok
(
	`ptls_handshake_is_complete
(
client
));

1424 
	`ok
(
cbuf
.
off
 != 0);

1425 
ret
 = 
	`feed_messages
(
server
, &
sbuf
, 
soffs
, 
cbuf
.
base
, 
coffs
, &
server_hs_prop
);

1426 
	`ok
(
ret
 == 0);

1427 
	`ok
(
	`ptls_handshake_is_complete
(
server
));

1429 
	`ptls_free
(
client
);

1430 
	`ptls_free
(
server
);

1432 
cbuf
.
off
 = 0;

1433 
sbuf
.
off
 = 0;

1436 
ctx
->
update_traffic_key
 = 
NULL
;

1437 
ctx
->
omit_end_of_early_data
 = 0;

1438 
ctx_peer
->
update_traffic_key
 = 
NULL
;

1439 
ctx_peer
->
omit_end_of_early_data
 = 0;

1440 
client_hs_prop
 = (
ptls_handshake_properties_t
){{{{
NULL
}, 
saved_ticket
, &
max_early_data_size
}}};

1441 
server_hs_prop
 = (
ptls_handshake_properties_t
){{{{
NULL
}}}};

1442 
server_hs_prop
.
server
.
enforce_retry
 = 1;

1443 
client
 = 
	`ptls_new
(
ctx
, 0);

1444 
server
 = 
	`ptls_new
(
ctx_peer
, 1);

1445 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
NULL
, NULL, &
client_hs_prop
);

1446 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1447 
	`ok
(
client_hs_prop
.
client
.
max_early_data_size
 != 0);

1448 
	`ok
(
client_hs_prop
.
client
.
early_data_acceptance
 == 
PTLS_EARLY_DATA_ACCEPTANCE_UNKNOWN
);

1449 
	`ok
(
cbuf
.
off
 != 0);

1450 
ret
 = 
	`ptls_send
(
client
, &
cbuf
, "hello world", 11);

1451 
	`ok
(
ret
 == 0);

1452 
size_t
 
inlen
 = 
cbuf
.
off
;

1453 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
inlen
, &
server_hs_prop
);

1454 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1455 
	`ok
(
cbuf
.
off
 == 
inlen
);

1456 
cbuf
.
off
 = 0;

1457 
	`ok
(
sbuf
.
off
 != 0);

1458 
inlen
 = 
sbuf
.
off
;

1459 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
sbuf
.
base
, &
inlen
, &
client_hs_prop
);

1460 
	`ok
(
ret
 == 
PTLS_ERROR_IN_PROGRESS
);

1461 
	`ok
(
client_hs_prop
.
client
.
early_data_acceptance
 == 
PTLS_EARLY_DATA_REJECTED
);

1462 
	`ok
(
sbuf
.
off
 == 
inlen
);

1463 
sbuf
.
off
 = 0;

1464 
	`ok
(
cbuf
.
off
 != 0);

1465 
inlen
 = 
cbuf
.
off
;

1466 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
inlen
, &
server_hs_prop
);

1467 
	`ok
(
ret
 == 0);

1468 
	`ok
(!
	`ptls_handshake_is_complete
(
server
));

1469 
	`ok
(
cbuf
.
off
 == 
inlen
);

1470 
cbuf
.
off
 = 0;

1471 
	`ok
(
sbuf
.
off
 != 0);

1472 
inlen
 = 
sbuf
.
off
;

1473 
ret
 = 
	`ptls_handshake
(
client
, &
cbuf
, 
sbuf
.
base
, &
inlen
, &
client_hs_prop
);

1474 
	`ok
(
ret
 == 0);

1475 
	`ok
(
	`ptls_handshake_is_complete
(
client
));

1476 
	`ok
(
inlen
 < 
sbuf
.
off
);

1477 
sbuf
.
off
 = 0;

1478 
inlen
 = 
cbuf
.
off
;

1479 
ret
 = 
	`ptls_handshake
(
server
, &
sbuf
, 
cbuf
.
base
, &
inlen
, &
server_hs_prop
);

1480 
	`ok
(
ret
 == 0);

1481 
	`ok
(
	`ptls_handshake_is_complete
(
server
));

1482 
	`ok
(
sbuf
.
off
 == 0);

1484 
	`ptls_free
(
client
);

1485 
	`ptls_free
(
server
);

1487 
	`ptls_buffer_dispose
(&
cbuf
);

1488 
	`ptls_buffer_dispose
(&
sbuf
);

1490 
ctx
->
update_traffic_key
 = 
NULL
;

1491 
ctx
->
omit_end_of_early_data
 = 0;

1492 
ctx
->
save_ticket
 = 
NULL
;

1493 
ctx_peer
->
update_traffic_key
 = 
NULL
;

1494 
ctx_peer
->
omit_end_of_early_data
 = 0;

1495 
ctx_peer
->
encrypt_ticket
 = 
NULL
;

1496 
ctx_peer
->
save_ticket
 = 
NULL
;

1497 
ctx_peer
->
ticket_lifetime
 = 0;

1498 
ctx_peer
->
max_early_data_size
 = 0;

1499 
	}
}

1501 static void 
	$test_all_handshakes
(void)

1503 
ptls_sign_certificate_t
 
server_sc
 = {
sign_certificate
};

1504 
sc_orig
 = 
ctx_peer
->
sign_certificate
;

1505 
ctx_peer
->
sign_certificate
 = &
server_sc
;

1507 
ptls_sign_certificate_t
 
client_sc
 = {
second_sign_certificate
};

1508 if (
ctx_peer
 != 
ctx
) {

1509 
second_sc_orig
 = 
ctx
->
sign_certificate
;

1510 
ctx
->
sign_certificate
 = &
client_sc
;

1513 
	`subtest
("full-handshake", 
test_full_handshake
);

1514 
	`subtest
("full-handshake-with-client-authentication", 
test_full_handshake_with_client_authentication
);

1515 
	`subtest
("hrr-handshake", 
test_hrr_handshake
);

1516 
	`subtest
("hrr-stateless-handshake", 
test_hrr_stateless_handshake
);

1517 
	`subtest
("resumption", 
test_resumption
);

1518 
	`subtest
("resumption-different-preferred-key-share", 
test_resumption_different_preferred_key_share
);

1519 
	`subtest
("resumption-with-client-authentication", 
test_resumption_with_client_authentication
);

1521 
	`subtest
("enforce-retry-stateful", 
test_enforce_retry_stateful
);

1522 
	`subtest
("enforce-retry-stateless", 
test_enforce_retry_stateless
);

1524 
	`subtest
("stateless-hrr-aad-change", 
test_stateless_hrr_aad_change
);

1526 
	`subtest
("key-update", 
test_key_update
);

1528 
	`subtest
("handshake-api", 
test_handshake_api
);

1530 
ctx_peer
->
sign_certificate
 = 
sc_orig
;

1532 if (
ctx_peer
 != 
ctx
)

1533 
ctx
->
sign_certificate
 = 
second_sc_orig
;

1534 
	}
}

1536 static void 
	$test_quicint
(void)

1538 #define 
	#CHECK_PATTERN
(
output
, ...) \

1540 const 
uint8_t
 
pat
[] = {
__VA_ARGS__
}, *
p
 = pat; \

1541 
	`ok
(
output
 == 
	`ptls_decode_quicint
(&
p
, 
pat
 + sizeof(pat))); \

1542 
	`ok
(
p
 == 
pat
 + sizeof(pat)); \

1543 } while (0)

	)

1544 
	`CHECK_PATTERN
(0, 0);

1545 
	`CHECK_PATTERN
(0, 0x40, 0);

1546 
	`CHECK_PATTERN
(0, 0x80, 0, 0, 0);

1547 
	`CHECK_PATTERN
(0, 0xc0, 0, 0, 0, 0, 0, 0, 0);

1548 
	`CHECK_PATTERN
(9, 9);

1549 
	`CHECK_PATTERN
(9, 0x40, 9);

1550 
	`CHECK_PATTERN
(9, 0x80, 0, 0, 9);

1551 
	`CHECK_PATTERN
(9, 0xc0, 0, 0, 0, 0, 0, 0, 9);

1552 
	`CHECK_PATTERN
(0x1234, 0x52, 0x34);

1553 
	`CHECK_PATTERN
(0x1234, 0x80, 0, 0x12, 0x34);

1554 
	`CHECK_PATTERN
(0x1234, 0xc0, 0, 0, 0, 0, 0, 0x12, 0x34);

1555 
	`CHECK_PATTERN
(0x12345678, 0x92, 0x34, 0x56, 0x78);

1556 
	`CHECK_PATTERN
(0x12345678, 0xc0, 0, 0, 0, 0x12, 0x34, 0x56, 0x78);

1557 
	`CHECK_PATTERN
(0x123456789abcdef, 0xc1, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef);

1558 #undef 
CHECK_PATTERN


1560 static 
uint64_t
 
inputs
[] = {0, 1, 63, 64, 16383, 16384, 1073741823, 1073741824, 
UINT64_MAX
};

1561 
size_t
 
i
;

1563 for (
i
 = 0; 
inputs
[i] != 
UINT64_MAX
; ++i) {

1564 
uint8_t
 
buf
[
PTLS_ENCODE_QUICINT_CAPACITY
 + 1];

1565 
	`memset
(
buf
, 123, sizeof(buf));

1566 
uint8_t
 *
enc_end
 = 
	`ptls_encode_quicint
(
buf
, 
inputs
[
i
]);

1567 
	`assert
(
enc_end
 - 
buf
 <= 
PTLS_ENCODE_QUICINT_CAPACITY
);

1568 const 
uint8_t
 *
src
 = 
buf
;

1569 
uint64_t
 
decoded
 = 
	`ptls_decode_quicint
(&
src
, 
buf
 + sizeof(buf));

1570 
	`ok
(
inputs
[
i
] == 
decoded
);

1571 
	`ok
(
src
 == 
enc_end
);

1572 
	`ok
(*
src
 == 123);

1574 
	}
}

1576 static void 
	$test_quicblock
(void)

1578 
ptls_buffer_t
 
buf
;

1579 const 
uint8_t
 *
src
, *
end
;

1580 int 
ret
;

1582 
	`ptls_buffer_init
(&
buf
, "", 0);

1584 
	`ptls_buffer_push_block
(&
buf
, -1, { 
	`ptls_buffer_pushv
(&buf, "abc", 3); });

1585 
src
 = 
buf
.
base
;

1586 
end
 = 
buf
.
base
 + buf.
off
;

1587 
	`ptls_decode_block
(
src
, 
end
, -1, {

1588 
	`ok
(
end
 - 
src
 == 3);

1589 
	`ok
(
	`memcmp
(
src
, "abc", 3) == 0);

1590 
src
 += 3;

1593 
buf
.
off
 = 0;

1594 
	`ptls_buffer_push_block
(&
buf
, -1, {

1595 if ((
ret
 = 
	`ptls_buffer_reserve
(&
buf
, 123)) != 0)

1596 goto 
Exit
;

1597 
	`memset
(
buf
.
base
 + buf.
off
, 0x55, 123);

1598 
buf
.
off
 += 123;

1600 
src
 = 
buf
.
base
;

1601 
end
 = 
buf
.
base
 + buf.
off
;

1602 
	`ptls_decode_block
(
src
, 
end
, -1, {

1603 
	`ok
(
end
 - 
src
 == 123);

1604 
size_t
 
i
;

1605 for (
i
 = 0; i != 123; ++i)

1606 
	`ok
(*
src
++ == 0x55);

1609 
Exit
:

1610 if (
ret
 != 0)

1611 
	`ok
(!"fail");

1612 
	`ptls_buffer_dispose
(&
buf
);

1613 
	}
}

1615 static void 
	$test_quic
(void)

1617 
	`subtest
("varint", 
test_quicint
);

1618 
	`subtest
("block", 
test_quicblock
);

1619 
	}
}

1621 static int 
	gtest_legacy_ch_callback_called
 = 0;

1623 static const 
uint8_t
 
	glegacy_ch_tls12
[] = {

1636 static int 
	$test_legacy_ch_tls12_callback
(
ptls_on_client_hello_t
 *
self
, 
ptls_t
 *
tls
, 
ptls_on_client_hello_parameters_t
 *
params
)

1638 
test_legacy_ch_callback_called
 = 1;

1639 
	`ok
(
params
->
incompatible_version
);

1640 
	`ok
(sizeof(
legacy_ch_tls12
) - 5 == 
params
->
raw_message
.
len
);

1641 
	`ok
(
	`memcmp
(
legacy_ch_tls12
 + 5, 
params
->
raw_message
.
base
, params->raw_message.
len
) == 0);

1642 
	`ok
(
params
->
server_name
.
len
 == sizeof("i-need_sni") - 1);

1643 
	`ok
(
	`memcmp
(
params
->
server_name
.
base
, "i_need_sni", sizeof("i-need_sni") - 1) == 0);

1645 
	}
}

1647 static const 
uint8_t
 
	glegacy_ch_tls11
[] = {

1655 static int 
	$test_legacy_ch_tls11_callback
(
ptls_on_client_hello_t
 *
self
, 
ptls_t
 *
tls
, 
ptls_on_client_hello_parameters_t
 *
params
)

1657 
test_legacy_ch_callback_called
 = 1;

1658 
	`ok
(
params
->
incompatible_version
);

1659 
	`ok
(sizeof(
legacy_ch_tls11
) - 5 == 
params
->
raw_message
.
len
);

1660 
	`ok
(
	`memcmp
(
legacy_ch_tls11
 + 5, 
params
->
raw_message
.
base
, params->raw_message.
len
) == 0);

1661 
	`ok
(
params
->
server_name
.
len
 == 0);

1662 
	`ok
(
params
->
server_name
.
base
 == 
NULL
);

1664 
	}
}

1666 static void 
	$test_tls12_hello
(void)

1668 
ptls_on_client_hello_t
 
on_client_hello
 = {
test_legacy_ch_tls12_callback
}, *
orig
 = 
ctx
->on_client_hello;

1669 
ctx
->
on_client_hello
 = &on_client_hello;

1671 
ptls_buffer_t
 
sendbuf
;

1672 
	`ptls_buffer_init
(&
sendbuf
, "", 0);

1674 
test_legacy_ch_callback_called
 = 0;

1675 
ptls_t
 *
tls
 = 
	`ptls_new
(
ctx
, 1);

1676 
size_t
 
len
 = sizeof(
legacy_ch_tls12
);

1677 int 
ret
 = 
	`ptls_handshake
(
tls
, &
sendbuf
, 
legacy_ch_tls12
, &
len
, 
NULL
);

1678 
	`ptls_free
(
tls
);

1679 
	`ok
(
ret
 == 
PTLS_ALERT_PROTOCOL_VERSION
);

1680 
	`ok
(
test_legacy_ch_callback_called
);

1682 
on_client_hello
.
cb
 = 
test_legacy_ch_tls11_callback
;

1683 
test_legacy_ch_callback_called
 = 0;

1684 
tls
 = 
	`ptls_new
(
ctx
, 1);

1685 
len
 = sizeof(
legacy_ch_tls11
);

1686 
ret
 = 
	`ptls_handshake
(
tls
, &
sendbuf
, 
legacy_ch_tls11
, &
len
, 
NULL
);

1687 
	`ptls_free
(
tls
);

1688 
	`ok
(
ret
 == 
PTLS_ALERT_PROTOCOL_VERSION
);

1690 
ctx
->
on_client_hello
 = 
orig
;

1691 
	}
}

1693 void 
	$test_picotls
(void)

1695 
	`subtest
("is_ipaddr", 
test_is_ipaddr
);

1696 
	`subtest
("select_cypher", 
test_select_cipher
);

1697 
	`subtest
("sha256", 
test_sha256
);

1698 
	`subtest
("sha384", 
test_sha384
);

1699 
	`subtest
("hmac-sha256", 
test_hmac_sha256
);

1700 
	`subtest
("hkdf", 
test_hkdf
);

1701 
	`subtest
("aes128gcm", 
test_aes128gcm
);

1702 
	`subtest
("aes256gcm", 
test_aes256gcm
);

1703 
	`subtest
("chacha20poly1305", 
test_chacha20poly1305
);

1704 
	`subtest
("aes128ecb", 
test_aes128ecb
);

1705 
	`subtest
("aes256ecb", 
test_aes256ecb
);

1706 
	`subtest
("aes128ctr", 
test_aes128ctr
);

1707 
	`subtest
("chacha20", 
test_chacha20
);

1708 
	`subtest
("ffx", 
test_ffx
);

1709 
	`subtest
("base64-decode", 
test_base64_decode
);

1710 
	`subtest
("fragmented-message", 
test_fragmented_message
);

1711 
	`subtest
("handshake", 
test_all_handshakes
);

1712 
	`subtest
("quic", 
test_quic
);

1713 
	`subtest
("tls12-hello", 
test_tls12_hello
);

1714 
	}
}

1716 void 
	$test_picotls_esni
(
ptls_key_exchange_context_t
 **
keys
)

1718 
ptls_esni_context_t
 
esni
, *
esni_list
[] = {&esni, 
NULL
};

1719 
	`ptls_esni_init_context
(
ctx_peer
, &
esni
, 
	`ptls_iovec_init
(
ESNIKEYS
, sizeof(ESNIKEYS) - 1), 
keys
);

1720 
ctx_peer
->
esni
 = 
esni_list
;

1722 
	`subtest
("esni-handshake", 
test_picotls
);

1724 
ctx_peer
->
esni
 = 
NULL
;

1725 
	}
}

1727 void 
	$test_key_exchange
(
ptls_key_exchange_algorithm_t
 *
client
, ptls_key_exchange_algorithm_t *
server
)

1729 
ptls_key_exchange_context_t
 *
ctx
;

1730 
ptls_iovec_t
 
client_secret
, 
server_pubkey
, 
server_secret
;

1731 int 
ret
;

1734 
ret
 = 
server
->
	`exchange
(server, &
server_pubkey
, &
server_secret
, (
ptls_iovec_t
){
NULL
});

1735 
	`ok
(
ret
 != 0);

1738 
ret
 = 
client
->
	`create
(client, &
ctx
);

1739 
	`ok
(
ret
 == 0);

1740 
ret
 = 
server
->
	`exchange
(server, &
server_pubkey
, &
server_secret
, 
ctx
->
pubkey
);

1741 
	`ok
(
ret
 == 0);

1742 
ret
 = 
ctx
->
	`on_exchange
(&ctx, 1, &
client_secret
, 
server_pubkey
);

1743 
	`ok
(
ret
 == 0);

1744 
	`ok
(
client_secret
.
len
 == 
server_secret
.len);

1745 
	`ok
(
	`memcmp
(
client_secret
.
base
, 
server_secret
.base, client_secret.
len
) == 0);

1747 
	`free
(
client_secret
.
base
);

1748 
	`free
(
server_pubkey
.
base
);

1749 
	`free
(
server_secret
.
base
);

1752 
ret
 = 
client
->
	`create
(client, &
ctx
);

1753 
	`ok
(
ret
 == 0);

1754 
ret
 = 
ctx
->
	`on_exchange
(&ctx, 1, 
NULL
, 
	`ptls_iovec_init
(NULL, 0));

1755 
	`ok
(
ret
 == 0);

1756 
	`ok
(
ctx
 == 
NULL
);

1757 
	}
}

	@deps/picotls/t/ptlsbench.c

23 #ifdef 
_WINDOWS


24 #include 
	~"wincompat.h
"

26 #include 
	~<arpa/inet.h
>

27 #include 
	~<sys/time.h
>

28 #include 
	~<sys/utsname.h
>

29 #include 
	~<time.h
>

31 #include 
	~<assert.h
>

32 #include 
	~<string.h
>

33 #include 
	~<stdio.h
>

34 #include 
	~"picotls.h
"

35 #include 
	~"picotls/ffx.h
"

36 #include 
	~"picotls/minicrypto.h
"

37 #include 
	~"picotls/openssl.h
"

38 #include 
	~"picotls/fusion.h
"

39 #include 
	~<openssl/opensslv.h
>

41 #ifdef 
_WINDOWS


42 #include 
	~<bcrypt.h
>

43 #include 
	~"picotls/ptlsbcrypt.h
"

44 #ifdef 
_DEBUG


45 #define 
	#BENCH_MODE
 "check"

	)

47 #define 
	#BENCH_MODE
 "release"

	)

49 #include 
	~"../lib/ptlsbcrypt.c
"

51 #ifdef 
PTLS_DEBUG


52 #define 
	#BENCH_MODE
 "debug"

	)

54 #define 
	#BENCH_MODE
 "release"

	)

59 static 
uint64_t
 
	$bench_time
()

61 struct 
timeval
 
tv
;

62 #ifdef 
CLOCK_PROCESS_CPUTIME_ID


63 struct 
timespec
 
cpu
;

64 if (
	`clock_gettime
(
CLOCK_PROCESS_CPUTIME_ID
, &
cpu
) == 0) {

65 
uint64_t
 
nanos
 = (uint64_t)
cpu
.
tv_nsec
;

66 
uint64_t
 
micros
 = 
nanos
 / 1000;

67 
micros
 += (1000000ull) * ((
uint64_t
)
cpu
.
tv_sec
);

68 return 
micros
;

71 
	`gettimeofday
(&
tv
, 
NULL
);

72 return (
uint64_t
)
tv
.
tv_sec
 * 1000000 + tv.
tv_usec
;

73 
	}
}

78 #define 
	#BENCH_BATCH
 1000

	)

80 static int 
	$bench_run_one
(
ptls_aead_context_t
 *
e
, ptls_aead_context_t *
d
, 
size_t
 
n
, size_t 
l
, 
uint64_t
 *
t_enc
, uint64_t *
t_dec
,

81 
uint64_t
 *
s
)

83 int 
ret
 = 0;

84 
uint8_t
 *
v_in
 = 
NULL
;

85 
uint8_t
 *
v_enc
[
BENCH_BATCH
];

86 
uint8_t
 *
v_dec
 = 
NULL
;

87 
uint64_t
 
h
[4];

89 *
t_enc
 = 0;

90 *
t_dec
 = 0;

91 *
s
 = 0;

93 
	`memset
(
v_enc
, 0, sizeof(v_enc));

94 
	`memset
(
h
, 0, sizeof(h));

95 
v_in
 = (
uint8_t
 *)
	`malloc
(
l
);

96 
v_dec
 = (
uint8_t
 *)
	`malloc
(
l
);

97 if (
v_in
 == 
NULL
 || 
v_dec
 == NULL) {

98 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

101 for (
size_t
 
i
 = 0; 
ret
 == 0 && i < 
BENCH_BATCH
; i++) {

102 
v_enc
[
i
] = (
uint8_t
 *)
	`malloc
(
l
 + 
PTLS_MAX_DIGEST_SIZE
);

103 if (
v_enc
[
i
] == 0) {

104 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

108 if (
ret
 == 0) {

109 
	`memset
(
v_in
, 0, 
l
);

111 for (
size_t
 
k
 = 0; k < 
n
;) {

112 
size_t
 
e_len
;

113 
size_t
 
d_len
;

114 
size_t
 
i_max
 = ((
n
 - 
k
) > 
BENCH_BATCH
) ? BENCH_BATCH : n - k;

115 
uint64_t
 
old_h
 = 
h
[0];

116 
uint64_t
 
t_start
 = 
	`bench_time
();

117 
uint64_t
 
t_medium
;

118 
uint64_t
 
t_end
;

120 for (
size_t
 
i
 = 0; i < 
i_max
; i++) {

121 
h
[0]++;

122 
e_len
 = 
	`ptls_aead_encrypt
(
e
, 
v_enc
[
i
], 
v_in
, 
l
, 
h
[0], h, sizeof(h));

123 *
s
 += (
v_enc
[
i
])[
l
];

126 
t_medium
 = 
	`bench_time
();

128 
h
[0] = 
old_h
;

130 for (
size_t
 
i
 = 0; i < 
i_max
; i++) {

131 
h
[0]++;

133 
d_len
 = 
	`ptls_aead_decrypt
(
d
, 
v_dec
, 
v_enc
[
i
], 
e_len
, 
h
[0], h, sizeof(h));

134 if (
d_len
 != 
l
) {

135 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

138 *
s
 += 
v_dec
[0];

141 
t_end
 = 
	`bench_time
();

143 *
t_enc
 += 
t_medium
 - 
t_start
;

144 *
t_dec
 += 
t_end
 - 
t_medium
;

146 
k
 += 
i_max
;

150 if (
v_in
 != 
NULL
) {

151 
	`free
(
v_in
);

154 for (
size_t
 
i
 = 0; i < 
BENCH_BATCH
; i++) {

155 if (
v_enc
[
i
] != 
NULL
) {

156 
	`free
(
v_enc
[
i
]);

160 if (
v_dec
 != 
NULL
) {

161 
	`free
(
v_dec
);

164 return 
ret
;

165 
	}
}

167 static double 
	$bench_mbps
(
uint64_t
 
t
, 
size_t
 
l
, size_t 
n
)

169 double 
x
 = (double)
l
;

171 
x
 *= (double)
n
;

172 
x
 *= 8;

173 
x
 /= (double)
t
;

174 return 
x
;

175 
	}
}

179 static int 
	$bench_run_aead
(char *
OS
, char *
HW
, int 
basic_ref
, 
uint64_t
 
s0
, const char *
provider
, const char *
algo_name
,

180 
ptls_aead_algorithm_t
 *
aead
, 
ptls_hash_algorithm_t
 *
hash
, 
size_t
 
n
, size_t 
l
, 
uint64_t
 *
s
)

182 int 
ret
 = 0;

184 
uint8_t
 
secret
[
PTLS_MAX_SECRET_SIZE
];

185 
ptls_aead_context_t
 *
e
;

186 
ptls_aead_context_t
 *
d
;

187 
uint64_t
 
t_e
 = 0;

188 
uint64_t
 
t_d
 = 0;

189 char 
p_version
[128];

192 
p_version
[0] = 0;

194 if (
	`strcmp
(
provider
, "openssl") == 0) {

199 
uint32_t
 
combined
 = 
OPENSSL_VERSION_NUMBER
;

200 int 
M
 = 
combined
 >> 28;

201 int 
NN
 = (
combined
 >> 20) & 0xFF;

202 int 
FF
 = (
combined
 >> 12) & 0xFF;

203 int 
PP
 = (
combined
 >> 4) & 0xFF;

204 char 
letter
 = 'a' - 1 + 
PP
;

206 #ifdef 
_WINDOWS


207 (void)
	`sprintf_s
(
p_version
, sizeof(p_version), "%d.%d.%d%c", 
M
, 
NN
, 
FF
, 
letter
);

209 (void)
	`sprintf
(
p_version
, "%d.%d.%d%c", 
M
, 
NN
, 
FF
, 
letter
);

213 *
s
 += 
s0
;

215 
	`memset
(
secret
, 'z', sizeof(secret));

216 
e
 = 
	`ptls_aead_new
(
aead
, 
hash
, 1, 
secret
, 
NULL
);

217 
d
 = 
	`ptls_aead_new
(
aead
, 
hash
, 0, 
secret
, 
NULL
);

219 if (
e
 == 
NULL
 || 
d
 == NULL) {

220 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

222 
ret
 = 
	`bench_run_one
(
e
, 
d
, 
n
, 
l
, &
t_e
, &
t_d
, 
s
);

223 if (
ret
 == 0) {

224 
	`printf
("%s, %s, %d, %s, %d, %s, %s, %s, %d, %d, %d, %d, %.2f, %.2f\n", 
OS
, 
HW
, (int)(8 * sizeof(
size_t
)), 
BENCH_MODE
,

225 
basic_ref
, 
provider
, 
p_version
, 
algo_name
, (int)
n
, (int)
l
, (int)
t_e
, (int)
t_d
, 
	`bench_mbps
(t_e, l, n),

226 
	`bench_mbps
(
t_d
, 
l
, 
n
));

230 if (
e
) {

231 
	`ptls_aead_free
(
e
);

234 if (
d
) {

235 
	`ptls_aead_free
(
d
);

238 return 
ret
;

239 
	}
}

241 typedef struct 
	sst_ptls_bench_entry_t
 {

242 const char *
	mprovider
;

243 const char *
	malgo_name
;

244 
ptls_aead_algorithm_t
 *
	maead
;

245 
ptls_hash_algorithm_t
 *
	mhash
;

246 int 
	menabled_by_defaut
;

247 } 
	tptls_bench_entry_t
;

249 static 
ptls_bench_entry_t
 
	gaead_list
[] = {

251 {"minicrypto", "aes128gcm", &
ptls_minicrypto_aes128gcm
, &
ptls_minicrypto_sha256
, 0},

252 {"minicrypto", "aes256gcm", &
ptls_minicrypto_aes256gcm
, &
ptls_minicrypto_sha384
, 0},

253 {"minicrypto", "chacha20poly1305", &
ptls_minicrypto_chacha20poly1305
, &
ptls_minicrypto_sha256
, 1},

254 #ifdef 
_WINDOWS


255 {"ptlsbcrypt", "aes128gcm", &
ptls_bcrypt_aes128gcm
, &
ptls_bcrypt_sha256
, 1},

256 {"ptlsbcrypt", "aes256gcm", &
ptls_bcrypt_aes256gcm
, &
ptls_bcrypt_sha384
, 1},

258 #if !
defined
(
_WINDOWS
) || defined(
_WINDOWS64
)

259 {"fusion", "aes128gcm", &
ptls_fusion_aes128gcm
, &
ptls_minicrypto_sha256
, 1},

260 {"fusion", "aes256gcm", &
ptls_fusion_aes256gcm
, &
ptls_minicrypto_sha384
, 1},

262 #if 
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305


263 {"openssl", "chacha20poly1305", &
ptls_openssl_chacha20poly1305
, &
ptls_minicrypto_sha256
, 1},

265 {"openssl", "aes128gcm", &
ptls_openssl_aes128gcm
, &
ptls_minicrypto_sha256
, 1},

266 {"openssl", "aes256gcm", &
ptls_openssl_aes256gcm
, &
ptls_minicrypto_sha384
, 1}};

268 static 
size_t
 
	gnb_aead_list
 = sizeof(
aead_list
) / sizeof(
ptls_bench_entry_t
);

270 static int 
	$bench_basic
(
uint64_t
 *
x
)

272 
uint64_t
 
t_start
 = 
	`bench_time
();

273 
uint32_t
 
a
 = (uint32_t)((*
x
) & 0xFFFFFFFF);

274 
uint32_t
 
b
 = (uint32_t)((*
x
) >> 32);

279 for (unsigned int 
i
 = 0; i < 10000000; i++) {

280 
uint32_t
 
v
 = (
a
 >> 3) | (a << 29);

281 
v
 += 
a
;

282 
v
 ^= 
b
;

283 
b
 = 
a
;

284 
a
 = 
v
;

286 *
x
 = (((
uint64_t
)
b
) << 32) | 
a
;

288 return (int)(
	`bench_time
() - 
t_start
);

289 
	}
}

291 int 
	$main
(int 
argc
, char **
argv
)

293 int 
ret
 = 0;

294 int 
force_all_tests
 = 0;

295 
uint64_t
 
x
 = 0xdeadbeef;

296 
uint64_t
 
s
 = 0;

297 int 
basic_ref
 = 
	`bench_basic
(&
x
);

298 char 
OS
[128];

299 char 
HW
[128];

300 #ifndef 
_WINDOWS


301 struct 
utsname
 
uts
;

304 #ifdef 
_WINDOWS


305 (void)
	`strcpy_s
(
OS
, sizeof(OS), "windows");

306 (void)
	`strcpy_s
(
HW
, sizeof(HW), "x86_64");

308 
OS
[0] = 0;

309 
HW
[0] = 0;

310 if (
	`uname
(&
uts
) == 0) {

311 if (
	`strlen
(
uts
.
sysname
) + 1 < sizeof(
OS
)) {

312 
	`strcpy
(
OS
, 
uts
.
sysname
);

314 if (
	`strlen
(
uts
.
machine
) + 1 < sizeof(
HW
)) {

315 
	`strcpy
(
HW
, 
uts
.
machine
);

320 if (
argc
 == 2 && 
	`strcmp
(
argv
[1], "-f") == 0) {

321 
force_all_tests
 = 1;

322 } else if (
argc
 > 1) {

323 
	`fprintf
(
stderr
, "Usage: %s [-f]\n Use option \"-f\" to force execution of the slower tests.\n", 
argv
[0]);

324 
	`exit
(-1);

327 
	`printf
(

330 for (
size_t
 
i
 = 0; 
ret
 == 0 && i < 
nb_aead_list
; i++) {

331 if (
aead_list
[
i
].
enabled_by_defaut
 || 
force_all_tests
) {

332 
ret
 = 
	`bench_run_aead
(
OS
, 
HW
, 
basic_ref
, 
x
, 
aead_list
[
i
].
provider
, aead_list[i].
algo_name
, aead_list[i].
aead
,

333 
aead_list
[
i
].
hash
, 1000, 1500, &
s
);

339 if (
s
 == 0) {

340 
	`printf
("Unexpected value of test sum s = %llx\n", (unsigned long long)
s
);

343 return 
ret
;

344 
	}
}

	@deps/picotls/t/test.h

22 #ifndef 
test_h


23 #define 
	#test_h


	)

25 #include 
	~"picotls.h
"

26 #include 
	~"picotls/ffx.h
"

29 #define 
	#SECP256R1_PRIVATE_KEY
 \

31 "\x3a"

	)

32 #define 
	#SECP256R1_CERTIFICATE
 \

52 "\x62\x6b\x29\x4a\xa7\xa7\xf9\x3b\xde\xd8\xc8\x90\x57\xf2\x76\x2a\x23\x0b\x01\x68\xc6\x9a\xf2"

	)

55 #define 
	#ESNIKEYS
 \

61 "\x00\x4e\x94\xee\x6b\xc0\x62\x00\x00"

	)

62 #define 
	#ESNI_SECP256R1KEY
 \

65 "2tjD6P9zDM20LEtVbqwBr20KYLG\n2e5mhKljlES+BOfuz6vCyd1A5siJiO2Uhg==\n-----END EC PRIVATE KEY-----\n"

	)

67 extern 
ptls_context_t
 *
ctx
, *
ctx_peer
;

68 extern 
ptls_verify_certificate_t
 *
verify_certificate
;

70 struct 
	sst_ptls_ffx_test_variants_t
 {

71 
ptls_cipher_algorithm_t
 *
	malgo
;

72 int 
	mbit_length
;

74 extern struct 
st_ptls_ffx_test_variants_t
 
ffx_variants
[7];

76 #define 
	#DEFINE_FFX_AES128_ALGORITHMS
(
backend
) \

77 
	`PTLS_FFX_CIPHER_ALGO
(
ptls_
##
backend
##
_aes128ctr
, 31, 6, 16); \

78 
	`PTLS_FFX_CIPHER_ALGO
(
ptls_
##
backend
##
_aes128ctr
, 53, 4, 16); \

79 
	`PTLS_FFX_CIPHER_ALGO
(
ptls_
##
backend
##
_aes128ctr
, 125, 8, 16)

	)

80 #define 
	#DEFINE_FFX_CHACHA20_ALGORITHMS
(
backend
) \

81 
	`PTLS_FFX_CIPHER_ALGO
(
ptls_
##
backend
##
_chacha20
, 32, 6, 32); \

82 
	`PTLS_FFX_CIPHER_ALGO
(
ptls_
##
backend
##
_chacha20
, 57, 4, 32); \

83 
	`PTLS_FFX_CIPHER_ALGO
(
ptls_
##
backend
##
_chacha20
, 256, 8, 32)

	)

85 #define 
	#ADD_FFX_ALGORITHM
(
a
, 
bl
) \

87 
size_t
 
i
; \

88 for (
i
 = 0; 
ffx_variants
[i].
algo
 != 
NULL
; ++i) \

90 
ffx_variants
[
i
] = (struct 
st_ptls_ffx_test_variants_t
){&(
a
), (
bl
)}; \

91 } while (0)

	)

93 #define 
	#ADD_FFX_AES128_ALGORITHMS
(
backend
) \

94 
	`ADD_FFX_ALGORITHM
(
ptls_ffx_ptls_
##
backend
##
_aes128ctr_b125_r8
, 125); \

95 
	`ADD_FFX_ALGORITHM
(
ptls_ffx_ptls_
##
backend
##
_aes128ctr_b31_r6
, 31); \

96 
	`ADD_FFX_ALGORITHM
(
ptls_ffx_ptls_
##
backend
##
_aes128ctr_b53_r4
, 53)

	)

98 #define 
	#ADD_FFX_CHACHA20_ALGORITHMS
(
backend
) \

99 
	`ADD_FFX_ALGORITHM
(
ptls_ffx_ptls_
##
backend
##
_chacha20_b256_r8
, 256); \

100 
	`ADD_FFX_ALGORITHM
(
ptls_ffx_ptls_
##
backend
##
_chacha20_b32_r6
, 32); \

101 
	`ADD_FFX_ALGORITHM
(
ptls_ffx_ptls_
##
backend
##
_chacha20_b57_r4
, 57)

	)

103 void 
test_key_exchange
(
ptls_key_exchange_algorithm_t
 *
client
, ptls_key_exchange_algorithm_t *
server
);

104 void 
test_picotls
(void);

105 void 
test_picotls_esni
(
ptls_key_exchange_context_t
 **
keys
);

	@deps/picotls/t/util.h

22 #ifndef 
util_h


23 #define 
	#util_h


	)

25 #ifndef 
_XOPEN_SOURCE


26 #define 
	#_XOPEN_SOURCE
 700

	)

29 #include 
	~<errno.h
>

30 #include 
	~<netdb.h
>

31 #include 
	~<netinet/in.h
>

32 #include 
	~<stdio.h
>

33 #include 
	~<string.h
>

34 #include 
	~<sys/param.h
>

35 #include 
	~<sys/socket.h
>

36 #include 
	~<sys/types.h
>

37 #include 
	~<arpa/nameser.h
>

38 #include 
	~<resolv.h
>

39 #include 
	~<openssl/pem.h
>

40 #include 
	~"picotls/pembase64.h
"

41 #include 
	~"picotls/openssl.h
"

43 static 
inline
 void 
	$load_certificate_chain
(
ptls_context_t
 *
ctx
, const char *
fn
)

45 if (
	`ptls_load_certificates
(
ctx
, (char *)
fn
) != 0) {

46 
	`fprintf
(
stderr
, "failed to load certificate:%s:%s\n", 
fn
, 
	`strerror
(
errno
));

47 
	`exit
(1);

49 
	}
}

51 static 
inline
 void 
	$load_raw_public_key
(
ptls_iovec_t
 *
raw_public_key
, char const *
cert_pem_file
)

53 
size_t
 
count
;

54 if (
	`ptls_load_pem_objects
(
cert_pem_file
, "PUBLIC KEY", 
raw_public_key
, 1, &
count
) != 0) {

55 
	`fprintf
(
stderr
, "failed to load public key:%s:%s\n", 
cert_pem_file
, 
	`strerror
(
errno
));

56 
	`exit
(1);

58 
	}
}

60 static 
inline
 void 
	$load_private_key
(
ptls_context_t
 *
ctx
, const char *
fn
)

62 static 
ptls_openssl_sign_certificate_t
 
sc
;

63 
FILE
 *
fp
;

64 
EVP_PKEY
 *
pkey
;

66 if ((
fp
 = 
	`fopen
(
fn
, "rb")) == 
NULL
) {

67 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
fn
, 
	`strerror
(
errno
));

68 
	`exit
(1);

70 
pkey
 = 
	`PEM_read_PrivateKey
(
fp
, 
NULL
, NULL, NULL);

71 
	`fclose
(
fp
);

73 if (
pkey
 == 
NULL
) {

74 
	`fprintf
(
stderr
, "failed to read private key from file:%s\n", 
fn
);

75 
	`exit
(1);

78 
	`ptls_openssl_init_sign_certificate
(&
sc
, 
pkey
);

79 
	`EVP_PKEY_free
(
pkey
);

81 
ctx
->
sign_certificate
 = &
sc
.
super
;

82 
	}
}

84 struct 
	sst_util_save_ticket_t
 {

85 
ptls_save_ticket_t
 
	msuper
;

86 char 
	mfn
[
MAXPATHLEN
];

89 static int 
	$util_save_ticket_cb
(
ptls_save_ticket_t
 *
_self
, 
ptls_t
 *
tls
, 
ptls_iovec_t
 
src
)

91 struct 
st_util_save_ticket_t
 *
self
 = (void *)
_self
;

92 
FILE
 *
fp
;

94 if ((
fp
 = 
	`fopen
(
self
->
fn
, "wb")) == 
NULL
) {

95 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
self
->
fn
, 
	`strerror
(
errno
));

96 return 
PTLS_ERROR_LIBRARY
;

98 
	`fwrite
(
src
.
base
, 1, src.
len
, 
fp
);

99 
	`fclose
(
fp
);

102 
	}
}

104 static 
inline
 void 
	$setup_session_file
(
ptls_context_t
 *
ctx
, 
ptls_handshake_properties_t
 *
hsprop
, const char *
fn
)

106 static struct 
st_util_save_ticket_t
 
st
;

107 
FILE
 *
fp
;

110 
	`strcpy
(
st
.
fn
, fn);

111 
st
.
super
.
cb
 = 
util_save_ticket_cb
;

112 
ctx
->
save_ticket
 = &
st
.
super
;

115 if ((
fp
 = 
	`fopen
(
fn
, "rb")) != 
NULL
) {

116 static 
uint8_t
 
ticket
[16384];

117 
size_t
 
ticket_size
 = 
	`fread
(
ticket
, 1, sizeof(ticket), 
fp
);

118 if (
ticket_size
 == 0 || !
	`feof
(
fp
)) {

119 
	`fprintf
(
stderr
, "failed to load ticket from file:%s\n", 
fn
);

120 
	`exit
(1);

122 
	`fclose
(
fp
);

123 
hsprop
->
client
.
session_ticket
 = 
	`ptls_iovec_init
(
ticket
, 
ticket_size
);

125 
	}
}

127 static 
inline
 
X509_STORE
* 
	$init_cert_store
(char const *
crt_file
)

129 int 
ret
 = 0;

130 
X509_STORE
 *
store
 = 
	`X509_STORE_new
();

132 if (
store
 != 
NULL
) {

133 
X509_LOOKUP
 *
lookup
 = 
	`X509_STORE_add_lookup
(
store
, 
	`X509_LOOKUP_file
());

134 
ret
 = 
	`X509_LOOKUP_load_file
(
lookup
, 
crt_file
, 
X509_FILETYPE_PEM
);

135 if (
ret
 != 1) {

136 
	`fprintf
(
stderr
, "Cannot load store (%s), ret = %d\n",

137 
crt_file
, 
ret
);

138 
	`X509_STORE_free
(
store
);

139 
	`exit
(1);

142 
	`fprintf
(
stderr
, "Cannot get a new X509 store\n");

143 
	`exit
(1);

146 return 
store
;

147 
	}
}

149 static 
inline
 void 
	$setup_verify_certificate
(
ptls_context_t
 *
ctx
, const char *
ca_file
)

151 static 
ptls_openssl_verify_certificate_t
 
vc
;

152 
	`ptls_openssl_init_verify_certificate
(&
vc
, 
ca_file
 != 
NULL
 ? 
	`init_cert_store
(ca_file) : NULL);

153 
ctx
->
verify_certificate
 = &
vc
.
super
;

154 
	}
}

156 static 
inline
 void 
	$setup_raw_pubkey_verify_certificate
(
ptls_context_t
 *
ctx
, 
EVP_PKEY
 *
pubkey
)

158 static 
ptls_openssl_raw_pubkey_verify_certificate_t
 
vc
;

159 
	`ptls_openssl_raw_pubkey_init_verify_certificate
(&
vc
, 
pubkey
);

160 
ctx
->
verify_certificate
 = &
vc
.
super
;

161 
	}
}

163 static 
inline
 void 
	$setup_esni
(
ptls_context_t
 *
ctx
, const char *
esni_fn
, 
ptls_key_exchange_context_t
 **
key_exchanges
)

165 
uint8_t
 
esnikeys
[65536];

166 
size_t
 
esnikeys_len
;

167 int 
ret
 = 0;

170 
FILE
 *
fp
;

171 if ((
fp
 = 
	`fopen
(
esni_fn
, "rb")) == 
NULL
) {

172 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
esni_fn
, 
	`strerror
(
errno
));

173 
	`exit
(1);

175 
esnikeys_len
 = 
	`fread
(
esnikeys
, 1, sizeof(esnikeys), 
fp
);

176 if (
esnikeys_len
 == 0 || !
	`feof
(
fp
)) {

177 
	`fprintf
(
stderr
, "failed to load ESNI data from file:%s\n", 
esni_fn
);

178 
	`exit
(1);

180 
	`fclose
(
fp
);

183 if ((
ctx
->
esni
 = 
	`malloc
(sizeof(*ctx->esni) * 2)) == 
NULL
 || (*ctx->esni = malloc(sizeof(**ctx->esni))) == NULL) {

184 
	`fprintf
(
stderr
, "no memory\n");

185 
	`exit
(1);

188 if ((
ret
 = 
	`ptls_esni_init_context
(
ctx
, ctx->
esni
[0], 
	`ptls_iovec_init
(
esnikeys
, 
esnikeys_len
), 
key_exchanges
)) != 0) {

189 
	`fprintf
(
stderr
, "failed to parse ESNI data of file:%s:error=%d\n", 
esni_fn
, 
ret
);

190 
	`exit
(1);

192 
	}
}

194 struct 
	sst_util_log_event_t
 {

195 
ptls_log_event_t
 
	msuper
;

196 
FILE
 *
	mfp
;

199 static void 
	$log_event_cb
(
ptls_log_event_t
 *
_self
, 
ptls_t
 *
tls
, const char *
type
, const char *
fmt
, ...)

201 struct 
st_util_log_event_t
 *
self
 = (void *)
_self
;

202 char 
randomhex
[
PTLS_HELLO_RANDOM_SIZE
 * 2 + 1];

203 
va_list
 
args
;

205 
	`ptls_hexdump
(
randomhex
, 
	`ptls_get_client_random
(
tls
).
base
, 
PTLS_HELLO_RANDOM_SIZE
);

206 
	`fprintf
(
self
->
fp
, "%s %s ", 
type
, 
randomhex
);

208 
	`va_start
(
args
, 
fmt
);

209 
	`vfprintf
(
self
->
fp
, 
fmt
, 
args
);

210 
	`va_end
(
args
);

212 
	`fprintf
(
self
->
fp
, "\n");

213 
	`fflush
(
self
->
fp
);

214 
	}
}

216 static 
inline
 void 
	$setup_log_event
(
ptls_context_t
 *
ctx
, const char *
fn
)

218 static struct 
st_util_log_event_t
 
ls
;

220 if ((
ls
.
fp
 = 
	`fopen
(
fn
, "at")) == 
NULL
) {

221 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
fn
, 
	`strerror
(
errno
));

222 
	`exit
(1);

224 
ls
.
super
.
cb
 = 
log_event_cb
;

225 
ctx
->
log_event
 = &
ls
.
super
;

226 
	}
}

229 struct 
	sst_util_session_cache_t
 {

230 
ptls_encrypt_ticket_t
 
	msuper
;

231 
uint8_t
 
	mid
[32];

232 
ptls_iovec_t
 
	mdata
;

235 static int 
	$encrypt_ticket_cb
(
ptls_encrypt_ticket_t
 *
_self
, 
ptls_t
 *
tls
, int 
is_encrypt
, 
ptls_buffer_t
 *
dst
, 
ptls_iovec_t
 
src
)

237 struct 
st_util_session_cache_t
 *
self
 = (void *)
_self
;

238 int 
ret
;

240 if (
is_encrypt
) {

243 
	`free
(
self
->
data
.
base
);

244 if ((
self
->
data
.
base
 = 
	`malloc
(
src
.
len
)) == 
NULL
)

245 return 
PTLS_ERROR_NO_MEMORY
;

247 
	`ptls_get_context
(
tls
)->
	`random_bytes
(
self
->
id
, sizeof(self->id));

248 
	`memcpy
(
self
->
data
.
base
, 
src
.base, src.
len
);

249 
self
->
data
.
len
 = 
src
.len;

252 if ((
ret
 = 
	`ptls_buffer_reserve
(
dst
, sizeof(
self
->
id
))) != 0)

253 return 
ret
;

254 
	`memcpy
(
dst
->
base
 + dst->
off
, 
self
->
id
, sizeof(self->id));

255 
dst
->
off
 += sizeof(
self
->
id
);

260 if (
src
.
len
 != sizeof(
self
->
id
))

261 return 
PTLS_ERROR_SESSION_NOT_FOUND
;

262 if (
	`memcmp
(
self
->
id
, 
src
.
base
, sizeof(self->id)) != 0)

263 return 
PTLS_ERROR_SESSION_NOT_FOUND
;

266 if ((
ret
 = 
	`ptls_buffer_reserve
(
dst
, 
self
->
data
.
len
)) != 0)

267 return 
ret
;

268 
	`memcpy
(
dst
->
base
 + dst->
off
, 
self
->
data
.base, self->data.
len
);

269 
dst
->
off
 += 
self
->
data
.
len
;

273 
	}
}

275 static 
inline
 void 
	$setup_session_cache
(
ptls_context_t
 *
ctx
)

277 static struct 
st_util_session_cache_t
 
sc
;

279 
sc
.
super
.
cb
 = 
encrypt_ticket_cb
;

281 
ctx
->
ticket_lifetime
 = 86400;

282 
ctx
->
max_early_data_size
 = 8192;

283 
ctx
->
encrypt_ticket
 = &
sc
.
super
;

284 
	}
}

286 static 
inline
 int 
	$resolve_address
(struct 
sockaddr
 *
sa
, 
socklen_t
 *
salen
, const char *
host
, const char *
port
, int 
family
, int 
type
,

287 int 
proto
)

289 struct 
addrinfo
 
hints
, *
res
;

290 int 
err
;

292 
	`memset
(&
hints
, 0, sizeof(hints));

293 
hints
.
ai_family
 = 
family
;

294 
hints
.
ai_socktype
 = 
type
;

295 
hints
.
ai_protocol
 = 
proto
;

296 
hints
.
ai_flags
 = 
AI_ADDRCONFIG
 | 
AI_NUMERICSERV
 | 
AI_PASSIVE
;

297 if ((
err
 = 
	`getaddrinfo
(
host
, 
port
, &
hints
, &
res
)) != 0 || res == 
NULL
) {

298 
	`fprintf
(
stderr
, "failed to resolve address:%s:%s:%s\n", 
host
, 
port
,

299 
err
 != 0 ? 
	`gai_strerror
(err) : "getaddrinfo returned NULL");

303 
	`memcpy
(
sa
, 
res
->
ai_addr
, res->
ai_addrlen
);

304 *
salen
 = 
res
->
ai_addrlen
;

306 
	`freeaddrinfo
(
res
);

308 
	}
}

310 static 
inline
 int 
	$normalize_txt
(
uint8_t
 *
p
, 
size_t
 
len
)

312 
uint8_t
 *const 
end
 = 
p
 + 
len
, *
dst
 = p;

314 if (
p
 == 
end
)

318 
size_t
 
block_len
 = *
p
++;

319 if (
end
 - 
p
 < 
block_len
)

321 
	`memmove
(
dst
, 
p
, 
block_len
);

322 
dst
 += 
block_len
;

323 
p
 += 
block_len
;

324 } while (
p
 != 
end
);

325 *
dst
 = '\0';

328 
	}
}

330 static 
inline
 
ptls_iovec_t
 
	$resolve_esni_keys
(const char *
server_name
)

332 char 
esni_name
[256], *
base64
;

333 
uint8_t
 
answer
[1024];

334 
ns_msg
 
msg
;

335 
ns_rr
 
rr
;

336 
ptls_buffer_t
 
decode_buf
;

337 
ptls_base64_decode_state_t
 
ds
;

338 int 
answer_len
;

340 
	`ptls_buffer_init
(&
decode_buf
, "", 0);

342 if (
	`snprintf
(
esni_name
, sizeof(esni_name), "_esni.%s", 
server_name
) > sizeof(esni_name) - 1)

343 goto 
Error
;

344 if ((
answer_len
 = 
	`res_query
(
esni_name
, 
ns_c_in
, 
ns_t_txt
, 
answer
, sizeof(answer))) <= 0)

345 goto 
Error
;

346 if (
	`ns_initparse
(
answer
, 
answer_len
, &
msg
) != 0)

347 goto 
Error
;

348 if (
	`ns_msg_count
(
msg
, 
ns_s_an
) < 1)

349 goto 
Error
;

350 if (
	`ns_parserr
(&
msg
, 
ns_s_an
, 0, &
rr
) != 0)

351 goto 
Error
;

352 
base64
 = (void *)
	`ns_rr_rdata
(
rr
);

353 if (!
	`normalize_txt
((void *)
base64
, 
	`ns_rr_rdlen
(
rr
)))

354 goto 
Error
;

356 
	`ptls_base64_decode_init
(&
ds
);

357 if (
	`ptls_base64_decode
(
base64
, &
ds
, &
decode_buf
) != 0)

358 goto 
Error
;

359 
	`assert
(
decode_buf
.
is_allocated
);

361 return 
	`ptls_iovec_init
(
decode_buf
.
base
, decode_buf.
off
);

362 
Error
:

363 
	`ptls_buffer_dispose
(&
decode_buf
);

364 return 
	`ptls_iovec_init
(
NULL
, 0);

365 
	}
}

	@embedded-probes.h

1 #ifndef 
embedded_probes_h


2 #define 
	#embedded_probes_h


	)

4 extern 
FILE
 *
quicly_trace_fp
;

6 #define 
	#QUICLY_CONNECT_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

8 static void 
	$QUICLY_CONNECT
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint32_t
 
arg2
)

10 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"connect\", \"conn\":%u, \"time\":%lld, \"version\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

11 
	}
}

13 #define 
	#QUICLY_ACCEPT_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

15 static void 
	$QUICLY_ACCEPT
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, const char * 
arg2
, struct 
st_quicly_address_token_plaintext_t
 * 
arg3
)

17 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"accept\", \"conn\":%u, \"time\":%lld, \"dcid\":\"%s\", \"address-token\":\"0x%llx\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, 
arg2
, (unsigned long long)
arg3
);

18 
	}
}

20 #define 
	#QUICLY_FREE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

22 static void 
	$QUICLY_FREE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
)

24 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"free\", \"conn\":%u, \"time\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
);

25 
	}
}

27 #define 
	#QUICLY_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

29 static void 
	$QUICLY_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int 
arg2
, const char * 
arg3
)

31 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"send\", \"conn\":%u, \"time\":%lld, \"state\":%lld, \"dcid\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
, 
arg3
);

32 
	}
}

34 #define 
	#QUICLY_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

36 static void 
	$QUICLY_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, const char * 
arg2
, const void * 
arg3
, 
size_t
 
arg4
)

38 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"receive\", \"conn\":%u, \"time\":%lld, \"dcid\":\"%s\", \"bytes\":\"0x%llx\", \"first-octet\":%u, \"bytes-len\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, 
arg2
, (unsigned long long)
arg3
, *(
uint8_t
 *)arg3, (unsigned long long)
arg4
);

39 
	}
}

41 #define 
	#QUICLY_VERSION_SWITCH_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

43 static void 
	$QUICLY_VERSION_SWITCH
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint32_t
 
arg2
)

45 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"version-switch\", \"conn\":%u, \"time\":%lld, \"new-version\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

46 
	}
}

48 #define 
	#QUICLY_IDLE_TIMEOUT_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

50 static void 
	$QUICLY_IDLE_TIMEOUT
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
)

52 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"idle-timeout\", \"conn\":%u, \"time\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
);

53 
	}
}

55 #define 
	#QUICLY_STATELESS_RESET_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

57 static void 
	$QUICLY_STATELESS_RESET_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
)

59 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stateless-reset-receive\", \"conn\":%u, \"time\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
);

60 
	}
}

62 #define 
	#QUICLY_CRYPTO_HANDSHAKE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

64 static void 
	$QUICLY_CRYPTO_HANDSHAKE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int 
arg2
)

66 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"crypto-handshake\", \"conn\":%u, \"time\":%lld, \"ret\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
);

67 
	}
}

69 #define 
	#QUICLY_CRYPTO_UPDATE_SECRET_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

71 static void 
	$QUICLY_CRYPTO_UPDATE_SECRET
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int 
arg2
, 
uint8_t
 
arg3
, const char * 
arg4
, const char * 
arg5
)

73 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"crypto-update-secret\", \"conn\":%u, \"time\":%lld, \"is-enc\":%lld, \"epoch\":%llu, \"label\":\"%s\", \"secret\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
, (unsigned long long)
arg3
, 
arg4
, 
arg5
);

74 
	}
}

76 #define 
	#QUICLY_CRYPTO_SEND_KEY_UPDATE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

78 static void 
	$QUICLY_CRYPTO_SEND_KEY_UPDATE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, const char * 
arg3
)

80 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"crypto-send-key-update\", \"conn\":%u, \"time\":%lld, \"phase\":%llu, \"secret\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, 
arg3
);

81 
	}
}

83 #define 
	#QUICLY_CRYPTO_SEND_KEY_UPDATE_CONFIRMED_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

85 static void 
	$QUICLY_CRYPTO_SEND_KEY_UPDATE_CONFIRMED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

87 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"crypto-send-key-update-confirmed\", \"conn\":%u, \"time\":%lld, \"next-pn\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

88 
	}
}

90 #define 
	#QUICLY_CRYPTO_RECEIVE_KEY_UPDATE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

92 static void 
	$QUICLY_CRYPTO_RECEIVE_KEY_UPDATE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, const char * 
arg3
)

94 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"crypto-receive-key-update\", \"conn\":%u, \"time\":%lld, \"phase\":%llu, \"secret\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, 
arg3
);

95 
	}
}

97 #define 
	#QUICLY_CRYPTO_RECEIVE_KEY_UPDATE_PREPARE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

99 static void 
	$QUICLY_CRYPTO_RECEIVE_KEY_UPDATE_PREPARE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, const char * 
arg3
)

101 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"crypto-receive-key-update-prepare\", \"conn\":%u, \"time\":%lld, \"phase\":%llu, \"secret\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, 
arg3
);

102 
	}
}

104 #define 
	#QUICLY_PACKET_SENT_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

106 static void 
	$QUICLY_PACKET_SENT
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, 
size_t
 
arg3
, 
uint8_t
 
arg4
, int 
arg5
)

108 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"packet-sent\", \"conn\":%u, \"time\":%lld, \"pn\":%llu, \"len\":%llu, \"packet-type\":%llu, \"ack-only\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (long long)
arg5
);

109 
	}
}

111 #define 
	#QUICLY_PACKET_RECEIVED_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

113 static void 
	$QUICLY_PACKET_RECEIVED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, const void * 
arg3
, 
size_t
 
arg4
, 
uint8_t
 
arg5
)

115 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"packet-received\", \"conn\":%u, \"time\":%lld, \"pn\":%llu, \"decrypted\":\"0x%llx\", \"decrypted-len\":%llu, \"packet-type\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (unsigned long long)
arg5
);

116 
	}
}

118 #define 
	#QUICLY_PACKET_PREPARE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

120 static void 
	$QUICLY_PACKET_PREPARE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint8_t
 
arg2
, const char * 
arg3
)

122 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"packet-prepare\", \"conn\":%u, \"time\":%lld, \"first-octet\":%llu, \"dcid\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, 
arg3
);

123 
	}
}

125 #define 
	#QUICLY_PACKET_ACKED_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

127 static void 
	$QUICLY_PACKET_ACKED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, int 
arg3
)

129 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"packet-acked\", \"conn\":%u, \"time\":%lld, \"pn\":%llu, \"is-late-ack\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (long long)
arg3
);

130 
	}
}

132 #define 
	#QUICLY_PACKET_LOST_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

134 static void 
	$QUICLY_PACKET_LOST
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, 
uint8_t
 
arg3
)

136 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"packet-lost\", \"conn\":%u, \"time\":%lld, \"pn\":%llu, \"packet-type\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
);

137 
	}
}

139 #define 
	#QUICLY_PACKET_DECRYPTION_FAILED_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

141 static void 
	$QUICLY_PACKET_DECRYPTION_FAILED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

143 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"packet-decryption-failed\", \"conn\":%u, \"time\":%lld, \"pn\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

144 
	}
}

146 #define 
	#QUICLY_PTO_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

148 static void 
	$QUICLY_PTO
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
size_t
 
arg2
, 
uint32_t
 
arg3
, 
int8_t
 
arg4
)

150 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"pto\", \"conn\":%u, \"time\":%lld, \"inflight\":%llu, \"cwnd\":%llu, \"pto-count\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (long long)
arg4
);

151 
	}
}

153 #define 
	#QUICLY_CC_ACK_RECEIVED_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

155 static void 
	$QUICLY_CC_ACK_RECEIVED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, 
size_t
 
arg3
, 
uint32_t
 
arg4
, size_t 
arg5
)

157 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"cc-ack-received\", \"conn\":%u, \"time\":%lld, \"largest-acked\":%llu, \"bytes-acked\":%llu, \"cwnd\":%llu, \"inflight\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (unsigned long long)
arg5
);

158 
	}
}

160 #define 
	#QUICLY_CC_CONGESTION_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

162 static void 
	$QUICLY_CC_CONGESTION
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, 
size_t
 
arg3
, 
uint32_t
 
arg4
)

164 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"cc-congestion\", \"conn\":%u, \"time\":%lld, \"max-lost-pn\":%llu, \"inflight\":%llu, \"cwnd\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

165 
	}
}

167 #define 
	#QUICLY_ACK_BLOCK_RECEIVED_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

169 static void 
	$QUICLY_ACK_BLOCK_RECEIVED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, uint64_t 
arg3
)

171 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"ack-block-received\", \"conn\":%u, \"time\":%lld, \"ack-block-begin\":%llu, \"ack-block-end\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
);

172 
	}
}

174 #define 
	#QUICLY_ACK_DELAY_RECEIVED_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

176 static void 
	$QUICLY_ACK_DELAY_RECEIVED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int64_t 
arg2
)

178 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"ack-delay-received\", \"conn\":%u, \"time\":%lld, \"ack-delay\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
);

179 
	}
}

181 #define 
	#QUICLY_ACK_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

183 static void 
	$QUICLY_ACK_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, uint64_t 
arg3
)

185 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"ack-send\", \"conn\":%u, \"time\":%lld, \"largest-acked\":%llu, \"ack-delay\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
);

186 
	}
}

188 #define 
	#QUICLY_PING_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

190 static void 
	$QUICLY_PING_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
)

192 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"ping-send\", \"conn\":%u, \"time\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
);

193 
	}
}

195 #define 
	#QUICLY_PING_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

197 static void 
	$QUICLY_PING_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
)

199 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"ping-receive\", \"conn\":%u, \"time\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
);

200 
	}
}

202 #define 
	#QUICLY_TRANSPORT_CLOSE_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

204 static void 
	$QUICLY_TRANSPORT_CLOSE_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, uint64_t 
arg3
, const char * 
arg4
)

206 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"transport-close-send\", \"conn\":%u, \"time\":%lld, \"error-code\":%llu, \"frame-type\":%llu, \"reason-phrase\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, 
arg4
);

207 
	}
}

209 #define 
	#QUICLY_TRANSPORT_CLOSE_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

211 static void 
	$QUICLY_TRANSPORT_CLOSE_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, uint64_t 
arg3
, const char * 
arg4
)

213 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"transport-close-receive\", \"conn\":%u, \"time\":%lld, \"error-code\":%llu, \"frame-type\":%llu, \"reason-phrase\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, 
arg4
);

214 
	}
}

216 #define 
	#QUICLY_APPLICATION_CLOSE_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

218 static void 
	$QUICLY_APPLICATION_CLOSE_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, const char * 
arg3
)

220 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"application-close-send\", \"conn\":%u, \"time\":%lld, \"error-code\":%llu, \"reason-phrase\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, 
arg3
);

221 
	}
}

223 #define 
	#QUICLY_APPLICATION_CLOSE_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

225 static void 
	$QUICLY_APPLICATION_CLOSE_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, const char * 
arg3
)

227 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"application-close-receive\", \"conn\":%u, \"time\":%lld, \"error-code\":%llu, \"reason-phrase\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, 
arg3
);

228 
	}
}

230 #define 
	#QUICLY_STREAM_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

232 static void 
	$QUICLY_STREAM_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, 
uint64_t
 
arg3
, 
size_t
 
arg4
, int 
arg5
)

234 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-send\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"off\":%llu, \"len\":%llu, \"is-fin\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (long long)
arg5
);

235 
	}
}

237 #define 
	#QUICLY_STREAM_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

239 static void 
	$QUICLY_STREAM_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, 
uint64_t
 
arg3
, 
size_t
 
arg4
)

241 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-receive\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"off\":%llu, \"len\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

242 
	}
}

244 #define 
	#QUICLY_STREAM_ACKED_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

246 static void 
	$QUICLY_STREAM_ACKED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int64_t 
arg2
, 
uint64_t
 
arg3
, 
size_t
 
arg4
)

248 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-acked\", \"conn\":%u, \"time\":%lld, \"stream-id\":%lld, \"off\":%llu, \"len\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

249 
	}
}

251 #define 
	#QUICLY_STREAM_LOST_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

253 static void 
	$QUICLY_STREAM_LOST
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int64_t 
arg2
, 
uint64_t
 
arg3
, 
size_t
 
arg4
)

255 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-lost\", \"conn\":%u, \"time\":%lld, \"stream-id\":%lld, \"off\":%llu, \"len\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

256 
	}
}

258 #define 
	#QUICLY_MAX_DATA_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

260 static void 
	$QUICLY_MAX_DATA_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

262 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"max-data-send\", \"conn\":%u, \"time\":%lld, \"maximum\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

263 
	}
}

265 #define 
	#QUICLY_MAX_DATA_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

267 static void 
	$QUICLY_MAX_DATA_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

269 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"max-data-receive\", \"conn\":%u, \"time\":%lld, \"maximum\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

270 
	}
}

272 #define 
	#QUICLY_MAX_STREAMS_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

274 static void 
	$QUICLY_MAX_STREAMS_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, int 
arg3
)

276 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"max-streams-send\", \"conn\":%u, \"time\":%lld, \"maximum\":%llu, \"is-unidirectional\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (long long)
arg3
);

277 
	}
}

279 #define 
	#QUICLY_MAX_STREAMS_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

281 static void 
	$QUICLY_MAX_STREAMS_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, int 
arg3
)

283 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"max-streams-receive\", \"conn\":%u, \"time\":%lld, \"maximum\":%llu, \"is-unidirectional\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (long long)
arg3
);

284 
	}
}

286 #define 
	#QUICLY_MAX_STREAM_DATA_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

288 static void 
	$QUICLY_MAX_STREAM_DATA_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, 
uint64_t
 
arg3
)

290 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"max-stream-data-send\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"maximum\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (unsigned long long)
arg3
);

291 
	}
}

293 #define 
	#QUICLY_MAX_STREAM_DATA_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

295 static void 
	$QUICLY_MAX_STREAM_DATA_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int64_t 
arg2
, 
uint64_t
 
arg3
)

297 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"max-stream-data-receive\", \"conn\":%u, \"time\":%lld, \"stream-id\":%lld, \"maximum\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
, (unsigned long long)
arg3
);

298 
	}
}

300 #define 
	#QUICLY_NEW_TOKEN_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

302 static void 
	$QUICLY_NEW_TOKEN_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint8_t
 * 
arg2
, 
size_t
 
arg3
, 
uint64_t
 
arg4
)

304 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"new-token-send\", \"conn\":%u, \"time\":%lld, \"token\":\"0x%llx\", \"token-len\":%llu, \"generation\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

305 
	}
}

307 #define 
	#QUICLY_NEW_TOKEN_ACKED_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

309 static void 
	$QUICLY_NEW_TOKEN_ACKED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

311 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"new-token-acked\", \"conn\":%u, \"time\":%lld, \"generation\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

312 
	}
}

314 #define 
	#QUICLY_NEW_TOKEN_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

316 static void 
	$QUICLY_NEW_TOKEN_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint8_t
 * 
arg2
, 
size_t
 
arg3
)

318 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"new-token-receive\", \"conn\":%u, \"time\":%lld, \"token\":\"0x%llx\", \"token-len\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
);

319 
	}
}

321 #define 
	#QUICLY_HANDSHAKE_DONE_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

323 static void 
	$QUICLY_HANDSHAKE_DONE_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
)

325 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"handshake-done-send\", \"conn\":%u, \"time\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
);

326 
	}
}

328 #define 
	#QUICLY_HANDSHAKE_DONE_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

330 static void 
	$QUICLY_HANDSHAKE_DONE_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
)

332 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"handshake-done-receive\", \"conn\":%u, \"time\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
);

333 
	}
}

335 #define 
	#QUICLY_STREAMS_BLOCKED_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

337 static void 
	$QUICLY_STREAMS_BLOCKED_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, int 
arg3
)

339 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"streams-blocked-send\", \"conn\":%u, \"time\":%lld, \"maximum\":%llu, \"is-unidirectional\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (long long)
arg3
);

340 
	}
}

342 #define 
	#QUICLY_STREAMS_BLOCKED_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

344 static void 
	$QUICLY_STREAMS_BLOCKED_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, int 
arg3
)

346 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"streams-blocked-receive\", \"conn\":%u, \"time\":%lld, \"maximum\":%llu, \"is-unidirectional\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (long long)
arg3
);

347 
	}
}

349 #define 
	#QUICLY_NEW_CONNECTION_ID_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

351 static void 
	$QUICLY_NEW_CONNECTION_ID_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, uint64_t 
arg3
, const char * 
arg4
, const char * 
arg5
)

353 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"new-connection-id-send\", \"conn\":%u, \"time\":%lld, \"sequence\":%llu, \"retire-prior-to\":%llu, \"cid\":\"%s\", \"stateless-reset-token\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, 
arg4
, 
arg5
);

354 
	}
}

356 #define 
	#QUICLY_NEW_CONNECTION_ID_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

358 static void 
	$QUICLY_NEW_CONNECTION_ID_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, uint64_t 
arg3
, const char * 
arg4
, const char * 
arg5
)

360 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"new-connection-id-receive\", \"conn\":%u, \"time\":%lld, \"sequence\":%llu, \"retire-prior-to\":%llu, \"cid\":\"%s\", \"stateless-reset-token\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, 
arg4
, 
arg5
);

361 
	}
}

363 #define 
	#QUICLY_RETIRE_CONNECTION_ID_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

365 static void 
	$QUICLY_RETIRE_CONNECTION_ID_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

367 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"retire-connection-id-send\", \"conn\":%u, \"time\":%lld, \"sequence\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

368 
	}
}

370 #define 
	#QUICLY_RETIRE_CONNECTION_ID_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

372 static void 
	$QUICLY_RETIRE_CONNECTION_ID_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

374 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"retire-connection-id-receive\", \"conn\":%u, \"time\":%lld, \"sequence\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

375 
	}
}

377 #define 
	#QUICLY_DATA_BLOCKED_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

379 static void 
	$QUICLY_DATA_BLOCKED_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

381 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"data-blocked-send\", \"conn\":%u, \"time\":%lld, \"off\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

382 
	}
}

384 #define 
	#QUICLY_DATA_BLOCKED_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

386 static void 
	$QUICLY_DATA_BLOCKED_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

388 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"data-blocked-receive\", \"conn\":%u, \"time\":%lld, \"off\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
);

389 
	}
}

391 #define 
	#QUICLY_STREAM_DATA_BLOCKED_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

393 static void 
	$QUICLY_STREAM_DATA_BLOCKED_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int64_t 
arg2
, 
uint64_t
 
arg3
)

395 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-data-blocked-send\", \"conn\":%u, \"time\":%lld, \"stream-id\":%lld, \"maximum\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
, (unsigned long long)
arg3
);

396 
	}
}

398 #define 
	#QUICLY_STREAM_DATA_BLOCKED_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

400 static void 
	$QUICLY_STREAM_DATA_BLOCKED_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int64_t 
arg2
, 
uint64_t
 
arg3
)

402 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-data-blocked-receive\", \"conn\":%u, \"time\":%lld, \"stream-id\":%lld, \"maximum\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
, (unsigned long long)
arg3
);

403 
	}
}

405 #define 
	#QUICLY_DATAGRAM_SEND_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

407 static void 
	$QUICLY_DATAGRAM_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, const void * 
arg2
, 
size_t
 
arg3
)

409 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"datagram-send\", \"conn\":%u, \"time\":%lld, \"payload\":\"0x%llx\", \"payload-len\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
);

410 
	}
}

412 #define 
	#QUICLY_DATAGRAM_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

414 static void 
	$QUICLY_DATAGRAM_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, const void * 
arg2
, 
size_t
 
arg3
)

416 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"datagram-receive\", \"conn\":%u, \"time\":%lld, \"payload\":\"0x%llx\", \"payload-len\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
);

417 
	}
}

419 #define 
	#QUICLY_ACK_FREQUENCY_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

421 static void 
	$QUICLY_ACK_FREQUENCY_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, uint64_t 
arg3
, uint64_t 
arg4
, int 
arg5
)

423 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"ack-frequency-receive\", \"conn\":%u, \"time\":%lld, \"sequence\":%llu, \"packet-tolerance\":%llu, \"max-ack-delay\":%llu, \"ignore-order\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (long long)
arg5
);

424 
	}
}

426 #define 
	#QUICLY_QUICTRACE_SEND_STREAM_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

428 static void 
	$QUICLY_QUICTRACE_SEND_STREAM
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, 
uint64_t
 
arg3
, 
size_t
 
arg4
, int 
arg5
)

430 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"quictrace-send-stream\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"off\":%llu, \"len\":%llu, \"fin\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (long long)
arg5
);

431 
	}
}

433 #define 
	#QUICLY_QUICTRACE_RECV_STREAM_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

435 static void 
	$QUICLY_QUICTRACE_RECV_STREAM
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int64_t 
arg2
, 
uint64_t
 
arg3
, 
size_t
 
arg4
, int 
arg5
)

437 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"quictrace-recv-stream\", \"conn\":%u, \"time\":%lld, \"stream-id\":%lld, \"off\":%llu, \"len\":%llu, \"fin\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (long long)
arg5
);

438 
	}
}

440 #define 
	#QUICLY_QUICTRACE_CC_ACK_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

442 static void 
	$QUICLY_QUICTRACE_CC_ACK
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
quicly_rtt_t
 * 
arg2
, 
uint32_t
 
arg3
, 
size_t
 
arg4
)

444 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"quictrace-cc-ack\", \"conn\":%u, \"time\":%lld, \"min-rtt\":%u, \"smoothed-rtt\":%u, \"latest-rtt\":%u, \"cwnd\":%llu, \"inflight\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, 
arg2
->
minimum
, arg2->
smoothed
, arg2->
latest
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

445 
	}
}

447 #define 
	#QUICLY_QUICTRACE_CC_LOST_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

449 static void 
	$QUICLY_QUICTRACE_CC_LOST
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
quicly_rtt_t
 * 
arg2
, 
uint32_t
 
arg3
, 
size_t
 
arg4
)

451 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"quictrace-cc-lost\", \"conn\":%u, \"time\":%lld, \"min-rtt\":%u, \"smoothed-rtt\":%u, \"latest-rtt\":%u, \"cwnd\":%llu, \"inflight\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, 
arg2
->
minimum
, arg2->
smoothed
, arg2->
latest
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

452 
	}
}

454 #define 
	#QUICLY_STREAM_ON_OPEN_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

456 static void 
	$QUICLY_STREAM_ON_OPEN
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
)

458 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-on-open\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
);

459 
	}
}

461 #define 
	#QUICLY_STREAM_ON_DESTROY_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

463 static void 
	$QUICLY_STREAM_ON_DESTROY
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, int 
arg3
)

465 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-on-destroy\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"err\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (long long)
arg3
);

466 
	}
}

468 #define 
	#QUICLY_STREAM_ON_SEND_SHIFT_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

470 static void 
	$QUICLY_STREAM_ON_SEND_SHIFT
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, 
size_t
 
arg3
)

472 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-on-send-shift\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"delta\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (unsigned long long)
arg3
);

473 
	}
}

475 #define 
	#QUICLY_STREAM_ON_SEND_EMIT_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

477 static void 
	$QUICLY_STREAM_ON_SEND_EMIT
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, 
size_t
 
arg3
, size_t 
arg4
)

479 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-on-send-emit\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"off\":%llu, \"capacity\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

480 
	}
}

482 #define 
	#QUICLY_STREAM_ON_SEND_STOP_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

484 static void 
	$QUICLY_STREAM_ON_SEND_STOP
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, int 
arg3
)

486 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-on-send-stop\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"err\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (long long)
arg3
);

487 
	}
}

489 #define 
	#QUICLY_STREAM_ON_RECEIVE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

491 static void 
	$QUICLY_STREAM_ON_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, 
size_t
 
arg3
, const void * 
arg4
, size_t 
arg5
)

493 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-on-receive\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"off\":%llu, \"src\":\"0x%llx\", \"src-len\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (unsigned long long)
arg5
);

494 
	}
}

496 #define 
	#QUICLY_STREAM_ON_RECEIVE_RESET_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

498 static void 
	$QUICLY_STREAM_ON_RECEIVE_RESET
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, int 
arg3
)

500 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"stream-on-receive-reset\", \"conn\":%u, \"time\":%lld, \"stream-id\":%d, \"err\":%lld}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, (int)
arg2
->
stream_id
, (long long)
arg3
);

501 
	}
}

503 #define 
	#QUICLY_DEBUG_MESSAGE_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

505 static void 
	$QUICLY_DEBUG_MESSAGE
(struct 
st_quicly_conn_t
 * 
arg0
, const char * 
arg1
, int 
arg2
, const char * 
arg3
)

507 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"debug-message\", \"conn\":%u, \"function\":\"%s\", \"line\":%lld, \"message\":\"%s\"}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, 
arg1
, (long long)
arg2
, 
arg3
);

508 
	}
}

510 #define 
	#QUICLY_CONN_STATS_ENABLED
() (
quicly_trace_fp
 != 
NULL
)

	)

512 static void 
	$QUICLY_CONN_STATS
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stats_t
 * 
arg2
, 
size_t
 
arg3
)

514 
	`fprintf
(
quicly_trace_fp
, "{\"type\":\"conn-stats\", \"conn\":%u, \"time\":%lld, \"rtt_minimum\":%u, \"rtt_smoothed\":%u, \"rtt_variance\":%u, \"cc_cwnd\":%u, \"cc_ssthresh\":%u, \"cc_cwnd_initial\":%u, \"cc_cwnd_exiting_slow_start\":%u, \"cc_cwnd_minimum\":%u, \"cc_cwnd_maximum\":%u, \"cc_num_loss_episodes\":%u, \"num_packets_sent\":%" 
PRIu64
 ", \"num_packets_ack_received\":%" PRIu64 ", \"num_packets_lost\":%" PRIu64 ", \"num_packets_lost_time_threshold\":%" PRIu64 ", \"num_packets_late_acked\":%" PRIu64 ", \"num_packets_received\":%" PRIu64 ", \"num_packets_decryption_failed\":%" PRIu64 ", \"num_bytes_sent\":%" PRIu64 ", \"num_bytes_received\":%" PRIu64 ", \"num_frames_sent_padding\":%" PRIu64 ", \"num_frames_sent_ping\":%" PRIu64 ", \"num_frames_sent_ack\":%" PRIu64 ", \"num_frames_sent_reset_stream\":%" PRIu64 ", \"num_frames_sent_stop_sending\":%" PRIu64 ", \"num_frames_sent_crypto\":%" PRIu64 ", \"num_frames_sent_new_token\":%" PRIu64 ", \"num_frames_sent_stream\":%" PRIu64 ", \"num_frames_sent_max_data\":%" PRIu64 ", \"num_frames_sent_max_stream_data\":%" PRIu64 ", \"num_frames_sent_max_streams_bidi\":%" PRIu64 ", \"num_frames_sent_max_streams_uni\":%" PRIu64 ", \"num_frames_sent_data_blocked\":%" PRIu64 ", \"num_frames_sent_stream_data_blocked\":%" PRIu64 ", \"num_frames_sent_streams_blocked\":%" PRIu64 ", \"num_frames_sent_new_connection_id\":%" PRIu64 ", \"num_frames_sent_retire_connection_id\":%" PRIu64 ", \"num_frames_sent_path_challenge\":%" PRIu64 ", \"num_frames_sent_path_response\":%" PRIu64 ", \"num_frames_sent_transport_close\":%" PRIu64 ", \"num_frames_sent_application_close\":%" PRIu64 ", \"num_frames_sent_handshake_done\":%" PRIu64 ", \"num_frames_sent_ack_frequency\":%" PRIu64 ", \"num_frames_received_padding\":%" PRIu64 ", \"num_frames_received_ping\":%" PRIu64 ", \"num_frames_received_ack\":%" PRIu64 ", \"num_frames_received_reset_stream\":%" PRIu64 ", \"num_frames_received_stop_sending\":%" PRIu64 ", \"num_frames_received_crypto\":%" PRIu64 ", \"num_frames_received_new_token\":%" PRIu64 ", \"num_frames_received_stream\":%" PRIu64 ", \"num_frames_received_max_data\":%" PRIu64 ", \"num_frames_received_max_stream_data\":%" PRIu64 ", \"num_frames_received_max_streams_bidi\":%" PRIu64 ", \"num_frames_received_max_streams_uni\":%" PRIu64 ", \"num_frames_received_data_blocked\":%" PRIu64 ", \"num_frames_received_stream_data_blocked\":%" PRIu64 ", \"num_frames_received_streams_blocked\":%" PRIu64 ", \"num_frames_received_new_connection_id\":%" PRIu64 ", \"num_frames_received_retire_connection_id\":%" PRIu64 ", \"num_frames_received_path_challenge\":%" PRIu64 ", \"num_frames_received_path_response\":%" PRIu64 ", \"num_frames_received_transport_close\":%" PRIu64 ", \"num_frames_received_application_close\":%" PRIu64 ", \"num_frames_received_handshake_done\":%" PRIu64 ", \"num_frames_received_ack_frequency\":%" PRIu64 ", \"num_ptos\":%" PRIu64 ", \"cc_type\":\"%s\", \"size\":%llu}\n", 
arg0
 != 
NULL
 ? ((struct 
_st_quicly_conn_public_t
 *)arg0)->
local
.
cid_set
.
plaintext
.
master_id
 : 0, (long long)
arg1
, 
arg2
->
rtt
.
minimum
, arg2->rtt.
smoothed
, arg2->rtt.
variance
, arg2->
cc
.
cwnd
, arg2->cc.
ssthresh
, arg2->cc.
cwnd_initial
, arg2->cc.
cwnd_exiting_slow_start
, arg2->cc.
cwnd_minimum
, arg2->cc.
cwnd_maximum
, arg2->cc.
num_loss_episodes
, arg2->
num_packets
.
sent
, arg2->num_packets.
ack_received
, arg2->num_packets.
lost
, arg2->num_packets.
lost_time_threshold
, arg2->num_packets.
late_acked
, arg2->num_packets.
received
, arg2->num_packets.
decryption_failed
, arg2->
num_bytes
.sent, arg2->num_bytes.received, arg2->
num_frames_sent
.
padding
, arg2->num_frames_sent.
ping
, arg2->num_frames_sent.
ack
, arg2->num_frames_sent.
reset_stream
, arg2->num_frames_sent.
stop_sending
, arg2->num_frames_sent.
crypto
, arg2->num_frames_sent.
new_token
, arg2->num_frames_sent.
stream
, arg2->num_frames_sent.
max_data
, arg2->num_frames_sent.
max_stream_data
, arg2->num_frames_sent.
max_streams_bidi
, arg2->num_frames_sent.
max_streams_uni
, arg2->num_frames_sent.
data_blocked
, arg2->num_frames_sent.
stream_data_blocked
, arg2->num_frames_sent.
streams_blocked
, arg2->num_frames_sent.
new_connection_id
, arg2->num_frames_sent.
retire_connection_id
, arg2->num_frames_sent.
path_challenge
, arg2->num_frames_sent.
path_response
, arg2->num_frames_sent.
transport_close
, arg2->num_frames_sent.
application_close
, arg2->num_frames_sent.
handshake_done
, arg2->num_frames_sent.
ack_frequency
, arg2->
num_frames_received
.padding, arg2->num_frames_received.ping, arg2->num_frames_received.ack, arg2->num_frames_received.reset_stream, arg2->num_frames_received.stop_sending, arg2->num_frames_received.crypto, arg2->num_frames_received.new_token, arg2->num_frames_received.stream, arg2->num_frames_received.max_data, arg2->num_frames_received.max_stream_data, arg2->num_frames_received.max_streams_bidi, arg2->num_frames_received.max_streams_uni, arg2->num_frames_received.data_blocked, arg2->num_frames_received.stream_data_blocked, arg2->num_frames_received.streams_blocked, arg2->num_frames_received.new_connection_id, arg2->num_frames_received.retire_connection_id, arg2->num_frames_received.path_challenge, arg2->num_frames_received.path_response, arg2->num_frames_received.transport_close, arg2->num_frames_received.application_close, arg2->num_frames_received.handshake_done, arg2->num_frames_received.ack_frequency, arg2->
num_ptos
, arg2->cc.
type
->
name
, (unsigned long long)
arg3
);

515 
	}
}

	@examples/echo.c

22 #ifndef 
_XOPEN_SOURCE


23 #define 
	#_XOPEN_SOURCE
 700

	)

25 #include 
	~<assert.h
>

26 #include 
	~<errno.h
>

27 #include 
	~<fcntl.h
>

28 #include 
	~<getopt.h
>

29 #include 
	~<netdb.h
>

30 #include 
	~<stdio.h
>

31 #include 
	~<sys/select.h
>

32 #include 
	~<sys/socket.h
>

33 #include 
	~<sys/time.h
>

34 #include 
	~<sys/types.h
>

35 #include 
	~<unistd.h
>

36 #include 
	~<openssl/pem.h
>

37 #include 
	~"picotls.h
"

38 #include 
	~"picotls/openssl.h
"

39 #include 
	~"quicly.h
"

40 #include 
	~"quicly/defaults.h
"

41 #include 
	~"quicly/streambuf.h
"

46 static 
quicly_context_t
 
	gctx
;

50 static 
quicly_cid_plaintext_t
 
	gnext_cid
;

52 static int 
	$resolve_address
(struct 
sockaddr
 *
sa
, 
socklen_t
 *
salen
, const char *
host
, const char *
port
, int 
family
, int 
type
,

53 int 
proto
)

55 struct 
addrinfo
 
hints
, *
res
;

56 int 
err
;

58 
	`memset
(&
hints
, 0, sizeof(hints));

59 
hints
.
ai_family
 = 
family
;

60 
hints
.
ai_socktype
 = 
type
;

61 
hints
.
ai_protocol
 = 
proto
;

62 
hints
.
ai_flags
 = 
AI_ADDRCONFIG
 | 
AI_NUMERICSERV
 | 
AI_PASSIVE
;

63 if ((
err
 = 
	`getaddrinfo
(
host
, 
port
, &
hints
, &
res
)) != 0 || res == 
NULL
) {

64 
	`fprintf
(
stderr
, "failed to resolve address:%s:%s:%s\n", 
host
, 
port
,

65 
err
 != 0 ? 
	`gai_strerror
(err) : "getaddrinfo returned NULL");

69 
	`memcpy
(
sa
, 
res
->
ai_addr
, res->
ai_addrlen
);

70 *
salen
 = 
res
->
ai_addrlen
;

72 
	`freeaddrinfo
(
res
);

74 
	}
}

76 static void 
	$usage
(const char *
progname
)

78 
	`printf
("Usage: %s [options] [host]\n"

87 
progname
);

88 
	`exit
(0);

89 
	}
}

91 static int 
	$is_server
(void)

93 return 
ctx
.
tls
->
certificates
.
count
 != 0;

94 
	}
}

96 static int 
	$forward_stdin
(
quicly_conn_t
 *
conn
)

98 
quicly_stream_t
 *
stream0
;

99 char 
buf
[4096];

100 
size_t
 
rret
;

102 if ((
stream0
 = 
	`quicly_get_stream
(
conn
, 0)) == 
NULL
 || !
	`quicly_sendstate_is_open
(&stream0->
sendstate
))

105 while ((
rret
 = 
	`read
(0, 
buf
, sizeof(buf))) == -1 && 
errno
 == 
EINTR
)

107 if (
rret
 == 0) {

109 
	`quicly_streambuf_egress_shutdown
(
stream0
);

113 
	`quicly_streambuf_egress_write
(
stream0
, 
buf
, 
rret
);

116 
	}
}

118 static void 
	$on_stop_sending
(
quicly_stream_t
 *
stream
, int 
err
)

120 
	`fprintf
(
stderr
, "received STOP_SENDING: %" 
PRIu16
 "\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
));

121 
	`quicly_close
(
stream
->
conn
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(0), "");

122 
	}
}

124 static void 
	$on_receive_reset
(
quicly_stream_t
 *
stream
, int 
err
)

126 
	`fprintf
(
stderr
, "received RESET_STREAM: %" 
PRIu16
 "\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
));

127 
	`quicly_close
(
stream
->
conn
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(0), "");

128 
	}
}

130 static void 
	$on_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
)

133 if (
	`quicly_streambuf_ingress_receive
(
stream
, 
off
, 
src
, 
len
) != 0)

137 
ptls_iovec_t
 
input
 = 
	`quicly_streambuf_ingress_get
(
stream
);

139 if (
	`is_server
()) {

141 if (
	`quicly_sendstate_is_open
(&
stream
->
sendstate
) && (
input
.
len
 > 0)) {

142 
	`quicly_streambuf_egress_write
(
stream
, 
input
.
base
, input.
len
);

144 if (
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
))

145 
	`quicly_streambuf_egress_shutdown
(
stream
);

149 
	`fwrite
(
input
.
base
, 1, input.
len
, 
stdout
);

150 
	`fflush
(
stdout
);

152 if (
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
))

153 
	`quicly_close
(
stream
->
conn
, 0, "");

157 
	`quicly_streambuf_ingress_shift
(
stream
, 
input
.
len
);

158 
	}
}

160 static void 
	$process_msg
(int 
is_client
, 
quicly_conn_t
 **
conns
, struct 
msghdr
 *
msg
, 
size_t
 
dgram_len
)

162 
size_t
 
off
 = 0, 
i
;

165 while (
off
 < 
dgram_len
) {

166 
quicly_decoded_packet_t
 
decoded
;

167 if (
	`quicly_decode_packet
(&
ctx
, &
decoded
, 
msg
->
msg_iov
[0].
iov_base
, 
dgram_len
, &
off
) == 
SIZE_MAX
)

170 for (
i
 = 0; 
conns
[i] != 
NULL
; ++i)

171 if (
	`quicly_is_destination
(
conns
[
i
], 
NULL
, 
msg
->
msg_name
, &
decoded
))

173 if (
conns
[
i
] != 
NULL
) {

175 
	`quicly_receive
(
conns
[
i
], 
NULL
, 
msg
->
msg_name
, &
decoded
);

176 } else if (!
is_client
) {

178 
	`quicly_accept
(
conns
 + 
i
, &
ctx
, 
NULL
, 
msg
->
msg_name
, &
decoded
, NULL, &
next_cid
, NULL);

181 
	}
}

183 static int 
	$send_one
(int 
fd
, struct 
sockaddr
 *
dest
, struct 
iovec
 *
vec
)

185 struct 
msghdr
 
mess
 = {.
msg_name
 = 
dest
, .
msg_namelen
 = 
	`quicly_get_socklen
(dest), .
msg_iov
 = 
vec
, .
msg_iovlen
 = 1};

186 int 
ret
;

188 while ((
ret
 = (int)
	`sendmsg
(
fd
, &
mess
, 0)) == -1 && 
errno
 == 
EINTR
)

190 return 
ret
;

191 
	}
}

193 static int 
	$run_loop
(int 
fd
, 
quicly_conn_t
 *
client
)

195 
quicly_conn_t
 *
conns
[256] = {
client
};

196 
size_t
 
i
;

197 int 
read_stdin
 = 
client
 != 
NULL
;

202 
fd_set
 
readfds
;

203 struct 
timeval
 
tv
;

205 
int64_t
 
first_timeout
 = 
INT64_MAX
, 
now
 = 
ctx
.now->
	`cb
(ctx.now);

206 for (
i
 = 0; 
conns
[i] != 
NULL
; ++i) {

207 
int64_t
 
conn_timeout
 = 
	`quicly_get_first_timeout
(
conns
[
i
]);

208 if (
conn_timeout
 < 
first_timeout
)

209 
first_timeout
 = 
conn_timeout
;

211 if (
now
 < 
first_timeout
) {

212 
int64_t
 
delta
 = 
first_timeout
 - 
now
;

213 if (
delta
 > 1000 * 1000)

214 
delta
 = 1000 * 1000;

215 
tv
.
tv_sec
 = 
delta
 / 1000;

216 
tv
.
tv_usec
 = (
delta
 % 1000) * 1000;

218 
tv
.
tv_sec
 = 1000;

219 
tv
.
tv_usec
 = 0;

221 
	`FD_ZERO
(&
readfds
);

222 
	`FD_SET
(
fd
, &
readfds
);

224 if (
read_stdin
)

225 
	`FD_SET
(0, &
readfds
);

226 } while (
	`select
(
fd
 + 1, &
readfds
, 
NULL
, NULL, &
tv
) == -1 && 
errno
 == 
EINTR
);

229 if (
	`FD_ISSET
(
fd
, &
readfds
)) {

230 
uint8_t
 
buf
[4096];

231 struct 
sockaddr_storage
 
sa
;

232 struct 
iovec
 
vec
 = {.
iov_base
 = 
buf
, .
iov_len
 = sizeof(buf)};

233 struct 
msghdr
 
msg
 = {.
msg_name
 = &
sa
, .
msg_namelen
 = sizeof(sa), .
msg_iov
 = &
vec
, .
msg_iovlen
 = 1};

234 
ssize_t
 
rret
;

235 while ((
rret
 = 
	`recvmsg
(
fd
, &
msg
, 0)) == -1 && 
errno
 == 
EINTR
)

237 if (
rret
 > 0)

238 
	`process_msg
(
client
 != 
NULL
, 
conns
, &
msg
, 
rret
);

242 if (
	`FD_ISSET
(0, &
readfds
)) {

243 
	`assert
(
client
 != 
NULL
);

244 if (!
	`forward_stdin
(
client
))

245 
read_stdin
 = 0;

249 for (
i
 = 0; 
conns
[i] != 
NULL
; ++i) {

250 
quicly_address_t
 
dest
, 
src
;

251 struct 
iovec
 
dgrams
[10];

252 
uint8_t
 
dgrams_buf
[
	`PTLS_ELEMENTSOF
(
dgrams
) * 
ctx
.
transport_params
.
max_udp_payload_size
];

253 
size_t
 
num_dgrams
 = 
	`PTLS_ELEMENTSOF
(
dgrams
);

254 int 
ret
 = 
	`quicly_send
(
conns
[
i
], &
dest
, &
src
, 
dgrams
, &
num_dgrams
, 
dgrams_buf
, sizeof(dgrams_buf));

255 switch (
ret
) {

257 
size_t
 
j
;

258 for (
j
 = 0; j != 
num_dgrams
; ++j) {

259 
	`send_one
(
fd
, &
dest
.
sa
, &
dgrams
[
j
]);

262 case 
QUICLY_ERROR_FREE_CONNECTION
:

264 
	`quicly_free
(
conns
[
i
]);

265 
	`memmove
(
conns
 + 
i
, conns + i + 1, sizeof(conns) - sizeof(conns[0]) * (i + 1));

266 --
i
;

267 if (!
	`is_server
())

271 
	`fprintf
(
stderr
, "quicly_send returned %d\n", 
ret
);

278 
	}
}

280 static int 
	$on_stream_open
(
quicly_stream_open_t
 *
self
, 
quicly_stream_t
 *
stream
)

282 static const 
quicly_stream_callbacks_t
 
stream_callbacks
 = {

283 
quicly_streambuf_destroy
, 
quicly_streambuf_egress_shift
, 
quicly_streambuf_egress_emit
, 
on_stop_sending
, 
on_receive
,

284 
on_receive_reset
};

285 int 
ret
;

287 if ((
ret
 = 
	`quicly_streambuf_create
(
stream
, sizeof(
quicly_streambuf_t
))) != 0)

288 return 
ret
;

289 
stream
->
callbacks
 = &
stream_callbacks
;

291 
	}
}

293 int 
	$main
(int 
argc
, char **
argv
)

295 
ptls_openssl_sign_certificate_t
 
sign_certificate
;

296 
ptls_context_t
 
tlsctx
 = {

297 .
random_bytes
 = 
ptls_openssl_random_bytes
,

298 .
get_time
 = &
ptls_get_time
,

299 .
key_exchanges
 = 
ptls_openssl_key_exchanges
,

300 .
cipher_suites
 = 
ptls_openssl_cipher_suites
,

302 
quicly_stream_open_t
 
stream_open
 = {
on_stream_open
};

303 char *
host
 = "127.0.0.1", *
port
 = "4433";

304 struct 
sockaddr_storage
 
sa
;

305 
socklen_t
 
salen
;

306 int 
ch
, 
fd
;

309 
ctx
 = 
quicly_spec_context
;

310 
ctx
.
tls
 = &
tlsctx
;

311 
	`quicly_amend_ptls_context
(
ctx
.
tls
);

312 
ctx
.
stream_open
 = &stream_open;

315 while ((
ch
 = 
	`getopt
(
argc
, 
argv
, "c:k:p:h")) != -1) {

316 switch (
ch
) {

318 int 
ret
;

319 if ((
ret
 = 
	`ptls_load_certificates
(&
tlsctx
, 
optarg
)) != 0) {

320 
	`fprintf
(
stderr
, "failed to load certificates from file %s:%d\n", 
optarg
, 
ret
);

321 
	`exit
(1);

325 
FILE
 *
fp
;

326 if ((
fp
 = 
	`fopen
(
optarg
, "r")) == 
NULL
) {

327 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
optarg
, 
	`strerror
(
errno
));

328 
	`exit
(1);

330 
EVP_PKEY
 *
pkey
 = 
	`PEM_read_PrivateKey
(
fp
, 
NULL
, NULL, NULL);

331 
	`fclose
(
fp
);

332 if (
pkey
 == 
NULL
) {

333 
	`fprintf
(
stderr
, "failed to load private key from file:%s\n", 
optarg
);

334 
	`exit
(1);

336 
	`ptls_openssl_init_sign_certificate
(&
sign_certificate
, 
pkey
);

337 
	`EVP_PKEY_free
(
pkey
);

338 
tlsctx
.
sign_certificate
 = &sign_certificate.
super
;

341 
port
 = 
optarg
;

344 
	`usage
(
argv
[0]);

347 
	`exit
(1);

351 if ((
tlsctx
.
certificates
.
count
 != 0) != (tlsctx.
sign_certificate
 != 
NULL
)) {

352 
	`fprintf
(
stderr
, "-c and -k options must be used together\n");

353 
	`exit
(1);

355 
argc
 -= 
optind
;

356 
argv
 += 
optind
;

357 if (
argc
 != 0)

358 
host
 = *
argv
++;

359 if (
	`resolve_address
((struct 
sockaddr
 *)&
sa
, &
salen
, 
host
, 
port
, 
AF_INET
, 
SOCK_DGRAM
, 0) != 0)

360 
	`exit
(1);

363 if ((
fd
 = 
	`socket
(
sa
.
ss_family
, 
SOCK_DGRAM
, 0)) == -1) {

364 
	`perror
("socket(2) failed");

365 
	`exit
(1);

368 if (
	`is_server
()) {

369 int 
reuseaddr
 = 1;

370 
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_REUSEADDR
, &
reuseaddr
, sizeof(reuseaddr));

371 if (
	`bind
(
fd
, (struct 
sockaddr
 *)&
sa
, 
salen
) != 0) {

372 
	`perror
("bind(2) failed");

373 
	`exit
(1);

376 struct 
sockaddr_in
 
local
;

377 
	`memset
(&
local
, 0, sizeof(local));

378 if (
	`bind
(
fd
, (struct 
sockaddr
 *)&
local
, sizeof(local)) != 0) {

379 
	`perror
("bind(2) failed");

380 
	`exit
(1);

384 
quicly_conn_t
 *
client
 = 
NULL
;

385 if (!
	`is_server
()) {

387 int 
ret
;

388 if ((
ret
 = 
	`quicly_connect
(&
client
, &
ctx
, 
host
, (struct 
sockaddr
 *)&
sa
, 
NULL
, &
next_cid
, 
	`ptls_iovec_init
(NULL, 0), NULL,

389 
NULL
)) != 0) {

390 
	`fprintf
(
stderr
, "quicly_connect failed:%d\n", 
ret
);

391 
	`exit
(1);

393 
quicly_stream_t
 *
stream
;

394 
	`quicly_open_stream
(
client
, &
stream
, 0);

398 return 
	`run_loop
(
fd
, 
client
);

399 
	}
}

	@examples/pipeclient.c

5 #ifndef 
_XOPEN_SOURCE


6 #define 
	#_XOPEN_SOURCE
 700

	)

8 #include 
	~<linux/if_ether.h
>

9 #include 
	~<assert.h
>

10 #include 
	~<errno.h
>

11 #include 
	~<fcntl.h
>

12 #include 
	~<getopt.h
>

13 #include 
	~<netdb.h
>

14 #include 
	~<stdio.h
>

15 #include 
	~<sys/select.h
>

16 #include 
	~<sys/socket.h
>

17 #include 
	~<sys/time.h
>

18 #include 
	~<sys/types.h
>

19 #include 
	~<unistd.h
>

20 #include 
	~<openssl/pem.h
>

21 #include 
	~"picotls.h
"

22 #include 
	~"picotls/openssl.h
"

23 #include 
	~"quicly.h
"

24 #include 
	~"quicly/defaults.h
"

25 #include 
	~"quicly/streambuf.h
"

27 #include 
	~<linux/if_ether.h
>

28 #include 
	~<sys/select.h
>

29 #include 
	~<sys/socket.h
>

30 #include 
	~<sys/stat.h
>

31 #include 
	~<sys/time.h
>

32 #include 
	~<sys/types.h
>

33 #include 
	~<getopt.h
>

34 #include 
	~<netinet/udp.h
>

35 #include 
	~<fcntl.h
>

36 #include 
	~<netdb.h
>

37 #include 
	~<stdio.h
>

38 #include 
	~<unistd.h
>

40 #if 
QUICLY_HAVE_FUSION


41 #include 
	~"picotls/fusion.h
"

43 #include 
	~"quicly.h
"

44 #include 
	~"quicly/defaults.h
"

45 #include 
	~"quicly/streambuf.h
"

46 #include 
	~"../deps/picotls/t/util.h
"

47 #include 
	~<linux/if.h
>

49 #include 
	~<stdio.h
>

50 #include 
	~<string.h
>

51 #include 
	~<malloc.h
>

52 #include 
	~<errno.h
>

53 #include 
	~<sys/ioctl.h
>

54 #include 
	~<netinet/in.h
>

55 #include 
	~<netinet/ip.h
>

56 #include 
	~<netinet/if_ether.h
>

57 #include 
	~<netinet/udp.h
>

58 #include 
	~<linux/if_packet.h
>

59 #include 
	~<arpa/inet.h
>

64 static 
quicly_context_t
 
	gctx
;

68 static 
quicly_cid_plaintext_t
 
	gnext_cid
;

72 int 
	gis_verbose
 = 0;

74 static int 
	$resolve_address
(struct 
sockaddr
 *
sa
, 
socklen_t
 *
salen
, const char *
host
, const char *
port
, int 
family
, int 
type
,

75 int 
proto
)

77 struct 
addrinfo
 
hints
, *
res
;

78 int 
err
;

80 
	`memset
(&
hints
, 0, sizeof(hints));

81 
hints
.
ai_family
 = 
family
;

82 
hints
.
ai_socktype
 = 
type
;

83 
hints
.
ai_protocol
 = 
proto
;

84 
hints
.
ai_flags
 = 
AI_ADDRCONFIG
 | 
AI_NUMERICSERV
 | 
AI_PASSIVE
;

85 if ((
err
 = 
	`getaddrinfo
(
host
, 
port
, &
hints
, &
res
)) != 0 || res == 
NULL
) {

86 
	`fprintf
(
stderr
, "failed to resolve address:%s:%s:%s\n", 
host
, 
port
,

87 
err
 != 0 ? 
	`gai_strerror
(err) : "getaddrinfo returned NULL");

91 
	`memcpy
(
sa
, 
res
->
ai_addr
, res->
ai_addrlen
);

92 *
salen
 = 
res
->
ai_addrlen
;

94 
	`freeaddrinfo
(
res
);

96 
	}
}

98 static void 
	$usage
(const char *
progname
)

100 
	`printf
("Usage: %s [options] [host]\n"

110 
progname
, progname);

111 
	`exit
(0);

112 
	}
}

114 static int 
	$forward_stdin
(
quicly_conn_t
 *
conn
)

116 
quicly_stream_t
 *
stream0
;

117 const 
size_t
 
READ_BLOCK_SIZE
 = 188 * 6;

118 char 
buf
[
READ_BLOCK_SIZE
];

119 
size_t
 
rret
;

121 if ((
stream0
 = 
	`quicly_get_stream
(
conn
, 0)) == 
NULL
 || !
	`quicly_sendstate_is_open
(&stream0->
sendstate
))

125 while ((
rret
 = 
	`read
(
STDIN_FILENO
, 
buf
, 
READ_BLOCK_SIZE
)) == -1 && 
errno
 == 
EINTR
)

128 
	`fprintf
(
stderr
, "Read from stdin: %zu bytes\n", 
rret
);

131 if (
rret
 < 0) {

133 
	`fprintf
(
stderr
, "failed to read from stdin");

134 
rret
 = 0;

137 if (
rret
 == 0) {

138 
	`fprintf
(
stderr
, "Closing\n");

140 
	`quicly_streambuf_egress_shutdown
(
stream0
);

144 
	`quicly_streambuf_egress_write
(
stream0
, 
buf
, 
rret
);

147 
	}
}

149 static void 
	$on_stop_sending
(
quicly_stream_t
 *
stream
, int 
err
)

151 
	`fprintf
(
stderr
, "received STOP_SENDING: %" 
PRIu16
 "\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
));

152 
	`quicly_close
(
stream
->
conn
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(0), "");

153 
	}
}

155 static void 
	$on_receive_reset
(
quicly_stream_t
 *
stream
, int 
err
)

157 
	`fprintf
(
stderr
, "received RESET_STREAM: %" 
PRIu16
 "\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
));

158 
	`quicly_close
(
stream
->
conn
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(0), "");

159 
	}
}

161 static void 
	$on_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
)

164 if (
	`quicly_streambuf_ingress_receive
(
stream
, 
off
, 
src
, 
len
) != 0)

168 
ptls_iovec_t
 
input
 = 
	`quicly_streambuf_ingress_get
(
stream
);

171 if (
is_verbose
) {

172 
	`fwrite
(
input
.
base
, 1, input.
len
, 
stdout
);

173 
	`fflush
(
stdout
);

176 if (
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
))

177 
	`quicly_close
(
stream
->
conn
, 0, "");

180 
	`quicly_streambuf_ingress_shift
(
stream
, 
input
.
len
);

181 
	}
}

183 static void 
	$process_msg
(
quicly_conn_t
 *
client
, struct 
msghdr
 *
msg
, 
size_t
 
dgram_len
)

185 
size_t
 
off
 = 0;

188 while (
off
 < 
dgram_len
) {

189 
quicly_decoded_packet_t
 
decoded
;

190 if (
	`quicly_decode_packet
(&
ctx
, &
decoded
, 
msg
->
msg_iov
[0].
iov_base
, 
dgram_len
, &
off
) == 
SIZE_MAX
)

193 if (
client
 != 
NULL
) {

194 if (
	`quicly_is_destination
(
client
, 
NULL
, 
msg
->
msg_name
, &
decoded
))

195 
	`quicly_receive
(
client
, 
NULL
, 
msg
->
msg_name
, &
decoded
);

198 
	}
}

200 static int 
	$send_one
(int 
fd
, struct 
sockaddr
 *
dest
, struct 
iovec
 *
vec
)

202 struct 
msghdr
 
mess
 = {.
msg_name
 = 
dest
, .
msg_namelen
 = 
	`quicly_get_socklen
(dest), .
msg_iov
 = 
vec
, .
msg_iovlen
 = 1};

203 int 
ret
;

205 while ((
ret
 = (int)
	`sendmsg
(
fd
, &
mess
, 0)) == -1 && 
errno
 == 
EINTR
)

207 return 
ret
;

208 
	}
}

210 static int 
	$run_loop_client
(int 
fd
, 
quicly_conn_t
 *
client
)

212 int 
read_stdin
 = 1;

216 
fd_set
 
readfds
;

217 struct 
timeval
 
tv
;

219 
int64_t
 
first_timeout
 = 
INT64_MAX
, 
now
 = 
ctx
.now->
	`cb
(ctx.now);

220 
int64_t
 
conn_timeout
 = 
	`quicly_get_first_timeout
(
client
);

221 if (
conn_timeout
 < 
first_timeout
)

222 
first_timeout
 = 
conn_timeout
;

223 if (
now
 < 
first_timeout
) {

224 
int64_t
 
delta
 = 
first_timeout
 - 
now
;

225 if (
delta
 > 1000 * 1000)

226 
delta
 = 1000 * 1000;

227 
tv
.
tv_sec
 = 
delta
 / 1000;

228 
tv
.
tv_usec
 = (
delta
 % 1000) * 1000;

230 
tv
.
tv_sec
 = 1000;

231 
tv
.
tv_usec
 = 0;

233 
	`FD_ZERO
(&
readfds
);

234 
	`FD_SET
(
fd
, &
readfds
);

235 if (
read_stdin
)

236 
	`FD_SET
(
STDIN_FILENO
, &
readfds
);

237 } while (
	`select
(
fd
 + 1, &
readfds
, 
NULL
, NULL, &
tv
) == -1 && 
errno
 == 
EINTR
);

240 if (
	`FD_ISSET
(
fd
, &
readfds
)) {

241 
uint8_t
 
buf
[4096];

242 struct 
sockaddr_storage
 
sa
;

243 struct 
iovec
 
vec
 = {.
iov_base
 = 
buf
, .
iov_len
 = sizeof(buf)};

244 struct 
msghdr
 
msg
 = {.
msg_name
 = &
sa
, .
msg_namelen
 = sizeof(sa), .
msg_iov
 = &
vec
, .
msg_iovlen
 = 1};

245 
ssize_t
 
rret
;

246 while ((
rret
 = 
	`recvmsg
(
fd
, &
msg
, 0)) == -1 && 
errno
 == 
EINTR
)

248 if (
rret
 > 0)

249 
	`process_msg
(
client
, &
msg
, 
rret
);

252 if (
	`FD_ISSET
(0, &
readfds
)) {

253 
	`assert
(
client
 != 
NULL
);

254 if (!
	`forward_stdin
(
client
))

255 
read_stdin
 = 0;

259 
quicly_address_t
 
dest
, 
src
;

260 struct 
iovec
 
dgrams
[10];

261 
uint8_t
 
dgrams_buf
[
	`PTLS_ELEMENTSOF
(
dgrams
) * 
ctx
.
transport_params
.
max_udp_payload_size
];

262 
size_t
 
num_dgrams
 = 
	`PTLS_ELEMENTSOF
(
dgrams
);

263 int 
ret
 = 
	`quicly_send
(
client
, &
dest
, &
src
, 
dgrams
, &
num_dgrams
, 
dgrams_buf
, sizeof(dgrams_buf));

264 switch (
ret
) {

266 
size_t
 
j
;

267 for (
j
 = 0; j != 
num_dgrams
; ++j) {

268 
	`send_one
(
fd
, &
dest
.
sa
, &
dgrams
[
j
]);

271 case 
QUICLY_ERROR_FREE_CONNECTION
:

273 
	`quicly_free
(
client
);

276 
	`fprintf
(
stderr
, "quicly_send returned %d\n", 
ret
);

282 
	}
}

284 static int 
	$on_stream_open
(
quicly_stream_open_t
 *
self
, 
quicly_stream_t
 *
stream
)

286 static const 
quicly_stream_callbacks_t
 
stream_callbacks
 = {

287 
quicly_streambuf_destroy
, 
quicly_streambuf_egress_shift
, 
quicly_streambuf_egress_emit
, 
on_stop_sending
, 
on_receive
,

288 
on_receive_reset
};

289 int 
ret
;

291 if ((
ret
 = 
	`quicly_streambuf_create
(
stream
, sizeof(
quicly_streambuf_t
))) != 0)

292 return 
ret
;

293 
stream
->
callbacks
 = &
stream_callbacks
;

295 
	}
}

297 int 
	$main
(int 
argc
, char **
argv
)

299 
ptls_context_t
 
tlsctx
 = {

300 .
random_bytes
 = 
ptls_openssl_random_bytes
,

301 .
get_time
 = &
ptls_get_time
,

302 .
key_exchanges
 = 
ptls_openssl_key_exchanges
,

303 .
cipher_suites
 = 
ptls_openssl_cipher_suites
,

305 
quicly_stream_open_t
 
stream_open
 = {
on_stream_open
};

306 char *
host
 = "127.0.0.1", *
port
 = "4433";

307 struct 
sockaddr_storage
 
sa
;

308 
socklen_t
 
salen
;

309 int 
ch
, 
fd
;

312 
ctx
 = 
quicly_spec_context
;

313 
ctx
.
tls
 = &
tlsctx
;

314 
	`quicly_amend_ptls_context
(
ctx
.
tls
);

315 
ctx
.
stream_open
 = &stream_open;

318 while ((
ch
 = 
	`getopt
(
argc
, 
argv
, "p:h:v")) != -1) {

319 switch (
ch
) {

321 
port
 = 
optarg
;

324 
is_verbose
 = 1;

327 
	`usage
(
argv
[0]);

330 
	`exit
(1);

334 
argc
 -= 
optind
;

335 
argv
 += 
optind
;

336 if (
argc
 != 0)

337 
host
 = *
argv
++;

338 if (
	`resolve_address
((struct 
sockaddr
 *)&
sa
, &
salen
, 
host
, 
port
, 
AF_INET
, 
SOCK_DGRAM
, 0) != 0)

339 
	`exit
(1);

347 if ((
fd
 = 
	`socket
(
AF_PACKET
, 
SOCK_RAW
, 
	`htons
(
ETH_P_IP
))) == -1) {

348 
	`perror
("socket(2) failed for AF_PACKET");

349 
	`exit
(1);

355 struct 
sockaddr_ll
 
sll
;

356 
	`memset
(&
sll
, 0, sizeof(sll));

357 
sll
.
sll_family
 = 
AF_PACKET
;

358 
sll
.
sll_ifindex
 = 
	`if_nametoindex
("eth0");

359 
sll
.
sll_protocol
 = 
	`htons
(
ETH_P_IP
);

360 if (
	`bind
(
fd
, (struct 
sockaddr
 *)&
sll
, sizeof(sll)) != 0) {

361 
	`perror
("bind(2) failed for AF_PACKET");

362 
	`exit
(1);

373 
quicly_conn_t
 *
client
 = 
NULL
;

375 int 
ret
;

376 if ((
ret
 = 
	`quicly_connect
(&
client
, &
ctx
, 
host
, (struct 
sockaddr
 *)&
sa
, 
NULL
, &
next_cid
, 
	`ptls_iovec_init
(NULL, 0), NULL,

377 
NULL
)) != 0) {

378 
	`fprintf
(
stderr
, "quicly_connect failed:%d\n", 
ret
);

379 
	`exit
(1);

381 
quicly_stream_t
 *
stream
;

382 
	`quicly_open_stream
(
client
, &
stream
, 0);

385 return 
	`run_loop_client
(
fd
, 
client
);

386 
	}
}

	@examples/pipeserver.c

5 #ifndef 
_XOPEN_SOURCE


6 #define 
	#_XOPEN_SOURCE
 700

	)

8 #include 
	~<assert.h
>

9 #include 
	~<errno.h
>

10 #include 
	~<fcntl.h
>

11 #include 
	~<getopt.h
>

12 #include 
	~<netdb.h
>

13 #include 
	~<stdio.h
>

14 #include 
	~<sys/select.h
>

15 #include 
	~<sys/socket.h
>

16 #include 
	~<sys/time.h
>

17 #include 
	~<sys/types.h
>

18 #include 
	~<unistd.h
>

19 #include 
	~<openssl/pem.h
>

20 #include 
	~"picotls.h
"

21 #include 
	~"picotls/openssl.h
"

22 #include 
	~"quicly.h
"

23 #include 
	~"quicly/defaults.h
"

24 #include 
	~"quicly/streambuf.h
"

29 static 
quicly_context_t
 
	gctx
;

33 static 
quicly_cid_plaintext_t
 
	gnext_cid
;

37 int 
	gis_verbose
 = 0;

40 static int 
	$resolve_address
(struct 
sockaddr
 *
sa
, 
socklen_t
 *
salen
, const char *
host
, const char *
port
, int 
family
, int 
type
,

41 int 
proto
)

43 struct 
addrinfo
 
hints
, *
res
;

44 int 
err
;

46 
	`memset
(&
hints
, 0, sizeof(hints));

47 
hints
.
ai_family
 = 
family
;

48 
hints
.
ai_socktype
 = 
type
;

49 
hints
.
ai_protocol
 = 
proto
;

50 
hints
.
ai_flags
 = 
AI_ADDRCONFIG
 | 
AI_NUMERICSERV
 | 
AI_PASSIVE
;

51 if ((
err
 = 
	`getaddrinfo
(
host
, 
port
, &
hints
, &
res
)) != 0 || res == 
NULL
) {

52 
	`fprintf
(
stderr
, "failed to resolve address:%s:%s:%s\n", 
host
, 
port
,

53 
err
 != 0 ? 
	`gai_strerror
(err) : "getaddrinfo returned NULL");

57 
	`memcpy
(
sa
, 
res
->
ai_addr
, res->
ai_addrlen
);

58 *
salen
 = 
res
->
ai_addrlen
;

60 
	`freeaddrinfo
(
res
);

62 
	}
}

64 static void 
	$usage
(const char *
progname
)

66 
	`printf
("Usage: %s [options] [host]\n"

79 
progname
, progname);

80 
	`exit
(0);

81 
	}
}

83 static void 
	$on_stop_sending
(
quicly_stream_t
 *
stream
, int 
err
)

85 
	`fprintf
(
stderr
, "received STOP_SENDING: %" 
PRIu16
 "\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
));

86 
	`quicly_close
(
stream
->
conn
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(0), "");

87 
	}
}

89 static void 
	$on_receive_reset
(
quicly_stream_t
 *
stream
, int 
err
)

91 
	`fprintf
(
stderr
, "received RESET_STREAM: %" 
PRIu16
 "\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
));

92 
	`quicly_close
(
stream
->
conn
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(0), "");

93 
	}
}

95 static void 
	$on_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
)

98 if (
	`quicly_streambuf_ingress_receive
(
stream
, 
off
, 
src
, 
len
) != 0)

102 
ptls_iovec_t
 
input
 = 
	`quicly_streambuf_ingress_get
(
stream
);

105 if (
	`quicly_sendstate_is_open
(&
stream
->
sendstate
) && (
input
.
len
 > 0)) {

107 
	`fwrite
(
input
.
base
, 1, input.
len
, 
stdout
);

108 
	`fflush
(
stdout
);

111 char 
str
[128];

112 
	`sprintf
(
str
, "Received: %zu bytes\n", 
input
.
len
);

113 if (
is_verbose
)

114 
	`fprintf
(
stderr
, "%s", 
str
);

115 
	`quicly_streambuf_egress_write
(
stream
, 
str
, 
	`strlen
(str));

117 if (
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
))

118 
	`quicly_streambuf_egress_shutdown
(
stream
);

122 
	`quicly_streambuf_ingress_shift
(
stream
, 
input
.
len
);

123 
	}
}

125 static void 
	$process_msg
(
quicly_conn_t
 **
conn
, struct 
msghdr
 *
msg
, 
size_t
 
dgram_len
)

127 
size_t
 
off
 = 0;

130 while (
off
 < 
dgram_len
) {

131 
quicly_decoded_packet_t
 
decoded
;

132 if (
	`quicly_decode_packet
(&
ctx
, &
decoded
, 
msg
->
msg_iov
[0].
iov_base
, 
dgram_len
, &
off
) == 
SIZE_MAX
)

135 if (*
conn
 != 
NULL
) {

136 if (
	`quicly_is_destination
(*
conn
, 
NULL
, 
msg
->
msg_name
, &
decoded
)) {

137 
	`quicly_receive
(*
conn
, 
NULL
, 
msg
->
msg_name
, &
decoded
);

139 
	`fprintf
(
stderr
, "failed to accept new incoming connection, this server only allows 1 concurrent connection\n");

143 
	`quicly_accept
(
conn
, &
ctx
, 
NULL
, 
msg
->
msg_name
, &
decoded
, NULL, &
next_cid
, NULL);

146 
	}
}

148 static int 
	$send_one
(int 
fd
, struct 
sockaddr
 *
dest
, struct 
iovec
 *
vec
)

150 struct 
msghdr
 
mess
 = {.
msg_name
 = 
dest
, .
msg_namelen
 = 
	`quicly_get_socklen
(dest), .
msg_iov
 = 
vec
, .
msg_iovlen
 = 1};

151 int 
ret
;

153 while ((
ret
 = (int)
	`sendmsg
(
fd
, &
mess
, 0)) == -1 && 
errno
 == 
EINTR
)

155 return 
ret
;

156 
	}
}

158 static int 
	$run_loop_server
(int 
fd
)

160 
quicly_conn_t
 *
conn
 = 
NULL
;

165 
fd_set
 
readfds
;

166 struct 
timeval
 
tv
;

168 
int64_t
 
first_timeout
 = 
INT64_MAX
, 
now
 = 
ctx
.now->
	`cb
(ctx.now);

169 if (
conn
 != 
NULL
) {

170 
int64_t
 
conn_timeout
 = 
	`quicly_get_first_timeout
(
conn
);

171 if (
conn_timeout
 < 
first_timeout
)

172 
first_timeout
 = 
conn_timeout
;

174 if (
now
 < 
first_timeout
) {

175 
int64_t
 
delta
 = 
first_timeout
 - 
now
;

176 if (
delta
 > 1000 * 1000)

177 
delta
 = 1000 * 1000;

178 
tv
.
tv_sec
 = 
delta
 / 1000;

179 
tv
.
tv_usec
 = (
delta
 % 1000) * 1000;

181 
tv
.
tv_sec
 = 1000;

182 
tv
.
tv_usec
 = 0;

184 
	`FD_ZERO
(&
readfds
);

185 
	`FD_SET
(
fd
, &
readfds
);

186 } while (
	`select
(
fd
 + 1, &
readfds
, 
NULL
, NULL, &
tv
) == -1 && 
errno
 == 
EINTR
);

189 if (
	`FD_ISSET
(
fd
, &
readfds
)) {

190 
uint8_t
 
buf
[4096];

191 struct 
sockaddr_storage
 
sa
;

192 struct 
iovec
 
vec
 = {.
iov_base
 = 
buf
, .
iov_len
 = sizeof(buf)};

193 struct 
msghdr
 
msg
 = {.
msg_name
 = &
sa
, .
msg_namelen
 = sizeof(sa), .
msg_iov
 = &
vec
, .
msg_iovlen
 = 1};

194 
ssize_t
 
rret
;

195 while ((
rret
 = 
	`recvmsg
(
fd
, &
msg
, 0)) == -1 && 
errno
 == 
EINTR
)

197 if (
rret
 > 0)

198 
	`process_msg
(&
conn
, &
msg
, 
rret
);

202 if (
conn
 != 
NULL
) {

203 
quicly_address_t
 
dest
, 
src
;

204 struct 
iovec
 
dgrams
[10];

205 
uint8_t
 
dgrams_buf
[
	`PTLS_ELEMENTSOF
(
dgrams
) * 
ctx
.
transport_params
.
max_udp_payload_size
];

206 
size_t
 
num_dgrams
 = 
	`PTLS_ELEMENTSOF
(
dgrams
);

207 int 
ret
 = 
	`quicly_send
(
conn
, &
dest
, &
src
, 
dgrams
, &
num_dgrams
, 
dgrams_buf
, sizeof(dgrams_buf));

208 switch (
ret
) {

210 
size_t
 
j
;

211 for (
j
 = 0; j != 
num_dgrams
; ++j) {

212 
	`send_one
(
fd
, &
dest
.
sa
, &
dgrams
[
j
]);

215 case 
QUICLY_ERROR_FREE_CONNECTION
:

217 
	`quicly_free
(
conn
);

218 
conn
 = 
NULL
;

221 
	`fprintf
(
stderr
, "quicly_send returned %d\n", 
ret
);

228 
	}
}

230 static int 
	$on_stream_open
(
quicly_stream_open_t
 *
self
, 
quicly_stream_t
 *
stream
)

232 static const 
quicly_stream_callbacks_t
 
stream_callbacks
 = {

233 
quicly_streambuf_destroy
, 
quicly_streambuf_egress_shift
, 
quicly_streambuf_egress_emit
, 
on_stop_sending
, 
on_receive
,

234 
on_receive_reset
};

235 int 
ret
;

237 if ((
ret
 = 
	`quicly_streambuf_create
(
stream
, sizeof(
quicly_streambuf_t
))) != 0)

238 return 
ret
;

239 
stream
->
callbacks
 = &
stream_callbacks
;

241 
	}
}

243 int 
	$main
(int 
argc
, char **
argv
)

245 
ptls_openssl_sign_certificate_t
 
sign_certificate
;

246 
ptls_context_t
 
tlsctx
 = {

247 .
random_bytes
 = 
ptls_openssl_random_bytes
,

248 .
get_time
 = &
ptls_get_time
,

249 .
key_exchanges
 = 
ptls_openssl_key_exchanges
,

250 .
cipher_suites
 = 
ptls_openssl_cipher_suites
,

252 
quicly_stream_open_t
 
stream_open
 = {
on_stream_open
};

253 char *
host
 = "127.0.0.1", *
port
 = "4433";

254 struct 
sockaddr_storage
 
sa
;

255 
socklen_t
 
salen
;

256 int 
ch
, 
fd
;

259 
ctx
 = 
quicly_spec_context
;

260 
ctx
.
tls
 = &
tlsctx
;

261 
	`quicly_amend_ptls_context
(
ctx
.
tls
);

262 
ctx
.
stream_open
 = &stream_open;

265 while ((
ch
 = 
	`getopt
(
argc
, 
argv
, "c:k:p:h:v")) != -1) {

266 switch (
ch
) {

268 int 
ret
;

269 if ((
ret
 = 
	`ptls_load_certificates
(&
tlsctx
, 
optarg
)) != 0) {

270 
	`fprintf
(
stderr
, "failed to load certificates from file %s:%d\n", 
optarg
, 
ret
);

271 
	`exit
(1);

275 
FILE
 *
fp
;

276 if ((
fp
 = 
	`fopen
(
optarg
, "r")) == 
NULL
) {

277 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
optarg
, 
	`strerror
(
errno
));

278 
	`exit
(1);

280 
EVP_PKEY
 *
pkey
 = 
	`PEM_read_PrivateKey
(
fp
, 
NULL
, NULL, NULL);

281 
	`fclose
(
fp
);

282 if (
pkey
 == 
NULL
) {

283 
	`fprintf
(
stderr
, "failed to load private key from file:%s\n", 
optarg
);

284 
	`exit
(1);

286 
	`ptls_openssl_init_sign_certificate
(&
sign_certificate
, 
pkey
);

287 
	`EVP_PKEY_free
(
pkey
);

288 
tlsctx
.
sign_certificate
 = &sign_certificate.
super
;

291 
port
 = 
optarg
;

294 
is_verbose
 = 1;

297 
	`usage
(
argv
[0]);

300 
	`exit
(1);

304 if ((
tlsctx
.
certificates
.
count
 <= 0) || (tlsctx.
sign_certificate
 == 
NULL
)) {

305 
	`fprintf
(
stderr
, "-c and -k options must be used\n");

306 
	`exit
(1);

308 
argc
 -= 
optind
;

309 
argv
 += 
optind
;

310 if (
argc
 != 0)

311 
host
 = *
argv
++;

312 if (
	`resolve_address
((struct 
sockaddr
 *)&
sa
, &
salen
, 
host
, 
port
, 
AF_INET
, 
SOCK_DGRAM
, 0) != 0)

313 
	`exit
(1);

316 if ((
fd
 = 
	`socket
(
sa
.
ss_family
, 
SOCK_DGRAM
, 0)) == -1) {

317 
	`perror
("socket(2) failed");

318 
	`exit
(1);

321 int 
reuseaddr
 = 1;

322 
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_REUSEADDR
, &
reuseaddr
, sizeof(reuseaddr));

323 if (
	`bind
(
fd
, (struct 
sockaddr
 *)&
sa
, 
salen
) != 0) {

324 
	`perror
("bind(2) failed");

325 
	`exit
(1);

329 return 
	`run_loop_server
(
fd
);

330 
	}
}

	@fuzz/packet.cc

1 #include 
	~"quicly.h
"

2 #include 
	~"quicly/defaults.h
"

3 #include 
	~"quicly/frame.h
"

5 void 
	$__sanitizer_cov_trace_pc
(void)

7 
	}
}

9 extern "C" int 
	$LLVMFuzzerTestOneInput
(const 
uint8_t
 *
Data
, 
size_t
 
Size
)

11 int 
ret
;

12 
quicly_context_t
 
ctx
;

13 
quicly_decoded_packet_t
 
p
;

15 
ctx
 = 
quicly_spec_context
;

17 
ret
 = 
	`quicly_decode_packet
(&
ctx
, &
p
, 
Data
, 
Size
);

19 if (
ret
 != 
Size
)

21 const 
uint8_t
 *
src
 = 
p
.
octets
.
base
, *
end
 = src + p.octets.
len
;

22 if (
p
.
octets
.
len
 == 0)

25 
uint8_t
 
type_flags
 = *
src
++;

26 if ((
type_flags
 & ~
QUICLY_FRAME_TYPE_STREAM_BITS
) == 
QUICLY_FRAME_TYPE_STREAM_BASE
) {

27 
quicly_stream_frame_t
 
frame
;

28 if ((
ret
 = 
	`quicly_decode_stream_frame
(
type_flags
, &
src
, 
end
, &
frame
)) != 0)

31 switch (
type_flags
) {

32 case 
QUICLY_FRAME_TYPE_TRANSPORT_CLOSE
: {

33 
quicly_transport_close_frame_t
 
frame
;

34 if ((
ret
 = 
	`quicly_decode_transport_close_frame
(&
src
, 
end
, &
frame
)) != 0)

37 case 
QUICLY_FRAME_TYPE_APPLICATION_CLOSE
: {

38 
quicly_application_close_frame_t
 
frame
;

39 if ((
ret
 = 
	`quicly_decode_application_close_frame
(&
src
, 
end
, &
frame
)) != 0)

42 case 
QUICLY_FRAME_TYPE_ACK
:

43 case 
QUICLY_FRAME_TYPE_ACK_ECN
: {

44 
quicly_ack_frame_t
 
frame
;

45 if ((
ret
 = 
	`quicly_decode_ack_frame
(&
src
, 
end
, &
frame
, 
type_flags
 == 
QUICLY_FRAME_TYPE_ACK_ECN
)) != 0)

48 case 
QUICLY_FRAME_TYPE_CRYPTO
:

49 
quicly_stream_frame_t
 
frame
;

50 if ((
ret
 = 
	`quicly_decode_crypto_frame
(&
src
, 
end
, &
frame
)) != 0)

53 case 
QUICLY_FRAME_TYPE_RESET_STREAM
: {

54 
quicly_reset_stream_frame_t
 
frame
;

55 if ((
ret
 = 
	`quicly_decode_reset_stream_frame
(&
src
, 
end
, &
frame
)) != 0)

58 case 
QUICLY_FRAME_TYPE_MAX_DATA
: {

59 
quicly_max_data_frame_t
 
frame
;

60 if ((
ret
 = 
	`quicly_decode_max_data_frame
(&
src
, 
end
, &
frame
)) != 0)

63 case 
QUICLY_FRAME_TYPE_MAX_STREAM_DATA
: {

64 
quicly_max_stream_data_frame_t
 
frame
;

65 if ((
ret
 = 
	`quicly_decode_max_stream_data_frame
(&
src
, 
end
, &
frame
)) != 0)

68 case 
QUICLY_FRAME_TYPE_MAX_STREAMS_BIDI
:

69 case 
QUICLY_FRAME_TYPE_MAX_STREAMS_UNI
: {

70 
quicly_max_streams_frame_t
 
frame
;

71 if ((
ret
 = 
	`quicly_decode_max_streams_frame
(&
src
, 
end
, &
frame
)) != 0)

74 case 
QUICLY_FRAME_TYPE_PING
:

75 
ret
 = 0;

77 case 
QUICLY_FRAME_TYPE_DATA_BLOCKED
: {

78 
quicly_data_blocked_frame_t
 
frame
;

79 if ((
ret
 = 
	`quicly_decode_data_blocked_frame
(&
src
, 
end
, &
frame
)) != 0)

82 case 
QUICLY_FRAME_TYPE_STREAM_DATA_BLOCKED
: {

83 
quicly_stream_data_blocked_frame_t
 
frame
;

84 if ((
ret
 = 
	`quicly_decode_stream_data_blocked_frame
(&
src
, 
end
, &
frame
)) != 0)

87 case 
QUICLY_FRAME_TYPE_STREAMS_BLOCKED_BIDI
:

88 case 
QUICLY_FRAME_TYPE_STREAMS_BLOCKED_UNI
: {

89 
quicly_streams_blocked_frame_t
 
frame
;

90 if ((
ret
 = 
	`quicly_decode_streams_blocked_frame
(&
src
, 
end
, &
frame
)) != 0)

93 case 
QUICLY_FRAME_TYPE_NEW_CONNECTION_ID
: {

94 
quicly_new_connection_id_frame_t
 
frame
;

95 if ((
ret
 = 
	`quicly_decode_new_connection_id_frame
(&
src
, 
end
, &
frame
)) != 0)

98 case 
QUICLY_FRAME_TYPE_STOP_SENDING
: {

99 
quicly_stop_sending_frame_t
 
frame
;

100 if ((
ret
 = 
	`quicly_decode_stop_sending_frame
(&
src
, 
end
, &
frame
)) != 0)

103 case 
QUICLY_FRAME_TYPE_PATH_CHALLENGE
: {

104 
quicly_path_challenge_frame_t
 
frame
;

105 if ((
ret
 = 
	`quicly_decode_path_challenge_frame
(&
src
, 
end
, &
frame
)) != 0)

108 case 
QUICLY_FRAME_TYPE_NEW_TOKEN
: {

109 
quicly_new_token_frame_t
 
frame
;

110 if ((
ret
 = 
	`quicly_decode_new_token_frame
(&
src
, 
end
, &
frame
)) != 0)

116 
	}
}

	@include/quicly.h

22 #ifndef 
quicly_h


23 #define 
	#quicly_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<netinet/in.h
>

30 #include 
	~<stdint.h
>

31 #include 
	~<stdio.h
>

32 #include 
	~<string.h
>

33 #include 
	~<sys/socket.h
>

34 #include 
	~<sys/types.h
>

35 #include 
	~"picotls.h
"

36 #include 
	~"quicly/constants.h
"

37 #include 
	~"quicly/frame.h
"

38 #include 
	~"quicly/local_cid.h
"

39 #include 
	~"quicly/linklist.h
"

40 #include 
	~"quicly/loss.h
"

41 #include 
	~"quicly/cc.h
"

42 #include 
	~"quicly/recvstate.h
"

43 #include 
	~"quicly/sendstate.h
"

44 #include 
	~"quicly/maxsender.h
"

45 #include 
	~"quicly/cid.h
"

46 #include 
	~"quicly/remote_cid.h
"

48 #ifndef 
QUICLY_DEBUG


49 #define 
	#QUICLY_DEBUG
 0

	)

53 #define 
	#QUICLY_LONG_HEADER_BIT
 0x80

	)

54 #define 
	#QUICLY_QUIC_BIT
 0x40

	)

55 #define 
	#QUICLY_KEY_PHASE_BIT
 0x4

	)

56 #define 
	#QUICLY_LONG_HEADER_RESERVED_BITS
 0xc

	)

57 #define 
	#QUICLY_SHORT_HEADER_RESERVED_BITS
 0x18

	)

59 #define 
	#QUICLY_PACKET_TYPE_INITIAL
 (
QUICLY_LONG_HEADER_BIT
 | 
QUICLY_QUIC_BIT
 | 0)

	)

60 #define 
	#QUICLY_PACKET_TYPE_0RTT
 (
QUICLY_LONG_HEADER_BIT
 | 
QUICLY_QUIC_BIT
 | 0x10)

	)

61 #define 
	#QUICLY_PACKET_TYPE_HANDSHAKE
 (
QUICLY_LONG_HEADER_BIT
 | 
QUICLY_QUIC_BIT
 | 0x20)

	)

62 #define 
	#QUICLY_PACKET_TYPE_RETRY
 (
QUICLY_LONG_HEADER_BIT
 | 
QUICLY_QUIC_BIT
 | 0x30)

	)

63 #define 
	#QUICLY_PACKET_TYPE_BITMASK
 0xf0

	)

65 #define 
	#QUICLY_PACKET_IS_LONG_HEADER
(
first_byte
) (((first_byte)&
QUICLY_LONG_HEADER_BIT
) != 0)

	)

70 #define 
	#QUICLY_PROTOCOL_VERSION_CURRENT
 0xff00001d

	)

74 #define 
	#QUICLY_PROTOCOL_VERSION_DRAFT27
 0xff00001b

	)

76 #define 
	#QUICLY_PACKET_IS_INITIAL
(
first_byte
) (((first_byte)&0xf0) == 0xc0)

	)

78 #define 
	#QUICLY_STATELESS_RESET_PACKET_MIN_LEN
 39

	)

80 #define 
	#QUICLY_MAX_PN_SIZE
 4

	)

81 #define 
	#QUICLY_SEND_PN_SIZE
 2

	)

83 #define 
	#QUICLY_AEAD_BASE_LABEL
 "tls13 quic "

	)

85 typedef union 
	ust_quicly_address_t
 {

86 struct 
sockaddr
 
sa
;

87 struct 
sockaddr_in
 
sin
;

88 struct 
sockaddr_in6
 
sin6
;

89 } 
	tquicly_address_t
;

91 typedef struct 
st_quicly_context_t
 
	tquicly_context_t
;

92 typedef struct 
st_quicly_stream_t
 
	tquicly_stream_t
;

93 typedef struct 
st_quicly_send_context_t
 
	tquicly_send_context_t
;

94 typedef struct 
st_quicly_address_token_plaintext_t
 
	tquicly_address_token_plaintext_t
;

96 #define 
	#QUICLY_CALLBACK_TYPE0
(
ret
, 
name
) \

97 typedef struct 
st_quicly_
##
	tname
##
	t_t
 { \

98 
	`ret
 (*
cb
)(struct 
st_quicly_
##
name
##
_t
 * 
self
); \

99 } 
	tquicly_
##
	tname
##
	t_t


	)

101 #define 
	tQUICLY_CALLBACK_TYPE
(
	tret
, 
	tname
, ...) \

102 typedef struct 
st_quicly_
##
	tname
##
	t_t
 { \

103 
	`ret
 (*
cb
)(struct 
st_quicly_
##
name
##
_t
 * 
self
, 
__VA_ARGS__
); \

104 } 
	tquicly_
##
	tname
##
	t_t


	)

109 typedef struct 
	sst_quicly_stream_scheduler_t
 {

114 int (*
can_send
)(struct 
st_quicly_stream_scheduler_t
 *
sched
, 
quicly_conn_t
 *
conn
, int 
conn_is_saturated
);

119 int (*
do_send
)(struct 
st_quicly_stream_scheduler_t
 *
sched
, 
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
);

123 int (*
update_state
)(struct 
st_quicly_stream_scheduler_t
 *
sched
, 
quicly_stream_t
 *
stream
);

124 } 
	tquicly_stream_scheduler_t
;

129 
QUICLY_CALLBACK_TYPE
(int, 
stream_open
, 
quicly_stream_t
 *
stream
);

133 
QUICLY_CALLBACK_TYPE
(void, 
receive_datagram_frame
, 
quicly_conn_t
 *
conn
, 
ptls_iovec_t
 
payload
);

137 
QUICLY_CALLBACK_TYPE
(void, 
closed_by_remote
, 
quicly_conn_t
 *
conn
, int 
err
, 
uint64_t
 
frame_type
, const char *
reason
,

138 
size_t
 
reason_len
);

143 
QUICLY_CALLBACK_TYPE0
(
int64_t
, 
now
);

147 
QUICLY_CALLBACK_TYPE
(int, 
save_resumption_token
, 
quicly_conn_t
 *
conn
, 
ptls_iovec_t
 
token
);

151 
QUICLY_CALLBACK_TYPE
(int, 
generate_resumption_token
, 
quicly_conn_t
 *
conn
, 
ptls_buffer_t
 *
buf
,

152 
quicly_address_token_plaintext_t
 *
token
);

157 
QUICLY_CALLBACK_TYPE
(void, 
init_cc
, 
quicly_cc_t
 *
cc
, 
uint32_t
 
initcwnd
, 
int64_t
 
now
);

162 
QUICLY_CALLBACK_TYPE
(void, 
update_open_count
, 
ssize_t
 
delta
);

167 typedef struct 
	sst_quicly_crypto_engine_t
 {

181 int (*
setup_cipher
)(struct 
st_quicly_crypto_engine_t
 *
engine
, 
quicly_conn_t
 *
conn
, 
size_t
 
epoch
, int 
is_enc
,

182 
ptls_cipher_context_t
 **
header_protect_ctx
, 
ptls_aead_context_t
 **
packet_protect_ctx
,

183 
ptls_aead_algorithm_t
 *
aead
, 
ptls_hash_algorithm_t
 *
hash
, const void *
secret
);

190 void (*
encrypt_packet
)(struct 
st_quicly_crypto_engine_t
 *
engine
, 
quicly_conn_t
 *
conn
, 
ptls_cipher_context_t
 *
header_protect_ctx
,

191 
ptls_aead_context_t
 *
packet_protect_ctx
, 
ptls_iovec_t
 
datagram
, 
size_t
 
first_byte_at
,

192 
size_t
 
payload_from
, 
uint64_t
 
packet_number
, int 
coalesced
);

193 } 
	tquicly_crypto_engine_t
;

198 typedef struct 
	sst_quicly_tracer_t
 {

202 void (*
cb
)(void *
ctx
, const char *
fmt
, ...) 
__attribute__
((
format
(
printf
, 2, 3)));

206 void *
ctx
;

207 } 
	tquicly_tracer_t
;

209 typedef struct 
	sst_quicly_max_stream_data_t
 {

210 
uint64_t
 
bidi_local
, 
bidi_remote
, 
uni
;

211 } 
	tquicly_max_stream_data_t
;

216 typedef struct 
	sst_quicly_transport_parameters_t
 {

220 
quicly_max_stream_data_t
 
max_stream_data
;

224 
uint64_t
 
max_data
;

228 
uint64_t
 
max_idle_timeout
;

232 
uint64_t
 
max_streams_bidi
;

236 
uint64_t
 
max_streams_uni
;

240 
uint64_t
 
max_udp_payload_size
;

244 
uint8_t
 
ack_delay_exponent
;

248 
uint16_t
 
max_ack_delay
;

253 
uint64_t
 
min_ack_delay_usec
;

257 
uint8_t
 
disable_active_migration
 : 1;

261 
uint64_t
 
active_connection_id_limit
;

265 
uint16_t
 
max_datagram_frame_size
;

266 } 
	tquicly_transport_parameters_t
;

268 struct 
	sst_quicly_context_t
 {

272 
ptls_context_t
 *
tls
;

278 
uint16_t
 
initial_egress_max_udp_payload_size
;

282 
quicly_loss_conf_t
 
loss
;

286 
quicly_transport_parameters_t
 
transport_params
;

290 
uint64_t
 
max_packets_per_key
;

294 
uint64_t
 
max_crypto_bytes
;

298 
uint32_t
 
initcwnd_packets
;

303 
uint32_t
 
initial_version
;

307 
uint16_t
 
pre_validation_amplification_limit
;

311 unsigned 
expand_client_hello
 : 1;

315 
quicly_cid_encryptor_t
 *
cid_encryptor
;

319 
quicly_stream_open_t
 *
stream_open
;

323 
quicly_stream_scheduler_t
 *
stream_scheduler
;

327 
quicly_receive_datagram_frame_t
 *
receive_datagram_frame
;

331 
quicly_closed_by_remote_t
 *
closed_by_remote
;

335 
quicly_now_t
 *
now
;

339 
quicly_save_resumption_token_t
 *
save_resumption_token
;

343 
quicly_generate_resumption_token_t
 *
generate_resumption_token
;

347 
quicly_crypto_engine_t
 *
crypto_engine
;

351 
quicly_init_cc_t
 *
init_cc
;

355 
quicly_update_open_count_t
 *
update_open_count
;

365 
QUICLY_STATE_FIRSTFLIGHT
,

370 
QUICLY_STATE_ACCEPTING
,

374 
QUICLY_STATE_CONNECTED
,

378 
QUICLY_STATE_CLOSING
,

382 
QUICLY_STATE_DRAINING


383 } 
	tquicly_state_t
;

385 struct 
	sst_quicly_conn_streamgroup_state_t
 {

386 
uint32_t
 
num_streams
;

387 
quicly_stream_id_t
 
next_stream_id
;

394 #define 
	#QUICLY_STATS_PREBUILT_FIELDS
 \

399 
uint64_t
 
received
; \

403 
uint64_t
 
decryption_failed
; \

407 
uint64_t
 
sent
; \

411 
uint64_t
 
lost
; \

415 
uint64_t
 
lost_time_threshold
; \

419 
uint64_t
 
ack_received
; \

423 
uint64_t
 
late_acked
; \

424 } 
num_packets
; \

429 
uint64_t
 
received
; \

433 
uint64_t
 
sent
; \

434 } 
num_bytes
; \

439 
uint64_t
 
padding
, 
ping
, 
ack
, 
reset_stream
, 
stop_sending
, 
crypto
, 
new_token
, 
stream
, 
max_data
, 
max_stream_data
, \

440 
max_streams_bidi
, 
max_streams_uni
, 
data_blocked
, 
stream_data_blocked
, 
streams_blocked
, 
new_connection_id
, \

441 
retire_connection_id
, 
path_challenge
, 
path_response
, 
transport_close
, 
application_close
, 
handshake_done
, \

442 
datagram
, 
ack_frequency
; \

443 } 
num_frames_sent
, 
num_frames_received
; \

447 
uint64_t
 
num_ptos


	)

449 typedef struct 
	sst_quicly_stats_t
 {

453 
QUICLY_STATS_PREBUILT_FIELDS
;

457 
quicly_rtt_t
 
rtt
;

461 
quicly_cc_t
 
cc
;

462 } 
	tquicly_stats_t
;

472 struct 
	sst_quicly_default_scheduler_state_t
 {

473 
quicly_linklist_t
 
active
;

474 
quicly_linklist_t
 
blocked
;

477 typedef void (*
quicly_trace_cb
)(void *
	tctx
, const char *
	tfmt
, ...) 
	t__attribute__
((
	tformat
(
	tprintf
, 2, 3)));

479 struct 
	s_st_quicly_conn_public_t
 {

480 
quicly_context_t
 *
ctx
;

481 
quicly_state_t
 
state
;

488 
quicly_local_cid_set_t
 
cid_set
;

492 
quicly_address_t
 
address
;

497 
quicly_cid_t
 
long_header_src_cid
;

501 struct 
st_quicly_conn_streamgroup_state_t
 
bidi
, 
uni
;

502 } 
local
;

507 
quicly_remote_cid_set_t
 
cid_set
;

511 
quicly_address_t
 
address
;

512 struct 
st_quicly_conn_streamgroup_state_t
 
bidi
, 
uni
;

513 
quicly_transport_parameters_t
 
transport_params
;

515 unsigned 
validated
 : 1;

516 unsigned 
send_probe
 : 1;

517 } 
address_validation
;

521 
uint64_t
 
largest_retire_prior_to
;

522 } 
remote
;

527 
quicly_cid_t
 
original_dcid
;

528 struct 
st_quicly_default_scheduler_state_t
 
_default_scheduler
;

530 
QUICLY_STATS_PREBUILT_FIELDS
;

531 } 
stats
;

532 
uint32_t
 
version
;

533 void *
data
;

537 
quicly_tracer_t
 
tracer
;

544 
QUICLY_SENDER_STATE_NONE
,

548 
QUICLY_SENDER_STATE_SEND
,

552 
QUICLY_SENDER_STATE_UNACKED
,

556 
QUICLY_SENDER_STATE_ACKED
,

557 } 
	tquicly_sender_state_t
;

563 typedef struct 
	sst_quicly_stream_callbacks_t
 {

567 void (*
on_destroy
)(
quicly_stream_t
 *
stream
, int 
err
);

571 void (*
on_send_shift
)(
quicly_stream_t
 *
stream
, 
size_t
 
delta
);

579 void (*
on_send_emit
)(
quicly_stream_t
 *
stream
, 
size_t
 
off
, void *
dst
, size_t *
len
, int *
wrote_all
);

584 void (*
on_send_stop
)(
quicly_stream_t
 *
stream
, int 
err
);

590 void (*
on_receive
)(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
);

594 void (*
on_receive_reset
)(
quicly_stream_t
 *
stream
, int 
err
);

595 } 
	tquicly_stream_callbacks_t
;

597 struct 
	sst_quicly_stream_t
 {

601 
quicly_conn_t
 *
conn
;

605 
quicly_stream_id_t
 
stream_id
;

609 const 
quicly_stream_callbacks_t
 *
callbacks
;

613 
quicly_sendstate_t
 
sendstate
;

617 
quicly_recvstate_t
 
recvstate
;

621 void *
data
;

625 unsigned 
streams_blocked
 : 1;

633 
uint64_t
 
max_stream_data
;

638 
quicly_sender_state_t
 
sender_state
;

639 
uint16_t
 
error_code
;

640 } 
stop_sending
;

648 
quicly_sender_state_t
 
sender_state
;

649 
uint16_t
 
error_code
;

650 } 
reset_stream
;

654 
quicly_maxsender_t
 
max_stream_data_sender
;

658 
quicly_sender_state_t
 
blocked
;

663 
quicly_linklist_t
 
control
;

664 
quicly_linklist_t
 
default_scheduler
;

665 } 
pending_link
;

666 } 
_send_aux
;

674 
uint32_t
 
window
;

681 
uint32_t
 
max_ranges
;

682 } 
_recv_aux
;

685 typedef struct 
	sst_quicly_decoded_packet_t
 {

689 
ptls_iovec_t
 
octets
;

701 
ptls_iovec_t
 
encrypted
;

709 
quicly_cid_plaintext_t
 
plaintext
;

713 unsigned 
might_be_client_generated
 : 1;

714 } 
dest
;

718 
ptls_iovec_t
 
src
;

719 } 
cid
;

723 
uint32_t
 
version
;

727 
ptls_iovec_t
 
token
;

732 
size_t
 
encrypted_off
;

736 
size_t
 
datagram_size
;

741 
uint64_t
 
pn
;

742 
uint64_t
 
key_phase
;

743 } 
decrypted
;

748 
QUICLY__DECODED_PACKET_CACHED_MAYBE_STATELESS_RESET
 = 0,

749 
QUICLY__DECODED_PACKET_CACHED_IS_STATELESS_RESET
,

750 
QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET


751 } 
_is_stateless_reset_cached
;

752 } 
	tquicly_decoded_packet_t
;

754 struct 
	sst_quicly_address_token_plaintext_t
 {

755 enum { 
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
, 
QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION
 } 
type
;

756 
uint64_t
 
issued_at
;

757 
quicly_address_t
 
local
, 
remote
;

760 
quicly_cid_t
 
original_dcid
;

761 
quicly_cid_t
 
client_cid
;

762 
quicly_cid_t
 
server_cid
;

763 } 
retry
;

765 
uint8_t
 
bytes
[256];

766 
size_t
 
len
;

767 } 
resumption
;

770 
uint8_t
 
bytes
[256];

771 
size_t
 
len
;

772 } 
appdata
;

778 extern const 
uint32_t
 
quicly_supported_versions
[];

782 static int 
quicly_is_supported_version
(
uint32_t
 
version
);

796 
size_t
 
quicly_decode_packet
(
quicly_context_t
 *
ctx
, 
quicly_decoded_packet_t
 *
packet
, const 
uint8_t
 *
datagram
, size_t 
datagram_size
,

797 
size_t
 *
off
);

801 
uint64_t
 
quicly_determine_packet_number
(
uint32_t
 
truncated
, 
size_t
 
num_bits
, uint64_t 
expected
);

805 static 
quicly_context_t
 *
quicly_get_context
(
quicly_conn_t
 *
conn
);

809 static const 
quicly_cid_plaintext_t
 *
quicly_get_master_id
(
quicly_conn_t
 *
conn
);

813 static const 
quicly_cid_t
 *
quicly_get_original_dcid
(
quicly_conn_t
 *
conn
);

817 static const 
quicly_cid_t
 *
quicly_get_remote_cid
(
quicly_conn_t
 *
conn
);

821 static const 
quicly_transport_parameters_t
 *
quicly_get_remote_transport_parameters
(
quicly_conn_t
 *
conn
);

825 static 
quicly_state_t
 
quicly_get_state
(
quicly_conn_t
 *
conn
);

829 int 
quicly_connection_is_ready
(
quicly_conn_t
 *
conn
);

833 static 
uint32_t
 
quicly_num_streams
(
quicly_conn_t
 *
conn
);

837 
uint32_t
 
quicly_num_streams_by_group
(
quicly_conn_t
 *
conn
, int 
uni
, int 
locally_initiated
);

841 static int 
quicly_is_client
(
quicly_conn_t
 *
conn
);

845 static 
quicly_stream_id_t
 
quicly_get_local_next_stream_id
(
quicly_conn_t
 *
conn
, int 
uni
);

849 static 
quicly_stream_id_t
 
quicly_get_remote_next_stream_id
(
quicly_conn_t
 *
conn
, int 
uni
);

853 static struct 
sockaddr
 *
quicly_get_sockname
(
quicly_conn_t
 *
conn
);

857 static struct 
sockaddr
 *
quicly_get_peername
(
quicly_conn_t
 *
conn
);

861 int 
quicly_get_stats
(
quicly_conn_t
 *
conn
, 
quicly_stats_t
 *
stats
);

865 void 
quicly_get_max_data
(
quicly_conn_t
 *
conn
, 
uint64_t
 *
send_permitted
, uint64_t *
sent
, uint64_t *
consumed
);

869 static void **
quicly_get_data
(
quicly_conn_t
 *
conn
);

873 static 
quicly_tracer_t
 *
quicly_get_tracer
(
quicly_conn_t
 *
conn
);

877 void 
quicly_free
(
quicly_conn_t
 *
conn
);

883 int 
quicly_close
(
quicly_conn_t
 *
conn
, int 
err
, const char *
reason_phrase
);

887 
int64_t
 
quicly_get_first_timeout
(
quicly_conn_t
 *
conn
);

891 
uint64_t
 
quicly_get_next_expected_packet_number
(
quicly_conn_t
 *
conn
);

895 int 
quicly_is_blocked
(
quicly_conn_t
 *
conn
);

902 int 
quicly_stream_can_send
(
quicly_stream_t
 *
stream
, int 
at_stream_level
);

907 int 
quicly_can_send_data
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
);

912 int 
quicly_send_stream
(
quicly_stream_t
 *
stream
, 
quicly_send_context_t
 *
s
);

918 
size_t
 
quicly_send_version_negotiation
(
quicly_context_t
 *
ctx
, 
ptls_iovec_t
 
dest_cid
, ptls_iovec_t 
src_cid
, const 
uint32_t
 *
versions
,

919 void *
payload
);

923 int 
quicly_retry_calc_cidpair_hash
(
ptls_hash_algorithm_t
 *
sha256
, 
ptls_iovec_t
 
client_cid
, ptls_iovec_t 
server_cid
,

924 
uint64_t
 *
value
);

932 
size_t
 
quicly_send_retry
(
quicly_context_t
 *
ctx
, 
ptls_aead_context_t
 *
token_encrypt_ctx
, 
uint32_t
 
protocol_version
,

933 struct 
sockaddr
 *
dest_addr
, 
ptls_iovec_t
 
dest_cid
, struct sockaddr *
src_addr
, ptls_iovec_t 
src_cid
,

934 
ptls_iovec_t
 
odcid
, ptls_iovec_t 
token_prefix
, ptls_iovec_t 
appdata
,

935 
ptls_aead_context_t
 **
retry_aead_cache
, 
uint8_t
 *
payload
);

951 int 
quicly_send
(
quicly_conn_t
 *
conn
, 
quicly_address_t
 *
dest
, quicly_address_t *
src
, struct 
iovec
 *
datagrams
, 
size_t
 *
num_datagrams
,

952 void *
buf
, 
size_t
 
bufsize
);

956 
size_t
 
quicly_send_close_invalid_token
(
quicly_context_t
 *
ctx
, 
uint32_t
 
protocol_version
, 
ptls_iovec_t
 
dest_cid
,

957 
ptls_iovec_t
 
src_cid
, const char *
err_desc
, void *
datagram
);

961 
size_t
 
quicly_send_stateless_reset
(
quicly_context_t
 *
ctx
, const void *
src_cid
, void *
payload
);

965 int 
quicly_send_resumption_token
(
quicly_conn_t
 *
conn
);

969 int 
quicly_receive
(
quicly_conn_t
 *
conn
, struct 
sockaddr
 *
dest_addr
, struct sockaddr *
src_addr
, 
quicly_decoded_packet_t
 *
packet
);

973 int 
quicly_is_destination
(
quicly_conn_t
 *
conn
, struct 
sockaddr
 *
dest_addr
, struct sockaddr *
src_addr
,

974 
quicly_decoded_packet_t
 *
decoded
);

978 int 
quicly_encode_transport_parameter_list
(
ptls_buffer_t
 *
buf
, const 
quicly_transport_parameters_t
 *
params
,

979 const 
quicly_cid_t
 *
original_dcid
, const quicly_cid_t *
initial_scid
,

980 const 
quicly_cid_t
 *
retry_scid
, const void *
stateless_reset_token
, 
size_t
 
expand_by
);

991 int 
quicly_decode_transport_parameter_list
(
quicly_transport_parameters_t
 *
params
, 
quicly_cid_t
 *
original_dcid
,

992 
quicly_cid_t
 *
initial_scid
, quicly_cid_t *
retry_scid
, void *
stateless_reset_token
,

993 const 
uint8_t
 *
src
, const uint8_t *
end
, int 
recognize_delayed_ack
);

998 int 
quicly_connect
(
quicly_conn_t
 **
conn
, 
quicly_context_t
 *
ctx
, const char *
server_name
, struct 
sockaddr
 *
dest_addr
,

999 struct 
sockaddr
 *
src_addr
, const 
quicly_cid_plaintext_t
 *
new_cid
, 
ptls_iovec_t
 
address_token
,

1000 
ptls_handshake_properties_t
 *
handshake_properties
,

1001 const 
quicly_transport_parameters_t
 *
resumed_transport_params
);

1011 int 
quicly_accept
(
quicly_conn_t
 **
conn
, 
quicly_context_t
 *
ctx
, struct 
sockaddr
 *
dest_addr
, struct sockaddr *
src_addr
,

1012 
quicly_decoded_packet_t
 *
packet
, 
quicly_address_token_plaintext_t
 *
address_token
,

1013 const 
quicly_cid_plaintext_t
 *
new_cid
, 
ptls_handshake_properties_t
 *
handshake_properties
);

1017 
ptls_t
 *
quicly_get_tls
(
quicly_conn_t
 *
conn
);

1021 
quicly_stream_id_t
 
quicly_get_ingress_max_streams
(
quicly_conn_t
 *
conn
, int 
uni
);

1026 int 
quicly_foreach_stream
(
quicly_conn_t
 *
conn
, void *
thunk
, int (*
cb
)(void *thunk, 
quicly_stream_t
 *
stream
));

1030 
quicly_stream_t
 *
quicly_get_stream
(
quicly_conn_t
 *
conn
, 
quicly_stream_id_t
 
stream_id
);

1034 int 
quicly_open_stream
(
quicly_conn_t
 *
conn
, 
quicly_stream_t
 **
stream
, int 
unidirectional
);

1043 int 
quicly_get_or_open_stream
(
quicly_conn_t
 *
conn
, 
uint64_t
 
stream_id
, 
quicly_stream_t
 **
stream
);

1047 void 
quicly_reset_stream
(
quicly_stream_t
 *
stream
, int 
err
);

1051 void 
quicly_request_stop
(
quicly_stream_t
 *
stream
, int 
err
);

1055 static int 
quicly_stop_requested
(
quicly_stream_t
 *
stream
);

1059 int 
quicly_stream_sync_sendbuf
(
quicly_stream_t
 *
stream
, int 
activate
);

1063 void 
quicly_stream_sync_recvbuf
(
quicly_stream_t
 *
stream
, 
size_t
 
shift_amount
);

1067 static 
uint32_t
 
quicly_stream_get_receive_window
(
quicly_stream_t
 *
stream
);

1071 static void 
quicly_stream_set_receive_window
(
quicly_stream_t
 *
stream
, 
uint32_t
 
window
);

1075 static int 
quicly_stream_is_client_initiated
(
quicly_stream_id_t
 
stream_id
);

1079 static int 
quicly_stream_is_unidirectional
(
quicly_stream_id_t
 
stream_id
);

1083 static int 
quicly_stream_has_send_side
(int 
is_client
, 
quicly_stream_id_t
 
stream_id
);

1087 static int 
quicly_stream_has_receive_side
(int 
is_client
, 
quicly_stream_id_t
 
stream_id
);

1091 static int 
quicly_stream_is_self_initiated
(
quicly_stream_t
 *
stream
);

1098 void 
quicly_send_datagram_frames
(
quicly_conn_t
 *
conn
, 
ptls_iovec_t
 *
datagrams
, 
size_t
 
num_datagrams
);

1102 void 
quicly_amend_ptls_context
(
ptls_context_t
 *
ptls
);

1114 int 
quicly_encrypt_address_token
(void (*
random_bytes
)(void *, 
size_t
), 
ptls_aead_context_t
 *
aead
, 
ptls_buffer_t
 *
buf
,

1115 
size_t
 
start_off
, const 
quicly_address_token_plaintext_t
 *
plaintext
);

1121 int 
quicly_decrypt_address_token
(
ptls_aead_context_t
 *
aead
, 
quicly_address_token_plaintext_t
 *
plaintext
, const void *
src
,

1122 
size_t
 
len
, size_t 
prefix_len
, const char **
err_desc
);

1127 int 
quicly_build_session_ticket_auth_data
(
ptls_buffer_t
 *
auth_data
, const 
quicly_context_t
 *
ctx
);

1131 static void 
quicly_byte_to_hex
(char *
dst
, 
uint8_t
 
v
);

1135 
socklen_t
 
quicly_get_socklen
(struct 
sockaddr
 *
sa
);

1139 char *
quicly_escape_unsafe_string
(char *
dst
, const void *
bytes
, 
size_t
 
len
);

1143 char *
quicly_hexdump
(const 
uint8_t
 *
bytes
, 
size_t
 
len
, size_t 
indent
);

1147 void 
quicly_stream_noop_on_destroy
(
quicly_stream_t
 *
stream
, int 
err
);

1151 void 
quicly_stream_noop_on_send_shift
(
quicly_stream_t
 *
stream
, 
size_t
 
delta
);

1155 void 
quicly_stream_noop_on_send_emit
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, void *
dst
, size_t *
len
, int *
wrote_all
);

1159 void 
quicly_stream_noop_on_send_stop
(
quicly_stream_t
 *
stream
, int 
err
);

1163 void 
quicly_stream_noop_on_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
);

1167 void 
quicly_stream_noop_on_receive_reset
(
quicly_stream_t
 *
stream
, int 
err
);

1169 extern const 
quicly_stream_callbacks_t
 
quicly_stream_noop_callbacks
;

1173 
inline
 int 
quicly_is_supported_version
(
uint32_t
 
version
)

1175 switch (
	gversion
) {

1176 case 
	gQUICLY_PROTOCOL_VERSION_CURRENT
:

1177 case 
QUICLY_PROTOCOL_VERSION_DRAFT27
:

1184 
inline
 
quicly_state_t
 
quicly_get_state
(
quicly_conn_t
 *
conn
)

1186 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1187 return 
	gc
->
	gstate
;

1190 
inline
 
uint32_t
 
quicly_num_streams
(
quicly_conn_t
 *
conn
)

1192 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1193 return 
	gc
->
	glocal
.
	gbidi
.
	gnum_streams
 + c->local.
	guni
.num_streams + c->
	gremote
.bidi.num_streams + c->remote.uni.num_streams;

1196 
inline
 
quicly_context_t
 *
quicly_get_context
(
quicly_conn_t
 *
conn
)

1198 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1199 return 
	gc
->
	gctx
;

1202 
inline
 const 
quicly_cid_plaintext_t
 *
quicly_get_master_id
(
quicly_conn_t
 *
conn
)

1204 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1205 return &
	gc
->
	glocal
.
	gcid_set
.
	gplaintext
;

1208 
inline
 const 
quicly_cid_t
 *
quicly_get_original_dcid
(
quicly_conn_t
 *
conn
)

1210 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1211 return &
	gc
->
	goriginal_dcid
;

1214 
inline
 const 
quicly_cid_t
 *
quicly_get_remote_cid
(
quicly_conn_t
 *
conn
)

1216 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1217 return &
	gc
->
	gremote
.
	gcid_set
.
	gcids
[0].
	gcid
;

1220 
inline
 const 
quicly_transport_parameters_t
 *
quicly_get_remote_transport_parameters
(
quicly_conn_t
 *
conn
)

1222 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1223 return &
	gc
->
	gremote
.
	gtransport_params
;

1226 
inline
 int 
quicly_is_client
(
quicly_conn_t
 *
conn
)

1228 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1229 return (
	gc
->
	glocal
.
	gbidi
.
	gnext_stream_id
 & 1) == 0;

1232 
inline
 
quicly_stream_id_t
 
quicly_get_local_next_stream_id
(
quicly_conn_t
 *
conn
, int 
uni
)

1234 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1235 return 
	guni
 ? 
	gc
->
	glocal
.uni.
	gnext_stream_id
 : 
c
->
local
.
bidi
.
next_stream_id
;

1238 
inline
 
quicly_stream_id_t
 
quicly_get_remote_next_stream_id
(
quicly_conn_t
 *
conn
, int 
uni
)

1240 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1241 return 
	guni
 ? 
	gc
->
	gremote
.uni.
	gnext_stream_id
 : 
c
->
remote
.
bidi
.
next_stream_id
;

1244 
inline
 struct 
sockaddr
 *
quicly_get_sockname
(
quicly_conn_t
 *
conn
)

1246 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1247 return &
	gc
->
	glocal
.
	gaddress
.
	gsa
;

1250 
inline
 struct 
sockaddr
 *
quicly_get_peername
(
quicly_conn_t
 *
conn
)

1252 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1253 return &
	gc
->
	gremote
.
	gaddress
.
	gsa
;

1256 
inline
 void **
quicly_get_data
(
quicly_conn_t
 *
conn
)

1258 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1259 return &
	gc
->
	gdata
;

1262 
inline
 
quicly_tracer_t
 *
quicly_get_tracer
(
quicly_conn_t
 *
conn
)

1264 struct 
_st_quicly_conn_public_t
 *
	gc
 = (struct _st_quicly_conn_public_t *)
conn
;

1265 return &
	gc
->
	gtracer
;

1268 
inline
 int 
quicly_stop_requested
(
quicly_stream_t
 *
stream
)

1270 return 
	gstream
->
	g_send_aux
.
	gstop_sending
.
	gsender_state
 != 
QUICLY_SENDER_STATE_NONE
;

1273 
inline
 
uint32_t
 
quicly_stream_get_receive_window
(
quicly_stream_t
 *
stream
)

1275 return 
	gstream
->
	g_recv_aux
.
	gwindow
;

1278 
inline
 void 
quicly_stream_set_receive_window
(
quicly_stream_t
 *
stream
, 
uint32_t
 
window
)

1280 
	gstream
->
	g_recv_aux
.
	gwindow
 = 
window
;

1283 
inline
 int 
quicly_stream_is_client_initiated
(
quicly_stream_id_t
 
stream_id
)

1285 if (
	gstream_id
 < 0)

1286 return (
	gstream_id
 & 1) != 0;

1287 return (
	gstream_id
 & 1) == 0;

1290 
inline
 int 
quicly_stream_is_unidirectional
(
quicly_stream_id_t
 
stream_id
)

1292 if (
	gstream_id
 < 0)

1294 return (
	gstream_id
 & 2) != 0;

1297 
inline
 int 
quicly_stream_has_send_side
(int 
is_client
, 
quicly_stream_id_t
 
stream_id
)

1299 if (!
quicly_stream_is_unidirectional
(
stream_id
))

1301 return 
	gis_client
 == 
quicly_stream_is_client_initiated
(
stream_id
);

1304 
inline
 int 
quicly_stream_has_receive_side
(int 
is_client
, 
quicly_stream_id_t
 
stream_id
)

1306 if (!
quicly_stream_is_unidirectional
(
stream_id
))

1308 return 
	gis_client
 != 
quicly_stream_is_client_initiated
(
stream_id
);

1311 
inline
 int 
quicly_stream_is_self_initiated
(
quicly_stream_t
 *
stream
)

1313 return 
quicly_stream_is_client_initiated
(
stream
->
stream_id
) == 
quicly_is_client
(stream->
conn
);

1316 
inline
 void 
quicly_byte_to_hex
(char *
dst
, 
uint8_t
 
v
)

1318 
	gdst
[0] = "0123456789abcdef"[
v
 >> 4];

1319 
	gdst
[1] = "0123456789abcdef"[
v
 & 0xf];

1322 #ifdef 
__cplusplus


	@include/quicly/cc.h

26 #ifndef 
quicly_cc_h


27 #define 
	#quicly_cc_h


	)

29 #ifdef 
__cplusplus


33 #include 
	~<assert.h
>

34 #include 
	~<stdint.h
>

35 #include 
	~<string.h
>

36 #include 
	~"quicly/constants.h
"

37 #include 
	~"quicly/loss.h
"

39 #define 
	#QUICLY_MIN_CWND
 2

	)

40 #define 
	#QUICLY_RENO_BETA
 0.7

	)

45 typedef const struct 
	tst_quicly_cc_type_t
 
	tquicly_cc_type_t
;

47 typedef struct 
	sst_quicly_cc_t
 {

51 
quicly_cc_type_t
 *
type
;

55 
uint32_t
 
cwnd
;

59 
uint32_t
 
ssthresh
;

63 
uint64_t
 
recovery_end
;

76 
uint32_t
 
stash
;

77 } 
reno
;

85 double 
k
;

89 
uint32_t
 
w_max
;

93 
uint32_t
 
w_last_max
;

97 
int64_t
 
avoidance_start
;

101 
int64_t
 
last_sent_time
;

102 } 
cubic
;

103 } 
state
;

107 
uint32_t
 
cwnd_initial
;

111 
uint32_t
 
cwnd_exiting_slow_start
;

115 
uint32_t
 
cwnd_minimum
;

119 
uint32_t
 
cwnd_maximum
;

123 
uint32_t
 
num_loss_episodes
;

124 } 
	tquicly_cc_t
;

126 struct 
	sst_quicly_cc_type_t
 {

130 const char *
name
;

134 struct 
st_quicly_init_cc_t
 *
cc_init
;

138 void (*
cc_on_acked
)(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
uint64_t
 
largest_acked
, uint32_t 
inflight
,

139 
int64_t
 
now
, 
uint32_t
 
max_udp_payload_size
);

144 void (*
cc_on_lost
)(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
uint64_t
 
lost_pn
, uint64_t 
next_pn
, 
int64_t
 
now
,

145 
uint32_t
 
max_udp_payload_size
);

149 void (*
cc_on_persistent_congestion
)(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
int64_t
 
now
);

153 void (*
cc_on_sent
)(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
int64_t
 
now
);

157 int (*
cc_switch
)(
quicly_cc_t
 *
cc
);

163 extern 
quicly_cc_type_t
 
quicly_cc_type_reno
, 
quicly_cc_type_cubic
, 
quicly_cc_type_pico
;

167 extern struct 
st_quicly_init_cc_t
 
quicly_cc_reno_init
, 
quicly_cc_cubic_init
, 
quicly_cc_pico_init
;

172 extern 
quicly_cc_type_t
 *
quicly_cc_all_types
[];

177 
uint32_t
 
quicly_cc_calc_initial_cwnd
(uint32_t 
max_packets
, 
uint16_t
 
max_udp_payload_size
);

179 void 
quicly_cc_reno_on_lost
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
uint64_t
 
lost_pn
, uint64_t 
next_pn
,

180 
int64_t
 
now
, 
uint32_t
 
max_udp_payload_size
);

181 void 
quicly_cc_reno_on_persistent_congestion
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
int64_t
 
now
);

182 void 
quicly_cc_reno_on_sent
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
int64_t
 
now
);

184 #ifdef 
__cplusplus


	@include/quicly/cid.h

22 #ifndef 
quicly_cid_h


23 #define 
	#quicly_cid_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<stdint.h
>

30 #include 
	~<string.h
>

31 #include 
	~"picotls.h
"

32 #include 
	~"quicly/constants.h
"

37 #define 
	#QUICLY_MAX_PATH_ID
 
UINT8_MAX


	)

39 typedef struct 
	sst_quicly_cid_t
 {

40 
uint8_t
 
cid
[
QUICLY_MAX_CID_LEN_V1
];

41 
uint8_t
 
len
;

42 } 
	tquicly_cid_t
;

49 typedef struct 
	sst_quicly_cid_plaintext_t
 {

53 
uint32_t
 
master_id
;

57 
uint32_t
 
path_id
 : 8;

61 
uint32_t
 
thread_id
 : 24;

65 
uint64_t
 
node_id
;

66 } 
	tquicly_cid_plaintext_t
;

72 extern 
quicly_cid_plaintext_t
 
quicly_cid_plaintext_invalid
;

77 typedef struct 
	sst_quicly_cid_encryptor_t
 {

81 void (*
	gencrypt_cid
)(struct 
st_quicly_cid_encryptor_t
 *
	gself
, 
quicly_cid_t
 *
	gencrypted
, void *
	gstateless_reset_token
,

82 const 
quicly_cid_plaintext_t
 *
	gplaintext
);

90 
size_t
 (*
decrypt_cid
)(struct 
st_quicly_cid_encryptor_t
 *
	gself
, 
quicly_cid_plaintext_t
 *
	gplaintext
, const void *
	gencrypted
,

91 
size_t
 
	glen
);

95 int (*
	ggenerate_stateless_reset_token
)(struct 
st_quicly_cid_encryptor_t
 *
	gself
, void *
	gtoken
, const void *
	gcid
);

96 } 
	tquicly_cid_encryptor_t
;

98 static void 
quicly_set_cid
(
quicly_cid_t
 *
dest
, 
ptls_iovec_t
 
src
);

99 static int 
quicly_cid_is_equal
(const 
quicly_cid_t
 *
cid
, 
ptls_iovec_t
 
vec
);

103 
inline
 int 
quicly_cid_is_equal
(const 
quicly_cid_t
 *
cid
, 
ptls_iovec_t
 
vec
)

105 return 
	gcid
->
	glen
 == 
vec
.
len
 && 
memcmp
(
cid
->cid, vec.
base
, vec.len) == 0;

108 
inline
 void 
quicly_set_cid
(
quicly_cid_t
 *
dest
, 
ptls_iovec_t
 
src
)

110 
memcpy
(
dest
->
cid
, 
src
.
base
, src.
len
);

111 
	gdest
->
	glen
 = 
src
.
len
;

114 #ifdef 
__cplusplus


	@include/quicly/constants.h

22 #ifndef 
quicly_constants_h


23 #define 
	#quicly_constants_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<stddef.h
>

30 #include 
	~<stdint.h
>

31 #include 
	~"picotls.h
"

33 #define 
	#QUICLY_DELAYED_ACK_TIMEOUT
 25

	)

34 #define 
	#QUICLY_DEFAULT_MAX_ACK_DELAY
 25

	)

35 #define 
	#QUICLY_LOCAL_MAX_ACK_DELAY
 25

	)

36 #define 
	#QUICLY_DEFAULT_ACK_DELAY_EXPONENT
 3

	)

37 #define 
	#QUICLY_LOCAL_ACK_DELAY_EXPONENT
 10

	)

38 #define 
	#QUICLY_MIN_INITIAL_DCID_LEN
 8

	)

39 #define 
	#QUICLY_DEFAULT_ACTIVE_CONNECTION_ID_LIMIT
 2

	)

46 #define 
	#QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
 4

	)

47 #define 
	#QUICLY_MIN_ACTIVE_CONNECTION_ID_LIMIT
 2

	)

48 #define 
	#QUICLY_DEFAULT_MAX_UDP_PAYLOAD_SIZE
 65527

	)

49 #define 
	#QUICLY_MIN_CLIENT_INITIAL_SIZE
 1200

	)

50 #define 
	#QUICLY_DEFAULT_MIN_PTO
 1

	)

51 #define 
	#QUICLY_DEFAULT_INITIAL_RTT
 66

	)

52 #define 
	#QUICLY_LOSS_DEFAULT_PACKET_THRESHOLD
 3

	)

54 #define 
	#QUICLY_DEFAULT_PACKET_TOLERANCE
 2

	)

55 #define 
	#QUICLY_MAX_PACKET_TOLERANCE
 100

	)

56 #define 
	#QUICLY_FIRST_ACK_FREQUENCY_PACKET_NUMBER
 1000

	)

57 #define 
	#QUICLY_ACK_FREQUENCY_CWND_FRACTION
 8

	)

59 #define 
	#QUICLY_AEAD_TAG_SIZE
 16

	)

61 #define 
	#QUICLY_MAX_CID_LEN_V1
 20

	)

62 #define 
	#QUICLY_STATELESS_RESET_TOKEN_LEN
 16

	)

64 #define 
	#QUICLY_EPOCH_INITIAL
 0

	)

65 #define 
	#QUICLY_EPOCH_0RTT
 1

	)

66 #define 
	#QUICLY_EPOCH_HANDSHAKE
 2

	)

67 #define 
	#QUICLY_EPOCH_1RTT
 3

	)

68 #define 
	#QUICLY_NUM_EPOCHS
 4

	)

71 #define 
	#QUICLY_ERROR_IS_QUIC
(
e
) (((e) & ~0x1ffff) == 0x20000)

	)

72 #define 
	#QUICLY_ERROR_IS_QUIC_TRANSPORT
(
e
) (((e) & ~0xffff) == 0x20000)

	)

73 #define 
	#QUICLY_ERROR_IS_QUIC_APPLICATION
(
e
) (((e) & ~0xffff) == 0x30000)

	)

74 #define 
	#QUICLY_ERROR_GET_ERROR_CODE
(
e
) ((
uint16_t
)(e))

	)

75 #define 
	#QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(
e
) ((
uint16_t
)(e) + 0x20000)

	)

76 #define 
	#QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(
e
) ((
uint16_t
)(e) + 0x30000)

	)

81 #define 
	#QUICLY_ERROR_IS_CONCEALED
(
err
) ((err) == 
PTLS_ERROR_NO_MEMORY
 || (err) == 
QUICLY_ERROR_STATE_EXHAUSTION
)

	)

84 #define 
	#QUICLY_TRANSPORT_ERROR_NONE
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x0)

	)

85 #define 
	#QUICLY_TRANSPORT_ERROR_INTERNAL
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x1)

	)

86 #define 
	#QUICLY_TRANSPORT_ERROR_CONNECTION_REFUSED
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x2)

	)

87 #define 
	#QUICLY_TRANSPORT_ERROR_FLOW_CONTROL
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x3)

	)

88 #define 
	#QUICLY_TRANSPORT_ERROR_STREAM_LIMIT
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x4)

	)

89 #define 
	#QUICLY_TRANSPORT_ERROR_STREAM_STATE
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x5)

	)

90 #define 
	#QUICLY_TRANSPORT_ERROR_FINAL_SIZE
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x6)

	)

91 #define 
	#QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x7)

	)

92 #define 
	#QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x8)

	)

93 #define 
	#QUICLY_TRANSPORT_ERROR_CONNECTION_ID_LIMIT
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x9)

	)

94 #define 
	#QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0xa)

	)

95 #define 
	#QUICLY_TRANSPORT_ERROR_INVALID_TOKEN
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0xb)

	)

96 #define 
	#QUICLY_TRANSPORT_ERROR_APPLICATION
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0xc)

	)

97 #define 
	#QUICLY_TRANSPORT_ERROR_CRYPTO_BUFFER_EXCEEDED
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0xd)

	)

98 #define 
	#QUICLY_TRANSPORT_ERROR_TLS_ALERT_BASE
 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(0x100)

	)

101 #define 
	#QUICLY_ERROR_PACKET_IGNORED
 0xff01

	)

102 #define 
	#QUICLY_ERROR_SENDBUF_FULL
 0xff02

	)

103 #define 
	#QUICLY_ERROR_FREE_CONNECTION
 0xff03

	)

104 #define 
	#QUICLY_ERROR_RECEIVED_STATELESS_RESET
 0xff04

	)

105 #define 
	#QUICLY_ERROR_NO_COMPATIBLE_VERSION
 0xff05

	)

106 #define 
	#QUICLY_ERROR_IS_CLOSING
 0xff06

	)

107 #define 
	#QUICLY_ERROR_STATE_EXHAUSTION
 0xff07

	)

108 #define 
	#QUICLY_ERROR_INVALID_INITIAL_VERSION
 0xff08

	)

109 #define 
	#QUICLY_ERROR_DECRYPTION_FAILED
 0xff09

	)

111 typedef 
int64_t
 
	tquicly_stream_id_t
;

113 typedef struct 
st_quicly_conn_t
 
	tquicly_conn_t
;

119 void 
quicly__debug_printf
(
quicly_conn_t
 *
conn
, const char *
function
, int 
line
, const char *
fmt
, ...)

120 
__attribute__
((
format
(
printf
, 4, 5)));

122 #define 
	#quicly_debug_printf
(
conn
, ...) 
	`quicly__debug_printf
((conn), 
__FUNCTION__
, 
__LINE__
, 
__VA_ARGS__
)

	)

124 #ifdef 
__cplusplus


	@include/quicly/defaults.h

22 #ifndef 
quicly_defaults_h


23 #define 
	#quicly_defaults_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~"quicly.h
"

31 extern const 
quicly_context_t
 
quicly_spec_context
;

32 extern const 
quicly_context_t
 
quicly_performant_context
;

40 
quicly_cid_encryptor_t
 *
quicly_new_default_cid_encryptor
(
ptls_cipher_algorithm_t
 *
cid_cipher
,

41 
ptls_cipher_algorithm_t
 *
reset_token_cipher
, 
ptls_hash_algorithm_t
 *
hash
,

42 
ptls_iovec_t
 
key
);

46 void 
quicly_free_default_cid_encryptor
(
quicly_cid_encryptor_t
 *
self
);

50 extern 
quicly_stream_scheduler_t
 
quicly_default_stream_scheduler
;

54 extern 
quicly_now_t
 
quicly_default_now
;

58 extern 
quicly_crypto_engine_t
 
quicly_default_crypto_engine
;

60 #define 
	#quicly_default_cc
 
quicly_cc_type_reno


	)

61 #define 
	#quicly_default_init_cc
 
quicly_cc_reno_init


	)

63 #ifdef 
__cplusplus


	@include/quicly/frame.h

22 #ifndef 
quicly_frame_h


23 #define 
	#quicly_frame_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<stddef.h
>

30 #include 
	~<stdint.h
>

31 #include 
	~<string.h
>

32 #include 
	~"picotls.h
"

33 #include 
	~"quicly/constants.h
"

34 #include 
	~"quicly/ranges.h
"

36 #define 
	#QUICLY_FRAME_TYPE_PADDING
 0

	)

37 #define 
	#QUICLY_FRAME_TYPE_PING
 1

	)

38 #define 
	#QUICLY_FRAME_TYPE_ACK
 2

	)

39 #define 
	#QUICLY_FRAME_TYPE_ACK_ECN
 3

	)

40 #define 
	#QUICLY_FRAME_TYPE_RESET_STREAM
 4

	)

41 #define 
	#QUICLY_FRAME_TYPE_STOP_SENDING
 5

	)

42 #define 
	#QUICLY_FRAME_TYPE_CRYPTO
 6

	)

43 #define 
	#QUICLY_FRAME_TYPE_NEW_TOKEN
 7

	)

44 #define 
	#QUICLY_FRAME_TYPE_STREAM_BASE
 8

	)

45 #define 
	#QUICLY_FRAME_TYPE_MAX_DATA
 16

	)

46 #define 
	#QUICLY_FRAME_TYPE_MAX_STREAM_DATA
 17

	)

47 #define 
	#QUICLY_FRAME_TYPE_MAX_STREAMS_BIDI
 18

	)

48 #define 
	#QUICLY_FRAME_TYPE_MAX_STREAMS_UNI
 19

	)

49 #define 
	#QUICLY_FRAME_TYPE_DATA_BLOCKED
 20

	)

50 #define 
	#QUICLY_FRAME_TYPE_STREAM_DATA_BLOCKED
 21

	)

51 #define 
	#QUICLY_FRAME_TYPE_STREAMS_BLOCKED_BIDI
 22

	)

52 #define 
	#QUICLY_FRAME_TYPE_STREAMS_BLOCKED_UNI
 23

	)

53 #define 
	#QUICLY_FRAME_TYPE_NEW_CONNECTION_ID
 24

	)

54 #define 
	#QUICLY_FRAME_TYPE_RETIRE_CONNECTION_ID
 25

	)

55 #define 
	#QUICLY_FRAME_TYPE_PATH_CHALLENGE
 26

	)

56 #define 
	#QUICLY_FRAME_TYPE_PATH_RESPONSE
 27

	)

57 #define 
	#QUICLY_FRAME_TYPE_TRANSPORT_CLOSE
 28

	)

58 #define 
	#QUICLY_FRAME_TYPE_APPLICATION_CLOSE
 29

	)

59 #define 
	#QUICLY_FRAME_TYPE_HANDSHAKE_DONE
 30

	)

60 #define 
	#QUICLY_FRAME_TYPE_DATAGRAM_NOLEN
 48

	)

61 #define 
	#QUICLY_FRAME_TYPE_DATAGRAM_WITHLEN
 49

	)

62 #define 
	#QUICLY_FRAME_TYPE_ACK_FREQUENCY
 0xaf

	)

64 #define 
	#QUICLY_FRAME_TYPE_STREAM_BITS
 0x7

	)

65 #define 
	#QUICLY_FRAME_TYPE_STREAM_BIT_OFF
 0x4

	)

66 #define 
	#QUICLY_FRAME_TYPE_STREAM_BIT_LEN
 0x2

	)

67 #define 
	#QUICLY_FRAME_TYPE_STREAM_BIT_FIN
 0x1

	)

69 #define 
	#QUICLY_MAX_DATA_FRAME_CAPACITY
 (1 + 8)

	)

70 #define 
	#QUICLY_MAX_STREAM_DATA_FRAME_CAPACITY
 (1 + 8 + 8)

	)

71 #define 
	#QUICLY_MAX_STREAMS_FRAME_CAPACITY
 (1 + 8)

	)

72 #define 
	#QUICLY_PING_FRAME_CAPACITY
 1

	)

73 #define 
	#QUICLY_RST_FRAME_CAPACITY
 (1 + 8 + 8 + 8)

	)

74 #define 
	#QUICLY_DATA_BLOCKED_FRAME_CAPACITY
 (1 + 8)

	)

75 #define 
	#QUICLY_STREAM_DATA_BLOCKED_FRAME_CAPACITY
 (1 + 8 + 8)

	)

76 #define 
	#QUICLY_STREAMS_BLOCKED_FRAME_CAPACITY
 (1 + 8)

	)

77 #define 
	#QUICLY_STOP_SENDING_FRAME_CAPACITY
 (1 + 8 + 8)

	)

78 #define 
	#QUICLY_ACK_MAX_GAPS
 256

	)

79 #define 
	#QUICLY_ACK_FRAME_CAPACITY
 (1 + 8 + 8 + 1)

	)

80 #define 
	#QUICLY_PATH_CHALLENGE_FRAME_CAPACITY
 (1 + 8)

	)

81 #define 
	#QUICLY_STREAM_FRAME_CAPACITY
 (1 + 8 + 8 + 1)

	)

86 #define 
	#QUICLY_MAX_ACK_BLOCKS
 64

	)

88 static 
uint16_t
 
quicly_decode16
(const 
uint8_t
 **
src
);

89 static 
uint32_t
 
quicly_decode24
(const 
uint8_t
 **
src
);

90 static 
uint32_t
 
quicly_decode32
(const 
uint8_t
 **
src
);

91 static 
uint64_t
 
quicly_decode64
(const 
uint8_t
 **
src
);

92 #define 
	#quicly_decodev
 
ptls_decode_quicint


	)

93 static 
uint8_t
 *
quicly_encode16
(uint8_t *
p
, 
uint16_t
 
v
);

94 static 
uint8_t
 *
quicly_encode32
(uint8_t *
p
, 
uint32_t
 
v
);

95 static 
uint8_t
 *
quicly_encode64
(uint8_t *
p
, 
uint64_t
 
v
);

96 #define 
	#quicly_encodev
 
ptls_encode_quicint


	)

97 static 
size_t
 
quicly_encodev_capacity
(
uint64_t
 
v
);

98 static unsigned 
quicly_clz32
(
uint32_t
 
v
);

99 static unsigned 
quicly_clz64
(
uint64_t
 
v
);

101 typedef struct 
	sst_quicly_stream_frame_t
 {

102 
uint64_t
 
stream_id
;

103 unsigned 
is_fin
 : 1;

104 
uint64_t
 
offset
;

105 
ptls_iovec_t
 
data
;

106 } 
	tquicly_stream_frame_t
;

108 static int 
quicly_decode_stream_frame
(
uint8_t
 
type_flags
, const uint8_t **
src
, const uint8_t *
end
, 
quicly_stream_frame_t
 *
frame
);

109 static 
uint8_t
 *
quicly_encode_crypto_frame_header
(uint8_t *
dst
, uint8_t *
dst_end
, 
uint64_t
 
offset
, 
size_t
 *
data_len
);

110 static int 
quicly_decode_crypto_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_stream_frame_t
 *
frame
);

112 static 
uint8_t
 *
quicly_encode_reset_stream_frame
(uint8_t *
dst
, 
uint64_t
 
stream_id
, 
uint16_t
 
app_error_code
, uint64_t 
final_size
);

114 typedef struct 
	sst_quicly_reset_stream_frame_t
 {

115 
uint64_t
 
stream_id
;

116 
uint16_t
 
app_error_code
;

117 
uint64_t
 
final_size
;

118 } 
	tquicly_reset_stream_frame_t
;

120 static int 
quicly_decode_reset_stream_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_reset_stream_frame_t
 *
frame
);

122 typedef struct 
	sst_quicly_transport_close_frame_t
 {

123 
uint16_t
 
error_code
;

124 
uint64_t
 
frame_type
;

125 
ptls_iovec_t
 
reason_phrase
;

126 } 
	tquicly_transport_close_frame_t
;

128 static int 
quicly_decode_transport_close_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_transport_close_frame_t
 *
frame
);

130 typedef struct 
	sst_quicly_application_close_frame_t
 {

131 
uint16_t
 
error_code
;

132 
ptls_iovec_t
 
reason_phrase
;

133 } 
	tquicly_application_close_frame_t
;

135 static int 
quicly_decode_application_close_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_application_close_frame_t
 *
frame
);

137 static 
size_t
 
quicly_close_frame_capacity
(
uint64_t
 
error_code
, uint64_t 
offending_frame_type
, const char *
reason_phrase
);

141 
uint8_t
 *
quicly_encode_close_frame
(uint8_t *const 
base
, 
uint64_t
 
error_code
, uint64_t 
offending_frame_type
,

142 const char *
reason_phrase
);

144 static 
uint8_t
 *
quicly_encode_max_data_frame
(uint8_t *
dst
, 
uint64_t
 
max_data
);

146 typedef struct 
	sst_quicly_max_data_frame_t
 {

147 
uint64_t
 
max_data
;

148 } 
	tquicly_max_data_frame_t
;

150 static int 
quicly_decode_max_data_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_max_data_frame_t
 *
frame
);

152 static 
uint8_t
 *
quicly_encode_max_stream_data_frame
(uint8_t *
dst
, 
uint64_t
 
stream_id
, uint64_t 
max_stream_data
);

154 typedef struct 
	sst_quicly_max_stream_data_frame_t
 {

155 
uint64_t
 
stream_id
;

156 
uint64_t
 
max_stream_data
;

157 } 
	tquicly_max_stream_data_frame_t
;

159 static int 
quicly_decode_max_stream_data_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_max_stream_data_frame_t
 *
frame
);

161 static 
uint8_t
 *
quicly_encode_max_streams_frame
(uint8_t *
dst
, int 
uni
, 
uint64_t
 
count
);

163 typedef struct 
	sst_quicly_max_streams_frame_t
 {

164 
uint64_t
 
count
;

165 } 
	tquicly_max_streams_frame_t
;

167 static int 
quicly_decode_max_streams_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_max_streams_frame_t
 *
frame
);

169 #define 
	#QUICLY_PATH_CHALLENGE_DATA_LEN
 8

	)

171 
uint8_t
 *
quicly_encode_path_challenge_frame
(uint8_t *
dst
, int 
is_response
, const uint8_t *
data
);

173 typedef struct 
	sst_quicly_path_challenge_frame_t
 {

174 const 
uint8_t
 *
data
;

175 } 
	tquicly_path_challenge_frame_t
;

177 static int 
quicly_decode_path_challenge_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_path_challenge_frame_t
 *
frame
);

179 static 
uint8_t
 *
quicly_encode_data_blocked_frame
(uint8_t *
dst
, 
uint64_t
 
offset
);

181 typedef struct 
	sst_quicly_data_blocked_frame_t
 {

182 
uint64_t
 
offset
;

183 } 
	tquicly_data_blocked_frame_t
;

185 static int 
quicly_decode_data_blocked_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_data_blocked_frame_t
 *
frame
);

187 static 
uint8_t
 *
quicly_encode_stream_data_blocked_frame
(uint8_t *
dst
, 
quicly_stream_id_t
 
stream_id
, 
uint64_t
 
offset
);

189 typedef struct 
	sst_quicly_stream_data_blocked_frame_t
 {

190 
quicly_stream_id_t
 
stream_id
;

191 
uint64_t
 
offset
;

192 } 
	tquicly_stream_data_blocked_frame_t
;

194 static int 
quicly_decode_stream_data_blocked_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
,

195 
quicly_stream_data_blocked_frame_t
 *
frame
);

197 static 
uint8_t
 *
quicly_encode_streams_blocked_frame
(uint8_t *
dst
, int 
uni
, 
uint64_t
 
count
);

199 typedef struct 
	sst_quicly_streams_blocked_frame_t
 {

200 
uint64_t
 
count
;

201 } 
	tquicly_streams_blocked_frame_t
;

203 static int 
quicly_decode_streams_blocked_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_streams_blocked_frame_t
 *
frame
);

205 static 
size_t
 
quicly_new_connection_id_frame_capacity
(
uint64_t
 
sequence
, uint64_t 
retire_prior_to
, 
uint8_t
 
cid_len
);

206 static 
uint8_t
 *
quicly_encode_new_connection_id_frame
(uint8_t *
dst
, 
uint64_t
 
sequence
, uint64_t 
retire_prior_to
, const uint8_t *
cid
,

207 
uint8_t
 
cid_len
, const uint8_t *
stateless_reset_token
);

209 static 
size_t
 
quicly_retire_connection_id_frame_capacity
(
uint64_t
 
sequence
);

210 static 
uint8_t
 *
quicly_encode_retire_connection_id_frame
(uint8_t *
dst
, 
uint64_t
 
sequence
);

212 typedef struct 
	sst_quicly_new_connection_id_frame_t
 {

213 
uint64_t
 
sequence
;

214 
uint64_t
 
retire_prior_to
;

215 
ptls_iovec_t
 
cid
;

216 const 
uint8_t
 *
stateless_reset_token
;

217 } 
	tquicly_new_connection_id_frame_t
;

219 static int 
quicly_decode_new_connection_id_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_new_connection_id_frame_t
 *
frame
);

221 typedef struct 
	sst_quicly_retire_connection_id_frame_t
 {

222 
uint64_t
 
sequence
;

223 } 
	tquicly_retire_connection_id_frame_t
;

225 static int 
quicly_decode_retire_connection_id_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
,

226 
quicly_retire_connection_id_frame_t
 *
frame
);

228 static 
uint8_t
 *
quicly_encode_stop_sending_frame
(uint8_t *
dst
, 
uint64_t
 
stream_id
, 
uint16_t
 
app_error_code
);

230 typedef struct 
	sst_quicly_stop_sending_frame_t
 {

231 
uint64_t
 
stream_id
;

232 
uint16_t
 
app_error_code
;

233 } 
	tquicly_stop_sending_frame_t
;

235 static int 
quicly_decode_stop_sending_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_stop_sending_frame_t
 *
frame
);

237 
uint8_t
 *
quicly_encode_ack_frame
(uint8_t *
dst
, uint8_t *
dst_end
, 
quicly_ranges_t
 *
ranges
, 
uint64_t
 
ack_delay
);

239 typedef struct 
	sst_quicly_ack_frame_t
 {

240 
uint64_t
 
largest_acknowledged
;

241 
uint64_t
 
smallest_acknowledged
;

242 
uint64_t
 
ack_delay
;

243 
uint64_t
 
num_gaps
;

244 
uint64_t
 
ack_block_lengths
[
QUICLY_ACK_MAX_GAPS
 + 1];

245 
uint64_t
 
gaps
[
QUICLY_ACK_MAX_GAPS
];

246 } 
	tquicly_ack_frame_t
;

248 int 
quicly_decode_ack_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_ack_frame_t
 *
frame
, int 
is_ack_ecn
);

250 static 
size_t
 
quicly_new_token_frame_capacity
(
ptls_iovec_t
 
token
);

251 static 
uint8_t
 *
quicly_encode_new_token_frame
(uint8_t *
dst
, 
ptls_iovec_t
 
token
);

253 typedef struct 
	sst_quicly_new_token_frame_t
 {

254 
ptls_iovec_t
 
token
;

255 } 
	tquicly_new_token_frame_t
;

257 static int 
quicly_decode_new_token_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_new_token_frame_t
 *
frame
);

259 static 
size_t
 
quicly_datagram_frame_capacity
(
ptls_iovec_t
 
payload
);

260 static 
uint8_t
 *
quicly_encode_datagram_frame
(uint8_t *
dst
, 
ptls_iovec_t
 
payload
);

262 typedef struct 
	sst_quicly_datagram_frame_t
 {

263 
ptls_iovec_t
 
payload
;

264 } 
	tquicly_datagram_frame_t
;

266 static int 
quicly_decode_datagram_frame
(
uint64_t
 
frame_type
, const 
uint8_t
 **
src
, const uint8_t *
end
,

267 
quicly_datagram_frame_t
 *
frame
);

269 typedef struct 
	sst_quicly_ack_frequency_frame_t
 {

270 
uint64_t
 
sequence
;

271 
uint64_t
 
packet_tolerance
;

272 
uint64_t
 
max_ack_delay
;

273 
uint8_t
 
ignore_order
;

274 } 
	tquicly_ack_frequency_frame_t
;

276 static 
uint8_t
 *
quicly_encode_ack_frequency_frame
(uint8_t *
dst
, 
uint64_t
 
sequence
, uint64_t 
packet_tolerance
,

277 
uint64_t
 
max_ack_delay
, int 
ignore_order
);

278 static int 
quicly_decode_ack_frequency_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_ack_frequency_frame_t
 *
frame
);

282 
inline
 
uint16_t
 
quicly_decode16
(const 
uint8_t
 **
src
)

284 
uint16_t
 
v
 = (uint16_t)(*
src
)[0] << 8 | (*src)[1];

285 *
src
 += 2;

286 return 
v
;

289 
inline
 
uint32_t
 
quicly_decode24
(const 
uint8_t
 **
src
)

291 
uint32_t
 
v
 = (uint32_t)(*
src
)[0] << 16 | (uint32_t)(*src)[1] << 8 | (uint32_t)(*src)[2];

292 *
src
 += 3;

293 return 
v
;

296 
inline
 
uint32_t
 
quicly_decode32
(const 
uint8_t
 **
src
)

298 
uint32_t
 
v
 = (uint32_t)(*
src
)[0] << 24 | (uint32_t)(*src)[1] << 16 | (uint32_t)(*src)[2] << 8 | (*src)[3];

299 *
src
 += 4;

300 return 
v
;

303 
inline
 
uint64_t
 
quicly_decode64
(const 
uint8_t
 **
src
)

305 
uint64_t
 
v
 = (uint64_t)(*
src
)[0] << 56 | (uint64_t)(*src)[1] << 48 | (uint64_t)(*src)[2] << 40 | (uint64_t)(*src)[3] << 32 |

306 (
uint64_t
)(*
src
)[4] << 24 | (uint64_t)(*src)[5] << 16 | (uint64_t)(*src)[6] << 8 | (*src)[7];

307 *
src
 += 8;

308 return 
v
;

311 
inline
 
uint8_t
 *
quicly_encode16
(uint8_t *
p
, 
uint16_t
 
v
)

313 *
p
++ = (
uint8_t
)(
v
 >> 8);

314 *
p
++ = (
uint8_t
)
v
;

315 return 
p
;

318 
inline
 
uint8_t
 *
quicly_encode32
(uint8_t *
p
, 
uint32_t
 
v
)

320 *
p
++ = (
uint8_t
)(
v
 >> 24);

321 *
p
++ = (
uint8_t
)(
v
 >> 16);

322 *
p
++ = (
uint8_t
)(
v
 >> 8);

323 *
p
++ = (
uint8_t
)
v
;

324 return 
p
;

327 
inline
 
uint8_t
 *
quicly_encode64
(uint8_t *
p
, 
uint64_t
 
v
)

329 *
p
++ = (
uint8_t
)(
v
 >> 56);

330 *
p
++ = (
uint8_t
)(
v
 >> 48);

331 *
p
++ = (
uint8_t
)(
v
 >> 40);

332 *
p
++ = (
uint8_t
)(
v
 >> 32);

333 *
p
++ = (
uint8_t
)(
v
 >> 24);

334 *
p
++ = (
uint8_t
)(
v
 >> 16);

335 *
p
++ = (
uint8_t
)(
v
 >> 8);

336 *
p
++ = (
uint8_t
)
v
;

337 return 
p
;

340 
inline
 
size_t
 
quicly_encodev_capacity
(
uint64_t
 
v
)

342 if (
v
 > 63) {

343 if (
v
 > 16383) {

344 if (
v
 > 1073741823)

353 
inline
 unsigned 
quicly_clz32
(
uint32_t
 
v
)

355 
PTLS_BUILD_ASSERT
(sizeof(unsigned) == 4);

356 return 
v
 != 0 ? 
__builtin_clz
(v) : 32;

359 
inline
 unsigned 
quicly_clz64
(
uint64_t
 
v
)

361 
PTLS_BUILD_ASSERT
(sizeof(long long) == 8);

362 return 
v
 != 0 ? 
__builtin_clzll
(v) : 64;

365 
inline
 int 
quicly_decode_stream_frame
(
uint8_t
 
type_flags
, const uint8_t **
src
, const uint8_t *
end
, 
quicly_stream_frame_t
 *
frame
)

368 if ((
frame
->
stream_id
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

369 goto 
Error
;

372 if ((
type_flags
 & 
QUICLY_FRAME_TYPE_STREAM_BIT_OFF
) != 0) {

373 if ((
frame
->
offset
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

374 goto 
Error
;

376 
frame
->
offset
 = 0;

380 if ((
type_flags
 & 
QUICLY_FRAME_TYPE_STREAM_BIT_LEN
) != 0) {

381 
uint64_t
 
len
;

382 if ((
len
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

383 goto 
Error
;

384 if ((
uint64_t
)(
end
 - *
src
) < 
len
)

385 goto 
Error
;

386 
frame
->
data
 = 
ptls_iovec_init
(*
src
, 
len
);

387 *
src
 += 
len
;

389 
frame
->
data
 = 
ptls_iovec_init
(*
src
, 
end
 - *src);

390 *
src
 = 
end
;

394 
frame
->
is_fin
 = (
type_flags
 & 
QUICLY_FRAME_TYPE_STREAM_BIT_FIN
) != 0;

397 
Error
:

398 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

401 
inline
 
uint8_t
 *
quicly_encode_crypto_frame_header
(uint8_t *
dst
, uint8_t *
dst_end
, 
uint64_t
 
offset
, 
size_t
 *
data_len
)

403 
size_t
 
sizeleft
, 
len_length
;

405 *
dst
++ = 
QUICLY_FRAME_TYPE_CRYPTO
;

406 
dst
 = 
quicly_encodev
(dst, 
offset
);

408 
sizeleft
 = 
dst_end
 - 
dst
;

409 if (
sizeleft
 <= 64 || *
data_len
 < 64) {

410 if (*
data_len
 >= 
sizeleft
)

411 *
data_len
 = 
sizeleft
 - 1;

412 
len_length
 = 1;

414 if (*
data_len
 > 16383)

415 *
data_len
 = 16383;

416 
len_length
 = 2;

419 if (*
data_len
 > 
sizeleft
 - 
len_length
)

420 *
data_len
 = 
sizeleft
 - 
len_length
;

421 
dst
 = 
quicly_encodev
(dst, *
data_len
);

422 return 
dst
;

425 
inline
 int 
quicly_decode_crypto_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_stream_frame_t
 *
frame
)

427 
uint64_t
 
len
;

429 
frame
->
stream_id
 = 0;

430 
frame
->
is_fin
 = 0;

432 if ((
frame
->
offset
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

433 goto 
Error
;

434 if ((
len
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

435 goto 
Error
;

436 if ((
uint64_t
)(
end
 - *
src
) < 
len
)

437 goto 
Error
;

438 
frame
->
data
 = 
ptls_iovec_init
(*
src
, 
len
);

439 *
src
 += 
len
;

442 
Error
:

443 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

446 
inline
 
uint8_t
 *
quicly_encode_reset_stream_frame
(uint8_t *
dst
, 
uint64_t
 
stream_id
, 
uint16_t
 
app_error_code
, uint64_t 
final_size
)

448 *
dst
++ = 
QUICLY_FRAME_TYPE_RESET_STREAM
;

449 
dst
 = 
quicly_encodev
(dst, 
stream_id
);

450 
dst
 = 
quicly_encodev
(dst, 
app_error_code
);

451 
dst
 = 
quicly_encodev
(dst, 
final_size
);

452 return 
dst
;

455 
inline
 int 
quicly_decode_reset_stream_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_reset_stream_frame_t
 *
frame
)

457 
uint64_t
 
error_code
;

459 if ((
frame
->
stream_id
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

460 goto 
Error
;

461 if ((
error_code
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

462 goto 
Error
;

463 
frame
->
app_error_code
 = (
uint16_t
)
error_code
;

464 
frame
->
final_size
 = 
quicly_decodev
(
src
, 
end
);

466 
Error
:

467 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

470 
inline
 int 
quicly_decode_application_close_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_application_close_frame_t
 *
frame
)

472 
uint64_t
 
error_code
, 
reason_len
;

474 if ((
error_code
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

475 goto 
Error
;

476 
frame
->
error_code
 = (
uint16_t
)error_code;

477 if ((
reason_len
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

478 goto 
Error
;

479 if ((
uint64_t
)(
end
 - *
src
) < 
reason_len
)

480 goto 
Error
;

481 
frame
->
reason_phrase
 = 
ptls_iovec_init
(*
src
, 
reason_len
);

482 *
src
 += 
reason_len
;

484 
Error
:

485 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

488 
inline
 int 
quicly_decode_transport_close_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_transport_close_frame_t
 *
frame
)

490 
uint64_t
 
error_code
, 
reason_len
;

492 if ((
error_code
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

493 goto 
Error
;

494 
frame
->
error_code
 = (
uint16_t
)error_code;

495 if ((
frame
->
frame_type
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

496 goto 
Error
;

497 if ((
reason_len
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

498 goto 
Error
;

499 if ((
uint64_t
)(
end
 - *
src
) < 
reason_len
)

500 goto 
Error
;

501 
frame
->
reason_phrase
 = 
ptls_iovec_init
(*
src
, 
reason_len
);

502 *
src
 += 
reason_len
;

504 
Error
:

505 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

508 
inline
 
size_t
 
quicly_close_frame_capacity
(
uint64_t
 
error_code
, uint64_t 
offending_frame_type
, const char *
reason_phrase
)

510 return 
quicly_encode_close_frame
(
NULL
, 
error_code
, 
offending_frame_type
, 
reason_phrase
) - (
uint8_t
 *)NULL;

513 
inline
 
uint8_t
 *
quicly_encode_max_data_frame
(uint8_t *
dst
, 
uint64_t
 
max_data
)

515 *
dst
++ = 
QUICLY_FRAME_TYPE_MAX_DATA
;

516 
dst
 = 
quicly_encodev
(dst, 
max_data
);

517 return 
dst
;

520 
inline
 int 
quicly_decode_max_data_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_max_data_frame_t
 *
frame
)

522 if ((
frame
->
max_data
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

523 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

527 
inline
 
uint8_t
 *
quicly_encode_max_stream_data_frame
(uint8_t *
dst
, 
uint64_t
 
stream_id
, uint64_t 
max_stream_data
)

529 *
dst
++ = 
QUICLY_FRAME_TYPE_MAX_STREAM_DATA
;

530 
dst
 = 
quicly_encodev
(dst, 
stream_id
);

531 
dst
 = 
quicly_encodev
(dst, 
max_stream_data
);

532 return 
dst
;

535 
inline
 int 
quicly_decode_max_stream_data_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_max_stream_data_frame_t
 *
frame
)

537 if ((
frame
->
stream_id
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

538 goto 
Error
;

539 if ((
frame
->
max_stream_data
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

540 goto 
Error
;

542 
Error
:

543 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

546 
inline
 
uint8_t
 *
quicly_encode_max_streams_frame
(uint8_t *
dst
, int 
uni
, 
uint64_t
 
count
)

548 *
dst
++ = 
uni
 ? 
QUICLY_FRAME_TYPE_MAX_STREAMS_UNI
 : 
QUICLY_FRAME_TYPE_MAX_STREAMS_BIDI
;

549 
dst
 = 
quicly_encodev
(dst, 
count
);

550 return 
dst
;

553 
inline
 int 
quicly_decode_max_streams_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_max_streams_frame_t
 *
frame
)

555 if ((
frame
->
count
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

556 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

557 if (
frame
->
count
 > (
uint64_t
)1 << 60)

558 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

562 
inline
 int 
quicly_decode_path_challenge_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_path_challenge_frame_t
 *
frame
)

564 if (
end
 - *
src
 < 1)

565 goto 
Error
;

566 if (
end
 - *
src
 < 
QUICLY_PATH_CHALLENGE_DATA_LEN
)

567 goto 
Error
;

568 
frame
->
data
 = *
src
;

569 *
src
 += 
QUICLY_PATH_CHALLENGE_DATA_LEN
;

571 
Error
:

572 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

575 
inline
 
uint8_t
 *
quicly_encode_data_blocked_frame
(uint8_t *
dst
, 
uint64_t
 
offset
)

577 *
dst
++ = 
QUICLY_FRAME_TYPE_DATA_BLOCKED
;

578 
dst
 = 
quicly_encodev
(dst, 
offset
);

579 return 
dst
;

582 
inline
 int 
quicly_decode_data_blocked_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_data_blocked_frame_t
 *
frame
)

584 if ((
frame
->
offset
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

585 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

589 
inline
 
uint8_t
 *
quicly_encode_stream_data_blocked_frame
(uint8_t *
dst
, 
quicly_stream_id_t
 
stream_id
, 
uint64_t
 
offset
)

591 *
dst
++ = 
QUICLY_FRAME_TYPE_STREAM_DATA_BLOCKED
;

592 
dst
 = 
quicly_encodev
(dst, 
stream_id
);

593 
dst
 = 
quicly_encodev
(dst, 
offset
);

594 return 
dst
;

597 
inline
 int 
quicly_decode_stream_data_blocked_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
,

598 
quicly_stream_data_blocked_frame_t
 *
frame
)

600 if ((
frame
->
stream_id
 = 
quicly_decodev
(
src
, 
end
)) == -1)

601 goto 
Error
;

602 if ((
frame
->
offset
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

603 goto 
Error
;

605 
Error
:

606 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

609 
inline
 
uint8_t
 *
quicly_encode_streams_blocked_frame
(uint8_t *
dst
, int 
uni
, 
uint64_t
 
count
)

611 *
dst
++ = 
uni
 ? 
QUICLY_FRAME_TYPE_STREAMS_BLOCKED_UNI
 : 
QUICLY_FRAME_TYPE_STREAMS_BLOCKED_BIDI
;

612 
dst
 = 
quicly_encodev
(dst, 
count
);

613 return 
dst
;

616 
inline
 int 
quicly_decode_streams_blocked_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_streams_blocked_frame_t
 *
frame
)

618 if ((
frame
->
count
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

619 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

620 if (
frame
->
count
 > (
uint64_t
)1 << 60)

621 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

625 
inline
 
size_t
 
quicly_new_connection_id_frame_capacity
(
uint64_t
 
sequence
, uint64_t 
retire_prior_to
, 
uint8_t
 
cid_len
)

627 
size_t
 
frame_type_len
 = 1;

628 
size_t
 
length_len
 = 1;

629 return 
frame_type_len
 + 
quicly_encodev_capacity
(
sequence
) + quicly_encodev_capacity(
retire_prior_to
) + 
length_len
 + 
cid_len
 +

630 
QUICLY_STATELESS_RESET_TOKEN_LEN
;

633 
inline
 
uint8_t
 *
quicly_encode_new_connection_id_frame
(uint8_t *
dst
, 
uint64_t
 
sequence
, uint64_t 
retire_prior_to
, const uint8_t *
cid
,

634 
uint8_t
 
cid_len
, const uint8_t *
stateless_reset_token
)

636 *
dst
++ = 
QUICLY_FRAME_TYPE_NEW_CONNECTION_ID
;

637 
dst
 = 
quicly_encodev
(dst, 
sequence
);

638 
dst
 = 
quicly_encodev
(dst, 
retire_prior_to
);

639 *
dst
++ = 
cid_len
;

640 
memcpy
(
dst
, 
cid
, 
cid_len
);

641 
dst
 += 
cid_len
;

642 
memcpy
(
dst
, 
stateless_reset_token
, 
QUICLY_STATELESS_RESET_TOKEN_LEN
);

643 
dst
 += 
QUICLY_STATELESS_RESET_TOKEN_LEN
;

645 return 
dst
;

648 
inline
 
size_t
 
quicly_retire_connection_id_frame_capacity
(
uint64_t
 
sequence
)

650 return 1 + 
quicly_encodev_capacity
(
sequence
);

653 
inline
 
uint8_t
 *
quicly_encode_retire_connection_id_frame
(uint8_t *
dst
, 
uint64_t
 
sequence
)

655 *
dst
++ = 
QUICLY_FRAME_TYPE_RETIRE_CONNECTION_ID
;

656 
dst
 = 
quicly_encodev
(dst, 
sequence
);

658 return 
dst
;

661 
inline
 int 
quicly_decode_new_connection_id_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_new_connection_id_frame_t
 *
frame
)

664 if ((
frame
->
sequence
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

665 goto 
Fail
;

666 if ((
frame
->
retire_prior_to
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

667 goto 
Fail
;

669 if (
frame
->
sequence
 < frame->
retire_prior_to
)

670 goto 
Fail
;

671 if (
end
 - *
src
 < 1)

672 goto 
Fail
;

675 
uint8_t
 
cid_len
 = *(*
src
)++;

676 if (!(1 <= 
cid_len
 && cid_len <= 
QUICLY_MAX_CID_LEN_V1
))

677 goto 
Fail
;

678 
frame
->
cid
 = 
ptls_iovec_init
(*
src
, 
cid_len
);

679 *
src
 += 
cid_len
;

683 if (
end
 - *
src
 < 
QUICLY_STATELESS_RESET_TOKEN_LEN
)

684 goto 
Fail
;

685 
frame
->
stateless_reset_token
 = *
src
;

686 *
src
 += 
QUICLY_STATELESS_RESET_TOKEN_LEN
;

689 
Fail
:

690 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

693 
inline
 int 
quicly_decode_retire_connection_id_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
,

694 
quicly_retire_connection_id_frame_t
 *
frame
)

697 if ((
frame
->
sequence
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

698 goto 
Fail
;

701 
Fail
:

702 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

705 
inline
 
uint8_t
 *
quicly_encode_stop_sending_frame
(uint8_t *
dst
, 
uint64_t
 
stream_id
, 
uint16_t
 
app_error_code
)

707 *
dst
++ = 
QUICLY_FRAME_TYPE_STOP_SENDING
;

708 
dst
 = 
quicly_encodev
(dst, 
stream_id
);

709 
dst
 = 
quicly_encodev
(dst, 
app_error_code
);

710 return 
dst
;

713 
inline
 int 
quicly_decode_stop_sending_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_stop_sending_frame_t
 *
frame
)

715 
uint64_t
 
error_code
;

717 if ((
frame
->
stream_id
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

718 goto 
Error
;

719 if ((
error_code
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

720 goto 
Error
;

721 
frame
->
app_error_code
 = (
uint16_t
)
error_code
;

723 
Error
:

724 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

727 
inline
 
size_t
 
quicly_new_token_frame_capacity
(
ptls_iovec_t
 
token
)

729 return 1 + 
quicly_encodev_capacity
(
token
.
len
) + token.len;

732 
inline
 
uint8_t
 *
quicly_encode_new_token_frame
(uint8_t *
dst
, 
ptls_iovec_t
 
token
)

734 *
dst
++ = 
QUICLY_FRAME_TYPE_NEW_TOKEN
;

735 
dst
 = 
quicly_encodev
(dst, 
token
.
len
);

736 
memcpy
(
dst
, 
token
.
base
, token.
len
);

737 
dst
 += 
token
.
len
;

738 return 
dst
;

741 
inline
 int 
quicly_decode_new_token_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_new_token_frame_t
 *
frame
)

743 
uint64_t
 
token_len
;

744 if ((
token_len
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

745 goto 
Error
;

746 if (
token_len
 == 0)

747 goto 
Error
;

748 if ((
uint64_t
)(
end
 - *
src
) < 
token_len
)

749 goto 
Error
;

750 
frame
->
token
 = 
ptls_iovec_init
(*
src
, (
size_t
)
token_len
);

751 *
src
 += 
frame
->
token
.
len
;

753 
Error
:

754 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

757 
inline
 
size_t
 
quicly_datagram_frame_capacity
(
ptls_iovec_t
 
payload
)

759 return 
quicly_encodev_capacity
(
QUICLY_FRAME_TYPE_DATAGRAM_WITHLEN
) + quicly_encodev_capacity(
payload
.
len
) + payload.len;

762 
inline
 
uint8_t
 *
quicly_encode_datagram_frame
(uint8_t *
dst
, 
ptls_iovec_t
 
payload
)

764 
dst
 = 
quicly_encodev
(dst, 
QUICLY_FRAME_TYPE_DATAGRAM_WITHLEN
);

765 
dst
 = 
quicly_encodev
(dst, 
payload
.
len
);

766 
memcpy
(
dst
, 
payload
.
base
, payload.
len
);

767 
dst
 += 
payload
.
len
;

768 return 
dst
;

771 
inline
 int 
quicly_decode_datagram_frame
(
uint64_t
 
frame_type
, const 
uint8_t
 **
src
, const uint8_t *
end
,

772 
quicly_datagram_frame_t
 *
frame
)

774 if (
frame_type
 == 
QUICLY_FRAME_TYPE_DATAGRAM_WITHLEN
) {

775 
uint64_t
 
len
;

776 if ((
len
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

777 goto 
Error
;

778 if ((
uint64_t
)(
end
 - *
src
) < 
len
)

779 goto 
Error
;

780 
frame
->
payload
.
len
 = len;

782 
frame
->
payload
.
len
 = 
end
 - *
src
;

784 
frame
->
payload
.
base
 = (
uint8_t
 *)*
src
;

785 *
src
 += 
frame
->
payload
.
len
;

787 
Error
:

788 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

791 
inline
 
uint8_t
 *
quicly_encode_ack_frequency_frame
(uint8_t *
dst
, 
uint64_t
 
sequence
, uint64_t 
packet_tolerance
,

792 
uint64_t
 
max_ack_delay
, int 
ignore_order
)

794 
dst
 = 
quicly_encodev
(dst, 
QUICLY_FRAME_TYPE_ACK_FREQUENCY
);

795 
dst
 = 
quicly_encodev
(dst, 
sequence
);

796 
dst
 = 
quicly_encodev
(dst, 
packet_tolerance
);

797 
dst
 = 
quicly_encodev
(dst, 
max_ack_delay
);

798 *
dst
++ = !!
ignore_order
;

799 return 
dst
;

802 
inline
 int 
quicly_decode_ack_frequency_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_ack_frequency_frame_t
 *
frame
)

804 if ((
frame
->
sequence
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

805 goto 
Error
;

806 if ((
frame
->
packet_tolerance
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
 || frame->packet_tolerance == 0)

807 goto 
Error
;

808 if ((
frame
->
max_ack_delay
 = 
quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

809 goto 
Error
;

810 if (*
src
 == 
end
)

811 goto 
Error
;

812 switch (*(*
src
)++) {

814 
frame
->
ignore_order
 = 0;

817 
frame
->
ignore_order
 = 1;

820 goto 
Error
;

823 
Error
:

824 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

827 #ifdef 
__cplusplus


	@include/quicly/linklist.h

22 #ifndef 
quicly_linklist_h


23 #define 
	#quicly_linklist_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<assert.h
>

31 typedef struct 
	sst_quicly_linklist_t
 {

32 struct 
st_quicly_linklist_t
 *
prev
;

33 struct 
st_quicly_linklist_t
 *
next
;

34 } 
	tquicly_linklist_t
;

36 static void 
quicly_linklist_init
(
quicly_linklist_t
 *
l
);

37 static int 
quicly_linklist_is_linked
(
quicly_linklist_t
 *
l
);

38 static void 
quicly_linklist_insert
(
quicly_linklist_t
 *
prev
, quicly_linklist_t *
n
);

39 static void 
quicly_linklist_unlink
(
quicly_linklist_t
 *
l
);

40 static void 
quicly_linklist_insert_list
(
quicly_linklist_t
 *
prev
, quicly_linklist_t *
l
);

44 
inline
 void 
quicly_linklist_init
(
quicly_linklist_t
 *
l
)

46 
l
->
prev
 = l->
next
 = l;

49 
inline
 int 
quicly_linklist_is_linked
(
quicly_linklist_t
 *
l
)

51 return 
l
->
prev
 != l;

54 
inline
 void 
quicly_linklist_insert
(
quicly_linklist_t
 *
prev
, quicly_linklist_t *
n
)

56 
assert
(!
quicly_linklist_is_linked
(
n
));

57 
n
->
prev
 = prev;

58 
n
->
next
 = 
prev
->next;

59 
n
->
prev
->
next
 = n;

60 
n
->
next
->
prev
 = n;

63 
inline
 void 
quicly_linklist_unlink
(
quicly_linklist_t
 *
l
)

65 
l
->
prev
->
next
 = l->next;

66 
l
->
next
->
prev
 = l->prev;

67 
quicly_linklist_init
(
l
);

70 
inline
 void 
quicly_linklist_insert_list
(
quicly_linklist_t
 *
prev
, quicly_linklist_t *
l
)

72 if (
quicly_linklist_is_linked
(
l
)) {

73 
l
->
next
->
prev
 = prev;

74 
l
->
prev
->
next
 = prev->next;

75 
prev
->
next
->prev = 
l
->prev;

76 
prev
->
next
 = 
l
->next;

77 
quicly_linklist_init
(
l
);

81 #ifdef 
__cplusplus


	@include/quicly/local_cid.h

22 #ifndef 
quicly_local_cid_h


23 #define 
	#quicly_local_cid_h


	)

25 #include 
	~"quicly/cid.h
"

27 #ifdef 
__cplusplus


31 enum 
	een_quicly_local_cid_state_t
 {

35 
QUICLY_LOCAL_CID_STATE_IDLE
,

39 
QUICLY_LOCAL_CID_STATE_PENDING
,

43 
QUICLY_LOCAL_CID_STATE_INFLIGHT
,

47 
QUICLY_LOCAL_CID_STATE_DELIVERED
,

53 typedef struct 
	sst_quicly_local_cid_t
 {

54 enum 
en_quicly_local_cid_state_t
 
state
;

55 
uint64_t
 
sequence
;

56 
quicly_cid_t
 
cid
;

57 
uint8_t
 
stateless_reset_token
[
QUICLY_STATELESS_RESET_TOKEN_LEN
];

58 } 
	tquicly_local_cid_t
;

63 typedef struct 
	sst_quicly_local_cid_set_t
 {

68 
quicly_cid_plaintext_t
 
plaintext
;

77 
quicly_local_cid_t
 
cids
[
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
];

81 
size_t
 
_size
;

82 
quicly_cid_encryptor_t
 *
_encryptor
;

83 } 
	tquicly_local_cid_set_t
;

91 void 
quicly_local_cid_init_set
(
quicly_local_cid_set_t
 *
set
, 
quicly_cid_encryptor_t
 *
encryptor
,

92 const 
quicly_cid_plaintext_t
 *
new_cid
);

100 int 
quicly_local_cid_set_size
(
quicly_local_cid_set_t
 *
set
, 
size_t
 
new_cap
);

104 static 
size_t
 
quicly_local_cid_get_size
(const 
quicly_local_cid_set_t
 *
set
);

108 void 
quicly_local_cid_on_sent
(
quicly_local_cid_set_t
 *
set
, 
size_t
 
num_sent
);

112 void 
quicly_local_cid_on_acked
(
quicly_local_cid_set_t
 *
set
, 
uint64_t
 
sequence
);

118 int 
quicly_local_cid_on_lost
(
quicly_local_cid_set_t
 *
set
, 
uint64_t
 
sequence
);

125 int 
quicly_local_cid_retire
(
quicly_local_cid_set_t
 *
set
, 
uint64_t
 
sequence
, int *
has_pending
);

129 
inline
 
size_t
 
quicly_local_cid_get_size
(const 
quicly_local_cid_set_t
 *
set
)

131 return 
set
->
_size
;

134 #ifdef 
__cplusplus


	@include/quicly/loss.h

22 #ifndef 
quicly_loss_h


23 #define 
	#quicly_loss_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<assert.h
>

30 #include 
	~<stddef.h
>

31 #include 
	~<stdint.h
>

32 #include 
	~"quicly/constants.h
"

33 #include 
	~"quicly/sentmap.h
"

35 typedef struct 
	squicly_loss_conf_t
 {

39 unsigned 
time_reordering_percentile
;

43 
uint32_t
 
min_pto
;

47 
uint32_t
 
default_initial_rtt
;

51 
uint8_t
 
num_speculative_ptos
;

52 } 
	tquicly_loss_conf_t
;

54 #define 
	#QUICLY_LOSS_DEFAULT_TIME_REORDERING_PERCENTILE
 (1024 / 8)

	)

56 #define 
	#QUICLY_LOSS_SPEC_CONF
 \

58 
QUICLY_LOSS_DEFAULT_TIME_REORDERING_PERCENTILE
, \

59 
QUICLY_DEFAULT_MIN_PTO
, \

60 
QUICLY_DEFAULT_INITIAL_RTT
, \

62 }

	)

64 #define 
	#QUICLY_LOSS_PERFORMANT_CONF
 \

66 
QUICLY_LOSS_DEFAULT_TIME_REORDERING_PERCENTILE
, \

67 
QUICLY_DEFAULT_MIN_PTO
, \

68 
QUICLY_DEFAULT_INITIAL_RTT
, \

70 }

	)

77 typedef struct 
	squicly_rtt_t
 {

81 
uint32_t
 
minimum
;

85 
uint32_t
 
smoothed
;

89 
uint32_t
 
variance
;

93 
uint32_t
 
latest
;

94 } 
	tquicly_rtt_t
;

96 static void 
quicly_rtt_init
(
quicly_rtt_t
 *
rtt
, const 
quicly_loss_conf_t
 *
conf
, 
uint32_t
 
initial_rtt
);

97 static void 
quicly_rtt_update
(
quicly_rtt_t
 *
rtt
, 
uint32_t
 
latest_rtt
, uint32_t 
ack_delay
);

98 static 
uint32_t
 
quicly_rtt_get_pto
(
quicly_rtt_t
 *
rtt
, uint32_t 
max_ack_delay
, uint32_t 
min_pto
);

100 typedef struct 
	squicly_loss_t
 {

104 const 
quicly_loss_conf_t
 *
conf
;

108 const 
uint16_t
 *
max_ack_delay
;

112 const 
uint8_t
 *
ack_delay_exponent
;

116 
int8_t
 
pto_count
;

120 
int64_t
 
time_of_last_packet_sent
;

124 
uint64_t
 
largest_acked_packet_plus1
[
QUICLY_NUM_EPOCHS
];

128 
uint64_t
 
total_bytes_sent
;

132 
int64_t
 
loss_time
;

136 
int64_t
 
alarm_at
;

140 
quicly_rtt_t
 
rtt
;

144 
quicly_sentmap_t
 
sentmap
;

145 } 
	tquicly_loss_t
;

147 typedef void (*
quicly_loss_on_detect_cb
)(
	tquicly_loss_t
 *
	tloss
, const 
	tquicly_sent_packet_t
 *
	tlost_packet
, int 
	tis_time_threshold
);

149 static void 
quicly_loss_init
(
quicly_loss_t
 *
r
, const 
quicly_loss_conf_t
 *
conf
, 
uint32_t
 
initial_rtt
, const 
uint16_t
 *
max_ack_delay
,

150 const 
uint8_t
 *
ack_delay_exponent
);

151 static void 
quicly_loss_dispose
(
quicly_loss_t
 *
r
);

152 static void 
quicly_loss_update_alarm
(
quicly_loss_t
 *
r
, 
int64_t
 
now
, int64_t 
last_retransmittable_sent_at
, int 
has_outstanding
,

153 int 
can_send_stream_data
, int 
handshake_is_in_progress
, 
uint64_t
 
total_bytes_sent
,

154 int 
is_after_send
);

158 static void 
quicly_loss_on_ack_received
(
quicly_loss_t
 *
r
, 
uint64_t
 
largest_newly_acked
, 
size_t
 
epoch
, 
int64_t
 
now
, int64_t 
sent_at
,

159 
uint64_t
 
ack_delay_encoded
, int 
ack_eliciting
);

166 static int 
quicly_loss_on_alarm
(
quicly_loss_t
 *
r
, 
int64_t
 
now
, 
uint32_t
 
max_ack_delay
, int 
is_1rtt_only
,

167 
size_t
 *
min_packets_to_send
, int *
restrict_sending
, 
quicly_loss_on_detect_cb
 
on_loss_detected
);

171 int 
quicly_loss_detect_loss
(
quicly_loss_t
 *
r
, 
int64_t
 
now
, 
uint32_t
 
max_ack_delay
, int 
is_1rtt_only
,

172 
quicly_loss_on_detect_cb
 
on_loss_detected
);

176 int 
quicly_loss_init_sentmap_iter
(
quicly_loss_t
 *
loss
, 
quicly_sentmap_iter_t
 *
iter
, 
int64_t
 
now
, 
uint32_t
 
max_ack_delay
,

177 int 
is_closing
);

182 static 
int64_t
 
quicly_loss_get_sentmap_expiration_time
(
quicly_loss_t
 *
loss
, 
uint32_t
 
max_ack_delay
);

186 
inline
 void 
quicly_rtt_init
(
quicly_rtt_t
 *
rtt
, const 
quicly_loss_conf_t
 *
conf
, 
uint32_t
 
initial_rtt
)

188 
rtt
->
minimum
 = 
UINT32_MAX
;

189 
rtt
->
latest
 = 0;

190 
rtt
->
smoothed
 = 
initial_rtt
;

191 
rtt
->
variance
 = 
initial_rtt
 / 2;

194 
inline
 void 
quicly_rtt_update
(
quicly_rtt_t
 *
rtt
, 
uint32_t
 
latest_rtt
, uint32_t 
ack_delay
)

196 int 
is_first_sample
 = 
rtt
->
latest
 == 0;

198 
assert
(
latest_rtt
 != 
UINT32_MAX
);

199 
rtt
->
latest
 = 
latest_rtt
 != 0 ? latest_rtt : 1;

202 if (
rtt
->
latest
 < rtt->
minimum
)

203 
rtt
->
minimum
 = rtt->
latest
;

206 if (
rtt
->
latest
 > rtt->
minimum
 + 
ack_delay
)

207 
rtt
->
latest
 -= 
ack_delay
;

210 if (
is_first_sample
) {

211 
rtt
->
smoothed
 = rtt->
latest
;

212 
rtt
->
variance
 = rtt->
latest
 / 2;

214 
uint32_t
 
absdiff
 = 
rtt
->
smoothed
 >= rtt->
latest
 ? rtt->smoothed - rtt->latest : rtt->latest - rtt->smoothed;

215 
rtt
->
variance
 = (rtt->variance * 3 + 
absdiff
) / 4;

216 
rtt
->
smoothed
 = (rtt->smoothed * 7 + rtt->
latest
) / 8;

218 
assert
(
rtt
->
smoothed
 != 0);

221 
inline
 
uint32_t
 
quicly_rtt_get_pto
(
quicly_rtt_t
 *
rtt
, uint32_t 
max_ack_delay
, uint32_t 
min_pto
)

223 return 
rtt
->
smoothed
 + (rtt->
variance
 != 0 ? rtt->variance * 4 : 
min_pto
) + 
max_ack_delay
;

226 
inline
 void 
quicly_loss_init
(
quicly_loss_t
 *
r
, const 
quicly_loss_conf_t
 *
conf
, 
uint32_t
 
initial_rtt
, const 
uint16_t
 *
max_ack_delay
,

227 const 
uint8_t
 *
ack_delay_exponent
)

229 *
r
 = (
quicly_loss_t
){.
conf
 = conf,

230 .
max_ack_delay
 = max_ack_delay,

231 .
ack_delay_exponent
 = ack_delay_exponent,

232 .
pto_count
 = 0,

233 .
time_of_last_packet_sent
 = 0,

234 .
largest_acked_packet_plus1
 = {0},

235 .
total_bytes_sent
 = 0,

236 .
loss_time
 = 
INT64_MAX
,

237 .
alarm_at
 = 
INT64_MAX
};

238 
quicly_rtt_init
(&
r
->
rtt
, 
conf
, 
initial_rtt
);

239 
quicly_sentmap_init
(&
r
->
sentmap
);

242 
inline
 void 
quicly_loss_dispose
(
quicly_loss_t
 *
r
)

244 
quicly_sentmap_dispose
(&
r
->
sentmap
);

247 
inline
 void 
quicly_loss_update_alarm
(
quicly_loss_t
 *
r
, 
int64_t
 
now
, int64_t 
last_retransmittable_sent_at
, int 
has_outstanding
,

248 int 
can_send_stream_data
, int 
handshake_is_in_progress
, 
uint64_t
 
total_bytes_sent
,

249 int 
is_after_send
)

251 if (!
has_outstanding
) {

253 
r
->
alarm_at
 = 
INT64_MAX
;

254 
r
->
loss_time
 = 
INT64_MAX
;

257 
assert
(
last_retransmittable_sent_at
 != 
INT64_MAX
);

259 #define 
	#SET_ALARM
(
t
) \

261 
int64_t
 
_t
 = (
t
); \

262 if (
is_after_send
) { \

263 
	`assert
(
now
 < 
_t
); \

264 } else if (
_t
 < 
now
) { \

265 
_t
 = 
now
; \

267 
r
->
alarm_at
 = 
_t
; \

268 } while (0)

	)

271 if (
r
->
loss_time
 != 
INT64_MAX
) {

272 
SET_ALARM
(
r
->
loss_time
);

277 
int64_t
 
alarm_duration
;

278 
assert
(
r
->
pto_count
 < 63);

290 if (
r
->
conf
->
num_speculative_ptos
 > 0 && r->
pto_count
 <= 0 && !
handshake_is_in_progress
 && !
can_send_stream_data
 &&

291 
r
->
total_bytes_sent
 < total_bytes_sent) {

294 if (
r
->
pto_count
 == 0)

296 
r
->
pto_count
 = -r->
conf
->
num_speculative_ptos
;

297 
r
->
total_bytes_sent
 = total_bytes_sent;

299 if (
r
->
pto_count
 < 0) {

302 
alarm_duration
 = 
quicly_rtt_get_pto
(&
r
->
rtt
, 0, r->
conf
->
min_pto
);

303 
alarm_duration
 >>= -
r
->
pto_count
;

304 if (
alarm_duration
 < 
r
->
conf
->
min_pto
)

305 
alarm_duration
 = 
r
->
conf
->
min_pto
;

309 
alarm_duration
 = 
quicly_rtt_get_pto
(&
r
->
rtt
, 
handshake_is_in_progress
 ? 0 : *r->
max_ack_delay
, r->
conf
->
min_pto
);

310 
alarm_duration
 <<= 
r
->
pto_count
;

312 
SET_ALARM
(
last_retransmittable_sent_at
 + 
alarm_duration
);

314 #undef 
SET_ALARM


317 
inline
 void 
quicly_loss_on_ack_received
(
quicly_loss_t
 *
r
, 
uint64_t
 
largest_newly_acked
, 
size_t
 
epoch
, 
int64_t
 
now
, int64_t 
sent_at
,

318 
uint64_t
 
ack_delay_encoded
, int 
ack_eliciting
)

321 if (
largest_newly_acked
 != 
UINT64_MAX
 && 
r
->
pto_count
 > 0)

322 
r
->
pto_count
 = 0;

325 if (
largest_newly_acked
 == 
UINT64_MAX
 || 
r
->
largest_acked_packet_plus1
[
epoch
] > largest_newly_acked)

327 
r
->
largest_acked_packet_plus1
[
epoch
] = 
largest_newly_acked
 + 1;

330 if (!
ack_eliciting
)

334 
uint64_t
 
ack_delay_microsecs
 = 
ack_delay_encoded
 << *
r
->
ack_delay_exponent
;

335 
uint32_t
 
ack_delay_millisecs
 = (uint32_t)((
ack_delay_microsecs
 * 2 + 1000) / 2000);

337 if (
ack_delay_millisecs
 > *
r
->
max_ack_delay
)

338 
ack_delay_millisecs
 = *
r
->
max_ack_delay
;

339 
quicly_rtt_update
(&
r
->
rtt
, (
uint32_t
)(
now
 - 
sent_at
), 
ack_delay_millisecs
);

342 
inline
 int 
quicly_loss_on_alarm
(
quicly_loss_t
 *
r
, 
int64_t
 
now
, 
uint32_t
 
max_ack_delay
, int 
is_1rtt_only
,

343 
size_t
 *
min_packets_to_send
, int *
restrict_sending
, 
quicly_loss_on_detect_cb
 
on_loss_detected
)

345 
r
->
alarm_at
 = 
INT64_MAX
;

346 *
min_packets_to_send
 = 1;

347 if (
r
->
loss_time
 != 
INT64_MAX
) {

349 *
restrict_sending
 = 0;

350 return 
quicly_loss_detect_loss
(
r
, 
now
, 
max_ack_delay
, 
is_1rtt_only
, 
on_loss_detected
);

353 ++
r
->
pto_count
;

354 *
restrict_sending
 = 1;

355 if (
r
->
pto_count
 > 0)

356 *
min_packets_to_send
 = 2;

361 
inline
 
int64_t
 
quicly_loss_get_sentmap_expiration_time
(
quicly_loss_t
 *
loss
, 
uint32_t
 
max_ack_delay
)

363 return 
quicly_rtt_get_pto
(&
loss
->
rtt
, 
max_ack_delay
, loss->
conf
->
min_pto
) * 4;

366 #ifdef 
__cplusplus


	@include/quicly/maxsender.h

22 #ifndef 
quicly_maxsender_h


23 #define 
	#quicly_maxsender_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<assert.h
>

30 #include 
	~<stddef.h
>

31 #include 
	~<stdint.h
>

32 #include 
	~"quicly/constants.h
"

34 typedef struct 
	sst_quicly_maxsender_t
 {

38 
int64_t
 
max_committed
;

42 
int64_t
 
max_acked
;

46 
size_t
 
num_inflight
;

50 unsigned 
force_send
 : 1;

51 } 
	tquicly_maxsender_t
;

53 typedef struct 
	sst_quicly_maxsender_sent_t
 {

54 
uint64_t
 
inflight
 : 1;

55 
uint64_t
 
value
 : 63;

56 } 
	tquicly_maxsender_sent_t
;

58 static void 
quicly_maxsender_init
(
quicly_maxsender_t
 *
m
, 
int64_t
 
initial_value
);

59 static void 
quicly_maxsender_dispose
(
quicly_maxsender_t
 *
m
);

60 static void 
quicly_maxsender_request_transmit
(
quicly_maxsender_t
 *
m
);

61 static int 
quicly_maxsender_should_send_max
(
quicly_maxsender_t
 *
m
, 
int64_t
 
buffered_from
, 
uint32_t
 
window_size
,

62 
uint32_t
 
update_ratio
);

63 static int 
quicly_maxsender_should_send_blocked
(
quicly_maxsender_t
 *
m
, 
int64_t
 
local_max
);

64 static void 
quicly_maxsender_record
(
quicly_maxsender_t
 *
m
, 
int64_t
 
value
, 
quicly_maxsender_sent_t
 *
sent
);

65 static void 
quicly_maxsender_acked
(
quicly_maxsender_t
 *
m
, 
quicly_maxsender_sent_t
 *
sent
);

66 static void 
quicly_maxsender_lost
(
quicly_maxsender_t
 *
m
, 
quicly_maxsender_sent_t
 *
sent
);

70 
inline
 void 
quicly_maxsender_init
(
quicly_maxsender_t
 *
m
, 
int64_t
 
initial_value
)

72 
m
->
max_committed
 = 
initial_value
;

73 
m
->
max_acked
 = 
initial_value
;

74 
m
->
num_inflight
 = 0;

75 
m
->
force_send
 = 0;

78 
inline
 void 
quicly_maxsender_dispose
(
quicly_maxsender_t
 *
m
)

82 
inline
 void 
quicly_maxsender_request_transmit
(
quicly_maxsender_t
 *
m
)

84 
m
->
force_send
 = 1;

87 
inline
 int 
quicly_maxsender_should_send_max
(
quicly_maxsender_t
 *
m
, 
int64_t
 
buffered_from
, 
uint32_t
 
window_size
,

88 
uint32_t
 
update_ratio
)

90 if (
m
->
force_send
)

94 
int64_t
 
threshold
 = 
buffered_from
 + ((int64_t)
window_size
 * 
update_ratio
) / 1024;

95 return (
m
->
num_inflight
 != 0 ? m->
max_committed
 : m->
max_acked
) <= 
threshold
;

98 
inline
 int 
quicly_maxsender_should_send_blocked
(
quicly_maxsender_t
 *
m
, 
int64_t
 
local_max
)

100 return 
m
->
max_committed
 < 
local_max
;

103 
inline
 void 
quicly_maxsender_record
(
quicly_maxsender_t
 *
m
, 
int64_t
 
value
, 
quicly_maxsender_sent_t
 *
sent
)

105 
assert
(
value
 >= 
m
->
max_committed
);

106 
m
->
max_committed
 = 
value
;

107 ++
m
->
num_inflight
;

108 
m
->
force_send
 = 0;

109 
sent
->
inflight
 = 1;

110 
sent
->
value
 = value;

113 
inline
 void 
quicly_maxsender_acked
(
quicly_maxsender_t
 *
m
, 
quicly_maxsender_sent_t
 *
sent
)

115 if (
m
->
max_acked
 < (
int64_t
)
sent
->
value
)

116 
m
->
max_acked
 = 
sent
->
value
;

118 if (
sent
->
inflight
) {

119 
assert
(
m
->
num_inflight
 != 0);

120 --
m
->
num_inflight
;

121 
sent
->
inflight
 = 0;

125 
inline
 void 
quicly_maxsender_lost
(
quicly_maxsender_t
 *
m
, 
quicly_maxsender_sent_t
 *
sent
)

128 
assert
(
m
->
num_inflight
 != 0);

129 --
m
->
num_inflight
;

130 
sent
->
inflight
 = 0;

133 #ifdef 
__cplusplus


	@include/quicly/ranges.h

22 #ifndef 
quicly_ranges_h


23 #define 
	#quicly_ranges_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<stddef.h
>

30 #include 
	~<stdint.h
>

31 #include 
	~<stdlib.h
>

33 typedef struct 
	sst_quicly_range_t
 {

34 
uint64_t
 
start
;

35 
uint64_t
 
end
;

36 } 
	tquicly_range_t
;

38 typedef struct 
	sst_quicly_ranges_t
 {

39 
quicly_range_t
 *
ranges
;

40 
size_t
 
num_ranges
, 
capacity
;

41 
quicly_range_t
 
_initial
;

42 } 
	tquicly_ranges_t
;

47 static void 
quicly_ranges_init
(
quicly_ranges_t
 *
ranges
);

51 int 
quicly_ranges_init_with_range
(
quicly_ranges_t
 *
ranges
, 
uint64_t
 
start
, uint64_t 
end
);

55 static void 
quicly_ranges_clear
(
quicly_ranges_t
 *
ranges
);

59 int 
quicly_ranges_add
(
quicly_ranges_t
 *
ranges
, 
uint64_t
 
start
, uint64_t 
end
);

63 int 
quicly_ranges_subtract
(
quicly_ranges_t
 *
ranges
, 
uint64_t
 
start
, uint64_t 
end
);

67 void 
quicly_ranges_drop_by_range_indices
(
quicly_ranges_t
 *
ranges
, 
size_t
 
begin_index
, size_t 
end_index
);

71 
inline
 void 
quicly_ranges_init
(
quicly_ranges_t
 *
ranges
)

73 
ranges
->ranges = &ranges->
_initial
;

74 
ranges
->
num_ranges
 = 0;

75 
ranges
->
capacity
 = 1;

78 
inline
 void 
quicly_ranges_clear
(
quicly_ranges_t
 *
ranges
)

80 if (
ranges
->ranges != &ranges->
_initial
) {

81 
free
(
ranges
->ranges);

82 
ranges
->ranges = &ranges->
_initial
;

84 
ranges
->
num_ranges
 = 0;

85 
ranges
->
capacity
 = 1;

88 #ifdef 
__cplusplus


	@include/quicly/recvstate.h

22 #ifndef 
quicly_recvstate_h


23 #define 
	#quicly_recvstate_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<assert.h
>

30 #include 
	~<stddef.h
>

31 #include 
	~"picotls.h
"

32 #include 
	~"quicly/ranges.h
"

34 typedef struct 
	sst_quicly_recvstate_t
 {

38 
quicly_ranges_t
 
received
;

42 
uint64_t
 
data_off
;

46 
uint64_t
 
eos
;

47 } 
	tquicly_recvstate_t
;

49 void 
quicly_recvstate_init
(
quicly_recvstate_t
 *
state
);

50 void 
quicly_recvstate_init_closed
(
quicly_recvstate_t
 *
state
);

51 void 
quicly_recvstate_dispose
(
quicly_recvstate_t
 *
state
);

52 static int 
quicly_recvstate_transfer_complete
(
quicly_recvstate_t
 *
state
);

53 static 
size_t
 
quicly_recvstate_bytes_available
(
quicly_recvstate_t
 *
state
);

59 int 
quicly_recvstate_update
(
quicly_recvstate_t
 *
state
, 
uint64_t
 
off
, 
size_t
 *
len
, int 
is_fin
, size_t 
max_ranges
);

60 int 
quicly_recvstate_reset
(
quicly_recvstate_t
 *
state
, 
uint64_t
 
eos_at
, uint64_t *
bytes_missing
);

64 
inline
 int 
quicly_recvstate_transfer_complete
(
quicly_recvstate_t
 *
state
)

66 return 
state
->
received
.
num_ranges
 == 0;

69 
inline
 
size_t
 
quicly_recvstate_bytes_available
(
quicly_recvstate_t
 *
state
)

71 
uint64_t
 
total
 = 
quicly_recvstate_transfer_complete
(
state
) ? state->
eos
 : state->
received
.
ranges
[0].
end
;

72 
assert
(
state
->
data_off
 <= 
total
);

73 return 
total
 - 
state
->
data_off
;

76 #ifdef 
__cplusplus


	@include/quicly/remote_cid.h

22 #ifndef 
quicly_received_cid_h


23 #define 
	#quicly_received_cid_h


	)

25 #include 
	~"quicly/cid.h
"

27 #ifdef 
__cplusplus


34 typedef struct 
	sst_quicly_remote_cid_t
 {

38 int 
is_active
;

46 
uint64_t
 
sequence
;

50 struct 
st_quicly_cid_t
 
cid
;

54 
uint8_t
 
stateless_reset_token
[
QUICLY_STATELESS_RESET_TOKEN_LEN
];

55 } 
	tquicly_remote_cid_t
;

60 typedef struct 
	sst_quicly_remote_cid_set_t
 {

65 
quicly_remote_cid_t
 
cids
[
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
];

69 
uint64_t
 
_largest_sequence_expected
;

70 } 
	tquicly_remote_cid_set_t
;

77 void 
quicly_remote_cid_init_set
(
quicly_remote_cid_set_t
 *
set
, 
ptls_iovec_t
 *
initial_cid
, void (*
random_bytes
)(void *, 
size_t
));

82 int 
quicly_remote_cid_register
(
quicly_remote_cid_set_t
 *
set
, 
uint64_t
 
sequence
, const 
uint8_t
 *
cid
, 
size_t
 
cid_len
,

83 const 
uint8_t
 
srt
[
QUICLY_STATELESS_RESET_TOKEN_LEN
], 
uint64_t
 
retire_prior_to
,

84 
uint64_t
 
unregistered_seqs
[
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
], 
size_t
 *
num_unregistered_seqs
);

89 int 
quicly_remote_cid_unregister
(
quicly_remote_cid_set_t
 *
set
, 
uint64_t
 
sequence
);

91 #ifdef 
__cplusplus


	@include/quicly/retire_cid.h

22 #ifndef 
quicly_retire_cid_h


23 #define 
	#quicly_retire_cid_h


	)

25 #include 
	~"quicly/cid.h
"

27 #ifdef 
__cplusplus


34 #define 
	#QUICLY_RETIRE_CONNECTION_ID_LIMIT
 (
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
 * 2)

	)

36 typedef struct 
st_quicly_retire_cid_set_t
 
	tquicly_retire_cid_set_t
;

38 struct 
	sst_quicly_retire_cid_set_t
 {

43 
uint64_t
 
sequences
[
QUICLY_RETIRE_CONNECTION_ID_LIMIT
];

47 
size_t
 
_num_pending
;

50 void 
quicly_retire_cid_init
(
quicly_retire_cid_set_t
 *
set
);

51 void 
quicly_retire_cid_push
(
quicly_retire_cid_set_t
 *
set
, 
uint64_t
 
sequence
);

52 void 
quicly_retire_cid_shift
(
quicly_retire_cid_set_t
 *
set
, 
size_t
 
num_shift
);

53 static 
size_t
 
quicly_retire_cid_get_num_pending
(const 
quicly_retire_cid_set_t
 *
set
);

55 
inline
 
size_t
 
quicly_retire_cid_get_num_pending
(const 
quicly_retire_cid_set_t
 *
set
)

57 return 
set
->
_num_pending
;

60 #ifdef 
__cplusplus


	@include/quicly/sendstate.h

22 #ifndef 
quicly_sendstate_h


23 #define 
	#quicly_sendstate_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~"quicly/ranges.h
"

31 typedef struct 
	sst_quicly_sendstate_t
 {

36 
quicly_ranges_t
 
acked
;

40 
quicly_ranges_t
 
pending
;

45 
uint64_t
 
size_inflight
;

49 
uint64_t
 
final_size
;

50 } 
	tquicly_sendstate_t
;

52 typedef struct 
	sst_quicly_sendstate_sent_t
 {

53 
uint64_t
 
start
;

54 
uint64_t
 
end
;

55 } 
	tquicly_sendstate_sent_t
;

57 void 
quicly_sendstate_init
(
quicly_sendstate_t
 *
state
);

58 void 
quicly_sendstate_init_closed
(
quicly_sendstate_t
 *
state
);

59 void 
quicly_sendstate_dispose
(
quicly_sendstate_t
 *
state
);

60 static int 
quicly_sendstate_transfer_complete
(
quicly_sendstate_t
 *
state
);

61 static int 
quicly_sendstate_is_open
(
quicly_sendstate_t
 *
state
);

62 int 
quicly_sendstate_activate
(
quicly_sendstate_t
 *
state
);

63 int 
quicly_sendstate_shutdown
(
quicly_sendstate_t
 *
state
, 
uint64_t
 
final_size
);

64 void 
quicly_sendstate_reset
(
quicly_sendstate_t
 *
state
);

65 int 
quicly_sendstate_acked
(
quicly_sendstate_t
 *
state
, 
quicly_sendstate_sent_t
 *
args
, 
size_t
 *
bytes_to_shift
);

66 int 
quicly_sendstate_lost
(
quicly_sendstate_t
 *
state
, 
quicly_sendstate_sent_t
 *
args
);

70 
inline
 int 
quicly_sendstate_transfer_complete
(
quicly_sendstate_t
 *
state
)

72 return 
state
->
final_size
 != 
UINT64_MAX
 && state->
acked
.
ranges
[0].
end
 == state->final_size + 1;

75 
inline
 int 
quicly_sendstate_is_open
(
quicly_sendstate_t
 *
state
)

77 return 
state
->
final_size
 == 
UINT64_MAX
;

80 #ifdef 
__cplusplus


	@include/quicly/sentmap.h

22 #ifndef 
quicly_sentmap_h


23 #define 
	#quicly_sentmap_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<assert.h
>

30 #include 
	~<stdint.h
>

31 #include 
	~"quicly/constants.h
"

32 #include 
	~"quicly/maxsender.h
"

33 #include 
	~"quicly/sendstate.h
"

35 typedef struct 
st_quicly_sent_t
 
	tquicly_sent_t
;

36 typedef struct 
st_quicly_sentmap_t
 
	tquicly_sentmap_t
;

38 typedef struct 
	sst_quicly_sent_packet_t
 {

42 
uint64_t
 
packet_number
;

46 
int64_t
 
sent_at
;

50 
uint8_t
 
ack_epoch
;

54 
uint8_t
 
ack_eliciting
 : 1;

58 
uint8_t
 
frames_in_flight
 : 1;

62 
uint16_t
 
cc_bytes_in_flight
;

63 } 
	tquicly_sent_packet_t
;

65 typedef enum 
	een_quicly_sentmap_event_t
 {

69 
QUICLY_SENTMAP_EVENT_ACKED
,

73 
QUICLY_SENTMAP_EVENT_PTO
,

77 
QUICLY_SENTMAP_EVENT_LOST
,

81 
QUICLY_SENTMAP_EVENT_EXPIRED


82 } 
	tquicly_sentmap_event_t
;

92 typedef int (*
quicly_sent_acked_cb
)(
	tquicly_sentmap_t
 *
	tmap
, const 
	tquicly_sent_packet_t
 *
	tpacket
, int 
	tacked
, 
	tquicly_sent_t
 *
	tdata
);

94 struct 
	sst_quicly_sent_t
 {

95 
quicly_sent_acked_cb
 
acked
;

97 
quicly_sent_packet_t
 
packet
;

99 
quicly_range_t
 
range
;

100 } 
ack
;

102 
quicly_stream_id_t
 
stream_id
;

103 
quicly_sendstate_sent_t
 
args
;

104 } 
stream
;

106 
quicly_stream_id_t
 
stream_id
;

107 
quicly_maxsender_sent_t
 
args
;

108 } 
max_stream_data
;

110 
quicly_maxsender_sent_t
 
args
;

111 } 
max_data
;

113 int 
uni
;

114 
quicly_maxsender_sent_t
 
args
;

115 } 
max_streams
;

117 
uint64_t
 
offset
;

118 } 
data_blocked
;

120 
quicly_stream_id_t
 
stream_id
;

121 
uint64_t
 
offset
;

122 } 
stream_data_blocked
;

124 int 
uni
;

125 
quicly_maxsender_sent_t
 
args
;

126 } 
streams_blocked
;

128 
quicly_stream_id_t
 
stream_id
;

129 } 
stream_state_sender
;

131 int 
is_inflight
;

132 
uint64_t
 
generation
;

133 } 
new_token
;

135 
uint64_t
 
sequence
;

136 } 
new_connection_id
;

138 
uint64_t
 
sequence
;

139 } 
retire_connection_id
;

140 } 
data
;

143 struct 
	sst_quicly_sent_block_t
 {

147 struct 
st_quicly_sent_block_t
 *
next
;

151 
size_t
 
num_entries
;

155 
size_t
 
next_insert_at
;

159 
quicly_sent_t
 
entries
[16];

181 struct 
	sst_quicly_sentmap_t
 {

185 struct 
st_quicly_sent_block_t
 *
head
, *
tail
;

189 
size_t
 
num_packets
;

193 
size_t
 
bytes_in_flight
;

197 
quicly_sent_t
 *
_pending_packet
;

200 typedef struct 
	sst_quicly_sentmap_iter_t
 {

201 
quicly_sent_t
 *
p
;

202 
size_t
 
count
;

203 struct 
st_quicly_sent_block_t
 **
ref
;

204 } 
	tquicly_sentmap_iter_t
;

206 extern const 
quicly_sent_t
 
quicly_sentmap__end_iter
;

211 static void 
quicly_sentmap_init
(
quicly_sentmap_t
 *
map
);

215 void 
quicly_sentmap_dispose
(
quicly_sentmap_t
 *
map
);

220 static int 
quicly_sentmap_is_open
(
quicly_sentmap_t
 *
map
);

224 int 
quicly_sentmap_prepare
(
quicly_sentmap_t
 *
map
, 
uint64_t
 
packet_number
, 
int64_t
 
now
, 
uint8_t
 
ack_epoch
);

228 static void 
quicly_sentmap_commit
(
quicly_sentmap_t
 *
map
, 
uint16_t
 
bytes_in_flight
);

232 static 
quicly_sent_t
 *
quicly_sentmap_allocate
(
quicly_sentmap_t
 *
map
, 
quicly_sent_acked_cb
 
acked
);

237 static void 
quicly_sentmap_init_iter
(
quicly_sentmap_t
 *
map
, 
quicly_sentmap_iter_t
 *
iter
);

241 static const 
quicly_sent_packet_t
 *
quicly_sentmap_get
(
quicly_sentmap_iter_t
 *
iter
);

245 void 
quicly_sentmap_skip
(
quicly_sentmap_iter_t
 *
iter
);

249 int 
quicly_sentmap_update
(
quicly_sentmap_t
 *
map
, 
quicly_sentmap_iter_t
 *
iter
, 
quicly_sentmap_event_t
 
event
);

251 struct 
st_quicly_sent_block_t
 *
quicly_sentmap__new_block
(
quicly_sentmap_t
 *
map
);

252 int 
quicly_sentmap__type_packet
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
);

256 
inline
 void 
quicly_sentmap_init
(
quicly_sentmap_t
 *
map
)

258 *
	gmap
 = (
quicly_sentmap_t
){
NULL
};

261 
inline
 int 
quicly_sentmap_is_open
(
quicly_sentmap_t
 *
map
)

263 return 
	gmap
->
	g_pending_packet
 != 
NULL
;

266 
inline
 void 
quicly_sentmap_commit
(
quicly_sentmap_t
 *
map
, 
uint16_t
 
bytes_in_flight
)

268 
assert
(
quicly_sentmap_is_open
(
map
));

270 if (
	gbytes_in_flight
 != 0) {

271 
map
->
_pending_packet
->
data
.
packet
.
ack_eliciting
 = 1;

272 
	gmap
->
	g_pending_packet
->
	gdata
.
	gpacket
.
	gcc_bytes_in_flight
 = 
bytes_in_flight
;

273 
	gmap
->
	gbytes_in_flight
 += 
bytes_in_flight
;

275 
	gmap
->
	g_pending_packet
->
	gdata
.
	gpacket
.
	gframes_in_flight
 = 1;

276 
	gmap
->
	g_pending_packet
 = 
NULL
;

278 ++
	gmap
->
	gnum_packets
;

281 
inline
 
quicly_sent_t
 *
quicly_sentmap_allocate
(
quicly_sentmap_t
 *
map
, 
quicly_sent_acked_cb
 
acked
)

283 struct 
st_quicly_sent_block_t
 *
	gblock
;

285 if ((
	gblock
 = 
map
->
tail
) == 
NULL
 || 
block
->
next_insert_at
 == 
PTLS_ELEMENTSOF
(block->
entries
)) {

286 if ((
block
 = 
quicly_sentmap__new_block
(
map
)) == 
NULL
)

287 return 
NULL
;

290 
quicly_sent_t
 *
	gsent
 = 
block
->
entries
 + block->
next_insert_at
++;

291 ++
	gblock
->
	gnum_entries
;

293 
	gsent
->
	gacked
 = 
acked
;

295 return 
	gsent
;

298 
inline
 void 
quicly_sentmap_init_iter
(
quicly_sentmap_t
 *
map
, 
quicly_sentmap_iter_t
 *
iter
)

301 
	giter
->
	gref
 = &
map
->
head
;

302 if (
	gmap
->
	ghead
 != 
NULL
) {

303 
assert
(
map
->
head
->
num_entries
 != 0);

304 for (
	giter
->
	gp
 = 
map
->
head
->
entries
; iter->p->
	gacked
 == 
NULL
; ++iter->p)

306 
assert
(
iter
->
p
->
acked
 == 
quicly_sentmap__type_packet
);

307 
	giter
->
	gcount
 = 
map
->
head
->
num_entries
;

309 
	giter
->
	gp
 = (
quicly_sent_t
 *)&
quicly_sentmap__end_iter
;

310 
	giter
->
	gcount
 = 0;

314 
inline
 const 
quicly_sent_packet_t
 *
quicly_sentmap_get
(
quicly_sentmap_iter_t
 *
iter
)

316 
assert
(
iter
->
p
->
acked
 == 
quicly_sentmap__type_packet
);

317 return &
	giter
->
	gp
->
	gdata
.
	gpacket
;

320 #ifdef 
__cplusplus


	@include/quicly/streambuf.h

22 #ifndef 
quicly_streambuf_h


23 #define 
	#quicly_streambuf_h


	)

25 #ifdef 
__cplusplus


29 #include 
	~<assert.h
>

30 #include 
	~<stddef.h
>

31 #include 
	~<stdint.h
>

32 #include 
	~<string.h
>

33 #include 
	~"picotls.h
"

34 #include 
	~"quicly.h
"

36 typedef struct 
st_quicly_sendbuf_vec_t
 
	tquicly_sendbuf_vec_t
;

45 typedef int (*
quicly_sendbuf_flatten_vec_cb
)(
	tquicly_sendbuf_vec_t
 *
	tvec
, void *
	tdst
, 
	tsize_t
 
	toff
, size_t 
	tlen
);

49 typedef void (*
quicly_sendbuf_discard_vec_cb
)(
	tquicly_sendbuf_vec_t
 *
	tvec
);

51 typedef struct 
	sst_quicly_streambuf_sendvec_callbacks_t
 {

52 
quicly_sendbuf_flatten_vec_cb
 
flatten_vec
;

53 
quicly_sendbuf_discard_vec_cb
 
discard_vec
;

54 } 
	tquicly_streambuf_sendvec_callbacks_t
;

56 struct 
	sst_quicly_sendbuf_vec_t
 {

57 const 
quicly_streambuf_sendvec_callbacks_t
 *
cb
;

58 
size_t
 
len
;

59 void *
cbdata
;

65 typedef struct 
	sst_quicly_sendbuf_t
 {

67 
quicly_sendbuf_vec_t
 *
entries
;

68 
size_t
 
size
, 
capacity
;

69 } 
vecs
;

70 
size_t
 
off_in_first_vec
;

71 
uint64_t
 
bytes_written
;

72 } 
	tquicly_sendbuf_t
;

77 static void 
quicly_sendbuf_init
(
quicly_sendbuf_t
 *
sb
);

81 void 
quicly_sendbuf_dispose
(
quicly_sendbuf_t
 *
sb
);

86 void 
quicly_sendbuf_shift
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_t
 *
sb
, 
size_t
 
delta
);

90 void 
quicly_sendbuf_emit
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_t
 *
sb
, 
size_t
 
off
, void *
dst
, size_t *
len
, int *
wrote_all
);

94 int 
quicly_sendbuf_write
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_t
 *
sb
, const void *
src
, 
size_t
 
len
);

98 int 
quicly_sendbuf_write_vec
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_t
 *
sb
, 
quicly_sendbuf_vec_t
 *
vec
);

103 void 
quicly_recvbuf_shift
(
quicly_stream_t
 *
stream
, 
ptls_buffer_t
 *
rb
, 
size_t
 
delta
);

109 
ptls_iovec_t
 
quicly_recvbuf_get
(
quicly_stream_t
 *
stream
, 
ptls_buffer_t
 *
rb
);

113 int 
quicly_recvbuf_receive
(
quicly_stream_t
 *
stream
, 
ptls_buffer_t
 *
rb
, 
size_t
 
off
, const void *
src
, size_t 
len
);

119 typedef struct 
	sst_quicly_streambuf_t
 {

120 
quicly_sendbuf_t
 
egress
;

121 
ptls_buffer_t
 
ingress
;

122 } 
	tquicly_streambuf_t
;

124 int 
quicly_streambuf_create
(
quicly_stream_t
 *
stream
, 
size_t
 
sz
);

125 void 
quicly_streambuf_destroy
(
quicly_stream_t
 *
stream
, int 
err
);

126 static void 
quicly_streambuf_egress_shift
(
quicly_stream_t
 *
stream
, 
size_t
 
delta
);

127 void 
quicly_streambuf_egress_emit
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, void *
dst
, size_t *
len
, int *
wrote_all
);

128 static int 
quicly_streambuf_egress_write
(
quicly_stream_t
 *
stream
, const void *
src
, 
size_t
 
len
);

129 static int 
quicly_streambuf_egress_write_vec
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_vec_t
 *
vec
);

130 int 
quicly_streambuf_egress_shutdown
(
quicly_stream_t
 *
stream
);

131 static void 
quicly_streambuf_ingress_shift
(
quicly_stream_t
 *
stream
, 
size_t
 
delta
);

132 static 
ptls_iovec_t
 
quicly_streambuf_ingress_get
(
quicly_stream_t
 *
stream
);

138 int 
quicly_streambuf_ingress_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
);

142 
inline
 void 
quicly_sendbuf_init
(
quicly_sendbuf_t
 *
sb
)

144 
memset
(
sb
, 0, sizeof(*sb));

147 
inline
 void 
quicly_streambuf_egress_shift
(
quicly_stream_t
 *
stream
, 
size_t
 
delta
)

149 
quicly_streambuf_t
 *
sbuf
 = (quicly_streambuf_t *)
stream
->
data
;

150 
quicly_sendbuf_shift
(
stream
, &
sbuf
->
egress
, 
delta
);

153 
inline
 int 
quicly_streambuf_egress_write
(
quicly_stream_t
 *
stream
, const void *
src
, 
size_t
 
len
)

155 
quicly_streambuf_t
 *
sbuf
 = (quicly_streambuf_t *)
stream
->
data
;

156 return 
quicly_sendbuf_write
(
stream
, &
sbuf
->
egress
, 
src
, 
len
);

159 
inline
 int 
quicly_streambuf_egress_write_vec
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_vec_t
 *
vec
)

161 
quicly_streambuf_t
 *
sbuf
 = (quicly_streambuf_t *)
stream
->
data
;

162 return 
quicly_sendbuf_write_vec
(
stream
, &
sbuf
->
egress
, 
vec
);

165 
inline
 void 
quicly_streambuf_ingress_shift
(
quicly_stream_t
 *
stream
, 
size_t
 
delta
)

167 
quicly_streambuf_t
 *
sbuf
 = (quicly_streambuf_t *)
stream
->
data
;

168 
quicly_recvbuf_shift
(
stream
, &
sbuf
->
ingress
, 
delta
);

171 
inline
 
ptls_iovec_t
 
quicly_streambuf_ingress_get
(
quicly_stream_t
 *
stream
)

173 
quicly_streambuf_t
 *
sbuf
 = (quicly_streambuf_t *)
stream
->
data
;

174 return 
quicly_recvbuf_get
(
stream
, &
sbuf
->
ingress
);

177 #ifdef 
__cplusplus


	@lib/cc-cubic.c

23 #include 
	~<math.h
>

24 #include 
	~"quicly/cc.h
"

25 #include 
	~"quicly.h
"

27 #define 
	#QUICLY_MIN_CWND
 2

	)

29 typedef double 
	tcubic_float_t
;

30 #define 
	#QUICLY_CUBIC_C
 ((
cubic_float_t
)0.4)

	)

31 #define 
	#QUICLY_CUBIC_BETA
 ((
cubic_float_t
)0.7)

	)

34 static 
cubic_float_t
 
	$calc_cubic_t
(const 
quicly_cc_t
 *
cc
, 
int64_t
 
now
)

36 
cubic_float_t
 
clock_delta
 = 
now
 - 
cc
->
state
.
cubic
.
avoidance_start
;

37 return 
clock_delta
 / 1000;

38 
	}
}

41 static 
uint32_t
 
	$calc_w_cubic
(const 
quicly_cc_t
 *
cc
, 
cubic_float_t
 
t_sec
, 
uint32_t
 
max_udp_payload_size
)

43 
cubic_float_t
 
tk
 = 
t_sec
 - 
cc
->
state
.
cubic
.
k
;

44 return (
QUICLY_CUBIC_C
 * (
tk
 * tk * tk) * 
max_udp_payload_size
) + 
cc
->
state
.
cubic
.
w_max
;

45 
	}
}

49 static void 
	$update_cubic_k
(
quicly_cc_t
 *
cc
, 
uint32_t
 
max_udp_payload_size
)

51 
cubic_float_t
 
w_max_mss
 = 
cc
->
state
.
cubic
.
w_max
 / (cubic_float_t)
max_udp_payload_size
;

52 
cc
->
state
.
cubic
.
k
 = 
	`cbrt
(
w_max_mss
 * ((1 - 
QUICLY_CUBIC_BETA
) / 
QUICLY_CUBIC_C
));

53 
	}
}

56 static 
uint32_t
 
	$calc_w_est
(const 
quicly_cc_t
 *
cc
, 
cubic_float_t
 
t_sec
, cubic_float_t 
rtt_sec
, 
uint32_t
 
max_udp_payload_size
)

58 return (
cc
->
state
.
cubic
.
w_max
 * 
QUICLY_CUBIC_BETA
) +

59 ((3 * (1 - 
QUICLY_CUBIC_BETA
) / (1 + QUICLY_CUBIC_BETA)) * (
t_sec
 / 
rtt_sec
) * 
max_udp_payload_size
);

60 
	}
}

63 static void 
	$cubic_on_acked
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
uint64_t
 
largest_acked
, uint32_t 
inflight
,

64 
int64_t
 
now
, 
uint32_t
 
max_udp_payload_size
)

66 
	`assert
(
inflight
 >= 
bytes
);

68 if (
largest_acked
 < 
cc
->
recovery_end
)

72 if (
cc
->
cwnd
 < cc->
ssthresh
) {

73 
cc
->
cwnd
 += 
bytes
;

74 if (
cc
->
cwnd_maximum
 < cc->
cwnd
)

75 
cc
->
cwnd_maximum
 = cc->
cwnd
;

80 
cubic_float_t
 
t_sec
 = 
	`calc_cubic_t
(
cc
, 
now
);

81 
cubic_float_t
 
rtt_sec
 = 
loss
->
rtt
.
smoothed
 / (cubic_float_t)1000;

83 
uint32_t
 
w_cubic
 = 
	`calc_w_cubic
(
cc
, 
t_sec
, 
max_udp_payload_size
);

84 
uint32_t
 
w_est
 = 
	`calc_w_est
(
cc
, 
t_sec
, 
rtt_sec
, 
max_udp_payload_size
);

86 if (
w_cubic
 < 
w_est
) {

89 if (
w_est
 > 
cc
->
cwnd
)

90 
cc
->
cwnd
 = 
w_est
;

93 
cubic_float_t
 
w_cubic_target
 = 
	`calc_w_cubic
(
cc
, 
t_sec
 + 
rtt_sec
, 
max_udp_payload_size
);

96 if (
w_cubic_target
 > 
cc
->
cwnd
)

98 
cc
->
cwnd
 += ((
w_cubic_target
 / cc->cwnd) - 1) * 
max_udp_payload_size
;

101 if (
cc
->
cwnd_maximum
 < cc->
cwnd
)

102 
cc
->
cwnd_maximum
 = cc->
cwnd
;

103 
	}
}

105 static void 
	$cubic_on_lost
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
uint64_t
 
lost_pn
, uint64_t 
next_pn
,

106 
int64_t
 
now
, 
uint32_t
 
max_udp_payload_size
)

109 if (
lost_pn
 < 
cc
->
recovery_end
)

111 
cc
->
recovery_end
 = 
next_pn
;

113 ++
cc
->
num_loss_episodes
;

114 if (
cc
->
cwnd_exiting_slow_start
 == 0)

115 
cc
->
cwnd_exiting_slow_start
 = cc->
cwnd
;

117 
cc
->
state
.
cubic
.
avoidance_start
 = 
now
;

118 
cc
->
state
.
cubic
.
w_max
 = cc->
cwnd
;

122 if (
cc
->
state
.
cubic
.
w_max
 < cc->state.cubic.
w_last_max
) {

123 
cc
->
state
.
cubic
.
w_last_max
 = cc->state.cubic.
w_max
;

124 
cc
->
state
.
cubic
.
w_max
 *= (1.0 + 
QUICLY_CUBIC_BETA
) / 2.0;

126 
cc
->
state
.
cubic
.
w_last_max
 = cc->state.cubic.
w_max
;

128 
	`update_cubic_k
(
cc
, 
max_udp_payload_size
);

131 
cc
->
cwnd
 *= 
QUICLY_CUBIC_BETA
;

132 if (
cc
->
cwnd
 < 
QUICLY_MIN_CWND
 * 
max_udp_payload_size
)

133 
cc
->
cwnd
 = 
QUICLY_MIN_CWND
 * 
max_udp_payload_size
;

134 
cc
->
ssthresh
 = cc->
cwnd
;

136 if (
cc
->
cwnd_minimum
 > cc->
cwnd
)

137 
cc
->
cwnd_minimum
 = cc->
cwnd
;

138 
	}
}

140 static void 
	$cubic_on_persistent_congestion
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
int64_t
 
now
)

143 
	}
}

145 static void 
	$cubic_on_sent
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
int64_t
 
now
)

151 if (
loss
->
sentmap
.
bytes_in_flight
 <= 
bytes
 && 
cc
->
state
.
cubic
.
avoidance_start
 != 0 && cc->state.cubic.
last_sent_time
 != 0) {

152 
int64_t
 
delta
 = 
now
 - 
cc
->
state
.
cubic
.
last_sent_time
;

153 if (
delta
 > 0)

154 
cc
->
state
.
cubic
.
avoidance_start
 += 
delta
;

157 
cc
->
state
.
cubic
.
last_sent_time
 = 
now
;

158 
	}
}

160 static void 
	$cubic_reset
(
quicly_cc_t
 *
cc
, 
uint32_t
 
initcwnd
)

162 
	`memset
(
cc
, 0, sizeof(
quicly_cc_t
));

163 
cc
->
type
 = &
quicly_cc_type_cubic
;

164 
cc
->
cwnd
 = cc->
cwnd_initial
 = cc->
cwnd_maximum
 = 
initcwnd
;

165 
cc
->
ssthresh
 = cc->
cwnd_minimum
 = 
UINT32_MAX
;

166 
	}
}

168 static int 
	$cubic_on_switch
(
quicly_cc_t
 *
cc
)

170 if (
cc
->
type
 == &
quicly_cc_type_cubic
)

173 if (
cc
->
type
 == &
quicly_cc_type_reno
 || cc->type == &
quicly_cc_type_pico
) {

175 if (
cc
->
cwnd_exiting_slow_start
 == 0) {

176 
cc
->
type
 = &
quicly_cc_type_cubic
;

178 
	`cubic_reset
(
cc
, cc->
cwnd_initial
);

184 
	}
}

186 static void 
	$cubic_init
(
quicly_init_cc_t
 *
self
, 
quicly_cc_t
 *
cc
, 
uint32_t
 
initcwnd
, 
int64_t
 
now
)

188 
	`cubic_reset
(
cc
, 
initcwnd
);

189 
	}
}

191 
quicly_cc_type_t
 
	gquicly_cc_type_cubic
 = {

192 "cubic", &
quicly_cc_cubic_init
, 
cubic_on_acked
, 
cubic_on_lost
, 
cubic_on_persistent_congestion
, 
cubic_on_sent
, 
cubic_on_switch
};

193 
quicly_init_cc_t
 
	gquicly_cc_cubic_init
 = {
cubic_init
};

	@lib/cc-pico.c

22 #include 
	~"quicly/cc.h
"

23 #include 
	~"quicly.h
"

28 #define 
	#QUICLY_PICO_MULT_HZ
 1.0

	)

30 static 
uint32_t
 
	$calc_bytes_per_mtu_increase
(
uint32_t
 
cwnd
, uint32_t 
ssthresh
, uint32_t 
rtt
, uint32_t 
mtu
)

33 double 
increase_per_byte
 = (double)
mtu
 / 
cwnd
;

36 if (
cwnd
 < 
ssthresh
) {

37 
increase_per_byte
 += 1;

39 
increase_per_byte
 += (1 / 
QUICLY_RENO_BETA
 - 1) * 
QUICLY_PICO_MULT_HZ
 / 1000 * 
rtt
;

42 return (
uint32_t
)(
mtu
 / 
increase_per_byte
);

43 
	}
}

46 static void 
	$pico_on_acked
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
uint64_t
 
largest_acked
, uint32_t 
inflight
,

47 
int64_t
 
now
, 
uint32_t
 
max_udp_payload_size
)

49 
	`assert
(
inflight
 >= 
bytes
);

52 if (
largest_acked
 < 
cc
->
recovery_end
)

55 
cc
->
state
.
reno
.
stash
 += 
bytes
;

58 
uint32_t
 
bytes_per_mtu_increase
 = 
	`calc_bytes_per_mtu_increase
(
cc
->
cwnd
, cc->
ssthresh
, 
loss
->
rtt
.
smoothed
, 
max_udp_payload_size
);

61 if (
cc
->
state
.
reno
.
stash
 < 
bytes_per_mtu_increase
)

65 
uint32_t
 
count
 = 
cc
->
state
.
reno
.
stash
 / 
bytes_per_mtu_increase
;

66 
cc
->
cwnd
 += 
count
 * 
max_udp_payload_size
;

67 
cc
->
state
.
reno
.
stash
 -= 
count
 * 
bytes_per_mtu_increase
;

69 if (
cc
->
cwnd_maximum
 < cc->
cwnd
)

70 
cc
->
cwnd_maximum
 = cc->
cwnd
;

71 
	}
}

73 static int 
	$pico_on_switch
(
quicly_cc_t
 *
cc
)

76 if (!
quicly_cc_type_reno
.
	`cc_switch
(
cc
))

78 
cc
->
type
 = &
quicly_cc_type_pico
;

80 
	}
}

82 static void 
	$pico_init
(
quicly_init_cc_t
 *
self
, 
quicly_cc_t
 *
cc
, 
uint32_t
 
initcwnd
, 
int64_t
 
now
)

84 
quicly_cc_type_reno
.
cc_init
->
	`cb
(quicly_cc_type_reno.cc_init, 
cc
, 
initcwnd
, 
now
);

85 
cc
->
type
 = &
quicly_cc_type_pico
;

86 
	}
}

88 
quicly_cc_type_t
 
	gquicly_cc_type_pico
 = {"pico",

89 &
quicly_cc_pico_init
,

90 
pico_on_acked
,

91 
quicly_cc_reno_on_lost
,

92 
quicly_cc_reno_on_persistent_congestion
,

93 
quicly_cc_reno_on_sent
,

94 
pico_on_switch
};

95 
quicly_init_cc_t
 
	gquicly_cc_pico_init
 = {
pico_init
};

	@lib/cc-reno.c

22 #include 
	~"quicly/cc.h
"

23 #include 
	~"quicly.h
"

26 static void 
	$reno_on_acked
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
uint64_t
 
largest_acked
, uint32_t 
inflight
,

27 
int64_t
 
now
, 
uint32_t
 
max_udp_payload_size
)

29 
	`assert
(
inflight
 >= 
bytes
);

31 if (
largest_acked
 < 
cc
->
recovery_end
)

35 if (
cc
->
cwnd
 < cc->
ssthresh
) {

36 
cc
->
cwnd
 += 
bytes
;

37 if (
cc
->
cwnd_maximum
 < cc->
cwnd
)

38 
cc
->
cwnd_maximum
 = cc->
cwnd
;

42 
cc
->
state
.
reno
.
stash
 += 
bytes
;

43 if (
cc
->
state
.
reno
.
stash
 < cc->
cwnd
)

46 
uint32_t
 
count
 = 
cc
->
state
.
reno
.
stash
 / cc->
cwnd
;

47 
cc
->
state
.
reno
.
stash
 -= 
count
 * cc->
cwnd
;

48 
cc
->
cwnd
 += 
count
 * 
max_udp_payload_size
;

49 if (
cc
->
cwnd_maximum
 < cc->
cwnd
)

50 
cc
->
cwnd_maximum
 = cc->
cwnd
;

51 
	}
}

53 void 
	$quicly_cc_reno_on_lost
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
uint64_t
 
lost_pn
, uint64_t 
next_pn
,

54 
int64_t
 
now
, 
uint32_t
 
max_udp_payload_size
)

57 if (
lost_pn
 < 
cc
->
recovery_end
)

59 
cc
->
recovery_end
 = 
next_pn
;

61 ++
cc
->
num_loss_episodes
;

62 if (
cc
->
cwnd_exiting_slow_start
 == 0)

63 
cc
->
cwnd_exiting_slow_start
 = cc->
cwnd
;

66 
cc
->
cwnd
 *= 
QUICLY_RENO_BETA
;

67 if (
cc
->
cwnd
 < 
QUICLY_MIN_CWND
 * 
max_udp_payload_size
)

68 
cc
->
cwnd
 = 
QUICLY_MIN_CWND
 * 
max_udp_payload_size
;

69 
cc
->
ssthresh
 = cc->
cwnd
;

71 if (
cc
->
cwnd_minimum
 > cc->
cwnd
)

72 
cc
->
cwnd_minimum
 = cc->
cwnd
;

73 
	}
}

75 void 
	$quicly_cc_reno_on_persistent_congestion
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
int64_t
 
now
)

78 
	}
}

80 void 
	$quicly_cc_reno_on_sent
(
quicly_cc_t
 *
cc
, const 
quicly_loss_t
 *
loss
, 
uint32_t
 
bytes
, 
int64_t
 
now
)

83 
	}
}

85 static void 
	$reno_reset
(
quicly_cc_t
 *
cc
, 
uint32_t
 
initcwnd
)

87 
	`memset
(
cc
, 0, sizeof(
quicly_cc_t
));

88 
cc
->
type
 = &
quicly_cc_type_reno
;

89 
cc
->
cwnd
 = cc->
cwnd_initial
 = cc->
cwnd_maximum
 = 
initcwnd
;

90 
cc
->
ssthresh
 = cc->
cwnd_minimum
 = 
UINT32_MAX
;

91 
	}
}

93 static int 
	$reno_on_switch
(
quicly_cc_t
 *
cc
)

95 if (
cc
->
type
 == &
quicly_cc_type_reno
) {

97 } else if (
cc
->
type
 == &
quicly_cc_type_pico
) {

98 
cc
->
type
 = &
quicly_cc_type_reno
;

100 } else if (
cc
->
type
 == &
quicly_cc_type_cubic
) {

102 if (
cc
->
cwnd_exiting_slow_start
 == 0) {

103 
cc
->
type
 = &
quicly_cc_type_reno
;

105 
	`reno_reset
(
cc
, cc->
cwnd_initial
);

111 
	}
}

113 static void 
	$reno_init
(
quicly_init_cc_t
 *
self
, 
quicly_cc_t
 *
cc
, 
uint32_t
 
initcwnd
, 
int64_t
 
now
)

115 
	`reno_reset
(
cc
, 
initcwnd
);

116 
	}
}

118 
quicly_cc_type_t
 
	gquicly_cc_type_reno
 = {"reno",

119 &
quicly_cc_reno_init
,

120 
reno_on_acked
,

121 
quicly_cc_reno_on_lost
,

122 
quicly_cc_reno_on_persistent_congestion
,

123 
quicly_cc_reno_on_sent
,

124 
reno_on_switch
};

125 
quicly_init_cc_t
 
	gquicly_cc_reno_init
 = {
reno_init
};

127 
quicly_cc_type_t
 *
	gquicly_cc_all_types
[] = {&
quicly_cc_type_reno
, &
quicly_cc_type_cubic
, &
quicly_cc_type_pico
, 
NULL
};

129 
uint32_t
 
	$quicly_cc_calc_initial_cwnd
(
uint32_t
 
max_packets
, 
uint16_t
 
max_udp_payload_size
)

131 static const 
uint32_t
 
mtu_max
 = 1472;

134 if (
max_packets
 < 
QUICLY_MIN_CWND
)

135 
max_packets
 = 
QUICLY_MIN_CWND
;

136 if (
max_udp_payload_size
 > 
mtu_max
)

137 
max_udp_payload_size
 = 
mtu_max
;

139 return 
max_packets
 * 
max_udp_payload_size
;

140 
	}
}

	@lib/defaults.c

22 #include 
	~<sys/time.h
>

23 #include 
	~"quicly/defaults.h
"

25 #define 
	#DEFAULT_INITIAL_EGRESS_MAX_UDP_PAYLOAD_SIZE
 1280

	)

26 #define 
	#DEFAULT_MAX_UDP_PAYLOAD_SIZE
 1472

	)

27 #define 
	#DEFAULT_MAX_PACKETS_PER_KEY
 16777216

	)

28 #define 
	#DEFAULT_MAX_CRYPTO_BYTES
 65536

	)

29 #define 
	#DEFAULT_INITCWND_PACKETS
 10

	)

30 #define 
	#DEFAULT_PRE_VALIDATION_AMPLIFICATION_LIMIT
 3

	)

33 const 
quicly_context_t
 
	gquicly_spec_context
 = {
NULL
,

34 
DEFAULT_INITIAL_EGRESS_MAX_UDP_PAYLOAD_SIZE
,

35 
QUICLY_LOSS_SPEC_CONF
,

41 
DEFAULT_MAX_UDP_PAYLOAD_SIZE
},

42 
DEFAULT_MAX_PACKETS_PER_KEY
,

43 
DEFAULT_MAX_CRYPTO_BYTES
,

44 
DEFAULT_INITCWND_PACKETS
,

45 
QUICLY_PROTOCOL_VERSION_CURRENT
,

46 
DEFAULT_PRE_VALIDATION_AMPLIFICATION_LIMIT
,

48 
NULL
,

49 
NULL
,

50 &
quicly_default_stream_scheduler
,

51 
NULL
,

52 
NULL
,

53 &
quicly_default_now
,

54 
NULL
,

55 
NULL
,

56 &
quicly_default_crypto_engine
,

57 &
quicly_default_init_cc
};

60 const 
quicly_context_t
 
	gquicly_performant_context
 = {
NULL
,

61 
DEFAULT_INITIAL_EGRESS_MAX_UDP_PAYLOAD_SIZE
,

62 
QUICLY_LOSS_PERFORMANT_CONF
,

68 
DEFAULT_MAX_UDP_PAYLOAD_SIZE
},

69 
DEFAULT_MAX_PACKETS_PER_KEY
,

70 
DEFAULT_MAX_CRYPTO_BYTES
,

71 
DEFAULT_INITCWND_PACKETS
,

72 
QUICLY_PROTOCOL_VERSION_CURRENT
,

73 
DEFAULT_PRE_VALIDATION_AMPLIFICATION_LIMIT
,

75 
NULL
,

76 
NULL
,

77 &
quicly_default_stream_scheduler
,

78 
NULL
,

79 
NULL
,

80 &
quicly_default_now
,

81 
NULL
,

82 
NULL
,

83 &
quicly_default_crypto_engine
,

84 &
quicly_default_init_cc
};

90 struct 
	sst_quicly_default_encrypt_cid_t
 {

91 
quicly_cid_encryptor_t
 
	msuper
;

92 
ptls_cipher_context_t
 *
	mcid_encrypt_ctx
, *
	mcid_decrypt_ctx
, *
	mreset_token_ctx
;

95 static void 
	$generate_reset_token
(struct 
st_quicly_default_encrypt_cid_t
 *
self
, void *
token
, const void *
cid
)

97 
uint8_t
 
expandbuf
[
QUICLY_STATELESS_RESET_TOKEN_LEN
];

99 
	`assert
(
self
->
reset_token_ctx
->
algo
->
block_size
 == 
QUICLY_STATELESS_RESET_TOKEN_LEN
);

102 if (
self
->
cid_encrypt_ctx
->
algo
->
block_size
 != 
QUICLY_STATELESS_RESET_TOKEN_LEN
) {

103 
	`assert
(
self
->
cid_encrypt_ctx
->
algo
->
block_size
 < 
QUICLY_STATELESS_RESET_TOKEN_LEN
);

104 
	`memset
(
expandbuf
, 0, sizeof(expandbuf));

105 
	`memcpy
(
expandbuf
, 
cid
, 
self
->
cid_encrypt_ctx
->
algo
->
block_size
);

106 
cid
 = 
expandbuf
;

110 
	`ptls_cipher_encrypt
(
self
->
reset_token_ctx
, 
token
, 
cid
, 
QUICLY_STATELESS_RESET_TOKEN_LEN
);

111 
	}
}

113 static void 
	$default_encrypt_cid
(
quicly_cid_encryptor_t
 *
_self
, 
quicly_cid_t
 *
encrypted
, void *
reset_token
,

114 const 
quicly_cid_plaintext_t
 *
plaintext
)

116 struct 
st_quicly_default_encrypt_cid_t
 *
self
 = (void *)
_self
;

117 
uint8_t
 
buf
[16], *
p
;

120 
p
 = 
buf
;

121 switch (
self
->
cid_encrypt_ctx
->
algo
->
block_size
) {

125 
p
 = 
	`quicly_encode64
(p, 
plaintext
->
node_id
);

128 
	`assert
(!"unexpected block size");

131 
p
 = 
	`quicly_encode32
(p, 
plaintext
->
master_id
);

132 
p
 = 
	`quicly_encode32
(p, (
plaintext
->
thread_id
 << 8) | plaintext->
path_id
);

133 
	`assert
(
p
 - 
buf
 == 
self
->
cid_encrypt_ctx
->
algo
->
block_size
);

136 
	`ptls_cipher_encrypt
(
self
->
cid_encrypt_ctx
, 
encrypted
->
cid
, 
buf
, self->cid_encrypt_ctx->
algo
->
block_size
);

137 
encrypted
->
len
 = 
self
->
cid_encrypt_ctx
->
algo
->
block_size
;

140 if (
reset_token
 != 
NULL
)

141 
	`generate_reset_token
(
self
, 
reset_token
, 
encrypted
->
cid
);

142 
	}
}

144 static 
size_t
 
	$default_decrypt_cid
(
quicly_cid_encryptor_t
 *
_self
, 
quicly_cid_plaintext_t
 *
plaintext
, const void *
encrypted
,

145 
size_t
 
len
)

147 struct 
st_quicly_default_encrypt_cid_t
 *
self
 = (void *)
_self
;

148 
uint8_t
 
ptbuf
[16];

149 const 
uint8_t
 *
p
;

151 if (
len
 != 0) {

153 if (
len
 != 
self
->
cid_decrypt_ctx
->
algo
->
block_size
)

154 return 
SIZE_MAX
;

157 
len
 = 
self
->
cid_decrypt_ctx
->
algo
->
block_size
;

161 
	`ptls_cipher_encrypt
(
self
->
cid_decrypt_ctx
, 
ptbuf
, 
encrypted
, 
len
);

164 
p
 = 
ptbuf
;

165 if (
len
 == 16) {

166 
plaintext
->
node_id
 = 
	`quicly_decode64
(&
p
);

168 
plaintext
->
node_id
 = 0;

170 
plaintext
->
master_id
 = 
	`quicly_decode32
(&
p
);

171 
plaintext
->
thread_id
 = 
	`quicly_decode24
(&
p
);

172 
plaintext
->
path_id
 = *
p
++;

173 
	`assert
(
p
 - 
ptbuf
 == 
len
);

175 return 
len
;

176 
	}
}

178 static int 
	$default_generate_reset_token
(
quicly_cid_encryptor_t
 *
_self
, void *
token
, const void *
cid
)

180 struct 
st_quicly_default_encrypt_cid_t
 *
self
 = (void *)
_self
;

181 
	`generate_reset_token
(
self
, 
token
, 
cid
);

183 
	}
}

185 
quicly_cid_encryptor_t
 *
	$quicly_new_default_cid_encryptor
(
ptls_cipher_algorithm_t
 *
cid_cipher
,

186 
ptls_cipher_algorithm_t
 *
reset_token_cipher
, 
ptls_hash_algorithm_t
 *
hash
,

187 
ptls_iovec_t
 
key
)

189 struct 
st_quicly_default_encrypt_cid_t
 *
self
;

190 
uint8_t
 
digestbuf
[
PTLS_MAX_DIGEST_SIZE
], 
keybuf
[
PTLS_MAX_SECRET_SIZE
];

192 
	`assert
(
cid_cipher
->
block_size
 == 8 || cid_cipher->block_size == 16);

193 
	`assert
(
reset_token_cipher
->
block_size
 == 16);

195 if (
key
.
len
 > 
hash
->
block_size
) {

196 
	`ptls_calc_hash
(
hash
, 
digestbuf
, 
key
.
base
, key.
len
);

197 
key
 = 
	`ptls_iovec_init
(
digestbuf
, 
hash
->
digest_size
);

200 if ((
self
 = 
	`malloc
(sizeof(*self))) == 
NULL
)

201 goto 
Fail
;

202 *
self
 = (struct 
st_quicly_default_encrypt_cid_t
){{
default_encrypt_cid
, 
default_decrypt_cid
, 
default_generate_reset_token
}};

204 if (
	`ptls_hkdf_expand_label
(
hash
, 
keybuf
, 
cid_cipher
->
key_size
, 
key
, "cid", 
	`ptls_iovec_init
(
NULL
, 0), "") != 0)

205 goto 
Fail
;

206 if ((
self
->
cid_encrypt_ctx
 = 
	`ptls_cipher_new
(
cid_cipher
, 1, 
keybuf
)) == 
NULL
)

207 goto 
Fail
;

208 if ((
self
->
cid_decrypt_ctx
 = 
	`ptls_cipher_new
(
cid_cipher
, 0, 
keybuf
)) == 
NULL
)

209 goto 
Fail
;

210 if (
	`ptls_hkdf_expand_label
(
hash
, 
keybuf
, 
reset_token_cipher
->
key_size
, 
key
, "reset", 
	`ptls_iovec_init
(
NULL
, 0), "") != 0)

211 goto 
Fail
;

212 if ((
self
->
reset_token_ctx
 = 
	`ptls_cipher_new
(
reset_token_cipher
, 1, 
keybuf
)) == 
NULL
)

213 goto 
Fail
;

215 
	`ptls_clear_memory
(
digestbuf
, sizeof(digestbuf));

216 
	`ptls_clear_memory
(
keybuf
, sizeof(keybuf));

217 return &
self
->
super
;

219 
Fail
:

220 if (
self
 != 
NULL
) {

221 if (
self
->
cid_encrypt_ctx
 != 
NULL
)

222 
	`ptls_cipher_free
(
self
->
cid_encrypt_ctx
);

223 if (
self
->
cid_decrypt_ctx
 != 
NULL
)

224 
	`ptls_cipher_free
(
self
->
cid_decrypt_ctx
);

225 if (
self
->
reset_token_ctx
 != 
NULL
)

226 
	`ptls_cipher_free
(
self
->
reset_token_ctx
);

227 
	`free
(
self
);

229 
	`ptls_clear_memory
(
digestbuf
, sizeof(digestbuf));

230 
	`ptls_clear_memory
(
keybuf
, sizeof(keybuf));

231 return 
NULL
;

232 
	}
}

234 void 
	$quicly_free_default_cid_encryptor
(
quicly_cid_encryptor_t
 *
_self
)

236 struct 
st_quicly_default_encrypt_cid_t
 *
self
 = (void *)
_self
;

238 
	`ptls_cipher_free
(
self
->
cid_encrypt_ctx
);

239 
	`ptls_cipher_free
(
self
->
cid_decrypt_ctx
);

240 
	`ptls_cipher_free
(
self
->
reset_token_ctx
);

241 
	`free
(
self
);

242 
	}
}

247 static int 
	$default_stream_scheduler_can_send
(
quicly_stream_scheduler_t
 *
self
, 
quicly_conn_t
 *
conn
, int 
conn_is_saturated
)

249 struct 
st_quicly_default_scheduler_state_t
 *
sched
 = &((struct 
_st_quicly_conn_public_t
 *)
conn
)->
_default_scheduler
;

251 if (!
conn_is_saturated
) {

253 
	`quicly_linklist_insert_list
(&
sched
->
active
, &sched->
blocked
);

261 while (
	`quicly_linklist_is_linked
(&
sched
->
active
)) {

262 
quicly_stream_t
 *
stream
 =

263 (void *)((char *)
sched
->
active
.
next
 - 
	`offsetof
(
quicly_stream_t
, 
_send_aux
.
pending_link
.
default_scheduler
));

264 if (
	`quicly_stream_can_send
(
stream
, 0))

266 
	`quicly_linklist_unlink
(&
stream
->
_send_aux
.
pending_link
.
default_scheduler
);

267 
	`quicly_linklist_insert
(
sched
->
blocked
.
prev
, &
stream
->
_send_aux
.
pending_link
.
default_scheduler
);

272 return 
	`quicly_linklist_is_linked
(&
sched
->
active
);

273 
	}
}

275 static void 
	$link_stream
(struct 
st_quicly_default_scheduler_state_t
 *
sched
, 
quicly_stream_t
 *
stream
, int 
conn_is_blocked
)

277 if (!
	`quicly_linklist_is_linked
(&
stream
->
_send_aux
.
pending_link
.
default_scheduler
)) {

278 
quicly_linklist_t
 *
slot
 = &
sched
->
active
;

279 if (
conn_is_blocked
 && !
	`quicly_stream_can_send
(
stream
, 0))

280 
slot
 = &
sched
->
blocked
;

281 
	`quicly_linklist_insert
(
slot
->
prev
, &
stream
->
_send_aux
.
pending_link
.
default_scheduler
);

283 
	}
}

288 static int 
	$default_stream_scheduler_do_send
(
quicly_stream_scheduler_t
 *
self
, 
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
)

290 struct 
st_quicly_default_scheduler_state_t
 *
sched
 = &((struct 
_st_quicly_conn_public_t
 *)
conn
)->
_default_scheduler
;

291 int 
conn_is_blocked
 = 
	`quicly_is_blocked
(
conn
), 
ret
 = 0;

293 if (!
conn_is_blocked
)

294 
	`quicly_linklist_insert_list
(&
sched
->
active
, &sched->
blocked
);

296 while (
	`quicly_can_send_data
((
quicly_conn_t
 *)
conn
, 
s
) && 
	`quicly_linklist_is_linked
(&
sched
->
active
)) {

298 
quicly_stream_t
 *
stream
 =

299 (void *)((char *)
sched
->
active
.
next
 - 
	`offsetof
(
quicly_stream_t
, 
_send_aux
.
pending_link
.
default_scheduler
));

300 
	`quicly_linklist_unlink
(&
stream
->
_send_aux
.
pending_link
.
default_scheduler
);

302 if (
conn_is_blocked
 && !
	`quicly_stream_can_send
(
stream
, 0)) {

303 
	`quicly_linklist_insert
(
sched
->
blocked
.
prev
, &
stream
->
_send_aux
.
pending_link
.
default_scheduler
);

307 if ((
ret
 = 
	`quicly_send_stream
(
stream
, 
s
)) != 0) {

310 if (
ret
 == 
QUICLY_ERROR_SENDBUF_FULL
) {

311 
	`assert
(
	`quicly_stream_can_send
(
stream
, 1));

312 
	`link_stream
(
sched
, 
stream
, 
conn_is_blocked
);

317 
conn_is_blocked
 = 
	`quicly_is_blocked
(
conn
);

318 if (
	`quicly_stream_can_send
(
stream
, 1))

319 
	`link_stream
(
sched
, 
stream
, 
conn_is_blocked
);

322 return 
ret
;

323 
	}
}

328 static int 
	$default_stream_scheduler_update_state
(
quicly_stream_scheduler_t
 *
self
, 
quicly_stream_t
 *
stream
)

330 struct 
st_quicly_default_scheduler_state_t
 *
sched
 = &((struct 
_st_quicly_conn_public_t
 *)
stream
->
conn
)->
_default_scheduler
;

332 if (
	`quicly_stream_can_send
(
stream
, 1)) {

334 
	`link_stream
(
sched
, 
stream
, 
	`quicly_is_blocked
(stream->
conn
));

337 if (
	`quicly_linklist_is_linked
(&
stream
->
_send_aux
.
pending_link
.
default_scheduler
))

338 
	`quicly_linklist_unlink
(&
stream
->
_send_aux
.
pending_link
.
default_scheduler
);

342 
	}
}

344 
quicly_stream_scheduler_t
 
	gquicly_default_stream_scheduler
 = {
default_stream_scheduler_can_send
, 
default_stream_scheduler_do_send
,

345 
default_stream_scheduler_update_state
};

347 
quicly_stream_t
 *
	$quicly_default_alloc_stream
(
quicly_context_t
 *
ctx
)

349 return 
	`malloc
(sizeof(
quicly_stream_t
));

350 
	}
}

352 void 
	$quicly_default_free_stream
(
quicly_stream_t
 *
stream
)

354 
	`free
(
stream
);

355 
	}
}

357 static 
int64_t
 
	$default_now
(
quicly_now_t
 *
self
)

359 struct 
timeval
 
tv
;

360 
	`gettimeofday
(&
tv
, 
NULL
);

361 
int64_t
 
tv_now
 = (int64_t)
tv
.
tv_sec
 * 1000 + tv.
tv_usec
 / 1000;

364 static 
__thread
 
int64_t
 
now
;

365 if (
now
 < 
tv_now
)

366 
now
 = 
tv_now
;

367 return 
now
;

368 
	}
}

370 
quicly_now_t
 
	gquicly_default_now
 = {
default_now
};

372 static int 
	$default_setup_cipher
(
quicly_crypto_engine_t
 *
engine
, 
quicly_conn_t
 *
conn
, 
size_t
 
epoch
, int 
is_enc
,

373 
ptls_cipher_context_t
 **
hp_ctx
, 
ptls_aead_context_t
 **
aead_ctx
, 
ptls_aead_algorithm_t
 *
aead
,

374 
ptls_hash_algorithm_t
 *
hash
, const void *
secret
)

376 
uint8_t
 
hpkey
[
PTLS_MAX_SECRET_SIZE
];

377 int 
ret
;

379 if (
hp_ctx
 != 
NULL
)

380 *
hp_ctx
 = 
NULL
;

381 *
aead_ctx
 = 
NULL
;

384 if (
hp_ctx
 != 
NULL
) {

385 if ((
ret
 = 
	`ptls_hkdf_expand_label
(
hash
, 
hpkey
, 
aead
->
ctr_cipher
->
key_size
, 
	`ptls_iovec_init
(
secret
, hash->
digest_size
),

386 "quic hp", 
	`ptls_iovec_init
(
NULL
, 0), NULL)) != 0)

387 goto 
Exit
;

388 if ((*
hp_ctx
 = 
	`ptls_cipher_new
(
aead
->
ctr_cipher
, 
is_enc
, 
hpkey
)) == 
NULL
) {

389 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

390 goto 
Exit
;

395 if ((*
aead_ctx
 = 
	`ptls_aead_new
(
aead
, 
hash
, 
is_enc
, 
secret
, 
QUICLY_AEAD_BASE_LABEL
)) == 
NULL
) {

396 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

397 goto 
Exit
;

399 if (
QUICLY_DEBUG
) {

400 char *
secret_hex
 = 
	`quicly_hexdump
(
secret
, 
hash
->
digest_size
, 
SIZE_MAX
),

401 *
hpkey_hex
 = 
	`quicly_hexdump
(
hpkey
, 
aead
->
ctr_cipher
->
key_size
, 
SIZE_MAX
);

402 
	`fprintf
(
stderr
, "%s:\n aead-secret: %s\n hp-key: %s\n", 
__FUNCTION__
, 
secret_hex
, 
hpkey_hex
);

403 
	`free
(
secret_hex
);

404 
	`free
(
hpkey_hex
);

407 
ret
 = 0;

408 
Exit
:

409 if (
ret
 != 0) {

410 if (*
aead_ctx
 != 
NULL
) {

411 
	`ptls_aead_free
(*
aead_ctx
);

412 *
aead_ctx
 = 
NULL
;

414 if (
hp_ctx
 != 
NULL
 && *hp_ctx != NULL) {

415 
	`ptls_cipher_free
(*
hp_ctx
);

416 *
hp_ctx
 = 
NULL
;

419 
	`ptls_clear_memory
(
hpkey
, sizeof(hpkey));

420 return 
ret
;

421 
	}
}

423 static void 
	$default_finalize_send_packet
(
quicly_crypto_engine_t
 *
engine
, 
quicly_conn_t
 *
conn
,

424 
ptls_cipher_context_t
 *
header_protect_ctx
, 
ptls_aead_context_t
 *
packet_protect_ctx
,

425 
ptls_iovec_t
 
datagram
, 
size_t
 
first_byte_at
, size_t 
payload_from
, 
uint64_t
 
packet_number
,

426 int 
coalesced
)

428 
ptls_aead_supplementary_encryption_t
 
supp
 = {.
ctx
 = 
header_protect_ctx
,

429 .
input
 = 
datagram
.
base
 + 
payload_from
 - 
QUICLY_SEND_PN_SIZE
 + 
QUICLY_MAX_PN_SIZE
};

431 
	`ptls_aead_encrypt_s
(
packet_protect_ctx
, 
datagram
.
base
 + 
payload_from
, datagram.base + payload_from,

432 
datagram
.
len
 - 
payload_from
 - 
packet_protect_ctx
->
algo
->
tag_size
, 
packet_number
,

433 
datagram
.
base
 + 
first_byte_at
, 
payload_from
 - first_byte_at, &
supp
);

435 
datagram
.
base
[
first_byte_at
] ^= 
supp
.
output
[0] & (
	`QUICLY_PACKET_IS_LONG_HEADER
(datagram.base[first_byte_at]) ? 0xf : 0x1f);

436 for (
size_t
 
i
 = 0; i != 
QUICLY_SEND_PN_SIZE
; ++i)

437 
datagram
.
base
[
payload_from
 + 
i
 - 
QUICLY_SEND_PN_SIZE
] ^= 
supp
.
output
[i + 1];

438 
	}
}

440 
quicly_crypto_engine_t
 
	gquicly_default_crypto_engine
 = {
default_setup_cipher
, 
default_finalize_send_packet
};

	@lib/frame.c

22 #include 
	~<assert.h
>

23 #include 
	~<string.h
>

24 #include 
	~"quicly/frame.h
"

26 
uint8_t
 *
	$quicly_encode_path_challenge_frame
(
uint8_t
 *
dst
, int 
is_response
, const uint8_t *
data
)

28 *
dst
++ = 
is_response
 ? 
QUICLY_FRAME_TYPE_PATH_RESPONSE
 : 
QUICLY_FRAME_TYPE_PATH_CHALLENGE
;

29 
	`memcpy
(
dst
, 
data
, 
QUICLY_PATH_CHALLENGE_DATA_LEN
);

30 
dst
 += 
QUICLY_PATH_CHALLENGE_DATA_LEN
;

31 return 
dst
;

32 
	}
}

34 
uint8_t
 *
	$quicly_encode_ack_frame
(
uint8_t
 *
dst
, uint8_t *
dst_end
, 
quicly_ranges_t
 *
ranges
, 
uint64_t
 
ack_delay
)

36 #define 
	#WRITE_BLOCK
(
start
, 
end
) \

38 
uint64_t
 
_start
 = (
start
), 
_end
 = (
end
); \

39 
	`assert
(
_start
 < 
_end
); \

40 if (
dst_end
 - 
dst
 < 8) \

41 return 
NULL
; \

42 
dst
 = 
	`quicly_encodev
(dst, 
_end
 - 
_start
 - 1); \

43 } while (0)

	)

45 
size_t
 
range_index
 = 
ranges
->
num_ranges
 - 1;

47 
	`assert
(
ranges
->
num_ranges
 != 0);

50 *
dst
++ = 
QUICLY_FRAME_TYPE_ACK
;

51 
dst
 = 
	`quicly_encodev
(dst, 
ranges
->ranges[
range_index
].
end
 - 1);

52 
dst
 = 
	`quicly_encodev
(dst, 
ack_delay
);

53 
	`PTLS_BUILD_ASSERT
(
QUICLY_MAX_ACK_BLOCKS
 - 1 <= 63);

54 *
dst
++ = (
uint8_t
)(
ranges
->
num_ranges
 - 1);

57 
	`WRITE_BLOCK
(
ranges
->ranges[
range_index
].
start
, ranges->ranges[range_index].
end
);

58 if (
range_index
-- == 0)

60 
	`WRITE_BLOCK
(
ranges
->ranges[
range_index
].
end
, ranges->ranges[range_index + 1].
start
);

63 return 
dst
;

65 #undef 
WRITE_BLOCK


66 
	}
}

68 int 
	$quicly_decode_ack_frame
(const 
uint8_t
 **
src
, const uint8_t *
end
, 
quicly_ack_frame_t
 *
frame
, int 
is_ack_ecn
)

70 
uint64_t
 
i
, 
num_gaps
, 
gap
, 
ack_range
;

72 if ((
frame
->
largest_acknowledged
 = 
	`quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

73 goto 
Error
;

74 if ((
frame
->
ack_delay
 = 
	`quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

75 goto 
Error
;

76 if ((
num_gaps
 = 
	`quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

77 goto 
Error
;

79 if ((
ack_range
 = 
	`quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

80 goto 
Error
;

81 if (
frame
->
largest_acknowledged
 < 
ack_range
)

82 goto 
Error
;

83 
frame
->
smallest_acknowledged
 = frame->
largest_acknowledged
 - 
ack_range
;

84 
frame
->
ack_block_lengths
[0] = 
ack_range
 + 1;

85 
frame
->
num_gaps
 = 0;

87 for (
i
 = 0; i != 
num_gaps
; ++i) {

88 if ((
gap
 = 
	`quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

89 goto 
Error
;

90 if ((
ack_range
 = 
	`quicly_decodev
(
src
, 
end
)) == 
UINT64_MAX
)

91 goto 
Error
;

92 if (
i
 < 
QUICLY_ACK_MAX_GAPS
) {

93 if (
frame
->
smallest_acknowledged
 < 
gap
 + 
ack_range
 + 2)

94 goto 
Error
;

95 
frame
->
gaps
[
i
] = 
gap
 + 1;

96 
frame
->
ack_block_lengths
[
i
 + 1] = 
ack_range
 + 1;

97 
frame
->
smallest_acknowledged
 -= 
gap
 + 
ack_range
 + 2;

98 ++
frame
->
num_gaps
;

102 if (
is_ack_ecn
) {

104 for (
i
 = 0; i != 3; ++i)

105 if (
	`quicly_decodev
(
src
, 
end
) == 
UINT64_MAX
)

106 goto 
Error
;

109 
Error
:

110 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

111 
	}
}

113 
uint8_t
 *
	$quicly_encode_close_frame
(
uint8_t
 *const 
base
, 
uint64_t
 
error_code
, uint64_t 
offending_frame_type
,

114 const char *
reason_phrase
)

116 
size_t
 
offset
 = 0, 
reason_phrase_len
 = 
	`strlen
(
reason_phrase
);

118 #define 
	#PUSHV
(
v
) \

120 if (
base
 != 
NULL
) { \

121 
offset
 = 
	`quicly_encodev
(
base
 + offset, (
v
)) - base; \

123 
offset
 += 
	`quicly_encodev_capacity
(
v
); \

125 } while (0)

	)

127 
	`PUSHV
(
offending_frame_type
 == 
UINT64_MAX
 ? 
QUICLY_FRAME_TYPE_APPLICATION_CLOSE
 : 
QUICLY_FRAME_TYPE_TRANSPORT_CLOSE
);

128 
	`PUSHV
(
error_code
);

129 if (
offending_frame_type
 != 
UINT64_MAX
)

130 
	`PUSHV
(
offending_frame_type
);

131 
	`PUSHV
(
reason_phrase_len
);

132 if (
base
 != 
NULL
)

133 
	`memcpy
(
base
 + 
offset
, 
reason_phrase
, 
reason_phrase_len
);

134 
offset
 += 
reason_phrase_len
;

136 #undef 
PUSHV


138 return 
base
 + 
offset
;

139 
	}
}

	@lib/local_cid.c

22 #include 
	~"quicly/local_cid.h
"

24 static int 
	$has_pending
(
quicly_local_cid_set_t
 *
set
)

26 return 
set
->
cids
[0].
state
 == 
QUICLY_LOCAL_CID_STATE_PENDING
;

27 
	}
}

32 static int 
	$generate_cid
(
quicly_local_cid_set_t
 *
set
, 
size_t
 
idx
)

34 if (
set
->
_encryptor
 == 
NULL
 || set->
plaintext
.
path_id
 >= 
QUICLY_MAX_PATH_ID
)

37 
set
->
_encryptor
->
	`encrypt_cid
(set->_encryptor, &set->
cids
[
idx
].
cid
, set->cids[idx].
stateless_reset_token
, &set->
plaintext
);

38 
set
->
cids
[
idx
].
sequence
 = set->
plaintext
.
path_id
++;

41 
	}
}

43 static void 
	$swap_cids
(
quicly_local_cid_t
 *
a
, quicly_local_cid_t *
b
)

45 
quicly_local_cid_t
 
tmp
 = *
b
;

46 *
b
 = *
a
;

47 *
a
 = 
tmp
;

48 
	}
}

53 static void 
	$do_mark_pending
(
quicly_local_cid_set_t
 *
set
, 
size_t
 
idx
)

55 
set
->
cids
[
idx
].
state
 = 
QUICLY_LOCAL_CID_STATE_PENDING
;

56 for (
size_t
 
j
 = 0; j < 
idx
; j++) {

57 if (
set
->
cids
[
j
].
state
 != 
QUICLY_LOCAL_CID_STATE_PENDING
) {

58 
	`swap_cids
(&
set
->
cids
[
idx
], &set->cids[
j
]);

62 
	}
}

64 static void 
	$do_mark_delivered
(
quicly_local_cid_set_t
 *
set
, 
size_t
 
idx
)

66 if (
set
->
cids
[
idx
].
state
 == 
QUICLY_LOCAL_CID_STATE_PENDING
) {

68 while (
idx
 + 1 < 
set
->
_size
 && set->
cids
[idx + 1].
state
 == 
QUICLY_LOCAL_CID_STATE_PENDING
) {

69 
	`swap_cids
(&
set
->
cids
[
idx
], &set->cids[idx + 1]);

70 
idx
++;

73 
set
->
cids
[
idx
].
state
 = 
QUICLY_LOCAL_CID_STATE_DELIVERED
;

74 
	}
}

76 void 
	$quicly_local_cid_init_set
(
quicly_local_cid_set_t
 *
set
, 
quicly_cid_encryptor_t
 *
encryptor
,

77 const 
quicly_cid_plaintext_t
 *
new_cid
)

79 *
set
 = (
quicly_local_cid_set_t
){

80 .
_encryptor
 = 
encryptor
,

81 .
_size
 = 1,

85 if (
new_cid
 != 
NULL
) {

86 
	`assert
(
new_cid
->
path_id
 == 0);

87 
set
->
plaintext
 = *
new_cid
;

91 if (
encryptor
 != 
NULL
) {

92 
	`assert
(
new_cid
 != 
NULL
 && "master CID must be specified when a non-zero length CID is to be used");

93 
	`generate_cid
(
set
, 0);

95 
set
->
cids
[0].
state
 =

96 
QUICLY_LOCAL_CID_STATE_DELIVERED
;

98 for (
size_t
 
i
 = 1; i < 
	`PTLS_ELEMENTSOF
(
set
->
cids
); i++)

99 
set
->
cids
[
i
].
sequence
 = 
UINT64_MAX
;

100 
	}
}

102 int 
	$quicly_local_cid_set_size
(
quicly_local_cid_set_t
 *
set
, 
size_t
 
size
)

104 int 
is_pending
 = 0;

106 
	`assert
(
size
 <= 
	`PTLS_ELEMENTSOF
(
set
->
cids
));

107 
	`assert
(
set
->
_size
 <= 
size
);

109 for (
size_t
 
i
 = 
set
->
_size
; i < 
size
; i++)

110 
set
->
cids
[
i
].
state
 = 
QUICLY_LOCAL_CID_STATE_IDLE
;

112 
set
->
_size
 = 
size
;

117 for (
size_t
 
i
 = 0; i < 
size
; i++) {

118 if (
set
->
cids
[
i
].
state
 != 
QUICLY_LOCAL_CID_STATE_IDLE
)

121 if (!
	`generate_cid
(
set
, 
i
))

123 
	`do_mark_pending
(
set
, 
i
);

124 
is_pending
 = 1;

127 return 
is_pending
;

128 
	}
}

130 void 
	$quicly_local_cid_on_sent
(
quicly_local_cid_set_t
 *
set
, 
size_t
 
num_sent
)

132 
	`assert
(
num_sent
 <= 
set
->
_size
);

135 for (
size_t
 
i
 = 0; i < 
num_sent
; i++) {

136 
	`assert
(
set
->
cids
[
i
].
state
 == 
QUICLY_LOCAL_CID_STATE_PENDING
);

137 
set
->
cids
[
i
].
state
 = 
QUICLY_LOCAL_CID_STATE_INFLIGHT
;

141 for (
size_t
 
i
 = 
num_sent
; i < 
set
->
_size
; i++) {

142 if (
set
->
cids
[
i
].
state
 != 
QUICLY_LOCAL_CID_STATE_PENDING
)

144 
	`swap_cids
(&
set
->
cids
[
i
], &set->cids[i - 
num_sent
]);

146 
	}
}

148 static 
size_t
 
	$find_index
(const 
quicly_local_cid_set_t
 *
set
, 
uint64_t
 
sequence
)

150 for (
size_t
 
i
 = 0; i < 
set
->
_size
; i++) {

151 if (
set
->
cids
[
i
].
sequence
 == sequence)

152 return 
i
;

155 return 
SIZE_MAX
;

156 
	}
}

158 void 
	$quicly_local_cid_on_acked
(
quicly_local_cid_set_t
 *
set
, 
uint64_t
 
sequence
)

160 
size_t
 
i
 = 
	`find_index
(
set
, 
sequence
);

161 if (
i
 == 
SIZE_MAX
)

164 
	`do_mark_delivered
(
set
, 
i
);

165 
	}
}

167 int 
	$quicly_local_cid_on_lost
(
quicly_local_cid_set_t
 *
set
, 
uint64_t
 
sequence
)

169 
size_t
 
i
 = 
	`find_index
(
set
, 
sequence
);

170 if (
i
 == 
SIZE_MAX
)

171 return 
	`has_pending
(
set
);

174 if (
set
->
cids
[
i
].
state
 == 
QUICLY_LOCAL_CID_STATE_DELIVERED
)

175 return 
	`has_pending
(
set
);

177 
	`do_mark_pending
(
set
, 
i
);

180 
	}
}

182 int 
	$quicly_local_cid_retire
(
quicly_local_cid_set_t
 *
set
, 
uint64_t
 
sequence
, int *
_has_pending
)

185 
size_t
 
retired_at
 = 
set
->
_size
;

186 int 
becomes_empty
 = 1;

187 for (
size_t
 
i
 = 0; i < 
set
->
_size
; i++) {

188 if (
set
->
cids
[
i
].
state
 == 
QUICLY_LOCAL_CID_STATE_IDLE
)

190 if (
set
->
cids
[
i
].
sequence
 == sequence) {

191 
	`assert
(
retired_at
 == 
set
->
_size
);

192 
retired_at
 = 
i
;

194 
becomes_empty
 = 0;

199 if (
retired_at
 == 
set
->
_size
) {

200 *
_has_pending
 = 
	`has_pending
(
set
);

205 if (
becomes_empty
)

206 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

209 
set
->
cids
[
retired_at
].
state
 = 
QUICLY_LOCAL_CID_STATE_IDLE
;

210 
set
->
cids
[
retired_at
].
sequence
 = 
UINT64_MAX
;

213 for (
size_t
 
i
 = 
retired_at
 + 1; i < 
set
->
_size
; i++) {

214 if (
set
->
cids
[
i
].
state
 != 
QUICLY_LOCAL_CID_STATE_PENDING
)

216 
	`swap_cids
(&
set
->
cids
[
i
], &set->cids[
retired_at
]);

217 
retired_at
 = 
i
;

221 if (
	`generate_cid
(
set
, 
retired_at
)) {

222 
	`do_mark_pending
(
set
, 
retired_at
);

223 *
_has_pending
 = 1;

225 *
_has_pending
 = 
	`has_pending
(
set
);

229 
	}
}

	@lib/loss.c

22 #include 
	~"quicly/loss.h
"

24 int 
	$quicly_loss_init_sentmap_iter
(
quicly_loss_t
 *
loss
, 
quicly_sentmap_iter_t
 *
iter
, 
int64_t
 
now
, 
uint32_t
 
max_ack_delay
,

25 int 
is_closing
)

27 
	`quicly_sentmap_init_iter
(&
loss
->
sentmap
, 
iter
);

29 
int64_t
 
retire_before
 = 
now
 - 
	`quicly_loss_get_sentmap_expiration_time
(
loss
, 
max_ack_delay
);

34 const 
quicly_sent_packet_t
 *
sent
;

35 while ((
sent
 = 
	`quicly_sentmap_get
(
iter
))->
sent_at
 <= 
retire_before
 && sent->
cc_bytes_in_flight
 == 0) {

36 int 
ret
;

37 if (!
is_closing
 && 
loss
->
sentmap
.
num_packets
 < 32)

39 if ((
ret
 = 
	`quicly_sentmap_update
(&
loss
->
sentmap
, 
iter
, 
QUICLY_SENTMAP_EVENT_EXPIRED
)) != 0)

40 return 
ret
;

43 
	}
}

45 int 
	$quicly_loss_detect_loss
(
quicly_loss_t
 *
loss
, 
int64_t
 
now
, 
uint32_t
 
max_ack_delay
, int 
is_1rtt_only
,

46 
quicly_loss_on_detect_cb
 
on_loss_detected
)

51 const 
uint32_t
 
delay_until_lost
 = ((
loss
->
rtt
.
latest
 > loss->rtt.
smoothed
 ? loss->rtt.latest : loss->rtt.smoothed) * 9 + 7) / 8;

52 
quicly_sentmap_iter_t
 
iter
;

53 const 
quicly_sent_packet_t
 *
sent
;

54 int 
ret
;

56 
loss
->
loss_time
 = 
INT64_MAX
;

58 if ((
ret
 = 
	`quicly_loss_init_sentmap_iter
(
loss
, &
iter
, 
now
, 
max_ack_delay
, 0)) != 0)

59 return 
ret
;

63 while ((
sent
 = 
	`quicly_sentmap_get
(&
iter
))->
packet_number
 != 
UINT64_MAX
) {

64 
int64_t
 
largest_acked_signed
 = 
loss
->
largest_acked_packet_plus1
[
sent
->
ack_epoch
] - 1;

65 if ((
int64_t
)
sent
->
packet_number
 < 
largest_acked_signed
 &&

66 (
sent
->
sent_at
 <= 
now
 - 
delay_until_lost
 ||

67 (
int64_t
)
sent
->
packet_number
 <= 
largest_acked_signed
 - 
QUICLY_LOSS_DEFAULT_PACKET_THRESHOLD
)) {

68 if (
sent
->
cc_bytes_in_flight
 != 0) {

69 
	`on_loss_detected
(
loss
, 
sent
,

70 (
int64_t
)
sent
->
packet_number
 > 
largest_acked_signed
 - 
QUICLY_LOSS_DEFAULT_PACKET_THRESHOLD
);

71 if ((
ret
 = 
	`quicly_sentmap_update
(&
loss
->
sentmap
, &
iter
, 
QUICLY_SENTMAP_EVENT_LOST
)) != 0)

72 return 
ret
;

74 
	`quicly_sentmap_skip
(&
iter
);

79 if (
is_1rtt_only
)

81 
	`quicly_sentmap_skip
(&
iter
);

85 if (!
is_1rtt_only
) {

86 if ((
ret
 = 
	`quicly_loss_init_sentmap_iter
(
loss
, &
iter
, 
now
, 
max_ack_delay
, 0)) != 0)

87 return 
ret
;

88 
sent
 = 
	`quicly_sentmap_get
(&
iter
);

92 while (
sent
->
sent_at
 != 
INT64_MAX
 && sent->
packet_number
 + 1 < 
loss
->
largest_acked_packet_plus1
[sent->
ack_epoch
]) {

93 if (
sent
->
cc_bytes_in_flight
 != 0) {

94 
	`assert
(
now
 < 
sent
->
sent_at
 + 
delay_until_lost
);

95 
loss
->
loss_time
 = 
sent
->
sent_at
 + 
delay_until_lost
;

98 
	`quicly_sentmap_skip
(&
iter
);

99 
sent
 = 
	`quicly_sentmap_get
(&
iter
);

103 
	}
}

	@lib/quicly.c

22 #include 
	~<assert.h
>

23 #include 
	~<inttypes.h
>

24 #include 
	~<netinet/in.h
>

25 #include 
	~<pthread.h
>

26 #include 
	~<stdarg.h
>

27 #include 
	~<stdio.h
>

28 #include 
	~<stdlib.h
>

29 #include 
	~<sys/socket.h
>

30 #include 
	~<sys/time.h
>

31 #include 
	~"khash.h
"

32 #include 
	~"quicly.h
"

33 #include 
	~"quicly/defaults.h
"

34 #include 
	~"quicly/sentmap.h
"

35 #include 
	~"quicly/frame.h
"

36 #include 
	~"quicly/streambuf.h
"

37 #include 
	~"quicly/cc.h
"

38 #if 
QUICLY_USE_EMBEDDED_PROBES


39 #include 
	~"embedded-probes.h
"

40 #elif 
QUICLY_USE_DTRACE


41 #include 
	~"quicly-probes.h
"

43 #include 
	~"quicly/retire_cid.h
"

45 #define 
	#QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS
 0xffa5

	)

46 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_ORIGINAL_CONNECTION_ID
 0

	)

47 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_MAX_IDLE_TIMEOUT
 1

	)

48 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_STATELESS_RESET_TOKEN
 2

	)

49 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_MAX_UDP_PAYLOAD_SIZE
 3

	)

50 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA
 4

	)

51 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
 5

	)

52 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
 6

	)

53 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI
 7

	)

54 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI
 8

	)

55 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI
 9

	)

56 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_ACK_DELAY_EXPONENT
 10

	)

57 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_MAX_ACK_DELAY
 11

	)

58 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_DISABLE_ACTIVE_MIGRATION
 12

	)

59 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_PREFERRED_ADDRESS
 13

	)

60 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT
 14

	)

61 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_SOURCE_CONNECTION_ID
 15

	)

62 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_RETRY_SOURCE_CONNECTION_ID
 16

	)

63 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_MAX_DATAGRAM_FRAME_SIZE
 0x20

	)

64 #define 
	#QUICLY_TRANSPORT_PARAMETER_ID_MIN_ACK_DELAY
 0xff02de1a

	)

69 #define 
	#QUICLY_MAX_TOKEN_LEN
 512

	)

74 #define 
	#QUICLY_NUM_ACK_BLOCKS_TO_INDUCE_ACKACK
 8

	)

76 
	$KHASH_MAP_INIT_INT64
(
quicly_stream_t
, quicly_stream_t *)

78 #if 
QUICLY_USE_TRACER


79 #define 
	#QUICLY_TRACER
(
label
, 
conn
, ...) 
QUICLY_TRACER_
##
	`label
(conn, 
__VA_ARGS__
)

	)

81 #define 
	#QUICLY_TRACER
(...)

	)

84 #if 
QUICLY_USE_EMBEDDED_PROBES
 || 
QUICLY_USE_DTRACE


85 #define 
	#QUICLY_PROBE
(
label
, 
conn
, ...) \

87 
quicly_conn_t
 *
_conn
 = (
conn
); \

88 if (
	`PTLS_UNLIKELY
(
QUICLY_
##
label
##
	`_ENABLED
()) && !
	`ptls_skip_tracing
(
_conn
->
crypto
.
tls
)) \

89 
QUICLY_
##
	`label
(
_conn
, 
__VA_ARGS__
); \

90 
	`QUICLY_TRACER
(
label
, 
_conn
, 
__VA_ARGS__
); \

91 
	}
} while (0)

	)

93 #define 
	#QUICLY_PROBE
(
label
, 
conn
, ...) 
	`QUICLY_TRACER
(label, conn, 
__VA_ARGS__
)

	)

95 #define 
	#QUICLY_PROBE_HEXDUMP
(
s
, 
l
) \

97 
size_t
 
_l
 = (
l
); \

98 
	`ptls_hexdump
(
	`alloca
(
_l
 * 2 + 1), (
s
), _l); \

99 })

	)

100 #define 
	#QUICLY_PROBE_ESCAPE_UNSAFE_STRING
(
s
, 
l
) \

102 
size_t
 
_l
 = (
l
); \

103 
	`quicly_escape_unsafe_string
(
	`alloca
(
_l
 * 4 + 1), (
s
), _l); \

104 })

	)

106 struct 
	sst_quicly_cipher_context_t
 {

107 
ptls_aead_context_t
 *
	maead
;

108 
ptls_cipher_context_t
 *
	mheader_protection
;

111 struct 
	sst_quicly_pending_path_challenge_t
 {

112 struct 
st_quicly_pending_path_challenge_t
 *
	mnext
;

113 
uint8_t
 
	mis_response
;

114 
uint8_t
 
	mdata
[
QUICLY_PATH_CHALLENGE_DATA_LEN
];

117 struct 
	sst_quicly_pn_space_t
 {

121 
quicly_ranges_t
 
	mack_queue
;

125 
int64_t
 
	mlargest_pn_received_at
;

129 
uint64_t
 
	mnext_expected_packet_number
;

133 
uint32_t
 
	munacked_count
;

137 
uint32_t
 
	mpacket_tolerance
;

141 
uint8_t
 
	mignore_order
;

144 struct 
	sst_quicly_handshake_space_t
 {

145 struct 
st_quicly_pn_space_t
 
	msuper
;

147 struct 
st_quicly_cipher_context_t
 
	mingress
;

148 struct 
st_quicly_cipher_context_t
 
	megress
;

149 } 
	mcipher
;

150 
uint16_t
 
	mlargest_ingress_udp_payload_size
;

153 struct 
	sst_quicly_application_space_t
 {

154 struct 
st_quicly_pn_space_t
 
	msuper
;

158 
ptls_cipher_context_t
 *
	mzero_rtt
, *
	mone_rtt
;

159 } 
	mheader_protection
;

160 
ptls_aead_context_t
 *
	maead
[2];

161 
uint8_t
 
	msecret
[
PTLS_MAX_DIGEST_SIZE
];

163 
uint64_t
 
	mprepared
;

164 
uint64_t
 
	mdecrypted
;

165 } 
	mkey_phase
;

166 } 
	mingress
;

168 struct 
st_quicly_cipher_context_t
 
	mkey
;

169 
uint8_t
 
	msecret
[
PTLS_MAX_DIGEST_SIZE
];

170 
uint64_t
 
	mkey_phase
;

175 
uint64_t
 
	mlast
;

179 
uint64_t
 
	mnext
;

180 } 
	mkey_update_pn
;

181 } 
	megress
;

182 } 
	mcipher
;

183 int 
	mone_rtt_writable
;

186 struct 
	sst_quicly_conn_t
 {

187 struct 
_st_quicly_conn_public_t
 
	msuper
;

191 struct 
st_quicly_handshake_space_t
 *
	minitial
;

195 struct 
st_quicly_handshake_space_t
 *
	mhandshake
;

199 struct 
st_quicly_application_space_t
 *
	mapplication
;

203 
khash_t
(
quicly_stream_t
) * 
	mstreams
;

212 
uint64_t
 
	mbytes_consumed
;

213 
quicly_maxsender_t
 
	msender
;

214 } 
	mmax_data
;

219 
quicly_maxsender_t
 
	muni
, 
	mbidi
;

220 } 
	mmax_streams
;

225 
uint64_t
 
	mnext_sequence
;

226 } 
	mack_frequency
;

227 } 
	mingress
;

235 
quicly_loss_t
 
	mloss
;

239 
uint64_t
 
	mpacket_number
;

243 
uint64_t
 
	mnext_pn_to_skip
;

247 
uint16_t
 
	mmax_udp_payload_size
;

252 
uint16_t
 
	merror_code
;

253 
uint64_t
 
	mframe_type
;

254 const char *
	mreason_phrase
;

255 unsigned long 
	mnum_packets_received
;

256 } 
	mconnection_close
;

261 
uint64_t
 
	mpermitted
;

262 
uint64_t
 
	msent
;

263 } 
	mmax_data
;

268 struct 
	sst_quicly_max_streams_t
 {

269 
uint64_t
 
	mcount
;

270 
quicly_maxsender_t
 
	mblocked_sender
;

271 } 
	muni
, 
	mbidi
;

272 } 
	mmax_streams
;

277 struct 
st_quicly_pending_path_challenge_t
 *
	mhead
, **
	mtail_ref
;

278 } 
	mpath_challenge
;

283 
uint64_t
 
	mgeneration
;

284 
uint64_t
 
	mmax_acked
;

285 
uint32_t
 
	mnum_inflight
;

286 } 
	mnew_token
;

291 
int64_t
 
	mupdate_at
;

292 
uint64_t
 
	msequence
;

293 } 
	mack_frequency
;

297 
int64_t
 
	mlast_retransmittable_sent_at
;

301 
int64_t
 
	msend_ack_at
;

305 
quicly_cc_t
 
	mcc
;

314 
quicly_linklist_t
 
	muni
;

315 
quicly_linklist_t
 
	mbidi
;

316 } 
	mblocked
;

320 
quicly_linklist_t
 
	mcontrol
;

321 } 
	mpending_streams
;

325 
quicly_sender_state_t
 
	mdata_blocked
;

329 
uint8_t
 
	mpending_flows
;

330 #define 
	#QUICLY_PENDING_FLOW_NEW_TOKEN_BIT
 (1 << 5)

	)

331 #define 
	#QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT
 (1 << 6)

	)

339 #define 
	#QUICLY_PENDING_FLOW_CID_FRAME_BIT
 (1 << 7)

	)

343 
quicly_retire_cid_set_t
 
	mretire_cid
;

348 
ptls_iovec_t
 
	mpayloads
[10];

349 
size_t
 
	mcount
;

350 } 
	mdatagram_frame_payloads
;

351 } 
	megress
;

356 
ptls_t
 *
	mtls
;

357 
ptls_handshake_properties_t
 
	mhandshake_properties
;

359 
ptls_raw_extension_t
 
	mext
[2];

360 
ptls_buffer_t
 
	mbuf
;

361 } 
	mtransport_params
;

362 } 
	mcrypto
;

366 
ptls_iovec_t
 
	mtoken
;

370 
quicly_cid_t
 
	mretry_scid
;

379 
int64_t
 
	mat
;

383 
uint8_t
 
	mshould_rearm_on_send
 : 1;

384 } 
	midle_timeout
;

393 
int64_t
 
	mnow
;

397 
uint8_t
 
	mlock_count
;

408 
quicly_stream_id_t
 
	mstream_id
;

409 
quicly_sendstate_sent_t
 
	margs
;

410 } 
	mactive_acked_cache
;

411 } 
	mon_ack_stream
;

412 } 
	mstash
;

415 #if 
QUICLY_USE_TRACER


416 #include 
	~"quicly-tracer.h
"

419 struct 
	sst_quicly_handle_payload_state_t
 {

420 const 
uint8_t
 *
	msrc
, *const 
	mend
;

421 
size_t
 
	mepoch
;

422 
uint64_t
 
	mframe_type
;

425 struct 
	sst_ptls_salt_t
 {

426 
uint8_t
 
	minitial
[20];

428 
uint8_t
 
	mkey
[
PTLS_AES128_KEY_SIZE
];

429 
uint8_t
 
	miv
[
PTLS_AESGCM_IV_SIZE
];

430 } 
	mretry
;

433 static void 
crypto_stream_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
);

435 static const 
quicly_stream_callbacks_t
 
	gcrypto_stream_callbacks
 = {
quicly_streambuf_destroy
, 
quicly_streambuf_egress_shift
,

436 
quicly_streambuf_egress_emit
, 
NULL
, 
crypto_stream_receive
};

438 static int 
update_traffic_key_cb
(
ptls_update_traffic_key_t
 *
self
, 
ptls_t
 *
tls
, int 
is_enc
, 
size_t
 
epoch
, const void *
secret
);

439 static int 
initiate_close
(
quicly_conn_t
 *
conn
, int 
err
, 
uint64_t
 
frame_type
, const char *
reason_phrase
);

440 static int 
handle_close
(
quicly_conn_t
 *
conn
, int 
err
, 
uint64_t
 
frame_type
, 
ptls_iovec_t
 
reason_phrase
);

441 static int 
discard_sentmap_by_epoch
(
quicly_conn_t
 *
conn
, unsigned 
ack_epochs
);

443 
quicly_cid_plaintext_t
 
	gquicly_cid_plaintext_invalid
 = {.
node_id
 = 
UINT64_MAX
, .
	gthread_id
 = 0xffffff};

445 static const 
quicly_transport_parameters_t
 
	gdefault_transport_params
 = {.
max_udp_payload_size
 = 
QUICLY_DEFAULT_MAX_UDP_PAYLOAD_SIZE
,

446 .
	gack_delay_exponent
 = 
QUICLY_DEFAULT_ACK_DELAY_EXPONENT
,

447 .
	gmax_ack_delay
 = 
QUICLY_DEFAULT_MAX_ACK_DELAY
,

448 .
	gmin_ack_delay_usec
 = 
UINT64_MAX
,

449 .
	gactive_connection_id_limit
 =

450 
QUICLY_DEFAULT_ACTIVE_CONNECTION_ID_LIMIT
};

452 static const struct 
st_ptls_salt_t
 *
	$get_salt
(
uint32_t
 
protocol_version
)

454 static const struct 
st_ptls_salt_t
 
current
 = {.
initial
 = {0xaf, 0xbf, 0xec, 0x28, 0x99, 0x93, 0xd2, 0x4c, 0x9e, 0x97,

456 .
retry
 = {.
key
 = {0xcc, 0xce, 0x18, 0x7e, 0xd0, 0x9a, 0x09, 0xd0, 0x57, 0x28,

458 .
iv
 = {0xe5, 0x49, 0x30, 0xf9, 0x7f, 0x21, 0x36, 0xf0, 0x53, 0x0a, 0x8c,

460 
draft27
 = {.
initial
 = {0xc3, 0xee, 0xf7, 0x12, 0xc7, 0x2e, 0xbb, 0x5a, 0x11, 0xa7,

462 .
retry
 = {.
key
 = {0x4d, 0x32, 0xec, 0xdb, 0x2a, 0x21, 0x33, 0xc8, 0x41, 0xe4,

464 .
iv
 = {0x4d, 0x16, 0x11, 0xd0, 0x55, 0x13, 0xa5, 0x52, 0xc5, 0x87, 0xd5,

467 switch (
protocol_version
) {

468 case 
QUICLY_PROTOCOL_VERSION_CURRENT
:

469 return &
current
;

470 case 
QUICLY_PROTOCOL_VERSION_DRAFT27
:

471 return &
draft27
;

474 return 
NULL
;

476 
	}
}

478 static void 
	$lock_now
(
quicly_conn_t
 *
conn
, int 
is_reentrant
)

480 if (
conn
->
stash
.
now
 == 0) {

481 
	`assert
(
conn
->
stash
.
lock_count
 == 0);

482 
conn
->
stash
.
now
 = conn->
super
.
ctx
->now->
	`cb
(conn->super.ctx->now);

484 
	`assert
(
is_reentrant
 && "caller must be reentrant");

485 
	`assert
(
conn
->
stash
.
lock_count
 != 0);

488 ++
conn
->
stash
.
lock_count
;

489 
	}
}

491 static void 
	$unlock_now
(
quicly_conn_t
 *
conn
)

493 
	`assert
(
conn
->
stash
.
now
 != 0);

495 if (--
conn
->
stash
.
lock_count
 == 0)

496 
conn
->
stash
.
now
 = 0;

497 
	}
}

499 static void 
	$set_address
(
quicly_address_t
 *
addr
, struct 
sockaddr
 *
sa
)

501 if (
sa
 == 
NULL
) {

502 
addr
->
sa
.
sa_family
 = 
AF_UNSPEC
;

506 switch (
sa
->
sa_family
) {

507 case 
AF_UNSPEC
:

508 
addr
->
sa
.
sa_family
 = 
AF_UNSPEC
;

510 case 
AF_INET
:

511 
addr
->
sin
 = *(struct 
sockaddr_in
 *)
sa
;

513 case 
AF_INET6
:

514 
addr
->
sin6
 = *(struct 
sockaddr_in6
 *)
sa
;

517 
	`memset
(
addr
, 0xff, sizeof(*addr));

518 
	`assert
(!"unexpected address type");

521 
	}
}

523 static 
ptls_cipher_suite_t
 *
	$get_aes128gcmsha256
(
quicly_context_t
 *
ctx
)

525 
ptls_cipher_suite_t
 **
cs
;

527 for (
cs
 = 
ctx
->
tls
->
cipher_suites
;; ++cs) {

528 
	`assert
(
cs
 != 
NULL
);

529 if ((*
cs
)->
id
 == 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
)

532 return *
cs
;

533 
	}
}

535 static 
inline
 
uint8_t
 
	$get_epoch
(
uint8_t
 
first_byte
)

537 if (!
	`QUICLY_PACKET_IS_LONG_HEADER
(
first_byte
))

538 return 
QUICLY_EPOCH_1RTT
;

540 switch (
first_byte
 & 
QUICLY_PACKET_TYPE_BITMASK
) {

541 case 
QUICLY_PACKET_TYPE_INITIAL
:

542 return 
QUICLY_EPOCH_INITIAL
;

543 case 
QUICLY_PACKET_TYPE_HANDSHAKE
:

544 return 
QUICLY_EPOCH_HANDSHAKE
;

545 case 
QUICLY_PACKET_TYPE_0RTT
:

546 return 
QUICLY_EPOCH_0RTT
;

548 
	`assert
(!"FIXME");

550 
	}
}

552 static 
ptls_aead_context_t
 *
	$create_retry_aead
(
quicly_context_t
 *
ctx
, 
uint32_t
 
protocol_version
, int 
is_enc
)

554 const struct 
st_ptls_salt_t
 *
salt
 = 
	`get_salt
(
protocol_version
);

555 
	`assert
(
salt
 != 
NULL
);

557 
ptls_cipher_suite_t
 *
algo
 = 
	`get_aes128gcmsha256
(
ctx
);

558 
ptls_aead_context_t
 *
aead
 = 
	`ptls_aead_new_direct
(
algo
->aead, 
is_enc
, 
salt
->
retry
.
key
, salt->retry.
iv
);

559 
	`assert
(
aead
 != 
NULL
);

560 return 
aead
;

561 
	}
}

563 static void 
	$dispose_cipher
(struct 
st_quicly_cipher_context_t
 *
ctx
)

565 
	`ptls_aead_free
(
ctx
->
aead
);

566 
	`ptls_cipher_free
(
ctx
->
header_protection
);

567 
	}
}

569 static void 
	$clear_datagram_frame_payloads
(
quicly_conn_t
 *
conn
)

571 for (
size_t
 
i
 = 0; i != 
conn
->
egress
.
datagram_frame_payloads
.
count
; ++i) {

572 
	`free
(
conn
->
egress
.
datagram_frame_payloads
.
payloads
[
i
].
base
);

573 
conn
->
egress
.
datagram_frame_payloads
.
payloads
[
i
] = 
	`ptls_iovec_init
(
NULL
, 0);

575 
conn
->
egress
.
datagram_frame_payloads
.
count
 = 0;

576 
	}
}

578 static int 
	$is_retry
(
quicly_conn_t
 *
conn
)

580 return 
conn
->
retry_scid
.
len
 != 
UINT8_MAX
;

581 
	}
}

583 static int 
	$needs_cid_auth
(
quicly_conn_t
 *
conn
)

585 return 
conn
->
super
.
version
 > 
QUICLY_PROTOCOL_VERSION_DRAFT27
;

586 
	}
}

588 static int 
	$recognize_delayed_ack
(
quicly_conn_t
 *
conn
)

590 return 
conn
->
super
.
ctx
->
transport_params
.
min_ack_delay_usec
 != 
UINT64_MAX
;

591 
	}
}

593 static 
int64_t
 
	$get_sentmap_expiration_time
(
quicly_conn_t
 *
conn
)

595 return 
	`quicly_loss_get_sentmap_expiration_time
(&
conn
->
egress
.
loss
, conn->
super
.
remote
.
transport_params
.
max_ack_delay
);

596 
	}
}

598 static void 
	$ack_frequency_set_next_update_at
(
quicly_conn_t
 *
conn
)

600 if (
conn
->
super
.
remote
.
transport_params
.
min_ack_delay_usec
 != 
UINT64_MAX
)

601 
conn
->
egress
.
ack_frequency
.
update_at
 = conn->
stash
.
now
 + 
	`get_sentmap_expiration_time
(conn);

602 
	}
}

604 
size_t
 
	$quicly_decode_packet
(
quicly_context_t
 *
ctx
, 
quicly_decoded_packet_t
 *
packet
, const 
uint8_t
 *
datagram
, 
size_t
 
datagram_size
,

605 
size_t
 *
off
)

607 const 
uint8_t
 *
src
 = 
datagram
, *
src_end
 = datagram + 
datagram_size
;

609 
	`assert
(*
off
 <= 
datagram_size
);

611 
packet
->
octets
 = 
	`ptls_iovec_init
(
src
 + *
off
, 
datagram_size
 - *off);

612 if (
packet
->
octets
.
len
 < 2)

613 goto 
Error
;

614 
packet
->
datagram_size
 = *
off
 == 0 ? datagram_size : 0;

615 
packet
->
token
 = 
	`ptls_iovec_init
(
NULL
, 0);

616 
packet
->
decrypted
.
pn
 = 
UINT64_MAX
;

619 
src
 += *
off
 + 1;

621 if (
	`QUICLY_PACKET_IS_LONG_HEADER
(
packet
->
octets
.
base
[0])) {

623 
uint64_t
 
rest_length
;

624 if (
src_end
 - 
src
 < 5)

625 goto 
Error
;

626 
packet
->
version
 = 
	`quicly_decode32
(&
src
);

627 
packet
->
cid
.
dest
.
encrypted
.
len
 = *
src
++;

628 if (
src_end
 - 
src
 < 
packet
->
cid
.
dest
.
encrypted
.
len
 + 1)

629 goto 
Error
;

630 
packet
->
cid
.
dest
.
encrypted
.
base
 = (
uint8_t
 *)
src
;

631 
src
 += 
packet
->
cid
.
dest
.
encrypted
.
len
;

632 
packet
->
cid
.
src
.
len
 = *src++;

633 if (
src_end
 - 
src
 < 
packet
->
cid
.src.
len
)

634 goto 
Error
;

635 
packet
->
cid
.
src
.
base
 = (
uint8_t
 *)src;

636 
src
 += 
packet
->
cid
.src.
len
;

637 switch (
packet
->
octets
.
base
[0] & 
QUICLY_PACKET_TYPE_BITMASK
) {

638 case 
QUICLY_PACKET_TYPE_INITIAL
:

639 case 
QUICLY_PACKET_TYPE_0RTT
:

640 if (
ctx
->
cid_encryptor
 == 
NULL
 || 
packet
->
cid
.
dest
.
encrypted
.
len
 == 0 ||

641 
ctx
->
cid_encryptor
->
	`decrypt_cid
(ctx->cid_encryptor, &
packet
->
cid
.
dest
.
plaintext
, packet->cid.dest.
encrypted
.
base
,

642 
packet
->
cid
.
dest
.
encrypted
.
len
) == 
SIZE_MAX
)

643 
packet
->
cid
.
dest
.
plaintext
 = 
quicly_cid_plaintext_invalid
;

644 
packet
->
cid
.
dest
.
might_be_client_generated
 = 1;

647 if (
ctx
->
cid_encryptor
 != 
NULL
) {

648 if (
packet
->
cid
.
dest
.
encrypted
.
len
 == 0)

649 goto 
Error
;

650 if (
ctx
->
cid_encryptor
->
	`decrypt_cid
(ctx->cid_encryptor, &
packet
->
cid
.
dest
.
plaintext
,

651 
packet
->
cid
.
dest
.
encrypted
.
base
, packet->cid.dest.encrypted.
len
) == 
SIZE_MAX
)

652 goto 
Error
;

654 
packet
->
cid
.
dest
.
plaintext
 = 
quicly_cid_plaintext_invalid
;

656 
packet
->
cid
.
dest
.
might_be_client_generated
 = 0;

659 switch (
packet
->
version
) {

660 case 
QUICLY_PROTOCOL_VERSION_CURRENT
:

661 case 
QUICLY_PROTOCOL_VERSION_DRAFT27
:

663 if ((
packet
->
octets
.
base
[0] & 
QUICLY_PACKET_TYPE_BITMASK
) == 
QUICLY_PACKET_TYPE_RETRY
) {

665 if (
src_end
 - 
src
 <= 
PTLS_AESGCM_TAG_SIZE
)

666 goto 
Error
;

667 
packet
->
token
 = 
	`ptls_iovec_init
(
src
, 
src_end
 - src - 
PTLS_AESGCM_TAG_SIZE
);

668 
src
 += 
packet
->
token
.
len
;

669 
packet
->
encrypted_off
 = 
src
 - packet->
octets
.
base
;

672 if ((
packet
->
octets
.
base
[0] & 
QUICLY_PACKET_TYPE_BITMASK
) == 
QUICLY_PACKET_TYPE_INITIAL
) {

674 
uint64_t
 
token_len
;

675 if ((
token_len
 = 
	`quicly_decodev
(&
src
, 
src_end
)) == 
UINT64_MAX
)

676 goto 
Error
;

677 if (
src_end
 - 
src
 < 
token_len
)

678 goto 
Error
;

679 
packet
->
token
 = 
	`ptls_iovec_init
(
src
, 
token_len
);

680 
src
 += 
token_len
;

682 if ((
rest_length
 = 
	`quicly_decodev
(&
src
, 
src_end
)) == 
UINT64_MAX
)

683 goto 
Error
;

684 if (
rest_length
 < 1)

685 goto 
Error
;

686 if (
src_end
 - 
src
 < 
rest_length
)

687 goto 
Error
;

688 
packet
->
encrypted_off
 = 
src
 - packet->
octets
.
base
;

689 
packet
->
octets
.
len
 = packet->
encrypted_off
 + 
rest_length
;

694 
packet
->
encrypted_off
 = 
src
 - packet->
octets
.
base
;

696 
packet
->
_is_stateless_reset_cached
 = 
QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET
;

699 if (
ctx
->
cid_encryptor
 != 
NULL
) {

700 if (
src_end
 - 
src
 < 
QUICLY_MAX_CID_LEN_V1
)

701 goto 
Error
;

702 
size_t
 
local_cidl
 = 
ctx
->
cid_encryptor
->
	`decrypt_cid
(ctx->cid_encryptor, &
packet
->
cid
.
dest
.
plaintext
, 
src
, 0);

703 if (
local_cidl
 == 
SIZE_MAX
)

704 goto 
Error
;

705 
packet
->
cid
.
dest
.
encrypted
 = 
	`ptls_iovec_init
(
src
, 
local_cidl
);

706 
src
 += 
local_cidl
;

708 
packet
->
cid
.
dest
.
encrypted
 = 
	`ptls_iovec_init
(
NULL
, 0);

709 
packet
->
cid
.
dest
.
plaintext
 = 
quicly_cid_plaintext_invalid
;

711 
packet
->
cid
.
dest
.
might_be_client_generated
 = 0;

712 
packet
->
cid
.
src
 = 
	`ptls_iovec_init
(
NULL
, 0);

713 
packet
->
version
 = 0;

714 
packet
->
encrypted_off
 = 
src
 - packet->
octets
.
base
;

715 
packet
->
_is_stateless_reset_cached
 = 
QUICLY__DECODED_PACKET_CACHED_MAYBE_STATELESS_RESET
;

718 *
off
 += 
packet
->
octets
.
len
;

719 return 
packet
->
octets
.
len
;

721 
Error
:

722 return 
SIZE_MAX
;

723 
	}
}

725 
uint64_t
 
	$quicly_determine_packet_number
(
uint32_t
 
truncated
, 
size_t
 
num_bits
, 
uint64_t
 
expected
)

727 
uint64_t
 
win
 = (uint64_t)1 << 
num_bits
, 
candidate
 = (
expected
 & ~(win - 1)) | 
truncated
;

729 if (
candidate
 + 
win
 / 2 <= 
expected
)

730 return 
candidate
 + 
win
;

731 if (
candidate
 > 
expected
 + 
win
 / 2 && candidate >= win)

732 return 
candidate
 - 
win
;

733 return 
candidate
;

734 
	}
}

736 static void 
	$assert_consistency
(
quicly_conn_t
 *
conn
, int 
timer_must_be_in_future
)

738 if (
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
) {

739 
	`assert
(!
timer_must_be_in_future
 || 
conn
->
stash
.
now
 < conn->
egress
.
send_ack_at
);

743 if (
conn
->
egress
.
loss
.
sentmap
.
bytes_in_flight
 != 0 || conn->
super
.
remote
.
address_validation
.
send_probe
) {

744 
	`assert
(
conn
->
egress
.
loss
.
alarm_at
 != 
INT64_MAX
);

746 
	`assert
(
conn
->
egress
.
loss
.
loss_time
 == 
INT64_MAX
);

750 if (
timer_must_be_in_future
 && 
conn
->
super
.
remote
.
address_validation
.
validated
)

751 
	`assert
(
conn
->
stash
.
now
 < conn->
egress
.
loss
.
alarm_at
);

752 
	}
}

754 static int 
	$on_invalid_ack
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

756 if (
acked
)

757 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

759 
	}
}

761 static 
uint64_t
 
	$calc_next_pn_to_skip
(
ptls_context_t
 *
tlsctx
, 
uint64_t
 
next_pn
, 
uint32_t
 
cwnd
, uint64_t 
mtu
)

763 static 
__thread
 struct {

764 
uint32_t
 
values
[8];

765 
size_t
 
off
;

766 } 
cached_rand
;

768 if (
cached_rand
.
off
 == 0) {

769 
tlsctx
->
	`random_bytes
(
cached_rand
.
values
, sizeof(cached_rand.values));

770 
cached_rand
.
off
 = 
	`PTLS_ELEMENTSOF
(cached_rand.
values
);

774 
uint32_t
 
packet_cwnd
 = 
cwnd
 / 
mtu
;

775 if (
packet_cwnd
 < 32)

776 
packet_cwnd
 = 32;

777 
uint64_t
 
skip_after
 = 
cached_rand
.
values
[--cached_rand.
off
] % (16 * 
packet_cwnd
);

778 return 
next_pn
 + 1 + 
skip_after
;

779 
	}
}

781 static void 
	$init_max_streams
(struct 
st_quicly_max_streams_t
 *
m
)

783 
m
->
count
 = 0;

784 
	`quicly_maxsender_init
(&
m
->
blocked_sender
, -1);

785 
	}
}

787 static int 
	$update_max_streams
(struct 
st_quicly_max_streams_t
 *
m
, 
uint64_t
 
count
)

789 if (
count
 > (
uint64_t
)1 << 60)

790 return 
QUICLY_TRANSPORT_ERROR_STREAM_LIMIT
;

792 if (
m
->
count
 < count) {

793 
m
->
count
 = count;

794 if (
m
->
blocked_sender
.
max_acked
 < 
count
)

795 
m
->
blocked_sender
.
max_acked
 = 
count
;

799 
	}
}

801 int 
	$quicly_connection_is_ready
(
quicly_conn_t
 *
conn
)

803 return 
conn
->
application
 != 
NULL
;

804 
	}
}

806 static int 
	$stream_is_destroyable
(
quicly_stream_t
 *
stream
)

808 if (!
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
))

810 if (!
	`quicly_sendstate_transfer_complete
(&
stream
->
sendstate
))

812 switch (
stream
->
_send_aux
.
reset_stream
.
sender_state
) {

813 case 
QUICLY_SENDER_STATE_NONE
:

814 case 
QUICLY_SENDER_STATE_ACKED
:

820 
	}
}

822 static void 
	$sched_stream_control
(
quicly_stream_t
 *
stream
)

824 
	`assert
(
stream
->
stream_id
 >= 0);

826 if (!
	`quicly_linklist_is_linked
(&
stream
->
_send_aux
.
pending_link
.
control
))

827 
	`quicly_linklist_insert
(
stream
->
conn
->
egress
.
pending_streams
.
control
.
prev
, &stream->
_send_aux
.
pending_link
.control);

828 
	}
}

830 static void 
	$resched_stream_data
(
quicly_stream_t
 *
stream
)

832 if (
stream
->
stream_id
 < 0) {

833 
	`assert
(-4 <= 
stream
->
stream_id
);

834 
uint8_t
 
mask
 = 1 << -(1 + 
stream
->
stream_id
);

835 if (
stream
->
sendstate
.
pending
.
num_ranges
 != 0) {

836 
stream
->
conn
->
egress
.
pending_flows
 |= 
mask
;

838 
stream
->
conn
->
egress
.
pending_flows
 &= ~
mask
;

844 if (
stream
->
streams_blocked
)

847 
quicly_stream_scheduler_t
 *
scheduler
 = 
stream
->
conn
->
super
.
ctx
->
stream_scheduler
;

848 
scheduler
->
	`update_state
(scheduler, 
stream
);

849 
	}
}

851 static int 
	$should_send_max_data
(
quicly_conn_t
 *
conn
)

853 return 
	`quicly_maxsender_should_send_max
(&
conn
->
ingress
.
max_data
.
sender
, conn->ingress.max_data.
bytes_consumed
,

854 (
uint32_t
)
conn
->
super
.
ctx
->
transport_params
.
max_data
, 512);

855 
	}
}

857 static int 
	$should_send_max_stream_data
(
quicly_stream_t
 *
stream
)

859 if (
stream
->
recvstate
.
eos
 != 
UINT64_MAX
)

861 return 
	`quicly_maxsender_should_send_max
(&
stream
->
_send_aux
.
max_stream_data_sender
, stream->
recvstate
.
data_off
,

862 
stream
->
_recv_aux
.
window
, 512);

863 
	}
}

865 int 
	$quicly_stream_sync_sendbuf
(
quicly_stream_t
 *
stream
, int 
activate
)

867 int 
ret
;

869 if (
activate
) {

870 if ((
ret
 = 
	`quicly_sendstate_activate
(&
stream
->
sendstate
)) != 0)

871 return 
ret
;

874 
	`resched_stream_data
(
stream
);

876 
	}
}

878 void 
	$quicly_stream_sync_recvbuf
(
quicly_stream_t
 *
stream
, 
size_t
 
shift_amount
)

880 
stream
->
recvstate
.
data_off
 += 
shift_amount
;

881 if (
stream
->
stream_id
 >= 0) {

882 if (
	`should_send_max_stream_data
(
stream
))

883 
	`sched_stream_control
(
stream
);

885 
	}
}

887 static int 
	$schedule_path_challenge_frame
(
quicly_conn_t
 *
conn
, int 
is_response
, const 
uint8_t
 *
data
)

889 struct 
st_quicly_pending_path_challenge_t
 *
pending
;

891 if ((
pending
 = 
	`malloc
(sizeof(struct 
st_quicly_pending_path_challenge_t
))) == 
NULL
)

892 return 
PTLS_ERROR_NO_MEMORY
;

894 
pending
->
next
 = 
NULL
;

895 
pending
->
is_response
 = is_response;

896 
	`memcpy
(
pending
->
data
, data, 
QUICLY_PATH_CHALLENGE_DATA_LEN
);

898 *
conn
->
egress
.
path_challenge
.
tail_ref
 = 
pending
;

899 
conn
->
egress
.
path_challenge
.
tail_ref
 = &
pending
->
next
;

901 
	}
}

906 static 
size_t
 
	$local_cid_size
(const 
quicly_conn_t
 *
conn
)

908 
	`PTLS_BUILD_ASSERT
(
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
 < 
SIZE_MAX
 / sizeof(
uint64_t
));

911 if (
conn
->
super
.
ctx
->
cid_encryptor
 == 
NULL
)

914 
uint64_t
 
capacity
 = 
conn
->
super
.
remote
.
transport_params
.
active_connection_id_limit
;

915 if (
capacity
 > 
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
)

916 
capacity
 = 
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
;

917 return 
capacity
;

918 
	}
}

923 static void 
	$schedule_retire_connection_id_frame
(
quicly_conn_t
 *
conn
, 
uint64_t
 
sequence
)

925 
	`quicly_retire_cid_push
(&
conn
->
egress
.
retire_cid
, 
sequence
);

926 
conn
->
egress
.
pending_flows
 |= 
QUICLY_PENDING_FLOW_CID_FRAME_BIT
;

927 
	}
}

929 static int 
	$write_crypto_data
(
quicly_conn_t
 *
conn
, 
ptls_buffer_t
 *
tlsbuf
, 
size_t
 
epoch_offsets
[5])

931 
size_t
 
epoch
;

932 int 
ret
;

934 if (
tlsbuf
->
off
 == 0)

937 for (
epoch
 = 0; epoch < 4; ++epoch) {

938 
size_t
 
len
 = 
epoch_offsets
[
epoch
 + 1] - epoch_offsets[epoch];

939 if (
len
 == 0)

941 
quicly_stream_t
 *
stream
 = 
	`quicly_get_stream
(
conn
, -(
quicly_stream_id_t
)(1 + 
epoch
));

942 
	`assert
(
stream
 != 
NULL
);

943 if ((
ret
 = 
	`quicly_streambuf_egress_write
(
stream
, 
tlsbuf
->
base
 + 
epoch_offsets
[
epoch
], 
len
)) != 0)

944 return 
ret
;

948 
	}
}

950 void 
	$crypto_stream_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
)

952 
quicly_conn_t
 *
conn
 = 
stream
->conn;

953 
size_t
 
in_epoch
 = -(1 + 
stream
->
stream_id
), 
epoch_offsets
[5] = {0};

954 
ptls_iovec_t
 
input
;

955 
ptls_buffer_t
 
output
;

957 if (
	`quicly_streambuf_ingress_receive
(
stream
, 
off
, 
src
, 
len
) != 0)

960 
	`ptls_buffer_init
(&
output
, "", 0);

963 while ((
input
 = 
	`quicly_streambuf_ingress_get
(
stream
)).
len
 != 0) {

964 int 
handshake_result
 = 
	`ptls_handle_message
(
conn
->
crypto
.
tls
, &
output
, 
epoch_offsets
, 
in_epoch
, 
input
.
base
, input.
len
,

965 &
conn
->
crypto
.
handshake_properties
);

966 
	`quicly_streambuf_ingress_shift
(
stream
, 
input
.
len
);

967 
	`QUICLY_PROBE
(
CRYPTO_HANDSHAKE
, 
conn
, conn->
stash
.
now
, 
handshake_result
);

968 switch (
handshake_result
) {

970 case 
PTLS_ERROR_IN_PROGRESS
:

973 
	`initiate_close
(
conn
,

974 
	`PTLS_ERROR_GET_CLASS
(
handshake_result
) == 
PTLS_ERROR_CLASS_SELF_ALERT
 ? handshake_result

975 : 
QUICLY_TRANSPORT_ERROR_INTERNAL
,

976 
QUICLY_FRAME_TYPE_CRYPTO
, 
NULL
);

977 goto 
Exit
;

980 if (
conn
->
application
 != 
NULL
 && !conn->application->
one_rtt_writable
 &&

981 
conn
->
application
->
cipher
.
egress
.
key
.
aead
 != 
NULL
) {

982 
	`assert
(
	`quicly_is_client
(
conn
));

983 if (
conn
->
crypto
.
handshake_properties
.
client
.
early_data_acceptance
 == 
PTLS_EARLY_DATA_REJECTED
) {

984 
	`dispose_cipher
(&
conn
->
application
->
cipher
.
egress
.
key
);

985 
conn
->
application
->
cipher
.
egress
.
key
 = (struct 
st_quicly_cipher_context_t
){
NULL
};

987 int 
ret
;

988 if ((
ret
 = 
	`discard_sentmap_by_epoch
(
conn
, 1u << 
QUICLY_EPOCH_1RTT
)) != 0) {

989 
	`initiate_close
(
conn
, 
ret
, 
QUICLY_FRAME_TYPE_CRYPTO
, 
NULL
);

990 goto 
Exit
;

995 
	`write_crypto_data
(
conn
, &
output
, 
epoch_offsets
);

997 
Exit
:

998 
	`ptls_buffer_dispose
(&
output
);

999 
	}
}

1001 static void 
	$init_stream_properties
(
quicly_stream_t
 *
stream
, 
uint32_t
 
initial_max_stream_data_local
,

1002 
uint64_t
 
initial_max_stream_data_remote
)

1004 int 
is_client
 = 
	`quicly_is_client
(
stream
->
conn
);

1006 if (
	`quicly_stream_has_send_side
(
is_client
, 
stream
->
stream_id
)) {

1007 
	`quicly_sendstate_init
(&
stream
->
sendstate
);

1009 
	`quicly_sendstate_init_closed
(&
stream
->
sendstate
);

1011 if (
	`quicly_stream_has_receive_side
(
is_client
, 
stream
->
stream_id
)) {

1012 
	`quicly_recvstate_init
(&
stream
->
recvstate
);

1014 
	`quicly_recvstate_init_closed
(&
stream
->
recvstate
);

1016 
stream
->
streams_blocked
 = 0;

1018 
stream
->
_send_aux
.
max_stream_data
 = 
initial_max_stream_data_remote
;

1019 
stream
->
_send_aux
.
stop_sending
.
sender_state
 = 
QUICLY_SENDER_STATE_NONE
;

1020 
stream
->
_send_aux
.
stop_sending
.
error_code
 = 0;

1021 
stream
->
_send_aux
.
reset_stream
.
sender_state
 = 
QUICLY_SENDER_STATE_NONE
;

1022 
stream
->
_send_aux
.
reset_stream
.
error_code
 = 0;

1023 
	`quicly_maxsender_init
(&
stream
->
_send_aux
.
max_stream_data_sender
, 
initial_max_stream_data_local
);

1024 
stream
->
_send_aux
.
blocked
 = 
QUICLY_SENDER_STATE_NONE
;

1025 
	`quicly_linklist_init
(&
stream
->
_send_aux
.
pending_link
.
control
);

1026 
	`quicly_linklist_init
(&
stream
->
_send_aux
.
pending_link
.
default_scheduler
);

1028 
stream
->
_recv_aux
.
window
 = 
initial_max_stream_data_local
;

1036 
uint32_t
 
fragments_minmax
 = (uint32_t)(
stream
->
conn
->
super
.
ctx
->
transport_params
.
max_streams_uni
 +

1037 
stream
->
conn
->
super
.
ctx
->
transport_params
.
max_streams_bidi
);

1038 if (
fragments_minmax
 < 63)

1039 
fragments_minmax
 = 63;

1040 if ((
stream
->
_recv_aux
.
max_ranges
 = 
initial_max_stream_data_local
 / 1024) < 
fragments_minmax
)

1041 
stream
->
_recv_aux
.
max_ranges
 = 
fragments_minmax
;

1042 
	}
}

1044 static void 
	$dispose_stream_properties
(
quicly_stream_t
 *
stream
)

1046 
	`quicly_sendstate_dispose
(&
stream
->
sendstate
);

1047 
	`quicly_recvstate_dispose
(&
stream
->
recvstate
);

1048 
	`quicly_maxsender_dispose
(&
stream
->
_send_aux
.
max_stream_data_sender
);

1049 
	`quicly_linklist_unlink
(&
stream
->
_send_aux
.
pending_link
.
control
);

1050 
	`quicly_linklist_unlink
(&
stream
->
_send_aux
.
pending_link
.
default_scheduler
);

1051 
	}
}

1053 static 
quicly_stream_t
 *
	$open_stream
(
quicly_conn_t
 *
conn
, 
uint64_t
 
stream_id
, 
uint32_t
 
initial_max_stream_data_local
,

1054 
uint64_t
 
initial_max_stream_data_remote
)

1056 
quicly_stream_t
 *
stream
;

1058 if ((
stream
 = 
	`malloc
(sizeof(*stream))) == 
NULL
)

1059 return 
NULL
;

1060 
stream
->
conn
 = conn;

1061 
stream
->
stream_id
 = stream_id;

1062 
stream
->
callbacks
 = 
NULL
;

1063 
stream
->
data
 = 
NULL
;

1065 int 
r
;

1066 
khiter_t
 
iter
 = 
	`kh_put
(
quicly_stream_t
, 
conn
->
streams
, 
stream_id
, &
r
);

1067 
	`assert
(
iter
 != 
	`kh_end
(
conn
->
streams
));

1068 
	`kh_val
(
conn
->
streams
, 
iter
) = 
stream
;

1070 
	`init_stream_properties
(
stream
, 
initial_max_stream_data_local
, 
initial_max_stream_data_remote
);

1072 return 
stream
;

1073 
	}
}

1075 static struct 
st_quicly_conn_streamgroup_state_t
 *
	$get_streamgroup_state
(
quicly_conn_t
 *
conn
, 
quicly_stream_id_t
 
stream_id
)

1077 if (
	`quicly_is_client
(
conn
) == 
	`quicly_stream_is_client_initiated
(
stream_id
)) {

1078 return 
	`quicly_stream_is_unidirectional
(
stream_id
) ? &
conn
->
super
.
local
.
uni
 : &conn->super.local.
bidi
;

1080 return 
	`quicly_stream_is_unidirectional
(
stream_id
) ? &
conn
->
super
.
remote
.
uni
 : &conn->super.remote.
bidi
;

1082 
	}
}

1084 static int 
	$should_send_max_streams
(
quicly_conn_t
 *
conn
, int 
uni
)

1086 
uint64_t
 
concurrency
;

1087 
quicly_maxsender_t
 *
maxsender
;

1088 struct 
st_quicly_conn_streamgroup_state_t
 *
group
;

1090 #define 
	#INIT_VARS
(
type
) \

1092 
concurrency
 = 
conn
->
super
.
ctx
->
transport_params
.
max_streams_
##
type
; \

1093 
maxsender
 = &
conn
->
ingress
.
max_streams
.
type
; \

1094 
group
 = &
conn
->
super
.
remote
.
type
; \

1095 } while (0)

	)

1096 if (
uni
) {

1097 
	`INIT_VARS
(
uni
);

1099 
	`INIT_VARS
(
bidi
);

1101 #undef 
INIT_VARS


1103 if (
concurrency
 == 0)

1106 if (!
	`quicly_maxsender_should_send_max
(
maxsender
, 
group
->
next_stream_id
 / 4, group->
num_streams
, 768))

1110 
	}
}

1112 static void 
	$destroy_stream
(
quicly_stream_t
 *
stream
, int 
err
)

1114 
quicly_conn_t
 *
conn
 = 
stream
->conn;

1116 
	`QUICLY_PROBE
(
STREAM_ON_DESTROY
, 
conn
, conn->
stash
.
now
, 
stream
, 
err
);

1118 if (
stream
->
callbacks
 != 
NULL
)

1119 
stream
->
callbacks
->
	`on_destroy
(stream, 
err
);

1121 
khiter_t
 
iter
 = 
	`kh_get
(
quicly_stream_t
, 
conn
->
streams
, 
stream
->
stream_id
);

1122 
	`assert
(
iter
 != 
	`kh_end
(
conn
->
streams
));

1123 
	`kh_del
(
quicly_stream_t
, 
conn
->
streams
, 
iter
);

1125 if (
stream
->
stream_id
 < 0) {

1126 
size_t
 
epoch
 = -(1 + 
stream
->
stream_id
);

1127 
stream
->
conn
->
egress
.
pending_flows
 &= ~(
uint8_t
)(1 << 
epoch
);

1129 struct 
st_quicly_conn_streamgroup_state_t
 *
group
 = 
	`get_streamgroup_state
(
conn
, 
stream
->
stream_id
);

1130 --
group
->
num_streams
;

1133 
	`dispose_stream_properties
(
stream
);

1135 if (
conn
->
application
 != 
NULL
) {

1140 if (
	`should_send_max_streams
(
conn
, 
	`quicly_stream_is_unidirectional
(
stream
->
stream_id
)))

1141 
conn
->
egress
.
send_ack_at
 = 0;

1144 
	`free
(
stream
);

1145 
	}
}

1147 static void 
	$destroy_all_streams
(
quicly_conn_t
 *
conn
, int 
err
, int 
including_crypto_streams
)

1149 
quicly_stream_t
 *
stream
;

1150 
	`kh_foreach_value
(
conn
->
streams
, 
stream
, {

1152 if (
including_crypto_streams
 || 
stream
->
stream_id
 >= 0)

1153 
	`destroy_stream
(
stream
, 
err
);

1155 
	`assert
(
	`quicly_num_streams
(
conn
) == 0);

1156 
	}
}

1158 int 
	$quicly_foreach_stream
(
quicly_conn_t
 *
conn
, void *
thunk
, int (*
cb
)(void *thunk, 
quicly_stream_t
 *
stream
))

1160 
quicly_stream_t
 *
stream
;

1161 
	`kh_foreach_value
(
conn
->
streams
, 
stream
, {

1162 if (
stream
->
stream_id
 >= 0) {

1163 int 
ret
 = 
	`cb
(
thunk
, 
stream
);

1164 if (
ret
 != 0)

1165 return 
ret
;

1169 
	}
}

1171 
quicly_stream_t
 *
	$quicly_get_stream
(
quicly_conn_t
 *
conn
, 
quicly_stream_id_t
 
stream_id
)

1173 
khiter_t
 
iter
 = 
	`kh_get
(
quicly_stream_t
, 
conn
->
streams
, 
stream_id
);

1174 if (
iter
 != 
	`kh_end
(
conn
->
streams
))

1175 return 
	`kh_val
(
conn
->
streams
, 
iter
);

1176 return 
NULL
;

1177 
	}
}

1179 
ptls_t
 *
	$quicly_get_tls
(
quicly_conn_t
 *
conn
)

1181 return 
conn
->
crypto
.
tls
;

1182 
	}
}

1184 
uint32_t
 
	$quicly_num_streams_by_group
(
quicly_conn_t
 *
conn
, int 
uni
, int 
locally_initiated
)

1186 int 
server_initiated
 = 
	`quicly_is_client
(
conn
) != 
locally_initiated
;

1187 struct 
st_quicly_conn_streamgroup_state_t
 *
state
 = 
	`get_streamgroup_state
(
conn
, 
uni
 * 2 + 
server_initiated
);

1188 return 
state
->
num_streams
;

1189 
	}
}

1191 int 
	$quicly_get_stats
(
quicly_conn_t
 *
conn
, 
quicly_stats_t
 *
stats
)

1194 
	`memcpy
(
stats
, &
conn
->
super
.stats, sizeof(conn->super.stats));

1197 
stats
->
rtt
 = 
conn
->
egress
.
loss
.rtt;

1198 
stats
->
cc
 = 
conn
->
egress
.cc;

1200 
	}
}

1202 
quicly_stream_id_t
 
	$quicly_get_ingress_max_streams
(
quicly_conn_t
 *
conn
, int 
uni
)

1204 
quicly_maxsender_t
 *
maxsender
 = 
uni
 ? &
conn
->
ingress
.
max_streams
.uni : &conn->ingress.max_streams.
bidi
;

1205 return 
maxsender
->
max_committed
;

1206 
	}
}

1208 void 
	$quicly_get_max_data
(
quicly_conn_t
 *
conn
, 
uint64_t
 *
send_permitted
, uint64_t *
sent
, uint64_t *
consumed
)

1210 if (
send_permitted
 != 
NULL
)

1211 *
send_permitted
 = 
conn
->
egress
.
max_data
.
permitted
;

1212 if (
sent
 != 
NULL
)

1213 *
sent
 = 
conn
->
egress
.
max_data
.sent;

1214 if (
consumed
 != 
NULL
)

1215 *
consumed
 = 
conn
->
ingress
.
max_data
.
bytes_consumed
;

1216 
	}
}

1218 static void 
	$update_idle_timeout
(
quicly_conn_t
 *
conn
, int 
is_in_receive
)

1220 if (!
is_in_receive
 && !
conn
->
idle_timeout
.
should_rearm_on_send
)

1224 
int64_t
 
idle_msec
 = 
INT64_MAX
;

1225 if (
conn
->
initial
 == 
NULL
 && conn->
handshake
 == NULL && conn->
super
.
remote
.
transport_params
.
max_idle_timeout
 != 0)

1226 
idle_msec
 = 
conn
->
super
.
remote
.
transport_params
.
max_idle_timeout
;

1227 if (
conn
->
super
.
ctx
->
transport_params
.
max_idle_timeout
 != 0 && conn->super.ctx->transport_params.max_idle_timeout < 
idle_msec
)

1228 
idle_msec
 = 
conn
->
super
.
ctx
->
transport_params
.
max_idle_timeout
;

1230 if (
idle_msec
 == 
INT64_MAX
)

1233 
uint32_t
 
three_pto
 = 3 * 
	`quicly_rtt_get_pto
(&
conn
->
egress
.
loss
.
rtt
, conn->
super
.
ctx
->
transport_params
.
max_ack_delay
,

1234 
conn
->
egress
.
loss
.
conf
->
min_pto
);

1235 
conn
->
idle_timeout
.
at
 = conn->
stash
.
now
 + (
idle_msec
 > 
three_pto
 ? idle_msec : three_pto);

1236 
conn
->
idle_timeout
.
should_rearm_on_send
 = 
is_in_receive
;

1237 
	}
}

1239 static int 
	$scheduler_can_send
(
quicly_conn_t
 *
conn
)

1243 switch (
conn
->
super
.
state
) {

1244 case 
QUICLY_STATE_FIRSTFLIGHT
:

1245 case 
QUICLY_STATE_CONNECTED
:

1252 if (
conn
->
application
 == 
NULL
)

1255 int 
conn_is_saturated
 = !(
conn
->
egress
.
max_data
.
sent
 < conn->egress.max_data.
permitted
);

1256 return 
conn
->
super
.
ctx
->
stream_scheduler
->
	`can_send
(conn->super.ctx->stream_scheduler, conn, 
conn_is_saturated
);

1257 
	}
}

1259 static void 
	$update_loss_alarm
(
quicly_conn_t
 *
conn
, int 
is_after_send
)

1261 int 
has_outstanding
 = 
conn
->
egress
.
loss
.
sentmap
.
bytes_in_flight
 != 0 || conn->
super
.
remote
.
address_validation
.
send_probe
,

1262 
handshake_is_in_progress
 = 
conn
->
initial
 != 
NULL
 || conn->
handshake
 != NULL;

1263 
	`quicly_loss_update_alarm
(&
conn
->
egress
.
loss
, conn->
stash
.
now
, conn->egress.
last_retransmittable_sent_at
, 
has_outstanding
,

1264 
	`scheduler_can_send
(
conn
), 
handshake_is_in_progress
, conn->
egress
.
max_data
.
sent
, 
is_after_send
);

1265 
	}
}

1267 static int 
	$create_handshake_flow
(
quicly_conn_t
 *
conn
, 
size_t
 
epoch
)

1269 
quicly_stream_t
 *
stream
;

1270 int 
ret
;

1272 if ((
stream
 = 
	`open_stream
(
conn
, -(
quicly_stream_id_t
)(1 + 
epoch
), 65536, 65536)) == 
NULL
)

1273 return 
PTLS_ERROR_NO_MEMORY
;

1274 if ((
ret
 = 
	`quicly_streambuf_create
(
stream
, sizeof(
quicly_streambuf_t
))) != 0) {

1275 
	`destroy_stream
(
stream
, 
ret
);

1276 return 
ret
;

1278 
stream
->
callbacks
 = &
crypto_stream_callbacks
;

1281 
	}
}

1283 static void 
	$destroy_handshake_flow
(
quicly_conn_t
 *
conn
, 
size_t
 
epoch
)

1285 
quicly_stream_t
 *
stream
 = 
	`quicly_get_stream
(
conn
, -(
quicly_stream_id_t
)(1 + 
epoch
));

1286 if (
stream
 != 
NULL
)

1287 
	`destroy_stream
(
stream
, 0);

1288 
	}
}

1290 static struct 
st_quicly_pn_space_t
 *
	$alloc_pn_space
(
size_t
 
sz
, 
uint32_t
 
packet_tolerance
)

1292 struct 
st_quicly_pn_space_t
 *
space
;

1294 if ((
space
 = 
	`malloc
(
sz
)) == 
NULL
)

1295 return 
NULL
;

1297 
	`quicly_ranges_init
(&
space
->
ack_queue
);

1298 
space
->
largest_pn_received_at
 = 
INT64_MAX
;

1299 
space
->
next_expected_packet_number
 = 0;

1300 
space
->
unacked_count
 = 0;

1301 
space
->
packet_tolerance
 = packet_tolerance;

1302 
space
->
ignore_order
 = 0;

1303 if (
sz
 != sizeof(*
space
))

1304 
	`memset
((
uint8_t
 *)
space
 + sizeof(*space), 0, 
sz
 - sizeof(*space));

1306 return 
space
;

1307 
	}
}

1309 static void 
	$do_free_pn_space
(struct 
st_quicly_pn_space_t
 *
space
)

1311 
	`quicly_ranges_clear
(&
space
->
ack_queue
);

1312 
	`free
(
space
);

1313 
	}
}

1315 static int 
	$record_pn
(
quicly_ranges_t
 *
ranges
, 
uint64_t
 
pn
, int *
is_out_of_order
)

1317 int 
ret
;

1319 *
is_out_of_order
 = 0;

1321 if (
ranges
->
num_ranges
 != 0) {

1323 if (
ranges
->ranges[ranges->
num_ranges
 - 1].
end
 == 
pn
) {

1324 
ranges
->ranges[ranges->
num_ranges
 - 1].
end
 = 
pn
 + 1;

1327 *
is_out_of_order
 = 1;

1331 if ((
ret
 = 
	`quicly_ranges_add
(
ranges
, 
pn
, pn + 1)) != 0)

1332 return 
ret
;

1333 if (
ranges
->
num_ranges
 > 
QUICLY_MAX_ACK_BLOCKS
)

1334 
	`quicly_ranges_drop_by_range_indices
(
ranges
, ranges->
num_ranges
 - 
QUICLY_MAX_ACK_BLOCKS
, ranges->num_ranges);

1337 
	}
}

1339 static int 
	$record_receipt
(struct 
st_quicly_pn_space_t
 *
space
, 
uint64_t
 
pn
, int 
is_ack_only
, 
int64_t
 
now
, int64_t *
send_ack_at
)

1341 int 
ret
, 
ack_now
, 
is_out_of_order
;

1343 if ((
ret
 = 
	`record_pn
(&
space
->
ack_queue
, 
pn
, &
is_out_of_order
)) != 0)

1344 goto 
Exit
;

1346 
ack_now
 = 
is_out_of_order
 && !
space
->
ignore_order
 && !
is_ack_only
;

1349 if (
space
->
ack_queue
.
ranges
[space->ack_queue.
num_ranges
 - 1].
end
 == 
pn
 + 1)

1350 
space
->
largest_pn_received_at
 = 
now
;

1353 if (!
is_ack_only
) {

1354 
space
->
unacked_count
++;

1355 if (
space
->
unacked_count
 >= space->
packet_tolerance
)

1356 
ack_now
 = 1;

1359 if (
ack_now
) {

1360 *
send_ack_at
 = 
now
;

1361 } else if (*
send_ack_at
 == 
INT64_MAX
 && 
space
->
unacked_count
 != 0) {

1362 *
send_ack_at
 = 
now
 + 
QUICLY_DELAYED_ACK_TIMEOUT
;

1365 
ret
 = 0;

1366 
Exit
:

1367 return 
ret
;

1368 
	}
}

1370 static void 
	$free_handshake_space
(struct 
st_quicly_handshake_space_t
 **
space
)

1372 if (*
space
 != 
NULL
) {

1373 if ((*
space
)->
cipher
.
ingress
.
aead
 != 
NULL
)

1374 
	`dispose_cipher
(&(*
space
)->
cipher
.
ingress
);

1375 if ((*
space
)->
cipher
.
egress
.
aead
 != 
NULL
)

1376 
	`dispose_cipher
(&(*
space
)->
cipher
.
egress
);

1377 
	`do_free_pn_space
(&(*
space
)->
super
);

1378 *
space
 = 
NULL
;

1380 
	}
}

1382 static int 
	$setup_cipher
(
quicly_conn_t
 *
conn
, 
size_t
 
epoch
, int 
is_enc
, 
ptls_cipher_context_t
 **
hp_ctx
,

1383 
ptls_aead_context_t
 **
aead_ctx
, 
ptls_aead_algorithm_t
 *
aead
, 
ptls_hash_algorithm_t
 *
hash
,

1384 const void *
secret
)

1387 
quicly_crypto_engine_t
 *
engine
 = 
conn
 != 
NULL
 ? conn->
super
.
ctx
->
crypto_engine
 : &
quicly_default_crypto_engine
;

1389 return 
engine
->
	`setup_cipher
(engine, 
conn
, 
epoch
, 
is_enc
, 
hp_ctx
, 
aead_ctx
, 
aead
, 
hash
, 
secret
);

1390 
	}
}

1392 static int 
	$setup_handshake_space_and_flow
(
quicly_conn_t
 *
conn
, 
size_t
 
epoch
)

1394 struct 
st_quicly_handshake_space_t
 **
space
 = 
epoch
 == 
QUICLY_EPOCH_INITIAL
 ? &
conn
->
initial
 : &conn->
handshake
;

1395 if ((*
space
 = (void *)
	`alloc_pn_space
(sizeof(struct 
st_quicly_handshake_space_t
), 1)) == 
NULL
)

1396 return 
PTLS_ERROR_NO_MEMORY
;

1397 return 
	`create_handshake_flow
(
conn
, 
epoch
);

1398 
	}
}

1400 static void 
	$free_application_space
(struct 
st_quicly_application_space_t
 **
space
)

1402 if (*
space
 != 
NULL
) {

1403 #define 
	#DISPOSE_INGRESS
(
label
, 
func
) \

1404 if ((*
space
)->
cipher
.
ingress
.
label
 != 
NULL
) \

1405 
	`func
((*
space
)->
cipher
.
ingress
.
label
)

	)

1406 
	`DISPOSE_INGRESS
(
header_protection
.
zero_rtt
, 
ptls_cipher_free
);

1407 
	`DISPOSE_INGRESS
(
header_protection
.
one_rtt
, 
ptls_cipher_free
);

1408 
	`DISPOSE_INGRESS
(
aead
[0], 
ptls_aead_free
);

1409 
	`DISPOSE_INGRESS
(
aead
[1], 
ptls_aead_free
);

1410 #undef 
DISPOSE_INGRESS


1411 if ((*
space
)->
cipher
.
egress
.
key
.
aead
 != 
NULL
)

1412 
	`dispose_cipher
(&(*
space
)->
cipher
.
egress
.
key
);

1413 
	`ptls_clear_memory
((*
space
)->
cipher
.
egress
.
secret
, sizeof((*space)->cipher.egress.secret));

1414 
	`do_free_pn_space
(&(*
space
)->
super
);

1415 *
space
 = 
NULL
;

1417 
	}
}

1419 static int 
	$setup_application_space
(
quicly_conn_t
 *
conn
)

1421 if ((
conn
->
application
 =

1422 (void *)
	`alloc_pn_space
(sizeof(struct 
st_quicly_application_space_t
), 
QUICLY_DEFAULT_PACKET_TOLERANCE
)) == 
NULL
)

1423 return 
PTLS_ERROR_NO_MEMORY
;

1426 
conn
->
application
->
cipher
.
egress
.
key_update_pn
.
last
 = 0;

1427 
conn
->
application
->
cipher
.
egress
.
key_update_pn
.
next
 = 
UINT64_MAX
;

1429 return 
	`create_handshake_flow
(
conn
, 
QUICLY_EPOCH_1RTT
);

1430 
	}
}

1432 static int 
	$discard_handshake_context
(
quicly_conn_t
 *
conn
, 
size_t
 
epoch
)

1434 int 
ret
;

1436 
	`assert
(
epoch
 == 
QUICLY_EPOCH_INITIAL
 || epoch == 
QUICLY_EPOCH_HANDSHAKE
);

1438 if ((
ret
 = 
	`discard_sentmap_by_epoch
(
conn
, 1u << 
epoch
)) != 0)

1439 return 
ret
;

1440 
	`destroy_handshake_flow
(
conn
, 
epoch
);

1441 
	`free_handshake_space
(
epoch
 == 
QUICLY_EPOCH_INITIAL
 ? &
conn
->
initial
 : &conn->
handshake
);

1444 
	}
}

1446 static int 
	$apply_remote_transport_params
(
quicly_conn_t
 *
conn
)

1448 int 
ret
;

1450 
conn
->
egress
.
max_data
.
permitted
 = conn->
super
.
remote
.
transport_params
.max_data;

1451 if ((
ret
 = 
	`update_max_streams
(&
conn
->
egress
.
max_streams
.
uni
, conn->
super
.
remote
.
transport_params
.
max_streams_uni
)) != 0)

1452 return 
ret
;

1453 if ((
ret
 = 
	`update_max_streams
(&
conn
->
egress
.
max_streams
.
bidi
, conn->
super
.
remote
.
transport_params
.
max_streams_bidi
)) != 0)

1454 return 
ret
;

1457 
	}
}

1459 static int 
	$update_1rtt_key
(
quicly_conn_t
 *
conn
, 
ptls_cipher_suite_t
 *
cipher
, int 
is_enc
, 
ptls_aead_context_t
 **
aead
,

1460 
uint8_t
 *
secret
)

1462 
uint8_t
 
new_secret
[
PTLS_MAX_DIGEST_SIZE
];

1463 
ptls_aead_context_t
 *
new_aead
 = 
NULL
;

1464 int 
ret
;

1467 if ((
ret
 = 
	`ptls_hkdf_expand_label
(
cipher
->
hash
, 
new_secret
, cipher->hash->
digest_size
,

1468 
	`ptls_iovec_init
(
secret
, 
cipher
->
hash
->
digest_size
), "quic ku", ptls_iovec_init(
NULL
, 0),

1469 
NULL
)) != 0)

1470 goto 
Exit
;

1471 if ((
ret
 = 
	`setup_cipher
(
conn
, 
QUICLY_EPOCH_1RTT
, 
is_enc
, 
NULL
, &
new_aead
, 
cipher
->
aead
, cipher->
hash
, 
new_secret
)) != 0)

1472 goto 
Exit
;

1475 if (*
aead
 != 
NULL
)

1476 
	`ptls_aead_free
(*
aead
);

1477 *
aead
 = 
new_aead
;

1478 
new_aead
 = 
NULL
;

1479 
	`memcpy
(
secret
, 
new_secret
, 
cipher
->
hash
->
digest_size
);

1481 
ret
 = 0;

1482 
Exit
:

1483 if (
new_aead
 != 
NULL
)

1484 
	`ptls_aead_free
(
new_aead
);

1485 
	`ptls_clear_memory
(
new_secret
, 
cipher
->
hash
->
digest_size
);

1486 return 
ret
;

1487 
	}
}

1489 static int 
	$update_1rtt_egress_key
(
quicly_conn_t
 *
conn
)

1491 struct 
st_quicly_application_space_t
 *
space
 = 
conn
->
application
;

1492 
ptls_cipher_suite_t
 *
cipher
 = 
	`ptls_get_cipher
(
conn
->
crypto
.
tls
);

1493 int 
ret
;

1496 if ((
ret
 = 
	`update_1rtt_key
(
conn
, 
cipher
, 1, &
space
->cipher.
egress
.
key
.
aead
, space->cipher.egress.
secret
)) != 0)

1497 return 
ret
;

1498 ++
space
->
cipher
.
egress
.
key_phase
;

1501 
space
->
cipher
.
egress
.
key_update_pn
.
last
 = 
conn
->egress.
packet_number
;

1502 
space
->
cipher
.
egress
.
key_update_pn
.
next
 = 
UINT64_MAX
;

1504 
	`QUICLY_PROBE
(
CRYPTO_SEND_KEY_UPDATE
, 
conn
, conn->
stash
.
now
, 
space
->
cipher
.
egress
.
key_phase
,

1505 
	`QUICLY_PROBE_HEXDUMP
(
space
->
cipher
.
egress
.
secret
, cipher->
hash
->
digest_size
));

1508 
	}
}

1510 static int 
	$received_key_update
(
quicly_conn_t
 *
conn
, 
uint64_t
 
newly_decrypted_key_phase
)

1512 struct 
st_quicly_application_space_t
 *
space
 = 
conn
->
application
;

1514 
	`assert
(
space
->
cipher
.
ingress
.
key_phase
.
decrypted
 < 
newly_decrypted_key_phase
);

1515 
	`assert
(
newly_decrypted_key_phase
 <= 
space
->
cipher
.
ingress
.
key_phase
.
prepared
);

1517 
space
->
cipher
.
ingress
.
key_phase
.
decrypted
 = 
newly_decrypted_key_phase
;

1519 
	`QUICLY_PROBE
(
CRYPTO_RECEIVE_KEY_UPDATE
, 
conn
, conn->
stash
.
now
, 
space
->
cipher
.
ingress
.
key_phase
.
decrypted
,

1520 
	`QUICLY_PROBE_HEXDUMP
(
space
->
cipher
.
ingress
.
secret
, 
	`ptls_get_cipher
(
conn
->
crypto
.
tls
)->
hash
->
digest_size
));

1522 if (
space
->
cipher
.
egress
.
key_phase
 < space->cipher.
ingress
.key_phase.
decrypted
) {

1523 return 
	`update_1rtt_egress_key
(
conn
);

1527 
	}
}

1529 static 
inline
 void 
	$update_open_count
(
quicly_context_t
 *
ctx
, 
ssize_t
 
delta
)

1531 if (
ctx
->
update_open_count
 != 
NULL
)

1532 
ctx
->
update_open_count
->
	`cb
(ctx->update_open_count, 
delta
);

1533 
	}
}

1535 void 
	$quicly_free
(
quicly_conn_t
 *
conn
)

1537 
	`lock_now
(
conn
, 0);

1539 
	`QUICLY_PROBE
(
FREE
, 
conn
, conn->
stash
.
now
);

1541 #if 
QUICLY_USE_EMBEDDED_PROBES
 || 
QUICLY_USE_DTRACE


1542 if (
	`QUICLY_CONN_STATS_ENABLED
()) {

1543 
quicly_stats_t
 
stats
;

1544 
	`quicly_get_stats
(
conn
, &
stats
);

1545 
	`QUICLY_PROBE
(
CONN_STATS
, 
conn
, conn->
stash
.
now
, &
stats
, sizeof(stats));

1548 
	`update_open_count
(
conn
->
super
.
ctx
, -1);

1550 
	`destroy_all_streams
(
conn
, 0, 1);

1551 
	`clear_datagram_frame_payloads
(
conn
);

1553 
	`quicly_maxsender_dispose
(&
conn
->
ingress
.
max_data
.
sender
);

1554 
	`quicly_maxsender_dispose
(&
conn
->
ingress
.
max_streams
.
uni
);

1555 
	`quicly_maxsender_dispose
(&
conn
->
ingress
.
max_streams
.
bidi
);

1556 while (
conn
->
egress
.
path_challenge
.
head
 != 
NULL
) {

1557 struct 
st_quicly_pending_path_challenge_t
 *
pending
 = 
conn
->
egress
.
path_challenge
.
head
;

1558 
conn
->
egress
.
path_challenge
.
head
 = 
pending
->
next
;

1559 
	`free
(
pending
);

1561 
	`quicly_loss_dispose
(&
conn
->
egress
.
loss
);

1563 
	`kh_destroy
(
quicly_stream_t
, 
conn
->
streams
);

1565 
	`assert
(!
	`quicly_linklist_is_linked
(&
conn
->
egress
.
pending_streams
.
blocked
.
uni
));

1566 
	`assert
(!
	`quicly_linklist_is_linked
(&
conn
->
egress
.
pending_streams
.
blocked
.
bidi
));

1567 
	`assert
(!
	`quicly_linklist_is_linked
(&
conn
->
egress
.
pending_streams
.
control
));

1568 
	`assert
(!
	`quicly_linklist_is_linked
(&
conn
->
super
.
_default_scheduler
.
active
));

1569 
	`assert
(!
	`quicly_linklist_is_linked
(&
conn
->
super
.
_default_scheduler
.
blocked
));

1571 
	`free_handshake_space
(&
conn
->
initial
);

1572 
	`free_handshake_space
(&
conn
->
handshake
);

1573 
	`free_application_space
(&
conn
->
application
);

1575 
	`ptls_buffer_dispose
(&
conn
->
crypto
.
transport_params
.
buf
);

1576 
	`ptls_free
(
conn
->
crypto
.
tls
);

1578 
	`unlock_now
(
conn
);

1580 
	`free
(
conn
->
token
.
base
);

1581 
	`free
(
conn
);

1582 
	}
}

1584 static int 
	$setup_initial_key
(struct 
st_quicly_cipher_context_t
 *
ctx
, 
ptls_cipher_suite_t
 *
cs
, const void *
master_secret
,

1585 const char *
label
, int 
is_enc
, 
quicly_conn_t
 *
conn
)

1587 
uint8_t
 
aead_secret
[
PTLS_MAX_DIGEST_SIZE
];

1588 int 
ret
;

1590 if ((
ret
 = 
	`ptls_hkdf_expand_label
(
cs
->
hash
, 
aead_secret
, cs->hash->
digest_size
,

1591 
	`ptls_iovec_init
(
master_secret
, 
cs
->
hash
->
digest_size
), 
label
, ptls_iovec_init(
NULL
, 0),

1592 
NULL
)) != 0)

1593 goto 
Exit
;

1594 if ((
ret
 = 
	`setup_cipher
(
conn
, 
QUICLY_EPOCH_INITIAL
, 
is_enc
, &
ctx
->
header_protection
, &ctx->
aead
, 
cs
->aead, cs->
hash
,

1595 
aead_secret
)) != 0)

1596 goto 
Exit
;

1598 
Exit
:

1599 
	`ptls_clear_memory
(
aead_secret
, sizeof(aead_secret));

1600 return 
ret
;

1601 
	}
}

1606 static int 
	$setup_initial_encryption
(
ptls_cipher_suite_t
 *
cs
, struct 
st_quicly_cipher_context_t
 *
ingress
,

1607 struct 
st_quicly_cipher_context_t
 *
egress
, 
ptls_iovec_t
 
cid
, int 
is_client
, ptls_iovec_t 
salt
,

1608 
quicly_conn_t
 *
conn
)

1610 static const char *
labels
[2] = {"client in", "server in"};

1611 
uint8_t
 
secret
[
PTLS_MAX_DIGEST_SIZE
];

1612 int 
ret
;

1615 if ((
ret
 = 
	`ptls_hkdf_extract
(
cs
->
hash
, 
secret
, 
salt
, 
cid
)) != 0)

1616 goto 
Exit
;

1619 if (
ingress
 != 
NULL
 && (
ret
 = 
	`setup_initial_key
(ingress, 
cs
, 
secret
, 
labels
[
is_client
], 0, 
conn
)) != 0)

1620 goto 
Exit
;

1621 if (
egress
 != 
NULL
 && (
ret
 = 
	`setup_initial_key
(egress, 
cs
, 
secret
, 
labels
[!
is_client
], 1, 
conn
)) != 0) {

1622 if (
ingress
 != 
NULL
)

1623 
	`dispose_cipher
(
ingress
);

1624 goto 
Exit
;

1627 
Exit
:

1628 
	`ptls_clear_memory
(
secret
, sizeof(secret));

1629 return 
ret
;

1630 
	}
}

1632 static int 
	$reinstall_initial_encryption
(
quicly_conn_t
 *
conn
, int 
err_code_if_unknown_version
)

1634 const struct 
st_ptls_salt_t
 *
salt
;

1637 if ((
salt
 = 
	`get_salt
(
conn
->
super
.
version
)) == 
NULL
)

1638 return 
err_code_if_unknown_version
;

1641 
	`dispose_cipher
(&
conn
->
initial
->
cipher
.
ingress
);

1642 
	`dispose_cipher
(&
conn
->
initial
->
cipher
.
egress
);

1645 return 
	`setup_initial_encryption
(

1646 
	`get_aes128gcmsha256
(
conn
->
super
.
ctx
), &conn->
initial
->
cipher
.
ingress
, &conn->initial->cipher.
egress
,

1647 
	`ptls_iovec_init
(
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
.cid, conn->super.remote.cid_set.cids[0].cid.
len
), 1,

1648 
	`ptls_iovec_init
(
salt
->
initial
, sizeof(salt->initial)), 
NULL
);

1649 
	}
}

1651 static int 
	$apply_stream_frame
(
quicly_stream_t
 *
stream
, 
quicly_stream_frame_t
 *
frame
)

1653 int 
ret
;

1655 
	`QUICLY_PROBE
(
STREAM_RECEIVE
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream, 
frame
->
offset
, frame->
data
.
len
);

1657 if (
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
))

1661 if (
stream
->
stream_id
 >= 0) {

1663 
uint64_t
 
max_stream_data
 = 
frame
->
offset
 + frame->
data
.
len
;

1664 if ((
int64_t
)
stream
->
_recv_aux
.
window
 < (int64_t)
max_stream_data
 - (int64_t)stream->
recvstate
.
data_off
)

1665 return 
QUICLY_TRANSPORT_ERROR_FLOW_CONTROL
;

1666 if (
stream
->
recvstate
.
received
.
ranges
[stream->recvstate.received.
num_ranges
 - 1].
end
 < 
max_stream_data
) {

1667 
uint64_t
 
newly_received
 =

1668 
max_stream_data
 - 
stream
->
recvstate
.
received
.
ranges
[stream->recvstate.received.
num_ranges
 - 1].
end
;

1669 if (
stream
->
conn
->
ingress
.
max_data
.
bytes_consumed
 + 
newly_received
 >

1670 
stream
->
conn
->
ingress
.
max_data
.
sender
.
max_committed
)

1671 return 
QUICLY_TRANSPORT_ERROR_FLOW_CONTROL
;

1672 
stream
->
conn
->
ingress
.
max_data
.
bytes_consumed
 += 
newly_received
;

1677 if (
frame
->
offset
 + frame->
data
.
len
 > 
stream
->
conn
->
super
.
ctx
->
max_crypto_bytes
)

1678 return 
QUICLY_TRANSPORT_ERROR_CRYPTO_BUFFER_EXCEEDED
;

1682 
size_t
 
apply_len
 = 
frame
->
data
.
len
;

1683 if ((
ret
 = 
	`quicly_recvstate_update
(&
stream
->
recvstate
, 
frame
->
offset
, &
apply_len
, frame->
is_fin
,

1684 
stream
->
_recv_aux
.
max_ranges
)) != 0)

1685 return 
ret
;

1687 if (
apply_len
 != 0 || 
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
)) {

1688 
uint64_t
 
buf_offset
 = 
frame
->
offset
 + frame->
data
.
len
 - 
apply_len
 - 
stream
->
recvstate
.
data_off
;

1689 const void *
apply_src
 = 
frame
->
data
.
base
 + frame->data.
len
 - 
apply_len
;

1690 
	`QUICLY_PROBE
(
STREAM_ON_RECEIVE
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream, (
size_t
)
buf_offset
, 
apply_src
, 
apply_len
);

1691 
stream
->
callbacks
->
	`on_receive
(stream, (
size_t
)
buf_offset
, 
apply_src
, 
apply_len
);

1692 if (
stream
->
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
)

1693 return 
QUICLY_ERROR_IS_CLOSING
;

1696 if (
	`should_send_max_stream_data
(
stream
))

1697 
	`sched_stream_control
(
stream
);

1699 if (
	`stream_is_destroyable
(
stream
))

1700 
	`destroy_stream
(
stream
, 0);

1703 
	}
}

1705 int 
	$quicly_encode_transport_parameter_list
(
ptls_buffer_t
 *
buf
, const 
quicly_transport_parameters_t
 *
params
,

1706 const 
quicly_cid_t
 *
original_dcid
, const quicly_cid_t *
initial_scid
,

1707 const 
quicly_cid_t
 *
retry_scid
, const void *
stateless_reset_token
, 
size_t
 
expand_by
)

1709 int 
ret
;

1711 #define 
	#PUSH_TP
(
buf
, 
id
, 
block
) \

1713 
	`ptls_buffer_push_quicint
((
buf
), (
id
)); \

1714 
	`ptls_buffer_push_block
((
buf
), -1, 
block
); \

1715 } while (0)

	)

1717 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_MAX_UDP_PAYLOAD_SIZE
,

1718 { 
	`ptls_buffer_push_quicint
(
buf
, 
params
->
max_udp_payload_size
); });

1719 if (
params
->
max_stream_data
.
bidi_local
 != 0)

1720 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
,

1721 { 
	`ptls_buffer_push_quicint
(
buf
, 
params
->
max_stream_data
.
bidi_local
); });

1722 if (
params
->
max_stream_data
.
bidi_remote
 != 0)

1723 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
,

1724 { 
	`ptls_buffer_push_quicint
(
buf
, 
params
->
max_stream_data
.
bidi_remote
); });

1725 if (
params
->
max_stream_data
.
uni
 != 0)

1726 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI
,

1727 { 
	`ptls_buffer_push_quicint
(
buf
, 
params
->
max_stream_data
.
uni
); });

1728 if (
params
->
max_data
 != 0)

1729 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA
, { 
	`ptls_buffer_push_quicint
(buf, 
params
->
max_data
); });

1730 if (
params
->
max_idle_timeout
 != 0)

1731 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_MAX_IDLE_TIMEOUT
, { 
	`ptls_buffer_push_quicint
(buf, 
params
->
max_idle_timeout
); });

1732 if (
original_dcid
 != 
NULL
)

1733 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_ORIGINAL_CONNECTION_ID
,

1734 { 
	`ptls_buffer_pushv
(
buf
, 
original_dcid
->
cid
, original_dcid->
len
); });

1735 if (
initial_scid
 != 
NULL
)

1736 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_SOURCE_CONNECTION_ID
,

1737 { 
	`ptls_buffer_pushv
(
buf
, 
initial_scid
->
cid
, initial_scid->
len
); });

1738 if (
retry_scid
 != 
NULL
)

1739 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_RETRY_SOURCE_CONNECTION_ID
,

1740 { 
	`ptls_buffer_pushv
(
buf
, 
retry_scid
->
cid
, retry_scid->
len
); });

1741 if (
stateless_reset_token
 != 
NULL
)

1742 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_STATELESS_RESET_TOKEN
,

1743 { 
	`ptls_buffer_pushv
(
buf
, 
stateless_reset_token
, 
QUICLY_STATELESS_RESET_TOKEN_LEN
); });

1744 if (
params
->
max_streams_bidi
 != 0)

1745 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI
,

1746 { 
	`ptls_buffer_push_quicint
(
buf
, 
params
->
max_streams_bidi
); });

1747 if (
params
->
max_streams_uni
 != 0)

1748 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI
,

1749 { 
	`ptls_buffer_push_quicint
(
buf
, 
params
->
max_streams_uni
); });

1750 if (
QUICLY_LOCAL_ACK_DELAY_EXPONENT
 != 
QUICLY_DEFAULT_ACK_DELAY_EXPONENT
)

1751 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_ACK_DELAY_EXPONENT
,

1752 { 
	`ptls_buffer_push_quicint
(
buf
, 
QUICLY_LOCAL_ACK_DELAY_EXPONENT
); });

1753 if (
QUICLY_LOCAL_MAX_ACK_DELAY
 != 
QUICLY_DEFAULT_MAX_ACK_DELAY
)

1754 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_MAX_ACK_DELAY
, { 
	`ptls_buffer_push_quicint
(buf, 
QUICLY_LOCAL_MAX_ACK_DELAY
); });

1755 if (
params
->
min_ack_delay_usec
 != 
UINT64_MAX
) {

1757 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_MIN_ACK_DELAY
,

1758 { 
	`ptls_buffer_push_quicint
(
buf
, 
QUICLY_LOCAL_MAX_ACK_DELAY
 * 1000 ); });

1760 if (
params
->
disable_active_migration
)

1761 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_DISABLE_ACTIVE_MIGRATION
, {});

1762 if (
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
 != 
QUICLY_DEFAULT_ACTIVE_CONNECTION_ID_LIMIT
)

1763 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT
,

1764 { 
	`ptls_buffer_push_quicint
(
buf
, 
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
); });

1765 if (
params
->
max_datagram_frame_size
 != 0)

1766 
	`PUSH_TP
(
buf
, 
QUICLY_TRANSPORT_PARAMETER_ID_MAX_DATAGRAM_FRAME_SIZE
,

1767 { 
	`ptls_buffer_push_quicint
(
buf
, 
params
->
max_datagram_frame_size
); });

1769 if (
expand_by
 != 0) {

1770 
	`PUSH_TP
(
buf
, 31 * 100 + 27, {

1771 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
expand_by
)) != 0)

1772 goto 
Exit
;

1773 
	`memset
(
buf
->
base
 + buf->
off
, 0, 
expand_by
);

1774 
buf
->
off
 += 
expand_by
;

1778 #undef 
PUSH_TP


1780 
ret
 = 0;

1781 
Exit
:

1782 return 
ret
;

1783 
	}
}

1788 static const 
quicly_cid_t
 
	g_tp_cid_ignore
;

1789 #define 
	#tp_cid_ignore
 (*(
quicly_cid_t
 *)&
_tp_cid_ignore
)

	)

1791 int 
	$quicly_decode_transport_parameter_list
(
quicly_transport_parameters_t
 *
params
, 
quicly_cid_t
 *
original_dcid
,

1792 
quicly_cid_t
 *
initial_scid
, quicly_cid_t *
retry_scid
, void *
stateless_reset_token
,

1793 const 
uint8_t
 *
src
, const uint8_t *
end
, int 
recognize_delayed_ack
)

1798 #define 
	#DECODE_TP
(
_id
, 
block
) \

1800 if (
tp_index
 >= 0) { \

1801 if (
id
 == (
_id
)) { \

1802 if ((
found_bits
 & ((
uint64_t
)1 << 
tp_index
)) != 0) { \

1803 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
; \

1804 goto 
Exit
; \

1806 
found_bits
 |= (
uint64_t
)1 << 
tp_index
; \

1807 {
block
} 
tp_index
 = -1; \

1809 ++
tp_index
; \

1812 } while (0)

	)

1813 #define 
	#DECODE_CID_TP
(
_id
, 
dest
) \

1814 
	`DECODE_TP
(
_id
, { \

1815 
size_t
 
cidl
 = 
end
 - 
src
; \

1816 if (
cidl
 > 
QUICLY_MAX_CID_LEN_V1
) { \

1817 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
; \

1818 goto 
Exit
; \

1820 if (
dest
 == 
NULL
) { \

1821 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
; \

1822 goto 
Exit
; \

1823 } else if (
dest
 != &
tp_cid_ignore
) { \

1824 
	`quicly_set_cid
(
dest
, 
	`ptls_iovec_init
(
src
, 
cidl
)); \

1826 
src
 = 
end
; \

1827 });

	)

1829 
uint64_t
 
found_bits
 = 0;

1830 int 
ret
;

1833 *
params
 = 
default_transport_params
;

1836 if (
original_dcid
 != 
NULL
 && original_dcid != &
tp_cid_ignore
)

1837 
original_dcid
->
len
 = 
UINT8_MAX
;

1838 if (
initial_scid
 != 
NULL
 && initial_scid != &
tp_cid_ignore
)

1839 
initial_scid
->
len
 = 
UINT8_MAX
;

1840 if (
retry_scid
 != 
NULL
 && retry_scid != &
tp_cid_ignore
)

1841 
retry_scid
->
len
 = 
UINT8_MAX
;

1844 while (
src
 != 
end
) {

1845 
uint64_t
 
id
;

1846 if ((
id
 = 
	`quicly_decodev
(&
src
, 
end
)) == 
UINT64_MAX
) {

1847 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1848 goto 
Exit
;

1850 int 
tp_index
 = 0;

1851 
	`ptls_decode_open_block
(
src
, 
end
, -1, {

1852 
	`DECODE_CID_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_ORIGINAL_CONNECTION_ID
, 
original_dcid
);

1853 
	`DECODE_CID_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_SOURCE_CONNECTION_ID
, 
initial_scid
);

1854 
	`DECODE_CID_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_RETRY_SOURCE_CONNECTION_ID
, 
retry_scid
);

1855 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_MAX_UDP_PAYLOAD_SIZE
, {

1856 
uint64_t
 
v
;

1857 if ((
v
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1858 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1859 goto 
Exit
;

1861 if (
v
 < 1200) {

1862 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1863 goto 
Exit
;

1865 if (
v
 > 
UINT16_MAX
)

1866 
v
 = 
UINT16_MAX
;

1867 
params
->
max_udp_payload_size
 = (
uint16_t
)
v
;

1869 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
, {

1870 if ((
params
->
max_stream_data
.
bidi_local
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1871 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1872 goto 
Exit
;

1875 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
, {

1876 if ((
params
->
max_stream_data
.
bidi_remote
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1877 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1878 goto 
Exit
;

1881 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI
, {

1882 if ((
params
->
max_stream_data
.
uni
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1883 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1884 goto 
Exit
;

1887 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA
, {

1888 if ((
params
->
max_data
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1889 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1890 goto 
Exit
;

1893 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_STATELESS_RESET_TOKEN
, {

1894 if (!(
stateless_reset_token
 != 
NULL
 && 
end
 - 
src
 == 
QUICLY_STATELESS_RESET_TOKEN_LEN
)) {

1895 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1896 goto 
Exit
;

1898 
	`memcpy
(
stateless_reset_token
, 
src
, 
QUICLY_STATELESS_RESET_TOKEN_LEN
);

1899 
src
 = 
end
;

1901 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_MAX_IDLE_TIMEOUT
, {

1902 if ((
params
->
max_idle_timeout
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1903 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1904 goto 
Exit
;

1907 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI
, {

1908 if ((
params
->
max_streams_bidi
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1909 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1910 goto 
Exit
;

1913 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI
, {

1914 if ((
params
->
max_streams_uni
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1915 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1916 goto 
Exit
;

1919 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_ACK_DELAY_EXPONENT
, {

1920 
uint64_t
 
v
;

1921 if ((
v
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1922 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1923 goto 
Exit
;

1925 if (
v
 > 20) {

1926 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1927 goto 
Exit
;

1929 
params
->
ack_delay_exponent
 = (
uint8_t
)
v
;

1931 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_MAX_ACK_DELAY
, {

1932 
uint64_t
 
v
;

1933 if ((
v
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1934 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1935 goto 
Exit
;

1937 if (
v
 >= 16384) {

1938 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1939 goto 
Exit
;

1941 
params
->
max_ack_delay
 = (
uint16_t
)
v
;

1944 if (
recognize_delayed_ack
) {

1945 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_MIN_ACK_DELAY
, {

1946 if ((
params
->
min_ack_delay_usec
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1947 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1948 goto 
Exit
;

1950 if (
params
->
min_ack_delay_usec
 >= 16777216) {

1951 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1952 goto 
Exit
;

1956 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT
, {

1957 
uint64_t
 
v
;

1958 if ((
v
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1959 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1960 goto 
Exit
;

1962 if (
v
 < 
QUICLY_MIN_ACTIVE_CONNECTION_ID_LIMIT
) {

1963 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1964 goto 
Exit
;

1966 
params
->
active_connection_id_limit
 = 
v
;

1968 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_DISABLE_ACTIVE_MIGRATION
, { 
params
->
disable_active_migration
 = 1; });

1969 
	`DECODE_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_MAX_DATAGRAM_FRAME_SIZE
, {

1970 
uint64_t
 
v
;

1971 if ((
v
 = 
	`ptls_decode_quicint
(&
src
, 
end
)) == 
UINT64_MAX
) {

1972 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1973 goto 
Exit
;

1975 if (
v
 > 
UINT16_MAX
)

1976 
v
 = 
UINT16_MAX
;

1977 
params
->
max_datagram_frame_size
 = (
uint16_t
)
v
;

1980 if (
tp_index
 >= 0)

1981 
src
 = 
end
;

1986 if (
params
->
min_ack_delay_usec
 != 
UINT64_MAX
) {

1987 if (
params
->
min_ack_delay_usec
 > params->
max_ack_delay
 * 1000) {

1988 
ret
 = 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

1989 goto 
Exit
;

1994 if ((
original_dcid
 != 
NULL
 && original_dcid->
len
 == 
UINT8_MAX
) || (
initial_scid
 != NULL && initial_scid->len == UINT8_MAX) ||

1995 (
retry_scid
 != 
NULL
 && retry_scid->
len
 == 
UINT8_MAX
)) {

1996 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

1997 goto 
Exit
;

2000 
ret
 = 0;

2001 
Exit
:

2002 if (
ret
 == 
PTLS_ALERT_DECODE_ERROR
)

2003 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

2004 return 
ret
;

2006 #undef 
DECODE_TP


2007 #undef 
DECODE_CID_TP


2008 
	}
}

2010 static int 
	$collect_transport_parameters
(
ptls_t
 *
tls
, struct 
st_ptls_handshake_properties_t
 *
properties
, 
uint16_t
 
type
)

2012 return 
type
 == 
QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS
;

2013 
	}
}

2015 static 
quicly_conn_t
 *
	$create_connection
(
quicly_context_t
 *
ctx
, 
uint32_t
 
protocol_version
, const char *
server_name
,

2016 struct 
sockaddr
 *
remote_addr
, struct sockaddr *
local_addr
, 
ptls_iovec_t
 *
remote_cid
,

2017 const 
quicly_cid_plaintext_t
 *
local_cid
, 
ptls_handshake_properties_t
 *
handshake_properties
,

2018 
uint32_t
 
initcwnd
)

2020 
ptls_t
 *
tls
 = 
NULL
;

2021 
quicly_conn_t
 *
conn
;

2024 
	`assert
(
remote_addr
 != 
NULL
 && remote_addr->
sa_family
 != 
AF_UNSPEC
);

2025 if (
ctx
->
transport_params
.
max_datagram_frame_size
 != 0)

2026 
	`assert
(
ctx
->
receive_datagram_frame
 != 
NULL
);

2029 if ((
tls
 = 
	`ptls_new
(
ctx
->tls, 
server_name
 == 
NULL
)) == NULL)

2030 return 
NULL
;

2031 if (
server_name
 != 
NULL
 && 
	`ptls_set_server_name
(
tls
, server_name, 
	`strlen
(server_name)) != 0) {

2032 
	`ptls_free
(
tls
);

2033 return 
NULL
;

2037 if ((
conn
 = 
	`malloc
(sizeof(*conn))) == 
NULL
) {

2038 
	`ptls_free
(
tls
);

2039 return 
NULL
;

2041 
	`memset
(
conn
, 0, sizeof(*conn));

2042 
conn
->
super
.
ctx
 = ctx;

2043 
	`lock_now
(
conn
, 0);

2044 
	`set_address
(&
conn
->
super
.
local
.
address
, 
local_addr
);

2045 
	`set_address
(&
conn
->
super
.
remote
.
address
, 
remote_addr
);

2046 
	`quicly_local_cid_init_set
(&
conn
->
super
.
local
.
cid_set
, 
ctx
->
cid_encryptor
, 
local_cid
);

2047 
conn
->
super
.
local
.
long_header_src_cid
 = conn->super.local.
cid_set
.
cids
[0].
cid
;

2048 
	`quicly_remote_cid_init_set
(&
conn
->
super
.
remote
.
cid_set
, 
remote_cid
, 
ctx
->
tls
->
random_bytes
);

2049 
conn
->
super
.
state
 = 
QUICLY_STATE_FIRSTFLIGHT
;

2050 if (
server_name
 != 
NULL
) {

2051 
conn
->
super
.
local
.
bidi
.
next_stream_id
 = 0;

2052 
conn
->
super
.
local
.
uni
.
next_stream_id
 = 2;

2053 
conn
->
super
.
remote
.
bidi
.
next_stream_id
 = 1;

2054 
conn
->
super
.
remote
.
uni
.
next_stream_id
 = 3;

2056 
conn
->
super
.
local
.
bidi
.
next_stream_id
 = 1;

2057 
conn
->
super
.
local
.
uni
.
next_stream_id
 = 3;

2058 
conn
->
super
.
remote
.
bidi
.
next_stream_id
 = 0;

2059 
conn
->
super
.
remote
.
uni
.
next_stream_id
 = 2;

2061 
conn
->
super
.
remote
.
transport_params
 = 
default_transport_params
;

2062 
conn
->
super
.
version
 = 
protocol_version
;

2063 
conn
->
super
.
remote
.
largest_retire_prior_to
 = 0;

2064 
	`quicly_linklist_init
(&
conn
->
super
.
_default_scheduler
.
active
);

2065 
	`quicly_linklist_init
(&
conn
->
super
.
_default_scheduler
.
blocked
);

2066 
conn
->
streams
 = 
	`kh_init
(
quicly_stream_t
);

2067 
	`quicly_maxsender_init
(&
conn
->
ingress
.
max_data
.
sender
, conn->
super
.
ctx
->
transport_params
.max_data);

2068 
	`quicly_maxsender_init
(&
conn
->
ingress
.
max_streams
.
uni
, conn->
super
.
ctx
->
transport_params
.
max_streams_uni
);

2069 
	`quicly_maxsender_init
(&
conn
->
ingress
.
max_streams
.
bidi
, conn->
super
.
ctx
->
transport_params
.
max_streams_bidi
);

2070 
	`quicly_loss_init
(&
conn
->
egress
.
loss
, &conn->
super
.
ctx
->loss,

2071 
conn
->
super
.
ctx
->
loss
.
default_initial_rtt
 ,

2072 &
conn
->
super
.
remote
.
transport_params
.
max_ack_delay
, &conn->super.remote.transport_params.
ack_delay_exponent
);

2073 
conn
->
egress
.
next_pn_to_skip
 =

2074 
	`calc_next_pn_to_skip
(
conn
->
super
.
ctx
->
tls
, 0, 
initcwnd
, conn->super.ctx->
initial_egress_max_udp_payload_size
);

2075 
conn
->
egress
.
max_udp_payload_size
 = conn->
super
.
ctx
->
initial_egress_max_udp_payload_size
;

2076 
	`init_max_streams
(&
conn
->
egress
.
max_streams
.
uni
);

2077 
	`init_max_streams
(&
conn
->
egress
.
max_streams
.
bidi
);

2078 
conn
->
egress
.
path_challenge
.
tail_ref
 = &conn->egress.path_challenge.
head
;

2079 
conn
->
egress
.
ack_frequency
.
update_at
 = 
INT64_MAX
;

2080 
conn
->
egress
.
send_ack_at
 = 
INT64_MAX
;

2081 
conn
->
super
.
ctx
->
init_cc
->
	`cb
(conn->super.ctx->init_cc, &conn->
egress
.
cc
, 
initcwnd
, conn->
stash
.
now
);

2082 
	`quicly_retire_cid_init
(&
conn
->
egress
.
retire_cid
);

2083 
	`quicly_linklist_init
(&
conn
->
egress
.
pending_streams
.
blocked
.
uni
);

2084 
	`quicly_linklist_init
(&
conn
->
egress
.
pending_streams
.
blocked
.
bidi
);

2085 
	`quicly_linklist_init
(&
conn
->
egress
.
pending_streams
.
control
);

2086 
conn
->
crypto
.
tls
 = tls;

2087 if (
handshake_properties
 != 
NULL
) {

2088 
	`assert
(
handshake_properties
->
additional_extensions
 == 
NULL
);

2089 
	`assert
(
handshake_properties
->
collect_extension
 == 
NULL
);

2090 
	`assert
(
handshake_properties
->
collected_extensions
 == 
NULL
);

2091 
conn
->
crypto
.
handshake_properties
 = *handshake_properties;

2093 
conn
->
crypto
.
handshake_properties
 = (
ptls_handshake_properties_t
){{{{
NULL
}}}};

2095 
conn
->
crypto
.
handshake_properties
.
collect_extension
 = 
collect_transport_parameters
;

2096 
conn
->
retry_scid
.
len
 = 
UINT8_MAX
;

2097 
conn
->
idle_timeout
.
at
 = 
INT64_MAX
;

2098 
conn
->
idle_timeout
.
should_rearm_on_send
 = 1;

2099 
conn
->
stash
.
on_ack_stream
.
active_acked_cache
.
stream_id
 = 
INT64_MIN
;

2101 *
	`ptls_get_data_ptr
(
tls
) = 
conn
;

2103 
	`update_open_count
(
conn
->
super
.
ctx
, 1);

2105 return 
conn
;

2106 
	}
}

2108 static int 
	$client_collected_extensions
(
ptls_t
 *
tls
, 
ptls_handshake_properties_t
 *
properties
, 
ptls_raw_extension_t
 *
slots
)

2110 
quicly_conn_t
 *
conn
 = (void *)((char *)
properties
 - 
	`offsetof
(quicly_conn_t, 
crypto
.
handshake_properties
));

2111 int 
ret
;

2113 
	`assert
(
properties
->
client
.
early_data_acceptance
 != 
PTLS_EARLY_DATA_ACCEPTANCE_UNKNOWN
);

2115 if (
slots
[0].
type
 == 
UINT16_MAX
) {

2116 
ret
 = 
PTLS_ALERT_MISSING_EXTENSION
;

2117 goto 
Exit
;

2119 
	`assert
(
slots
[0].
type
 == 
QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS
);

2120 
	`assert
(
slots
[1].
type
 == 
UINT16_MAX
);

2122 const 
uint8_t
 *
src
 = 
slots
[0].
data
.
base
, *
end
 = src + slots[0].data.
len
;

2123 
quicly_transport_parameters_t
 
params
;

2124 
quicly_cid_t
 
original_dcid
, 
initial_scid
, 
retry_scid
 = {};

2128 
quicly_remote_cid_t
 *
remote_cid
 = &
conn
->
super
.
remote
.
cid_set
.
cids
[0];

2129 
	`assert
(
remote_cid
->
sequence
 == 0);

2132 if ((
ret
 = 
	`quicly_decode_transport_parameter_list
(&
params
, 
	`needs_cid_auth
(
conn
) || 
	`is_retry
(conn) ? &
original_dcid
 : 
NULL
,

2133 
	`needs_cid_auth
(
conn
) ? &
initial_scid
 : &
tp_cid_ignore
,

2134 
	`needs_cid_auth
(
conn
) ? 
	`is_retry
(conn) ? &
retry_scid
 : 
NULL
 : &
tp_cid_ignore
,

2135 
remote_cid
->
stateless_reset_token
, 
src
, 
end
, 
	`recognize_delayed_ack
(
conn
))) !=

2137 goto 
Exit
;

2140 if (
	`needs_cid_auth
(
conn
) || 
	`is_retry
(conn)) {

2141 if (!
	`quicly_cid_is_equal
(&
conn
->
super
.
original_dcid
, 
	`ptls_iovec_init
(original_dcid.
cid
, original_dcid.
len
))) {

2142 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

2143 goto 
Exit
;

2146 if (
	`needs_cid_auth
(
conn
)) {

2147 if (!
	`quicly_cid_is_equal
(&
remote_cid
->
cid
, 
	`ptls_iovec_init
(
initial_scid
.cid, initial_scid.
len
))) {

2148 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

2149 goto 
Exit
;

2151 if (
	`is_retry
(
conn
)) {

2152 if (!
	`quicly_cid_is_equal
(&
conn
->
retry_scid
, 
	`ptls_iovec_init
(retry_scid.
cid
, retry_scid.
len
))) {

2153 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
;

2154 goto 
Exit
;

2159 if (
properties
->
client
.
early_data_acceptance
 == 
PTLS_EARLY_DATA_ACCEPTED
) {

2160 #define 
	#ZERORTT_VALIDATE
(
x
) \

2161 if (
params
.
x
 < 
conn
->
super
.
remote
.
transport_params
.x) { \

2162 
ret
 = 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
; \

2163 goto 
Exit
; \

2164 }

	)

2165 
	`ZERORTT_VALIDATE
(
max_data
);

2166 
	`ZERORTT_VALIDATE
(
max_stream_data
.
bidi_local
);

2167 
	`ZERORTT_VALIDATE
(
max_stream_data
.
bidi_remote
);

2168 
	`ZERORTT_VALIDATE
(
max_stream_data
.
uni
);

2169 
	`ZERORTT_VALIDATE
(
max_streams_bidi
);

2170 
	`ZERORTT_VALIDATE
(
max_streams_uni
);

2171 #undef 
ZERORTT_VALIDATE


2175 
conn
->
super
.
remote
.
transport_params
 = 
params
;

2176 
	`ack_frequency_set_next_update_at
(
conn
);

2178 
Exit
:

2179 return 
ret
;

2180 
	}
}

2182 int 
	$quicly_connect
(
quicly_conn_t
 **
_conn
, 
quicly_context_t
 *
ctx
, const char *
server_name
, struct 
sockaddr
 *
dest_addr
,

2183 struct 
sockaddr
 *
src_addr
, const 
quicly_cid_plaintext_t
 *
new_cid
, 
ptls_iovec_t
 
address_token
,

2184 
ptls_handshake_properties_t
 *
handshake_properties
, const 
quicly_transport_parameters_t
 *
resumed_transport_params
)

2186 const struct 
st_ptls_salt_t
 *
salt
;

2187 
quicly_conn_t
 *
conn
 = 
NULL
;

2188 const 
quicly_cid_t
 *
server_cid
;

2189 
ptls_buffer_t
 
buf
;

2190 
size_t
 
epoch_offsets
[5] = {0};

2191 
size_t
 
max_early_data_size
 = 0;

2192 int 
ret
;

2194 if ((
salt
 = 
	`get_salt
(
ctx
->
initial_version
)) == 
NULL
) {

2195 if ((
ctx
->
initial_version
 & 0x0f0f0f0f) == 0x0a0a0a0a) {

2197 static const struct 
st_ptls_salt_t
 
grease_salt
 = {.
initial
 = {0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe,

2200 
salt
 = &
grease_salt
;

2202 
ret
 = 
QUICLY_ERROR_INVALID_INITIAL_VERSION
;

2203 goto 
Exit
;

2207 if ((
conn
 = 
	`create_connection
(

2208 
ctx
, ctx->
initial_version
, 
server_name
, 
dest_addr
, 
src_addr
, 
NULL
, 
new_cid
, 
handshake_properties
,

2209 
	`quicly_cc_calc_initial_cwnd
(
ctx
->
initcwnd_packets
, ctx->
transport_params
.
max_udp_payload_size
))) == 
NULL
) {

2210 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

2211 goto 
Exit
;

2213 
conn
->
super
.
remote
.
address_validation
.
validated
 = 1;

2214 
conn
->
super
.
remote
.
address_validation
.
send_probe
 = 1;

2215 if (
address_token
.
len
 != 0) {

2216 if ((
conn
->
token
.
base
 = 
	`malloc
(
address_token
.
len
)) == 
NULL
) {

2217 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

2218 goto 
Exit
;

2220 
	`memcpy
(
conn
->
token
.
base
, 
address_token
.base, address_token.
len
);

2221 
conn
->
token
.
len
 = 
address_token
.len;

2223 
server_cid
 = 
	`quicly_get_remote_cid
(
conn
);

2224 
conn
->
super
.
original_dcid
 = *
server_cid
;

2226 
	`QUICLY_PROBE
(
CONNECT
, 
conn
, conn->
stash
.
now
, conn->
super
.
version
);

2228 if ((
ret
 = 
	`setup_handshake_space_and_flow
(
conn
, 
QUICLY_EPOCH_INITIAL
)) != 0)

2229 goto 
Exit
;

2230 if ((
ret
 = 
	`setup_initial_encryption
(
	`get_aes128gcmsha256
(
ctx
), &
conn
->
initial
->
cipher
.
ingress
, &conn->initial->cipher.
egress
,

2231 
	`ptls_iovec_init
(
server_cid
->
cid
, server_cid->
len
), 1,

2232 
	`ptls_iovec_init
(
salt
->
initial
, sizeof(salt->initial)), 
conn
)) != 0)

2233 goto 
Exit
;

2236 
	`ptls_buffer_init
(&
conn
->
crypto
.
transport_params
.
buf
, "", 0);

2237 if ((
ret
 = 
	`quicly_encode_transport_parameter_list
(

2238 &
conn
->
crypto
.
transport_params
.
buf
, &conn->
super
.
ctx
->transport_params, 
NULL
, &conn->super.
local
.
cid_set
.
cids
[0].
cid
,

2239 
NULL
, NULL, 
conn
->
super
.
ctx
->
expand_client_hello
 ? conn->super.ctx->
initial_egress_max_udp_payload_size
 : 0)) != 0)

2240 goto 
Exit
;

2241 
conn
->
crypto
.
transport_params
.
ext
[0] =

2242 (
ptls_raw_extension_t
){
QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS
,

2243 {
conn
->
crypto
.
transport_params
.
buf
.
base
, conn->crypto.transport_params.buf.
off
}};

2244 
conn
->
crypto
.
transport_params
.
ext
[1] = (
ptls_raw_extension_t
){
UINT16_MAX
};

2245 
conn
->
crypto
.
handshake_properties
.
additional_extensions
 = conn->crypto.
transport_params
.
ext
;

2246 
conn
->
crypto
.
handshake_properties
.
collected_extensions
 = 
client_collected_extensions
;

2248 
	`ptls_buffer_init
(&
buf
, "", 0);

2249 if (
resumed_transport_params
 != 
NULL
)

2250 
conn
->
crypto
.
handshake_properties
.
client
.
max_early_data_size
 = &max_early_data_size;

2251 
ret
 = 
	`ptls_handle_message
(
conn
->
crypto
.
tls
, &
buf
, 
epoch_offsets
, 0, 
NULL
, 0, &conn->crypto.
handshake_properties
);

2252 
conn
->
crypto
.
handshake_properties
.
client
.
max_early_data_size
 = 
NULL
;

2253 if (
ret
 != 
PTLS_ERROR_IN_PROGRESS
) {

2254 
	`assert
(
ret
 > 0);

2255 goto 
Exit
;

2257 
	`write_crypto_data
(
conn
, &
buf
, 
epoch_offsets
);

2258 
	`ptls_buffer_dispose
(&
buf
);

2260 if (
max_early_data_size
 != 0) {

2262 #define 
	#APPLY
(
n
) 
conn
->
super
.
remote
.
transport_params
.n = 
resumed_transport_params
->
	)
n

2263 
	`APPLY
(
active_connection_id_limit
);

2264 
	`APPLY
(
max_data
);

2265 
	`APPLY
(
max_stream_data
.
bidi_local
);

2266 
	`APPLY
(
max_stream_data
.
bidi_remote
);

2267 
	`APPLY
(
max_stream_data
.
uni
);

2268 
	`APPLY
(
max_streams_bidi
);

2269 
	`APPLY
(
max_streams_uni
);

2270 #undef 
APPLY


2271 if ((
ret
 = 
	`apply_remote_transport_params
(
conn
)) != 0)

2272 goto 
Exit
;

2275 *
_conn
 = 
conn
;

2276 
ret
 = 0;

2278 
Exit
:

2279 if (
conn
 != 
NULL
)

2280 
	`unlock_now
(
conn
);

2281 if (
ret
 != 0) {

2282 if (
conn
 != 
NULL
)

2283 
	`quicly_free
(
conn
);

2285 return 
ret
;

2286 
	}
}

2288 static int 
	$server_collected_extensions
(
ptls_t
 *
tls
, 
ptls_handshake_properties_t
 *
properties
, 
ptls_raw_extension_t
 *
slots
)

2290 
quicly_conn_t
 *
conn
 = (void *)((char *)
properties
 - 
	`offsetof
(quicly_conn_t, 
crypto
.
handshake_properties
));

2291 
quicly_cid_t
 
initial_scid
;

2292 int 
ret
;

2294 if (
slots
[0].
type
 == 
UINT16_MAX
) {

2295 
ret
 = 
PTLS_ALERT_MISSING_EXTENSION
;

2296 goto 
Exit
;

2298 
	`assert
(
slots
[0].
type
 == 
QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS
);

2299 
	`assert
(
slots
[1].
type
 == 
UINT16_MAX
);

2302 const 
uint8_t
 *
src
 = 
slots
[0].
data
.
base
, *
end
 = src + slots[0].data.
len
;

2303 if ((
ret
 = 
	`quicly_decode_transport_parameter_list
(

2304 &
conn
->
super
.
remote
.
transport_params
, 
	`needs_cid_auth
(conn) ? 
NULL
 : &
tp_cid_ignore
,

2305 
	`needs_cid_auth
(
conn
) ? &
initial_scid
 : &
tp_cid_ignore
, needs_cid_auth(conn) ? 
NULL
 : &tp_cid_ignore, NULL, 
src
,

2306 
end
, 
	`recognize_delayed_ack
(
conn
))) != 0)

2307 goto 
Exit
;

2308 if (
	`needs_cid_auth
(
conn
) &&

2309 !
	`quicly_cid_is_equal
(&
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
, 
	`ptls_iovec_init
(
initial_scid
.cid, initial_scid.
len
))) {

2310 
ret
 = 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

2311 goto 
Exit
;

2316 
	`ack_frequency_set_next_update_at
(
conn
);

2320 
	`assert
(
conn
->
initial
 != 
NULL
);

2321 if (
conn
->
egress
.
max_udp_payload_size
 < conn->
initial
->
largest_ingress_udp_payload_size
) {

2322 
uint16_t
 
size
 = 
conn
->
initial
->
largest_ingress_udp_payload_size
;

2323 if (
size
 > 
conn
->
super
.
remote
.
transport_params
.
max_udp_payload_size
)

2324 
size
 = 
conn
->
super
.
remote
.
transport_params
.
max_udp_payload_size
;

2325 if (
size
 > 
conn
->
super
.
ctx
->
transport_params
.
max_udp_payload_size
)

2326 
size
 = 
conn
->
super
.
ctx
->
transport_params
.
max_udp_payload_size
;

2327 
conn
->
egress
.
max_udp_payload_size
 = 
size
;

2331 
	`assert
(
properties
->
additional_extensions
 == 
NULL
);

2332 
	`ptls_buffer_init
(&
conn
->
crypto
.
transport_params
.
buf
, "", 0);

2333 
	`assert
(
conn
->
super
.
local
.
cid_set
.
cids
[0].
sequence
 == 0 && "make sure that local_cid is in expected state before sending SRT");

2334 if ((
ret
 = 
	`quicly_encode_transport_parameter_list
(

2335 &
conn
->
crypto
.
transport_params
.
buf
, &conn->
super
.
ctx
->transport_params,

2336 
	`needs_cid_auth
(
conn
) || 
	`is_retry
(conn) ? &conn->
super
.
original_dcid
 : 
NULL
,

2337 
	`needs_cid_auth
(
conn
) ? &conn->
super
.
local
.
cid_set
.
cids
[0].
cid
 : 
NULL
,

2338 
	`needs_cid_auth
(
conn
) && 
	`is_retry
(conn) ? &conn->
retry_scid
 : 
NULL
,

2339 
conn
->
super
.
ctx
->
cid_encryptor
 != 
NULL
 ? conn->super.
local
.
cid_set
.
cids
[0].
stateless_reset_token
 : NULL, 0)) != 0)

2340 goto 
Exit
;

2341 
properties
->
additional_extensions
 = 
conn
->
crypto
.
transport_params
.
ext
;

2342 
conn
->
crypto
.
transport_params
.
ext
[0] =

2343 (
ptls_raw_extension_t
){
QUICLY_TLS_EXTENSION_TYPE_TRANSPORT_PARAMETERS
,

2344 {
conn
->
crypto
.
transport_params
.
buf
.
base
, conn->crypto.transport_params.buf.
off
}};

2345 
conn
->
crypto
.
transport_params
.
ext
[1] = (
ptls_raw_extension_t
){
UINT16_MAX
};

2346 
conn
->
crypto
.
handshake_properties
.
additional_extensions
 = conn->crypto.
transport_params
.
ext
;

2348 
ret
 = 0;

2350 
Exit
:

2351 return 
ret
;

2352 
	}
}

2354 static 
size_t
 
	$aead_decrypt_core
(
ptls_aead_context_t
 *
aead
, 
uint64_t
 
pn
, 
quicly_decoded_packet_t
 *
packet
, 
size_t
 
aead_off
)

2356 return 
	`ptls_aead_decrypt
(
aead
, 
packet
->
octets
.
base
 + 
aead_off
, packet->octets.base + aead_off, packet->octets.
len
 - aead_off,

2357 
pn
, 
packet
->
octets
.
base
, 
aead_off
);

2358 
	}
}

2360 static int 
	$aead_decrypt_fixed_key
(void *
ctx
, 
uint64_t
 
pn
, 
quicly_decoded_packet_t
 *
packet
, 
size_t
 
aead_off
, size_t *
ptlen
)

2362 
ptls_aead_context_t
 *
aead
 = 
ctx
;

2364 if ((*
ptlen
 = 
	`aead_decrypt_core
(
aead
, 
pn
, 
packet
, 
aead_off
)) == 
SIZE_MAX
)

2365 return 
QUICLY_ERROR_PACKET_IGNORED
;

2367 
	}
}

2369 static int 
	$aead_decrypt_1rtt
(void *
ctx
, 
uint64_t
 
pn
, 
quicly_decoded_packet_t
 *
packet
, 
size_t
 
aead_off
, size_t *
ptlen
)

2371 
quicly_conn_t
 *
conn
 = 
ctx
;

2372 struct 
st_quicly_application_space_t
 *
space
 = 
conn
->
application
;

2373 
size_t
 
aead_index
 = (
packet
->
octets
.
base
[0] & 
QUICLY_KEY_PHASE_BIT
) != 0;

2374 int 
ret
;

2377 if (
space
->
cipher
.
ingress
.
aead
[
aead_index
] == 
NULL
) {

2378 
Retry_1RTT
 : {

2381 if (
conn
->
application
->
cipher
.
ingress
.
header_protection
.
zero_rtt
 != 
NULL
) {

2382 
	`ptls_cipher_free
(
conn
->
application
->
cipher
.
ingress
.
header_protection
.
zero_rtt
);

2383 
conn
->
application
->
cipher
.
ingress
.
header_protection
.
zero_rtt
 = 
NULL
;

2385 
ptls_cipher_suite_t
 *
cipher
 = 
	`ptls_get_cipher
(
conn
->
crypto
.
tls
);

2386 if ((
ret
 = 
	`update_1rtt_key
(
conn
, 
cipher
, 0, &
space
->cipher.
ingress
.
aead
[
aead_index
], space->cipher.ingress.
secret
)) != 0)

2387 return 
ret
;

2388 ++
space
->
cipher
.
ingress
.
key_phase
.
prepared
;

2389 
	`QUICLY_PROBE
(
CRYPTO_RECEIVE_KEY_UPDATE_PREPARE
, 
conn
, conn->
stash
.
now
, 
space
->
cipher
.
ingress
.
key_phase
.
prepared
,

2390 
	`QUICLY_PROBE_HEXDUMP
(
space
->
cipher
.
ingress
.
secret
, cipher->
hash
->
digest_size
));

2395 
ptls_aead_context_t
 *
aead
 = 
space
->
cipher
.
ingress
.aead[
aead_index
];

2396 if ((*
ptlen
 = 
	`aead_decrypt_core
(
aead
, 
pn
, 
packet
, 
aead_off
)) == 
SIZE_MAX
) {

2398 if (
space
->
cipher
.
ingress
.
key_phase
.
decrypted
 == space->cipher.ingress.key_phase.
prepared
 &&

2399 
space
->
cipher
.
ingress
.
key_phase
.
decrypted
 % 2 != 
aead_index
) {

2401 
	`aead_decrypt_core
(
aead
, 
pn
, 
packet
, 
aead_off
);

2402 goto 
Retry_1RTT
;

2405 return 
QUICLY_ERROR_PACKET_IGNORED
;

2409 if (
space
->
cipher
.
ingress
.
key_phase
.
prepared
 != space->cipher.ingress.key_phase.
decrypted
 &&

2410 
space
->
cipher
.
ingress
.
key_phase
.
prepared
 % 2 == 
aead_index
) {

2411 if ((
ret
 = 
	`received_key_update
(
conn
, 
space
->
cipher
.
ingress
.
key_phase
.
prepared
)) != 0)

2412 return 
ret
;

2416 
	}
}

2418 static int 
	$do_decrypt_packet
(
ptls_cipher_context_t
 *
header_protection
,

2419 int (*
aead_cb
)(void *, 
uint64_t
, 
quicly_decoded_packet_t
 *, 
size_t
, size_t *), void *
aead_ctx
,

2420 
uint64_t
 *
next_expected_pn
, 
quicly_decoded_packet_t
 *
packet
, uint64_t *
pn
, 
ptls_iovec_t
 *
payload
)

2422 
size_t
 
encrypted_len
 = 
packet
->
octets
.
len
 - packet->
encrypted_off
;

2423 
uint8_t
 
hpmask
[5] = {0};

2424 
uint32_t
 
pnbits
 = 0;

2425 
size_t
 
pnlen
, 
ptlen
, 
i
;

2426 int 
ret
;

2429 if (
encrypted_len
 < 
header_protection
->
algo
->
iv_size
 + 
QUICLY_MAX_PN_SIZE
) {

2430 *
pn
 = 
UINT64_MAX
;

2431 return 
QUICLY_ERROR_PACKET_IGNORED
;

2433 
	`ptls_cipher_init
(
header_protection
, 
packet
->
octets
.
base
 + packet->
encrypted_off
 + 
QUICLY_MAX_PN_SIZE
);

2434 
	`ptls_cipher_encrypt
(
header_protection
, 
hpmask
, hpmask, sizeof(hpmask));

2435 
packet
->
octets
.
base
[0] ^= 
hpmask
[0] & (
	`QUICLY_PACKET_IS_LONG_HEADER
(packet->octets.base[0]) ? 0xf : 0x1f);

2436 
pnlen
 = (
packet
->
octets
.
base
[0] & 0x3) + 1;

2437 for (
i
 = 0; i != 
pnlen
; ++i) {

2438 
packet
->
octets
.
base
[packet->
encrypted_off
 + 
i
] ^= 
hpmask
[i + 1];

2439 
pnbits
 = (pnbits << 8) | 
packet
->
octets
.
base
[packet->
encrypted_off
 + 
i
];

2442 
size_t
 
aead_off
 = 
packet
->
encrypted_off
 + 
pnlen
;

2443 *
pn
 = 
	`quicly_determine_packet_number
(
pnbits
, 
pnlen
 * 8, *
next_expected_pn
);

2446 if ((
ret
 = (*
aead_cb
)(
aead_ctx
, *
pn
, 
packet
, 
aead_off
, &
ptlen
)) != 0) {

2447 if (
QUICLY_DEBUG
)

2448 
	`fprintf
(
stderr
, "%s: aead decryption failure (pn: %" 
PRIu64
 ",code:%d)\n", 
__FUNCTION__
, *
pn
, 
ret
);

2449 return 
ret
;

2451 if (*
next_expected_pn
 <= *
pn
)

2452 *
next_expected_pn
 = *
pn
 + 1;

2454 *
payload
 = 
	`ptls_iovec_init
(
packet
->
octets
.
base
 + 
aead_off
, 
ptlen
);

2456 
	}
}

2458 static int 
	$decrypt_packet
(
ptls_cipher_context_t
 *
header_protection
,

2459 int (*
aead_cb
)(void *, 
uint64_t
, 
quicly_decoded_packet_t
 *, 
size_t
, size_t *), void *
aead_ctx
,

2460 
uint64_t
 *
next_expected_pn
, 
quicly_decoded_packet_t
 *
packet
, uint64_t *
pn
, 
ptls_iovec_t
 *
payload
)

2462 int 
ret
;

2465 if (
packet
->
decrypted
.
pn
 == 
UINT64_MAX
) {

2466 if ((
ret
 = 
	`do_decrypt_packet
(
header_protection
, 
aead_cb
, 
aead_ctx
, 
next_expected_pn
, 
packet
, 
pn
, 
payload
)) != 0)

2467 return 
ret
;

2469 *
payload
 = 
	`ptls_iovec_init
(
packet
->
octets
.
base
 + packet->
encrypted_off
, packet->octets.
len
 - packet->encrypted_off);

2470 *
pn
 = 
packet
->
decrypted
.pn;

2471 if (
aead_cb
 == 
aead_decrypt_1rtt
) {

2472 
quicly_conn_t
 *
conn
 = 
aead_ctx
;

2473 if (
conn
->
application
->
cipher
.
ingress
.
key_phase
.
decrypted
 < 
packet
->decrypted.key_phase) {

2474 if ((
ret
 = 
	`received_key_update
(
conn
, 
packet
->
decrypted
.
key_phase
)) != 0)

2475 return 
ret
;

2478 if (*
next_expected_pn
 < *
pn
)

2479 *
next_expected_pn
 = *
pn
 + 1;

2483 if ((
packet
->
octets
.
base
[0] & (
	`QUICLY_PACKET_IS_LONG_HEADER
(packet->octets.base[0]) ? 
QUICLY_LONG_HEADER_RESERVED_BITS


2484 : 
QUICLY_SHORT_HEADER_RESERVED_BITS
)) !=

2486 if (
QUICLY_DEBUG
)

2487 
	`fprintf
(
stderr
, "%s: non-zero reserved bits (pn: %" 
PRIu64
 ")\n", 
__FUNCTION__
, *
pn
);

2488 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

2490 if (
payload
->
len
 == 0) {

2491 if (
QUICLY_DEBUG
)

2492 
	`fprintf
(
stderr
, "%s: payload length is zero (pn: %" 
PRIu64
 ")\n", 
__FUNCTION__
, *
pn
);

2493 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

2496 if (
QUICLY_DEBUG
) {

2497 char *
payload_hex
 = 
	`quicly_hexdump
(
payload
->
base
, payload->
len
, 4);

2498 
	`fprintf
(
stderr
, "%s: AEAD payload:\n%s", 
__FUNCTION__
, 
payload_hex
);

2499 
	`free
(
payload_hex
);

2503 
	}
}

2505 static int 
	$on_ack_ack
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2507 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2511 if (
acked
) {

2513 struct 
st_quicly_pn_space_t
 *
space
;

2514 switch (
packet
->
ack_epoch
) {

2515 case 
QUICLY_EPOCH_INITIAL
:

2516 
space
 = &
conn
->
initial
->
super
;

2518 case 
QUICLY_EPOCH_HANDSHAKE
:

2519 
space
 = &
conn
->
handshake
->
super
;

2521 case 
QUICLY_EPOCH_1RTT
:

2522 
space
 = &
conn
->
application
->
super
;

2525 
	`assert
(!"FIXME");

2526 return 
QUICLY_TRANSPORT_ERROR_INTERNAL
;

2529 int 
ret
;

2530 if ((
ret
 = 
	`quicly_ranges_subtract
(&
space
->
ack_queue
, 
sent
->
data
.
ack
.
range
.
start
, sent->data.ack.range.
end
)) != 0)

2531 return 
ret
;

2532 if (
space
->
ack_queue
.
num_ranges
 == 0) {

2533 
space
->
largest_pn_received_at
 = 
INT64_MAX
;

2534 
space
->
unacked_count
 = 0;

2535 } else if (
space
->
ack_queue
.
num_ranges
 > 
QUICLY_MAX_ACK_BLOCKS
) {

2536 
	`quicly_ranges_drop_by_range_indices
(&
space
->
ack_queue
, space->ack_queue.
num_ranges
 - 
QUICLY_MAX_ACK_BLOCKS
,

2537 
space
->
ack_queue
.
num_ranges
);

2542 
	}
}

2544 static int 
	$on_ack_stream_ack_one
(
quicly_conn_t
 *
conn
, 
quicly_stream_id_t
 
stream_id
, 
quicly_sendstate_sent_t
 *
sent
)

2546 
quicly_stream_t
 *
stream
;

2547 int 
ret
;

2549 if ((
stream
 = 
	`quicly_get_stream
(
conn
, 
stream_id
)) == 
NULL
)

2552 
size_t
 
bytes_to_shift
;

2553 if ((
ret
 = 
	`quicly_sendstate_acked
(&
stream
->
sendstate
, 
sent
, &
bytes_to_shift
)) != 0)

2554 return 
ret
;

2555 if (
bytes_to_shift
 != 0) {

2556 
	`QUICLY_PROBE
(
STREAM_ON_SEND_SHIFT
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream, 
bytes_to_shift
);

2557 
stream
->
callbacks
->
	`on_send_shift
(stream, 
bytes_to_shift
);

2559 if (
	`stream_is_destroyable
(
stream
)) {

2560 
	`destroy_stream
(
stream
, 0);

2561 } else if (
stream
->
_send_aux
.
reset_stream
.
sender_state
 == 
QUICLY_SENDER_STATE_NONE
) {

2562 
	`resched_stream_data
(
stream
);

2566 
	}
}

2568 static int 
	$on_ack_stream_ack_cached
(
quicly_conn_t
 *
conn
)

2570 int 
ret
;

2572 if (
conn
->
stash
.
on_ack_stream
.
active_acked_cache
.
stream_id
 == 
INT64_MIN
)

2574 
ret
 = 
	`on_ack_stream_ack_one
(
conn
, conn->
stash
.
on_ack_stream
.
active_acked_cache
.
stream_id
,

2575 &
conn
->
stash
.
on_ack_stream
.
active_acked_cache
.
args
);

2576 
conn
->
stash
.
on_ack_stream
.
active_acked_cache
.
stream_id
 = 
INT64_MIN
;

2577 return 
ret
;

2578 
	}
}

2580 static int 
	$on_ack_stream
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2582 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2583 int 
ret
;

2585 if (
acked
) {

2587 
	`QUICLY_PROBE
(
STREAM_ACKED
, 
conn
, conn->
stash
.
now
, 
sent
->
data
.
stream
.
stream_id
, sent->data.stream.
args
.
start
,

2588 
sent
->
data
.
stream
.
args
.
end
 - sent->data.stream.args.
start
);

2590 if (
packet
->
frames_in_flight
 && 
conn
->
stash
.
on_ack_stream
.
active_acked_cache
.
stream_id
 == 
sent
->
data
.
stream
.stream_id &&

2591 
conn
->
stash
.
on_ack_stream
.
active_acked_cache
.
args
.
end
 == 
sent
->
data
.
stream
.args.
start
) {

2593 
conn
->
stash
.
on_ack_stream
.
active_acked_cache
.
args
.
end
 = 
sent
->
data
.
stream
.args.end;

2597 if ((
ret
 = 
	`on_ack_stream_ack_cached
(
conn
)) != 0)

2598 return 
ret
;

2599 if (
packet
->
frames_in_flight
) {

2600 
conn
->
stash
.
on_ack_stream
.
active_acked_cache
.
stream_id
 = 
sent
->
data
.
stream
.stream_id;

2601 
conn
->
stash
.
on_ack_stream
.
active_acked_cache
.
args
 = 
sent
->
data
.
stream
.args;

2603 if ((
ret
 = 
	`on_ack_stream_ack_one
(
conn
, 
sent
->
data
.
stream
.
stream_id
, &sent->data.stream.
args
)) != 0)

2604 return 
ret
;

2610 
	`QUICLY_PROBE
(
STREAM_LOST
, 
conn
, conn->
stash
.
now
, 
sent
->
data
.
stream
.
stream_id
, sent->data.stream.
args
.
start
,

2611 
sent
->
data
.
stream
.
args
.
end
 - sent->data.stream.args.
start
);

2613 
quicly_stream_t
 *
stream
;

2614 if ((
stream
 = 
	`quicly_get_stream
(
conn
, 
sent
->
data
.stream.
stream_id
)) == 
NULL
)

2617 if ((
ret
 = 
	`quicly_sendstate_lost
(&
stream
->
sendstate
, &
sent
->
data
.stream.
args
)) != 0)

2618 return 
ret
;

2619 if (
stream
->
_send_aux
.
reset_stream
.
sender_state
 == 
QUICLY_SENDER_STATE_NONE
)

2620 
	`resched_stream_data
(
stream
);

2624 
	}
}

2626 static int 
	$on_ack_max_stream_data
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2628 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2629 
quicly_stream_t
 *
stream
;

2631 if ((
stream
 = 
	`quicly_get_stream
(
conn
, 
sent
->
data
.stream.
stream_id
)) != 
NULL
) {

2632 if (
acked
) {

2633 
	`quicly_maxsender_acked
(&
stream
->
_send_aux
.
max_stream_data_sender
, &
sent
->
data
.
max_stream_data
.
args
);

2635 
	`quicly_maxsender_lost
(&
stream
->
_send_aux
.
max_stream_data_sender
, &
sent
->
data
.
max_stream_data
.
args
);

2636 if (
	`should_send_max_stream_data
(
stream
))

2637 
	`sched_stream_control
(
stream
);

2642 
	}
}

2644 static int 
	$on_ack_max_data
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2646 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2648 if (
acked
) {

2649 
	`quicly_maxsender_acked
(&
conn
->
ingress
.
max_data
.
sender
, &
sent
->
data
.max_data.
args
);

2651 
	`quicly_maxsender_lost
(&
conn
->
ingress
.
max_data
.
sender
, &
sent
->
data
.max_data.
args
);

2655 
	}
}

2657 static int 
	$on_ack_max_streams
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2659 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2660 
quicly_maxsender_t
 *
maxsender
 = 
sent
->
data
.
max_streams
.
uni
 ? &
conn
->
ingress
.max_streams.uni : &conn->ingress.max_streams.
bidi
;

2661 
	`assert
(
maxsender
 != 
NULL
);

2663 if (
acked
) {

2664 
	`quicly_maxsender_acked
(
maxsender
, &
sent
->
data
.
max_streams
.
args
);

2666 
	`quicly_maxsender_lost
(
maxsender
, &
sent
->
data
.
max_streams
.
args
);

2670 
	}
}

2672 static void 
	$on_ack_stream_state_sender
(
quicly_sender_state_t
 *
sender_state
, int 
acked
)

2674 *
sender_state
 = 
acked
 ? 
QUICLY_SENDER_STATE_ACKED
 : 
QUICLY_SENDER_STATE_SEND
;

2675 
	}
}

2677 static int 
	$on_ack_reset_stream
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2679 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2680 
quicly_stream_t
 *
stream
;

2682 if ((
stream
 = 
	`quicly_get_stream
(
conn
, 
sent
->
data
.
stream_state_sender
.
stream_id
)) != 
NULL
) {

2683 
	`on_ack_stream_state_sender
(&
stream
->
_send_aux
.
reset_stream
.
sender_state
, 
acked
);

2684 if (
	`stream_is_destroyable
(
stream
))

2685 
	`destroy_stream
(
stream
, 0);

2689 
	}
}

2691 static int 
	$on_ack_stop_sending
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2693 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2694 
quicly_stream_t
 *
stream
;

2696 if ((
stream
 = 
	`quicly_get_stream
(
conn
, 
sent
->
data
.
stream_state_sender
.
stream_id
)) != 
NULL
) {

2697 
	`on_ack_stream_state_sender
(&
stream
->
_send_aux
.
stop_sending
.
sender_state
, 
acked
);

2698 if (
stream
->
_send_aux
.
stop_sending
.
sender_state
 != 
QUICLY_SENDER_STATE_ACKED
)

2699 
	`sched_stream_control
(
stream
);

2703 
	}
}

2705 static int 
	$on_ack_streams_blocked
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2707 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2708 struct 
st_quicly_max_streams_t
 *
m
 =

2709 
sent
->
data
.
streams_blocked
.
uni
 ? &
conn
->
egress
.
max_streams
.uni : &conn->egress.max_streams.
bidi
;

2711 if (
acked
) {

2712 
	`quicly_maxsender_acked
(&
m
->
blocked_sender
, &
sent
->
data
.
streams_blocked
.
args
);

2714 
	`quicly_maxsender_lost
(&
m
->
blocked_sender
, &
sent
->
data
.
streams_blocked
.
args
);

2718 
	}
}

2720 static int 
	$on_ack_handshake_done
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2722 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2725 if (
acked
) {

2726 
conn
->
egress
.
pending_flows
 &= ~
QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT
;

2728 
conn
->
egress
.
pending_flows
 |= 
QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT
;

2731 
	}
}

2733 static int 
	$on_ack_data_blocked
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2735 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2737 if (
conn
->
egress
.
max_data
.
permitted
 == 
sent
->
data
.
data_blocked
.
offset
) {

2738 if (
acked
) {

2739 
conn
->
egress
.
data_blocked
 = 
QUICLY_SENDER_STATE_ACKED
;

2740 } else if (
packet
->
frames_in_flight
 && 
conn
->
egress
.
data_blocked
 == 
QUICLY_SENDER_STATE_UNACKED
) {

2741 
conn
->
egress
.
data_blocked
 = 
QUICLY_SENDER_STATE_SEND
;

2746 
	}
}

2748 static int 
	$on_ack_stream_data_blocked_frame
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
,

2749 
quicly_sent_t
 *
sent
)

2751 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2752 
quicly_stream_t
 *
stream
;

2754 if ((
stream
 = 
	`quicly_get_stream
(
conn
, 
sent
->
data
.
stream_data_blocked
.
stream_id
)) == 
NULL
)

2757 if (
stream
->
_send_aux
.
max_stream_data
 == 
sent
->
data
.
stream_data_blocked
.
offset
) {

2758 if (
acked
) {

2759 
stream
->
_send_aux
.
blocked
 = 
QUICLY_SENDER_STATE_ACKED
;

2760 } else if (
packet
->
frames_in_flight
 && 
stream
->
_send_aux
.
blocked
 == 
QUICLY_SENDER_STATE_UNACKED
) {

2761 
stream
->
_send_aux
.
blocked
 = 
QUICLY_SENDER_STATE_SEND
;

2762 
	`sched_stream_control
(
stream
);

2767 
	}
}

2769 static int 
	$on_ack_new_token
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2771 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2773 if (
sent
->
data
.
new_token
.
is_inflight
) {

2774 --
conn
->
egress
.
new_token
.
num_inflight
;

2775 
sent
->
data
.
new_token
.
is_inflight
 = 0;

2777 if (
acked
) {

2778 
	`QUICLY_PROBE
(
NEW_TOKEN_ACKED
, 
conn
, conn->
stash
.
now
, 
sent
->
data
.
new_token
.
generation
);

2779 if (
conn
->
egress
.
new_token
.
max_acked
 < 
sent
->
data
.new_token.
generation
)

2780 
conn
->
egress
.
new_token
.
max_acked
 = 
sent
->
data
.new_token.
generation
;

2783 if (
conn
->
egress
.
new_token
.
num_inflight
 == 0 && conn->egress.new_token.
max_acked
 < conn->egress.new_token.
generation
)

2784 
conn
->
egress
.
pending_flows
 |= 
QUICLY_PENDING_FLOW_NEW_TOKEN_BIT
;

2787 
	}
}

2789 static int 
	$on_ack_new_connection_id
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2791 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2792 
uint64_t
 
sequence
 = 
sent
->
data
.
new_connection_id
.sequence;

2794 if (
acked
) {

2795 
	`quicly_local_cid_on_acked
(&
conn
->
super
.
local
.
cid_set
, 
sequence
);

2797 if (
	`quicly_local_cid_on_lost
(&
conn
->
super
.
local
.
cid_set
, 
sequence
))

2798 
conn
->
egress
.
pending_flows
 |= 
QUICLY_PENDING_FLOW_CID_FRAME_BIT
;

2802 
	}
}

2804 static int 
	$on_ack_retire_connection_id
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

2806 
quicly_conn_t
 *
conn
 = (quicly_conn_t *)((char *)
map
 - 
	`offsetof
(quicly_conn_t, 
egress
.
loss
.
sentmap
));

2807 
uint64_t
 
sequence
 = 
sent
->
data
.
retire_connection_id
.sequence;

2809 if (!
acked
)

2810 
	`schedule_retire_connection_id_frame
(
conn
, 
sequence
);

2813 
	}
}

2815 static int 
	$should_send_datagram_frame
(
quicly_conn_t
 *
conn
)

2817 if (
conn
->
egress
.
datagram_frame_payloads
.
count
 == 0)

2819 if (
conn
->
application
 == 
NULL
)

2821 if (
conn
->
application
->
cipher
.
egress
.
key
.
aead
 == 
NULL
)

2824 
	}
}

2826 static 
inline
 
uint64_t
 
	$calc_amplification_limit_allowance
(
quicly_conn_t
 *
conn
)

2828 if (
conn
->
super
.
remote
.
address_validation
.
validated
)

2829 return 
UINT64_MAX
;

2830 
uint64_t
 
budget
 = 
conn
->
super
.
stats
.
num_bytes
.
received
 * conn->super.
ctx
->
pre_validation_amplification_limit
;

2831 if (
budget
 <= 
conn
->
super
.
stats
.
num_bytes
.
sent
)

2833 return 
budget
 - 
conn
->
super
.
stats
.
num_bytes
.
sent
;

2834 
	}
}

2842 static 
size_t
 
	$calc_send_window
(
quicly_conn_t
 *
conn
, 
size_t
 
min_bytes_to_send
, 
uint64_t
 
amp_window
, int 
restrict_sending
)

2844 
uint64_t
 
window
 = 0;

2845 if (
restrict_sending
) {

2847 
window
 = 
min_bytes_to_send
;

2850 if (
conn
->
egress
.
cc
.
cwnd
 > conn->egress.
loss
.
sentmap
.
bytes_in_flight
)

2851 
window
 = 
conn
->
egress
.
cc
.
cwnd
 - conn->egress.
loss
.
sentmap
.
bytes_in_flight
;

2853 
window
 = window > 
min_bytes_to_send
 ? window : min_bytes_to_send;

2856 if (
amp_window
 < 
window
)

2857 
window
 = 
amp_window
;

2859 return 
window
;

2860 
	}
}

2866 static int 
	$is_point5rtt_with_no_handshake_data_to_send
(
quicly_conn_t
 *
conn
)

2869 if (!(
conn
->
handshake
 != 
NULL
 && conn->
application
 != NULL && !
	`quicly_is_client
(conn)))

2871 
quicly_stream_t
 *
stream
 = 
	`quicly_get_stream
(
conn
, (
quicly_stream_id_t
)-1 - 
QUICLY_EPOCH_HANDSHAKE
);

2872 
	`assert
(
stream
 != 
NULL
);

2873 return 
stream
->
sendstate
.
pending
.
num_ranges
 == 0 && stream->sendstate.
acked
.
ranges
[0].
end
 == stream->sendstate.
size_inflight
;

2874 
	}
}

2876 
int64_t
 
	$quicly_get_first_timeout
(
quicly_conn_t
 *
conn
)

2878 if (
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
)

2879 return 
conn
->
egress
.
send_ack_at
;

2881 if (
	`should_send_datagram_frame
(
conn
))

2884 
uint64_t
 
amp_window
 = 
	`calc_amplification_limit_allowance
(
conn
);

2886 if (
	`calc_send_window
(
conn
, 0, 
amp_window
, 0) > 0) {

2887 if (
conn
->
egress
.
pending_flows
 != 0)

2889 if (
	`quicly_linklist_is_linked
(&
conn
->
egress
.
pending_streams
.
control
))

2891 if (
	`scheduler_can_send
(
conn
))

2896 
int64_t
 
at
 = 
conn
->
idle_timeout
.at;

2897 if (
amp_window
 > 0) {

2898 if (
conn
->
egress
.
loss
.
alarm_at
 < 
at
 && !
	`is_point5rtt_with_no_handshake_data_to_send
(conn))

2899 
at
 = 
conn
->
egress
.
loss
.
alarm_at
;

2900 if (
conn
->
egress
.
send_ack_at
 < 
at
)

2901 
at
 = 
conn
->
egress
.
send_ack_at
;

2904 return 
at
;

2905 
	}
}

2907 
uint64_t
 
	$quicly_get_next_expected_packet_number
(
quicly_conn_t
 *
conn
)

2909 if (!
conn
->
application
)

2910 return 
UINT64_MAX
;

2912 return 
conn
->
application
->
super
.
next_expected_packet_number
;

2913 
	}
}

2918 struct 
	sst_quicly_send_context_t
 {

2923 struct 
st_quicly_cipher_context_t
 *
	mcipher
;

2924 
uint8_t
 
	mfirst_byte
;

2925 } 
	mcurrent
;

2930 struct 
st_quicly_cipher_context_t
 *
	mcipher
;

2935 
uint8_t
 *
	mfirst_byte_at
;

2936 
uint8_t
 
	mack_eliciting
 : 1;

2937 } 
	mtarget
;

2941 struct 
iovec
 *
	mdatagrams
;

2945 
size_t
 
	mmax_datagrams
;

2949 
size_t
 
	mnum_datagrams
;

2957 
uint8_t
 *
	mdatagram
;

2961 
uint8_t
 *
	mend
;

2962 } 
	mpayload_buf
;

2967 
ssize_t
 
	msend_window
;

2971 
uint8_t
 *
	mdst
;

2975 
uint8_t
 *
	mdst_end
;

2979 
uint8_t
 *
	mdst_payload_from
;

2982 enum 
	een_quicly_send_packet_mode_t
 {

2983 
	mQUICLY_COMMIT_SEND_PACKET_MODE_FULL_SIZE
,

2984 
	mQUICLY_COMMIT_SEND_PACKET_MODE_SMALL
,

2985 
	mQUICLY_COMMIT_SEND_PACKET_MODE_COALESCED
,

2988 static int 
	$commit_send_packet
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
, enum 
en_quicly_send_packet_mode_t
 
mode
)

2990 
size_t
 
datagram_size
, 
packet_bytes_in_flight
;

2992 
	`assert
(
s
->
target
.
cipher
->
aead
 != 
NULL
);

2994 
	`assert
(
s
->
dst
 != s->
dst_payload_from
);

2997 while (
s
->
dst
 - s->
dst_payload_from
 < 
QUICLY_MAX_PN_SIZE
 - 
QUICLY_SEND_PN_SIZE
)

2998 *
s
->
dst
++ = 
QUICLY_FRAME_TYPE_PADDING
;

3000 if (
mode
 == 
QUICLY_COMMIT_SEND_PACKET_MODE_FULL_SIZE
) {

3001 
	`assert
(
s
->
num_datagrams
 == 0 || s->
datagrams
[s->num_datagrams - 1].
iov_len
 == 
conn
->
egress
.
max_udp_payload_size
);

3002 const 
size_t
 
max_size
 = 
conn
->
egress
.
max_udp_payload_size
 - 
QUICLY_AEAD_TAG_SIZE
;

3003 
	`assert
(
s
->
dst
 - s->
payload_buf
.
datagram
 <= 
max_size
);

3004 
	`memset
(
s
->
dst
, 
QUICLY_FRAME_TYPE_PADDING
, s->
payload_buf
.
datagram
 + 
max_size
 - s->dst);

3005 
s
->
dst
 = s->
payload_buf
.
datagram
 + 
max_size
;

3009 if (
	`QUICLY_PACKET_IS_LONG_HEADER
(*
s
->
target
.
first_byte_at
)) {

3010 
uint16_t
 
length
 = 
s
->
dst
 - s->
dst_payload_from
 + s->
target
.
cipher
->
aead
->
algo
->
tag_size
 + 
QUICLY_SEND_PN_SIZE
;

3012 
length
 |= 0x4000;

3013 
	`quicly_encode16
(
s
->
dst_payload_from
 - 
QUICLY_SEND_PN_SIZE
 - 2, 
length
);

3015 if (
conn
->
egress
.
packet_number
 >= conn->
application
->
cipher
.egress.
key_update_pn
.
next
) {

3016 int 
ret
;

3017 if ((
ret
 = 
	`update_1rtt_egress_key
(
conn
)) != 0)

3018 return 
ret
;

3020 if ((
conn
->
application
->
cipher
.
egress
.
key_phase
 & 1) != 0)

3021 *
s
->
target
.
first_byte_at
 |= 
QUICLY_KEY_PHASE_BIT
;

3023 
	`quicly_encode16
(
s
->
dst_payload_from
 - 
QUICLY_SEND_PN_SIZE
, (
uint16_t
)
conn
->
egress
.
packet_number
);

3026 
s
->
dst
 += s->
target
.
cipher
->
aead
->
algo
->
tag_size
;

3027 
datagram_size
 = 
s
->
dst
 - s->
payload_buf
.
datagram
;

3028 
	`assert
(
datagram_size
 <= 
conn
->
egress
.
max_udp_payload_size
);

3030 
conn
->
super
.
ctx
->
crypto_engine
->
	`encrypt_packet
(conn->super.ctx->crypto_engine, conn, 
s
->
target
.
cipher
->
header_protection
,

3031 
s
->
target
.
cipher
->
aead
, 
	`ptls_iovec_init
(s->
payload_buf
.
datagram
, 
datagram_size
),

3032 
s
->
target
.
first_byte_at
 - s->
payload_buf
.
datagram
,

3033 
s
->
dst_payload_from
 - s->
payload_buf
.
datagram
, 
conn
->
egress
.
packet_number
,

3034 
mode
 == 
QUICLY_COMMIT_SEND_PACKET_MODE_COALESCED
);

3037 if (
s
->
target
.
ack_eliciting
) {

3038 
packet_bytes_in_flight
 = 
s
->
dst
 - s->
target
.
first_byte_at
;

3039 
s
->
send_window
 -= 
packet_bytes_in_flight
;

3041 
packet_bytes_in_flight
 = 0;

3043 if (
	`quicly_sentmap_is_open
(&
conn
->
egress
.
loss
.
sentmap
))

3044 
	`quicly_sentmap_commit
(&
conn
->
egress
.
loss
.
sentmap
, (
uint16_t
)
packet_bytes_in_flight
);

3046 
conn
->
egress
.
cc
.
type
->
	`cc_on_sent
(&conn->egress.cc, &conn->egress.
loss
, (
uint32_t
)
packet_bytes_in_flight
, conn->
stash
.
now
);

3047 
	`QUICLY_PROBE
(
PACKET_SENT
, 
conn
, conn->
stash
.
now
, conn->
egress
.
packet_number
, 
s
->
dst
 - s->
target
.
first_byte_at
,

3048 
	`get_epoch
(*
s
->
target
.
first_byte_at
), !s->target.
ack_eliciting
);

3050 ++
conn
->
egress
.
packet_number
;

3051 ++
conn
->
super
.
stats
.
num_packets
.
sent
;

3053 if (
mode
 != 
QUICLY_COMMIT_SEND_PACKET_MODE_COALESCED
) {

3054 
conn
->
super
.
stats
.
num_bytes
.
sent
 += 
datagram_size
;

3055 
s
->
datagrams
[s->
num_datagrams
++] = (struct 
iovec
){.
iov_base
 = s->
payload_buf
.
datagram
, .
iov_len
 = 
datagram_size
};

3056 
s
->
payload_buf
.
datagram
 += 
datagram_size
;

3057 
s
->
target
.
cipher
 = 
NULL
;

3058 
s
->
target
.
first_byte_at
 = 
NULL
;

3063 if (
conn
->
egress
.
packet_number
 >= conn->egress.
next_pn_to_skip
 && !
	`QUICLY_PACKET_IS_LONG_HEADER
(
s
->
current
.
first_byte
) &&

3064 
conn
->
super
.
state
 < 
QUICLY_STATE_CLOSING
) {

3065 int 
ret
;

3066 if ((
ret
 = 
	`quicly_sentmap_prepare
(&
conn
->
egress
.
loss
.
sentmap
, conn->egress.
packet_number
, conn->
stash
.
now
,

3067 
QUICLY_EPOCH_1RTT
)) != 0)

3068 return 
ret
;

3069 if (
	`quicly_sentmap_allocate
(&
conn
->
egress
.
loss
.
sentmap
, 
on_invalid_ack
) == 
NULL
)

3070 return 
PTLS_ERROR_NO_MEMORY
;

3071 
	`quicly_sentmap_commit
(&
conn
->
egress
.
loss
.
sentmap
, 0);

3072 ++
conn
->
egress
.
packet_number
;

3073 
conn
->
egress
.
next_pn_to_skip
 = 
	`calc_next_pn_to_skip
(conn->
super
.
ctx
->
tls
, conn->egress.
packet_number
, conn->egress.
cc
.
cwnd
,

3074 
conn
->
egress
.
max_udp_payload_size
);

3078 
	}
}

3080 static 
inline
 
uint8_t
 *
	$emit_cid
(
uint8_t
 *
dst
, const 
quicly_cid_t
 *
cid
)

3082 if (
cid
->
len
 != 0) {

3083 
	`memcpy
(
dst
, 
cid
->cid, cid->
len
);

3084 
dst
 += 
cid
->
len
;

3086 return 
dst
;

3087 
	}
}

3089 static int 
	$_do_allocate_frame
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
, 
size_t
 
min_space
, int 
ack_eliciting
)

3091 int 
coalescible
, 
ret
;

3093 
	`assert
((
s
->
current
.
first_byte
 & 
QUICLY_QUIC_BIT
) != 0);

3096 if (
s
->
dst_end
 - s->
dst
 < 
min_space
 || s->
target
.
first_byte_at
 == 
NULL
) {

3097 
coalescible
 = 0;

3098 } else if (((*
s
->
target
.
first_byte_at
 ^ s->
current
.
first_byte
) & 
QUICLY_PACKET_TYPE_BITMASK
) != 0) {

3099 
coalescible
 = 
	`QUICLY_PACKET_IS_LONG_HEADER
(*
s
->
target
.
first_byte_at
);

3100 } else if (
s
->
dst_end
 - s->
dst
 < 
min_space
) {

3101 
coalescible
 = 0;

3104 goto 
TargetReady
;

3108 if (
s
->
target
.
first_byte_at
 != 
NULL
) {

3109 if (
coalescible
) {

3110 
size_t
 
overhead
 = 1 + 
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
.
len
 + 
QUICLY_SEND_PN_SIZE
 +

3111 
s
->
current
.
cipher
->
aead
->
algo
->
tag_size
;

3112 if (
	`QUICLY_PACKET_IS_LONG_HEADER
(
s
->
current
.
first_byte
))

3113 
overhead
 += 4 + 1 + 
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
.
len
 +

3114 
conn
->
super
.
local
.
long_header_src_cid
.
len
 +

3115 (
s
->
current
.
first_byte
 == 
QUICLY_PACKET_TYPE_INITIAL
) + 2 ;

3116 
size_t
 
packet_min_space
 = 
QUICLY_MAX_PN_SIZE
 - 
QUICLY_SEND_PN_SIZE
;

3117 if (
packet_min_space
 < 
min_space
)

3118 
packet_min_space
 = 
min_space
;

3119 if (
overhead
 + 
packet_min_space
 > 
s
->
dst_end
 - s->
dst
)

3120 
coalescible
 = 0;

3123 if ((
ret
 = 
	`commit_send_packet
(

3124 
conn
, 
s
, 
coalescible
 ? 
QUICLY_COMMIT_SEND_PACKET_MODE_COALESCED
 : 
QUICLY_COMMIT_SEND_PACKET_MODE_FULL_SIZE
)) != 0)

3125 return 
ret
;

3127 
coalescible
 = 0;

3131 if (
coalescible
) {

3132 
s
->
dst_end
 += s->
target
.
cipher
->
aead
->
algo
->
tag_size
;

3133 
s
->
target
.
cipher
 = s->
current
.cipher;

3135 if (
s
->
num_datagrams
 >= s->
max_datagrams
)

3136 return 
QUICLY_ERROR_SENDBUF_FULL
;

3138 if (
ack_eliciting
 && 
s
->
send_window
 <= 0)

3139 return 
QUICLY_ERROR_SENDBUF_FULL
;

3140 if (
s
->
payload_buf
.
end
 - s->payload_buf.
datagram
 < 
conn
->
egress
.
max_udp_payload_size
)

3141 return 
QUICLY_ERROR_SENDBUF_FULL
;

3142 
s
->
target
.
cipher
 = s->
current
.cipher;

3143 
s
->
dst
 = s->
payload_buf
.
datagram
;

3144 
s
->
dst_end
 = s->
dst
 + 
conn
->
egress
.
max_udp_payload_size
;

3146 
s
->
target
.
ack_eliciting
 = 0;

3148 
	`QUICLY_PROBE
(
PACKET_PREPARE
, 
conn
, conn->
stash
.
now
, 
s
->
current
.
first_byte
,

3149 
	`QUICLY_PROBE_HEXDUMP
(
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
.cid, conn->super.remote.cid_set.cids[0].cid.
len
));

3152 
s
->
target
.
first_byte_at
 = s->
dst
;

3153 *
s
->
dst
++ = s->
current
.
first_byte
 | 0x1 ;

3154 if (
	`QUICLY_PACKET_IS_LONG_HEADER
(
s
->
current
.
first_byte
)) {

3155 
s
->
dst
 = 
	`quicly_encode32
(s->dst, 
conn
->
super
.
version
);

3156 *
s
->
dst
++ = 
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
.
len
;

3157 
s
->
dst
 = 
	`emit_cid
(s->dst, &
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
);

3158 *
s
->
dst
++ = 
conn
->
super
.
local
.
long_header_src_cid
.
len
;

3159 
s
->
dst
 = 
	`emit_cid
(s->dst, &
conn
->
super
.
local
.
long_header_src_cid
);

3161 if (
s
->
current
.
first_byte
 == 
QUICLY_PACKET_TYPE_INITIAL
) {

3162 
s
->
dst
 = 
	`quicly_encodev
(s->dst, 
conn
->
token
.
len
);

3163 if (
conn
->
token
.
len
 != 0) {

3164 
	`assert
(
s
->
dst_end
 - s->
dst
 > 
conn
->
token
.
len
);

3165 
	`memcpy
(
s
->
dst
, 
conn
->
token
.
base
, conn->token.
len
);

3166 
s
->
dst
 += 
conn
->
token
.
len
;

3170 *
s
->
dst
++ = 0;

3171 *
s
->
dst
++ = 0;

3173 
s
->
dst
 = 
	`emit_cid
(s->dst, &
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
);

3175 
s
->
dst
 += 
QUICLY_SEND_PN_SIZE
;

3176 
s
->
dst_payload_from
 = s->
dst
;

3177 
	`assert
(
s
->
target
.
cipher
->
aead
 != 
NULL
);

3178 
s
->
dst_end
 -= s->
target
.
cipher
->
aead
->
algo
->
tag_size
;

3179 
	`assert
(
s
->
dst_end
 - s->
dst
 >= 
QUICLY_MAX_PN_SIZE
 - 
QUICLY_SEND_PN_SIZE
);

3181 if (
conn
->
super
.
state
 < 
QUICLY_STATE_CLOSING
) {

3183 
uint8_t
 
ack_epoch
 = 
	`get_epoch
(
s
->
current
.
first_byte
);

3184 if (
ack_epoch
 == 
QUICLY_EPOCH_0RTT
)

3185 
ack_epoch
 = 
QUICLY_EPOCH_1RTT
;

3186 if ((
ret
 = 
	`quicly_sentmap_prepare
(&
conn
->
egress
.
loss
.
sentmap
, conn->egress.
packet_number
, conn->
stash
.
now
, 
ack_epoch
)) != 0)

3187 return 
ret
;

3189 if (
conn
->
stash
.
now
 >= conn->
egress
.
ack_frequency
.
update_at
) {

3190 if (
conn
->
egress
.
packet_number
 >= 
QUICLY_FIRST_ACK_FREQUENCY_PACKET_NUMBER
 && conn->
initial
 == 
NULL
 &&

3191 
conn
->
handshake
 == 
NULL
) {

3192 
uint32_t
 
fraction_of_cwnd
 = 
conn
->
egress
.
cc
.
cwnd
 / 
QUICLY_ACK_FREQUENCY_CWND_FRACTION
;

3193 if (
fraction_of_cwnd
 >= 
conn
->
egress
.
max_udp_payload_size
 * 3) {

3194 
uint32_t
 
packet_tolerance
 = 
fraction_of_cwnd
 / 
conn
->
egress
.
max_udp_payload_size
;

3195 if (
packet_tolerance
 > 
QUICLY_MAX_PACKET_TOLERANCE
)

3196 
packet_tolerance
 = 
QUICLY_MAX_PACKET_TOLERANCE
;

3197 
s
->
dst
 = 
	`quicly_encode_ack_frequency_frame
(s->dst, 
conn
->
egress
.
ack_frequency
.
sequence
++, 
packet_tolerance
,

3198 
conn
->
super
.
remote
.
transport_params
.
max_ack_delay
 * 1000, 0);

3199 ++
conn
->
super
.
stats
.
num_frames_sent
.
ack_frequency
;

3202 
	`ack_frequency_set_next_update_at
(
conn
);

3206 
TargetReady
:

3207 if (
ack_eliciting
) {

3208 
s
->
target
.
ack_eliciting
 = 1;

3209 
conn
->
egress
.
last_retransmittable_sent_at
 = conn->
stash
.
now
;

3212 
	}
}

3214 static int 
	$allocate_frame
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
, 
size_t
 
min_space
)

3216 return 
	`_do_allocate_frame
(
conn
, 
s
, 
min_space
, 0);

3217 
	}
}

3219 static int 
	$allocate_ack_eliciting_frame
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
, 
size_t
 
min_space
, 
quicly_sent_t
 **
sent
,

3220 
quicly_sent_acked_cb
 
acked
)

3222 int 
ret
;

3224 if ((
ret
 = 
	`_do_allocate_frame
(
conn
, 
s
, 
min_space
, 1)) != 0)

3225 return 
ret
;

3226 if ((*
sent
 = 
	`quicly_sentmap_allocate
(&
conn
->
egress
.
loss
.
sentmap
, 
acked
)) == 
NULL
)

3227 return 
PTLS_ERROR_NO_MEMORY
;

3229 return 
ret
;

3230 
	}
}

3232 static int 
	$send_ack
(
quicly_conn_t
 *
conn
, struct 
st_quicly_pn_space_t
 *
space
, 
quicly_send_context_t
 *
s
)

3234 
uint64_t
 
ack_delay
;

3235 int 
ret
;

3237 if (
space
->
ack_queue
.
num_ranges
 == 0)

3241 if (
space
->
largest_pn_received_at
 < 
conn
->
stash
.
now
) {

3244 
ack_delay
 = ((
conn
->
stash
.
now
 - 
space
->
largest_pn_received_at
) * 1000) >> 
QUICLY_LOCAL_ACK_DELAY_EXPONENT
;

3246 
ack_delay
 = 0;

3249 
Emit
:

3250 if ((
ret
 = 
	`allocate_frame
(
conn
, 
s
, 
QUICLY_ACK_FRAME_CAPACITY
)) != 0)

3251 return 
ret
;

3252 
uint8_t
 *
dst
 = 
s
->dst;

3253 
dst
 = 
	`quicly_encode_ack_frame
(dst, 
s
->
dst_end
, &
space
->
ack_queue
, 
ack_delay
);

3256 if (
dst
 == 
NULL
) {

3259 if (
s
->
dst
 == s->
dst_payload_from
) {

3260 
	`assert
(
s
->
target
.
first_byte_at
 != s->
payload_buf
.
datagram
);

3261 *
s
->
dst
++ = 
QUICLY_FRAME_TYPE_PADDING
;

3263 if ((
ret
 = 
	`commit_send_packet
(
conn
, 
s
, 
QUICLY_COMMIT_SEND_PACKET_MODE_FULL_SIZE
)) != 0)

3264 return 
ret
;

3265 goto 
Emit
;

3268 ++
conn
->
super
.
stats
.
num_frames_sent
.
ack
;

3269 
	`QUICLY_PROBE
(
ACK_SEND
, 
conn
, conn->
stash
.
now
, 
space
->
ack_queue
.
ranges
[space->ack_queue.
num_ranges
 - 1].
end
 - 1, 
ack_delay
);

3272 if (
space
->
ack_queue
.
num_ranges
 >= 
QUICLY_NUM_ACK_BLOCKS_TO_INDUCE_ACKACK
 && 
conn
->
egress
.
packet_number
 % 4 == 0 &&

3273 
dst
 < 
s
->
dst_end
) {

3274 *
dst
++ = 
QUICLY_FRAME_TYPE_PING
;

3275 ++
conn
->
super
.
stats
.
num_frames_sent
.
ping
;

3276 
	`QUICLY_PROBE
(
PING_SEND
, 
conn
, conn->
stash
.
now
);

3279 
s
->
dst
 = dst;

3282 
size_t
 
i
;

3283 for (
i
 = 0; i != 
space
->
ack_queue
.
num_ranges
; ++i) {

3284 
quicly_sent_t
 *
sent
;

3285 if ((
sent
 = 
	`quicly_sentmap_allocate
(&
conn
->
egress
.
loss
.
sentmap
, 
on_ack_ack
)) == 
NULL
)

3286 return 
PTLS_ERROR_NO_MEMORY
;

3287 
sent
->
data
.
ack
.
range
 = 
space
->
ack_queue
.
ranges
[
i
];

3291 
space
->
unacked_count
 = 0;

3293 return 
ret
;

3294 
	}
}

3296 static int 
	$prepare_stream_state_sender
(
quicly_stream_t
 *
stream
, 
quicly_sender_state_t
 *
sender
, 
quicly_send_context_t
 *
s
,

3297 
size_t
 
min_space
, 
quicly_sent_acked_cb
 
ack_cb
)

3299 
quicly_sent_t
 *
sent
;

3300 int 
ret
;

3302 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
stream
->
conn
, 
s
, 
min_space
, &
sent
, 
ack_cb
)) != 0)

3303 return 
ret
;

3304 
sent
->
data
.
stream_state_sender
.
stream_id
 = 
stream
->stream_id;

3305 *
sender
 = 
QUICLY_SENDER_STATE_UNACKED
;

3308 
	}
}

3310 static int 
	$send_control_frames_of_stream
(
quicly_stream_t
 *
stream
, 
quicly_send_context_t
 *
s
)

3312 int 
ret
;

3315 if (
stream
->
_send_aux
.
stop_sending
.
sender_state
 == 
QUICLY_SENDER_STATE_SEND
) {

3317 if ((
ret
 = 
	`prepare_stream_state_sender
(
stream
, &stream->
_send_aux
.
stop_sending
.
sender_state
, 
s
,

3318 
QUICLY_STOP_SENDING_FRAME_CAPACITY
, 
on_ack_stop_sending
)) != 0)

3319 return 
ret
;

3320 
s
->
dst
 = 
	`quicly_encode_stop_sending_frame
(s->dst, 
stream
->
stream_id
, stream->
_send_aux
.
stop_sending
.
error_code
);

3321 ++
stream
->
conn
->
super
.
stats
.
num_frames_sent
.
stop_sending
;

3325 if (
	`should_send_max_stream_data
(
stream
)) {

3326 
uint64_t
 
new_value
 = 
stream
->
recvstate
.
data_off
 + stream->
_recv_aux
.
window
;

3327 
quicly_sent_t
 *
sent
;

3329 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
stream
->
conn
, 
s
, 
QUICLY_MAX_STREAM_DATA_FRAME_CAPACITY
, &
sent
,

3330 
on_ack_max_stream_data
)) != 0)

3331 return 
ret
;

3333 
s
->
dst
 = 
	`quicly_encode_max_stream_data_frame
(s->dst, 
stream
->
stream_id
, 
new_value
);

3335 
sent
->
data
.
max_stream_data
.
stream_id
 = 
stream
->stream_id;

3336 
	`quicly_maxsender_record
(&
stream
->
_send_aux
.
max_stream_data_sender
, 
new_value
, &
sent
->
data
.
max_stream_data
.
args
);

3338 ++
stream
->
conn
->
super
.
stats
.
num_frames_sent
.
max_stream_data
;

3339 
	`QUICLY_PROBE
(
MAX_STREAM_DATA_SEND
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream, 
new_value
);

3343 if (
stream
->
_send_aux
.
reset_stream
.
sender_state
 == 
QUICLY_SENDER_STATE_SEND
) {

3344 if ((
ret
 = 
	`prepare_stream_state_sender
(
stream
, &stream->
_send_aux
.
reset_stream
.
sender_state
, 
s
, 
QUICLY_RST_FRAME_CAPACITY
,

3345 
on_ack_reset_stream
)) != 0)

3346 return 
ret
;

3347 
s
->
dst
 = 
	`quicly_encode_reset_stream_frame
(s->dst, 
stream
->
stream_id
, stream->
_send_aux
.
reset_stream
.
error_code
,

3348 
stream
->
sendstate
.
size_inflight
);

3349 ++
stream
->
conn
->
super
.
stats
.
num_frames_sent
.
reset_stream
;

3353 if (
stream
->
_send_aux
.
blocked
 == 
QUICLY_SENDER_STATE_SEND
) {

3354 
quicly_sent_t
 *
sent
;

3355 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
stream
->
conn
, 
s
, 
QUICLY_STREAM_DATA_BLOCKED_FRAME_CAPACITY
, &
sent
,

3356 
on_ack_stream_data_blocked_frame
)) != 0)

3357 return 
ret
;

3358 
uint64_t
 
offset
 = 
stream
->
_send_aux
.
max_stream_data
;

3359 
sent
->
data
.
stream_data_blocked
.
stream_id
 = 
stream
->stream_id;

3360 
sent
->
data
.
stream_data_blocked
.
offset
 = offset;

3361 
s
->
dst
 = 
	`quicly_encode_stream_data_blocked_frame
(s->dst, 
stream
->
stream_id
, 
offset
);

3362 
stream
->
_send_aux
.
blocked
 = 
QUICLY_SENDER_STATE_UNACKED
;

3363 ++
stream
->
conn
->
super
.
stats
.
num_frames_sent
.
stream_data_blocked
;

3364 
	`QUICLY_PROBE
(
STREAM_DATA_BLOCKED_SEND
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream->
stream_id
, 
offset
);

3368 
	}
}

3370 static int 
	$send_stream_control_frames
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
)

3372 int 
ret
 = 0;

3374 while (
s
->
num_datagrams
 != s->
max_datagrams
 && 
	`quicly_linklist_is_linked
(&
conn
->
egress
.
pending_streams
.
control
)) {

3375 
quicly_stream_t
 *
stream
 =

3376 (void *)((char *)
conn
->
egress
.
pending_streams
.
control
.
next
 - 
	`offsetof
(
quicly_stream_t
, 
_send_aux
.
pending_link
.control));

3377 if ((
ret
 = 
	`send_control_frames_of_stream
(
stream
, 
s
)) != 0)

3378 goto 
Exit
;

3379 
	`quicly_linklist_unlink
(&
stream
->
_send_aux
.
pending_link
.
control
);

3382 
Exit
:

3383 return 
ret
;

3384 
	}
}

3386 int 
	$quicly_is_blocked
(
quicly_conn_t
 *
conn
)

3388 if (
conn
->
egress
.
max_data
.
sent
 < conn->egress.max_data.
permitted
)

3392 if (
conn
->
egress
.
data_blocked
 == 
QUICLY_SENDER_STATE_NONE
)

3393 
conn
->
egress
.
data_blocked
 = 
QUICLY_SENDER_STATE_SEND
;

3396 
	}
}

3398 int 
	$quicly_stream_can_send
(
quicly_stream_t
 *
stream
, int 
at_stream_level
)

3401 if (
stream
->
sendstate
.
pending
.
num_ranges
 == 0)

3406 
uint64_t
 
blocked_at
 = 
at_stream_level
 ? 
stream
->
_send_aux
.
max_stream_data
 : stream->
sendstate
.
size_inflight
;

3407 if (
stream
->
sendstate
.
pending
.
ranges
[0].
start
 < 
blocked_at
)

3410 if (
stream
->
sendstate
.
pending
.
ranges
[0].
start
 >= stream->sendstate.
final_size
) {

3411 
	`assert
(
stream
->
sendstate
.
pending
.
ranges
[0].
start
 == stream->sendstate.
final_size
);

3416 if (
at_stream_level
 && 
stream
->
_send_aux
.
blocked
 == 
QUICLY_SENDER_STATE_NONE
) {

3417 
stream
->
_send_aux
.
blocked
 = 
QUICLY_SENDER_STATE_SEND
;

3418 
	`sched_stream_control
(
stream
);

3422 
	}
}

3424 int 
	$quicly_can_send_data
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
)

3426 return 
s
->
num_datagrams
 < s->
max_datagrams
;

3427 
	}
}

3429 int 
	$quicly_send_stream
(
quicly_stream_t
 *
stream
, 
quicly_send_context_t
 *
s
)

3431 
uint64_t
 
off
 = 
stream
->
sendstate
.
pending
.
ranges
[0].
start
, 
end_off
;

3432 
quicly_sent_t
 *
sent
;

3433 
uint8_t
 *
frame_type_at
;

3434 
size_t
 
capacity
, 
len
;

3435 int 
ret
, 
wrote_all
, 
is_fin
;

3438 if (
stream
->
stream_id
 < 0) {

3439 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
stream
->
conn
, 
s
,

3440 1 + 
	`quicly_encodev_capacity
(
off
) + 2 ,

3441 &
sent
, 
on_ack_stream
)) != 0)

3442 return 
ret
;

3443 
frame_type_at
 = 
NULL
;

3444 *
s
->
dst
++ = 
QUICLY_FRAME_TYPE_CRYPTO
;

3445 
s
->
dst
 = 
	`quicly_encodev
(s->dst, 
off
);

3446 
capacity
 = 
s
->
dst_end
 - s->
dst
;

3448 
uint8_t
 
header
[18], *
hp
 = header + 1;

3449 
hp
 = 
	`quicly_encodev
(hp, 
stream
->
stream_id
);

3450 if (
off
 != 0) {

3451 
header
[0] = 
QUICLY_FRAME_TYPE_STREAM_BASE
 | 
QUICLY_FRAME_TYPE_STREAM_BIT_OFF
;

3452 
hp
 = 
	`quicly_encodev
(hp, 
off
);

3454 
header
[0] = 
QUICLY_FRAME_TYPE_STREAM_BASE
;

3456 if (!
	`quicly_sendstate_is_open
(&
stream
->
sendstate
) && 
off
 == stream->sendstate.
final_size
) {

3458 
header
[0] |= 
QUICLY_FRAME_TYPE_STREAM_BIT_FIN
;

3459 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
stream
->
conn
, 
s
, 
hp
 - 
header
, &
sent
, 
on_ack_stream
)) != 0)

3460 return 
ret
;

3461 if (
hp
 - 
header
 != 
s
->
dst_end
 - s->
dst
) {

3462 
header
[0] |= 
QUICLY_FRAME_TYPE_STREAM_BIT_LEN
;

3463 *
hp
++ = 0;

3465 
	`memcpy
(
s
->
dst
, 
header
, 
hp
 - header);

3466 
s
->
dst
 += 
hp
 - 
header
;

3467 
end_off
 = 
off
;

3468 
wrote_all
 = 1;

3469 
is_fin
 = 1;

3470 goto 
UpdateState
;

3472 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
stream
->
conn
, 
s
, 
hp
 - 
header
 + 1, &
sent
, 
on_ack_stream
)) != 0)

3473 return 
ret
;

3474 
frame_type_at
 = 
s
->
dst
;

3475 
	`memcpy
(
s
->
dst
, 
header
, 
hp
 - header);

3476 
s
->
dst
 += 
hp
 - 
header
;

3477 
capacity
 = 
s
->
dst_end
 - s->
dst
;

3479 if (
off
 + 
capacity
 > 
stream
->
_send_aux
.
max_stream_data
)

3480 
capacity
 = 
stream
->
_send_aux
.
max_stream_data
 - 
off
;

3482 if (
off
 + 
capacity
 > 
stream
->
sendstate
.
size_inflight
) {

3483 
uint64_t
 
new_bytes
 = 
off
 + 
capacity
 - 
stream
->
sendstate
.
size_inflight
;

3484 if (
new_bytes
 > 
stream
->
conn
->
egress
.
max_data
.
permitted
 - stream->conn->egress.max_data.
sent
) {

3485 
size_t
 
max_stream_data
 =

3486 
stream
->
sendstate
.
size_inflight
 + stream->
conn
->
egress
.
max_data
.
permitted
 - stream->conn->egress.max_data.
sent
;

3487 
capacity
 = 
max_stream_data
 - 
off
;

3492 
uint64_t
 
range_capacity
 = 
stream
->
sendstate
.
pending
.
ranges
[0].
end
 - 
off
;

3493 if (!
	`quicly_sendstate_is_open
(&
stream
->
sendstate
) && 
off
 + 
range_capacity
 > stream->sendstate.
final_size
) {

3494 
	`assert
(
range_capacity
 > 1);

3495 
range_capacity
 -= 1;

3497 if (
capacity
 > 
range_capacity
)

3498 
capacity
 = 
range_capacity
;

3502 
	`assert
(
capacity
 != 0);

3503 
len
 = 
capacity
;

3504 
size_t
 
emit_off
 = (size_t)(
off
 - 
stream
->
sendstate
.
acked
.
ranges
[0].
end
);

3505 
	`QUICLY_PROBE
(
STREAM_ON_SEND_EMIT
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream, 
emit_off
, 
len
);

3506 
stream
->
callbacks
->
	`on_send_emit
(stream, 
emit_off
, 
s
->
dst
, &
len
, &
wrote_all
);

3507 if (
stream
->
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
) {

3508 return 
QUICLY_ERROR_IS_CLOSING
;

3509 } else if (
stream
->
_send_aux
.
reset_stream
.
sender_state
 != 
QUICLY_SENDER_STATE_NONE
) {

3512 
	`assert
(
len
 <= 
capacity
);

3513 
	`assert
(
len
 != 0);

3516 if (
frame_type_at
 == 
NULL
 || 
len
 < 
s
->
dst_end
 - s->
dst
) {

3517 if (
frame_type_at
 != 
NULL
)

3518 *
frame_type_at
 |= 
QUICLY_FRAME_TYPE_STREAM_BIT_LEN
;

3519 
size_t
 
len_of_len
 = 
	`quicly_encodev_capacity
(
len
);

3520 if (
len_of_len
 + 
len
 > 
s
->
dst_end
 - s->
dst
) {

3521 
len
 = 
s
->
dst_end
 - s->
dst
 - 
len_of_len
;

3522 
wrote_all
 = 0;

3524 
	`memmove
(
s
->
dst
 + 
len_of_len
, s->dst, 
len
);

3525 
s
->
dst
 = 
	`quicly_encodev
(s->dst, 
len
);

3527 
s
->
dst
 += 
len
;

3528 
end_off
 = 
off
 + 
len
;

3531 if (!
	`quicly_sendstate_is_open
(&
stream
->
sendstate
) && 
end_off
 == stream->sendstate.
final_size
) {

3532 
	`assert
(
frame_type_at
 != 
NULL
);

3533 
is_fin
 = 1;

3534 *
frame_type_at
 |= 
QUICLY_FRAME_TYPE_STREAM_BIT_FIN
;

3536 
is_fin
 = 0;

3539 
UpdateState
:

3540 if (
stream
->
stream_id
 < 0) {

3541 ++
stream
->
conn
->
super
.
stats
.
num_frames_sent
.
crypto
;

3543 ++
stream
->
conn
->
super
.
stats
.
num_frames_sent
.stream;

3545 
	`QUICLY_PROBE
(
STREAM_SEND
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream, 
off
, 
end_off
 - off, 
is_fin
);

3546 
	`QUICLY_PROBE
(
QUICTRACE_SEND_STREAM
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream, 
off
, 
end_off
 - off, 
is_fin
);

3548 if (
stream
->
sendstate
.
size_inflight
 < 
end_off
) {

3549 if (
stream
->
stream_id
 >= 0)

3550 
stream
->
conn
->
egress
.
max_data
.
sent
 += 
end_off
 - stream->
sendstate
.
size_inflight
;

3551 
stream
->
sendstate
.
size_inflight
 = 
end_off
;

3553 if ((
ret
 = 
	`quicly_ranges_subtract
(&
stream
->
sendstate
.
pending
, 
off
, 
end_off
 + 
is_fin
)) != 0)

3554 return 
ret
;

3555 if (
wrote_all
) {

3556 if ((
ret
 = 
	`quicly_ranges_subtract
(&
stream
->
sendstate
.
pending
, stream->sendstate.
size_inflight
, 
UINT64_MAX
)) != 0)

3557 return 
ret
;

3561 
sent
->
data
.
stream
.
stream_id
 = stream->stream_id;

3562 
sent
->
data
.
stream
.
args
.
start
 = 
off
;

3563 
sent
->
data
.
stream
.
args
.
end
 = 
end_off
 + 
is_fin
;

3566 
	}
}

3568 static 
inline
 int 
	$init_acks_iter
(
quicly_conn_t
 *
conn
, 
quicly_sentmap_iter_t
 *
iter
)

3570 return 
	`quicly_loss_init_sentmap_iter
(&
conn
->
egress
.
loss
, 
iter
, conn->
stash
.
now
,

3571 
conn
->
super
.
remote
.
transport_params
.
max_ack_delay
,

3572 
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
);

3573 
	}
}

3575 int 
	$discard_sentmap_by_epoch
(
quicly_conn_t
 *
conn
, unsigned 
ack_epochs
)

3577 
quicly_sentmap_iter_t
 
iter
;

3578 const 
quicly_sent_packet_t
 *
sent
;

3579 int 
ret
;

3581 if ((
ret
 = 
	`init_acks_iter
(
conn
, &
iter
)) != 0)

3582 return 
ret
;

3584 while ((
sent
 = 
	`quicly_sentmap_get
(&
iter
))->
packet_number
 != 
UINT64_MAX
) {

3585 if ((
ack_epochs
 & (1u << 
sent
->
ack_epoch
)) != 0) {

3586 if ((
ret
 = 
	`quicly_sentmap_update
(&
conn
->
egress
.
loss
.
sentmap
, &
iter
, 
QUICLY_SENTMAP_EVENT_EXPIRED
)) != 0)

3587 return 
ret
;

3589 
	`quicly_sentmap_skip
(&
iter
);

3593 return 
ret
;

3594 
	}
}

3599 static int 
	$mark_frames_on_pto
(
quicly_conn_t
 *
conn
, 
uint8_t
 
ack_epoch
, 
size_t
 *
bytes_to_mark
)

3601 
quicly_sentmap_iter_t
 
iter
;

3602 const 
quicly_sent_packet_t
 *
sent
;

3603 int 
ret
;

3605 if ((
ret
 = 
	`init_acks_iter
(
conn
, &
iter
)) != 0)

3606 return 
ret
;

3608 while ((
sent
 = 
	`quicly_sentmap_get
(&
iter
))->
packet_number
 != 
UINT64_MAX
) {

3609 if (
sent
->
ack_epoch
 == ack_epoch && sent->
frames_in_flight
) {

3610 *
bytes_to_mark
 = *bytes_to_mark > 
sent
->
cc_bytes_in_flight
 ? *bytes_to_mark - sent->cc_bytes_in_flight : 0;

3611 if ((
ret
 = 
	`quicly_sentmap_update
(&
conn
->
egress
.
loss
.
sentmap
, &
iter
, 
QUICLY_SENTMAP_EVENT_PTO
)) != 0)

3612 return 
ret
;

3613 
	`assert
(!
sent
->
frames_in_flight
);

3614 if (*
bytes_to_mark
 == 0)

3617 
	`quicly_sentmap_skip
(&
iter
);

3622 
	}
}

3624 static void 
	$on_loss_detected
(
quicly_loss_t
 *
loss
, const 
quicly_sent_packet_t
 *
lost_packet
, int 
is_time_threshold
)

3626 
quicly_conn_t
 *
conn
 = (void *)((char *)
loss
 - 
	`offsetof
(quicly_conn_t, 
egress
.loss));

3628 ++
conn
->
super
.
stats
.
num_packets
.
lost
;

3629 if (
is_time_threshold
)

3630 ++
conn
->
super
.
stats
.
num_packets
.
lost_time_threshold
;

3631 
conn
->
egress
.
cc
.
type
->
	`cc_on_lost
(&conn->egress.cc, &conn->egress.
loss
, 
lost_packet
->
cc_bytes_in_flight
,

3632 
lost_packet
->
packet_number
, 
conn
->
egress
.packet_number, conn->
stash
.
now
,

3633 
conn
->
egress
.
max_udp_payload_size
);

3634 
	`QUICLY_PROBE
(
PACKET_LOST
, 
conn
, conn->
stash
.
now
, 
lost_packet
->
packet_number
, lost_packet->
ack_epoch
);

3635 
	`QUICLY_PROBE
(
CC_CONGESTION
, 
conn
, conn->
stash
.
now
, 
lost_packet
->
packet_number
 + 1, conn->
egress
.
loss
.
sentmap
.
bytes_in_flight
,

3636 
conn
->
egress
.
cc
.
cwnd
);

3637 
	`QUICLY_PROBE
(
QUICTRACE_CC_LOST
, 
conn
, conn->
stash
.
now
, &conn->
egress
.
loss
.
rtt
, conn->egress.
cc
.
cwnd
,

3638 
conn
->
egress
.
loss
.
sentmap
.
bytes_in_flight
);

3639 
	}
}

3641 static int 
	$send_max_streams
(
quicly_conn_t
 *
conn
, int 
uni
, 
quicly_send_context_t
 *
s
)

3643 if (!
	`should_send_max_streams
(
conn
, 
uni
))

3646 
quicly_maxsender_t
 *
maxsender
 = 
uni
 ? &
conn
->
ingress
.
max_streams
.uni : &conn->ingress.max_streams.
bidi
;

3647 struct 
st_quicly_conn_streamgroup_state_t
 *
group
 = 
uni
 ? &
conn
->
super
.
remote
.uni : &conn->super.remote.
bidi
;

3648 int 
ret
;

3650 
uint64_t
 
new_count
 =

3651 
group
->
next_stream_id
 / 4 +

3652 (
uni
 ? 
conn
->
super
.
ctx
->
transport_params
.
max_streams_uni
 : conn->super.ctx->transport_params.
max_streams_bidi
) -

3653 
group
->
num_streams
;

3655 
quicly_sent_t
 *
sent
;

3656 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
conn
, 
s
, 
QUICLY_MAX_STREAMS_FRAME_CAPACITY
, &
sent
, 
on_ack_max_streams
)) != 0)

3657 return 
ret
;

3658 
s
->
dst
 = 
	`quicly_encode_max_streams_frame
(s->dst, 
uni
, 
new_count
);

3659 
sent
->
data
.
max_streams
.
uni
 = uni;

3660 
	`quicly_maxsender_record
(
maxsender
, 
new_count
, &
sent
->
data
.
max_streams
.
args
);

3662 if (
uni
) {

3663 ++
conn
->
super
.
stats
.
num_frames_sent
.
max_streams_uni
;

3665 ++
conn
->
super
.
stats
.
num_frames_sent
.
max_streams_bidi
;

3667 
	`QUICLY_PROBE
(
MAX_STREAMS_SEND
, 
conn
, conn->
stash
.
now
, 
new_count
, 
uni
);

3670 
	}
}

3672 static int 
	$send_streams_blocked
(
quicly_conn_t
 *
conn
, int 
uni
, 
quicly_send_context_t
 *
s
)

3674 
quicly_linklist_t
 *
blocked_list
 = 
uni
 ? &
conn
->
egress
.
pending_streams
.
blocked
.uni : &conn->egress.pending_streams.blocked.
bidi
;

3675 int 
ret
;

3677 if (!
	`quicly_linklist_is_linked
(
blocked_list
))

3680 struct 
st_quicly_max_streams_t
 *
max_streams
 = 
uni
 ? &
conn
->
egress
.max_streams.uni : &conn->egress.max_streams.
bidi
;

3681 
quicly_stream_t
 *
oldest_blocked_stream
 =

3682 (void *)((char *)
blocked_list
->
next
 - 
	`offsetof
(
quicly_stream_t
, 
_send_aux
.
pending_link
.
control
));

3683 
	`assert
(
max_streams
->
count
 == 
oldest_blocked_stream
->
stream_id
 / 4);

3685 if (!
	`quicly_maxsender_should_send_blocked
(&
max_streams
->
blocked_sender
, max_streams->
count
))

3688 
quicly_sent_t
 *
sent
;

3689 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
conn
, 
s
, 
QUICLY_STREAMS_BLOCKED_FRAME_CAPACITY
, &
sent
, 
on_ack_streams_blocked
)) != 0)

3690 return 
ret
;

3691 
s
->
dst
 = 
	`quicly_encode_streams_blocked_frame
(s->dst, 
uni
, 
max_streams
->
count
);

3692 
sent
->
data
.
streams_blocked
.
uni
 = uni;

3693 
	`quicly_maxsender_record
(&
max_streams
->
blocked_sender
, max_streams->
count
, &
sent
->
data
.
streams_blocked
.
args
);

3695 ++
conn
->
super
.
stats
.
num_frames_sent
.
streams_blocked
;

3696 
	`QUICLY_PROBE
(
STREAMS_BLOCKED_SEND
, 
conn
, conn->
stash
.
now
, 
max_streams
->
count
, 
uni
);

3699 
	}
}

3701 static void 
	$open_blocked_streams
(
quicly_conn_t
 *
conn
, int 
uni
)

3703 
uint64_t
 
count
;

3704 
quicly_linklist_t
 *
anchor
;

3706 if (
uni
) {

3707 
count
 = 
conn
->
egress
.
max_streams
.
uni
.count;

3708 
anchor
 = &
conn
->
egress
.
pending_streams
.
blocked
.
uni
;

3710 
count
 = 
conn
->
egress
.
max_streams
.
bidi
.count;

3711 
anchor
 = &
conn
->
egress
.
pending_streams
.
blocked
.
bidi
;

3714 while (
	`quicly_linklist_is_linked
(
anchor
)) {

3715 
quicly_stream_t
 *
stream
 = (void *)((char *)
anchor
->
next
 - 
	`offsetof
(quicly_stream_t, 
_send_aux
.
pending_link
.
control
));

3716 if (
stream
->
stream_id
 / 4 >= 
count
)

3718 
	`assert
(
stream
->
streams_blocked
);

3719 
	`quicly_linklist_unlink
(&
stream
->
_send_aux
.
pending_link
.
control
);

3720 
stream
->
streams_blocked
 = 0;

3721 
stream
->
_send_aux
.
max_stream_data
 = 
	`quicly_stream_is_unidirectional
(stream->
stream_id
)

3722 ? 
conn
->
super
.
remote
.
transport_params
.
max_stream_data
.
uni


3723 : 
conn
->
super
.
remote
.
transport_params
.
max_stream_data
.
bidi_remote
;

3725 
	`sched_stream_control
(
stream
);

3726 
	`resched_stream_data
(
stream
);

3728 
	}
}

3730 static int 
	$send_handshake_done
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
)

3732 
quicly_sent_t
 *
sent
;

3733 int 
ret
;

3735 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
conn
, 
s
, 1, &
sent
, 
on_ack_handshake_done
)) != 0)

3736 goto 
Exit
;

3737 *
s
->
dst
++ = 
QUICLY_FRAME_TYPE_HANDSHAKE_DONE
;

3738 
conn
->
egress
.
pending_flows
 &= ~
QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT
;

3739 ++
conn
->
super
.
stats
.
num_frames_sent
.
handshake_done
;

3740 
	`QUICLY_PROBE
(
HANDSHAKE_DONE_SEND
, 
conn
, conn->
stash
.
now
);

3742 
ret
 = 0;

3743 
Exit
:

3744 return 
ret
;

3745 
	}
}

3747 static int 
	$send_data_blocked
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
)

3749 
quicly_sent_t
 *
sent
;

3750 int 
ret
;

3752 
uint64_t
 
offset
 = 
conn
->
egress
.
max_data
.
permitted
;

3753 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
conn
, 
s
, 
QUICLY_DATA_BLOCKED_FRAME_CAPACITY
, &
sent
, 
on_ack_data_blocked
)) != 0)

3754 goto 
Exit
;

3755 
sent
->
data
.
data_blocked
.
offset
 = offset;

3756 
s
->
dst
 = 
	`quicly_encode_data_blocked_frame
(s->dst, 
offset
);

3757 
conn
->
egress
.
data_blocked
 = 
QUICLY_SENDER_STATE_UNACKED
;

3759 ++
conn
->
super
.
stats
.
num_frames_sent
.
data_blocked
;

3760 
	`QUICLY_PROBE
(
DATA_BLOCKED_SEND
, 
conn
, conn->
stash
.
now
, 
offset
);

3762 
ret
 = 0;

3763 
Exit
:

3764 return 
ret
;

3765 
	}
}

3767 static int 
	$send_resumption_token
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
)

3769 
quicly_address_token_plaintext_t
 
token
;

3770 
ptls_buffer_t
 
tokenbuf
;

3771 
uint8_t
 
tokenbuf_small
[128];

3772 
quicly_sent_t
 *
sent
;

3773 int 
ret
;

3775 
	`ptls_buffer_init
(&
tokenbuf
, 
tokenbuf_small
, sizeof(tokenbuf_small));

3778 
token
 =

3779 (
quicly_address_token_plaintext_t
){
QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION
, 
conn
->
super
.
ctx
->
now
->
	`cb
(conn->super.ctx->now)};

3780 
token
.
remote
 = 
conn
->
super
.remote.
address
;

3784 if ((
ret
 = 
conn
->
super
.
ctx
->
generate_resumption_token
->
	`cb
(conn->super.ctx->generate_resumption_token, conn, &
tokenbuf
,

3785 &
token
)) != 0)

3786 goto 
Exit
;

3787 
	`assert
(
tokenbuf
.
off
 < 
QUICLY_MIN_CLIENT_INITIAL_SIZE
 / 2 && "this is a ballpark figure, but tokens ought to be small");

3790 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
conn
, 
s
, 
	`quicly_new_token_frame_capacity
(
	`ptls_iovec_init
(
tokenbuf
.
base
, tokenbuf.
off
)),

3791 &
sent
, 
on_ack_new_token
)) != 0)

3792 goto 
Exit
;

3793 ++
conn
->
egress
.
new_token
.
num_inflight
;

3794 
sent
->
data
.
new_token
.
is_inflight
 = 1;

3795 
sent
->
data
.
new_token
.
generation
 = 
conn
->
egress
.new_token.generation;

3796 
s
->
dst
 = 
	`quicly_encode_new_token_frame
(s->dst, 
	`ptls_iovec_init
(
tokenbuf
.
base
, tokenbuf.
off
));

3797 
conn
->
egress
.
pending_flows
 &= ~
QUICLY_PENDING_FLOW_NEW_TOKEN_BIT
;

3799 ++
conn
->
super
.
stats
.
num_frames_sent
.
new_token
;

3800 
	`QUICLY_PROBE
(
NEW_TOKEN_SEND
, 
conn
, conn->
stash
.
now
, 
tokenbuf
.
base
, tokenbuf.
off
, 
sent
->
data
.
new_token
.
generation
);

3801 
ret
 = 0;

3802 
Exit
:

3803 
	`ptls_buffer_dispose
(&
tokenbuf
);

3804 return 
ret
;

3805 
	}
}

3807 
size_t
 
	$quicly_send_version_negotiation
(
quicly_context_t
 *
ctx
, 
ptls_iovec_t
 
dest_cid
, ptls_iovec_t 
src_cid
, const 
uint32_t
 *
versions
,

3808 void *
payload
)

3810 
uint8_t
 *
dst
 = 
payload
;

3813 
ctx
->
tls
->
	`random_bytes
(
dst
, 1);

3814 *
dst
 |= 
QUICLY_LONG_HEADER_BIT
;

3815 ++
dst
;

3817 
dst
 = 
	`quicly_encode32
(dst, 0);

3819 *
dst
++ = 
dest_cid
.
len
;

3820 if (
dest_cid
.
len
 != 0) {

3821 
	`memcpy
(
dst
, 
dest_cid
.
base
, dest_cid.
len
);

3822 
dst
 += 
dest_cid
.
len
;

3824 *
dst
++ = 
src_cid
.
len
;

3825 if (
src_cid
.
len
 != 0) {

3826 
	`memcpy
(
dst
, 
src_cid
.
base
, src_cid.
len
);

3827 
dst
 += 
src_cid
.
len
;

3830 for (const 
uint32_t
 *
v
 = 
versions
; *v != 0; ++v)

3831 
dst
 = 
	`quicly_encode32
(dst, *
v
);

3833 
uint32_t
 
grease_version
 = 0;

3834 if (
src_cid
.
len
 >= sizeof(
grease_version
))

3835 
	`memcpy
(&
grease_version
, 
src_cid
.
base
, sizeof(grease_version));

3836 
grease_version
 = (grease_version & 0xf0f0f0f0) | 0x0a0a0a0a;

3837 
dst
 = 
	`quicly_encode32
(dst, 
grease_version
);

3839 return 
dst
 - (
uint8_t
 *)
payload
;

3840 
	}
}

3842 int 
	$quicly_retry_calc_cidpair_hash
(
ptls_hash_algorithm_t
 *
sha256
, 
ptls_iovec_t
 
client_cid
, ptls_iovec_t 
server_cid
, 
uint64_t
 *
value
)

3844 
uint8_t
 
digest
[
PTLS_SHA256_DIGEST_SIZE
], 
buf
[(
QUICLY_MAX_CID_LEN_V1
 + 1) * 2], *
p
 = buf;

3845 int 
ret
;

3847 *
p
++ = (
uint8_t
)
client_cid
.
len
;

3848 
	`memcpy
(
p
, 
client_cid
.
base
, client_cid.
len
);

3849 
p
 += 
client_cid
.
len
;

3850 *
p
++ = (
uint8_t
)
server_cid
.
len
;

3851 
	`memcpy
(
p
, 
server_cid
.
base
, server_cid.
len
);

3852 
p
 += 
server_cid
.
len
;

3854 if ((
ret
 = 
	`ptls_calc_hash
(
sha256
, 
digest
, 
buf
, 
p
 - buf)) != 0)

3855 return 
ret
;

3856 
p
 = 
digest
;

3857 *
value
 = 
	`quicly_decode64
((void *)&
p
);

3860 
	}
}

3862 
size_t
 
	$quicly_send_retry
(
quicly_context_t
 *
ctx
, 
ptls_aead_context_t
 *
token_encrypt_ctx
, 
uint32_t
 
protocol_version
,

3863 struct 
sockaddr
 *
dest_addr
, 
ptls_iovec_t
 
dest_cid
, struct sockaddr *
src_addr
, ptls_iovec_t 
src_cid
,

3864 
ptls_iovec_t
 
odcid
, ptls_iovec_t 
token_prefix
, ptls_iovec_t 
appdata
,

3865 
ptls_aead_context_t
 **
retry_aead_cache
, 
uint8_t
 *
datagram
)

3867 
quicly_address_token_plaintext_t
 
token
;

3868 
ptls_buffer_t
 
buf
;

3869 int 
ret
;

3871 
	`assert
(!(
src_cid
.
len
 == 
odcid
.len && 
	`memcmp
(src_cid.
base
, odcid.base, src_cid.len) == 0));

3874 
token
 = (
quicly_address_token_plaintext_t
){
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
, 
ctx
->
now
->
	`cb
(ctx->now)};

3875 
	`set_address
(&
token
.
remote
, 
dest_addr
);

3876 
	`set_address
(&
token
.
local
, 
src_addr
);

3878 
	`quicly_set_cid
(&
token
.
retry
.
original_dcid
, 
odcid
);

3879 
	`quicly_set_cid
(&
token
.
retry
.
client_cid
, 
dest_cid
);

3880 
	`quicly_set_cid
(&
token
.
retry
.
server_cid
, 
src_cid
);

3881 if (
appdata
.
len
 != 0) {

3882 
	`assert
(
appdata
.
len
 <= sizeof(
token
.appdata.
bytes
));

3883 
	`memcpy
(
token
.
appdata
.
bytes
, appdata.
base
, appdata.
len
);

3884 
token
.
appdata
.
len
 = appdata.len;

3888 
	`ptls_buffer_init
(&
buf
, 
datagram
, 
QUICLY_MIN_CLIENT_INITIAL_SIZE
);

3891 
	`ptls_buffer_push_block
(&
buf
, 1, { 
	`ptls_buffer_pushv
(&buf, 
odcid
.
base
, odcid.
len
); });

3892 
ctx
->
tls
->
	`random_bytes
(
buf
.
base
 + buf.
off
, 1);

3893 
buf
.
base
[buf.
off
] = 
QUICLY_PACKET_TYPE_RETRY
 | (buf.base[buf.off] & 0x0f);

3894 ++
buf
.
off
;

3895 
	`ptls_buffer_push32
(&
buf
, 
protocol_version
);

3896 
	`ptls_buffer_push_block
(&
buf
, 1, { 
	`ptls_buffer_pushv
(&buf, 
dest_cid
.
base
, dest_cid.
len
); });

3897 
	`ptls_buffer_push_block
(&
buf
, 1, { 
	`ptls_buffer_pushv
(&buf, 
src_cid
.
base
, src_cid.
len
); });

3898 if (
token_prefix
.
len
 != 0) {

3899 
	`assert
(
token_prefix
.
len
 <= 
buf
.
capacity
 - buf.
off
);

3900 
	`memcpy
(
buf
.
base
 + buf.
off
, 
token_prefix
.base, token_prefix.
len
);

3901 
buf
.
off
 += 
token_prefix
.
len
;

3903 if ((
ret
 = 
	`quicly_encrypt_address_token
(
ctx
->
tls
->
random_bytes
, 
token_encrypt_ctx
, &
buf
, buf.
off
 - 
token_prefix
.
len
, &
token
)) !=

3905 goto 
Exit
;

3908 
ret
 = 
	`ptls_buffer_reserve
(&
buf
, 
PTLS_AESGCM_TAG_SIZE
);

3909 
	`assert
(
ret
 == 0);

3910 
	`assert
(!
buf
.
is_allocated
 && "retry packet is too large");

3912 
ptls_aead_context_t
 *
aead
 =

3913 
retry_aead_cache
 != 
NULL
 && *retry_aead_cache != NULL ? *retry_aead_cache : 
	`create_retry_aead
(
ctx
, 
protocol_version
, 1);

3914 
	`ptls_aead_encrypt
(
aead
, 
buf
.
base
 + buf.
off
, "", 0, 0, buf.base, buf.off);

3915 if (
retry_aead_cache
 != 
NULL
) {

3916 *
retry_aead_cache
 = 
aead
;

3918 
	`ptls_aead_free
(
aead
);

3921 
buf
.
off
 += 
PTLS_AESGCM_TAG_SIZE
;

3924 
	`memmove
(
buf
.
base
, buf.base + 
odcid
.
len
 + 1, buf.
off
 - (odcid.len + 1));

3925 
buf
.
off
 -= 
odcid
.
len
 + 1;

3927 
ret
 = 0;

3929 
Exit
:

3930 return 
ret
 == 0 ? 
buf
.
off
 : 
SIZE_MAX
;

3931 
	}
}

3933 static struct 
st_quicly_pn_space_t
 *
	$setup_send_space
(
quicly_conn_t
 *
conn
, 
size_t
 
epoch
, 
quicly_send_context_t
 *
s
)

3935 struct 
st_quicly_pn_space_t
 *
space
 = 
NULL
;

3937 switch (
epoch
) {

3938 case 
QUICLY_EPOCH_INITIAL
:

3939 if (
conn
->
initial
 == 
NULL
 || (
s
->
current
.
cipher
 = &conn->initial->cipher.
egress
)->
aead
 == NULL)

3940 return 
NULL
;

3941 
s
->
current
.
first_byte
 = 
QUICLY_PACKET_TYPE_INITIAL
;

3942 
space
 = &
conn
->
initial
->
super
;

3944 case 
QUICLY_EPOCH_HANDSHAKE
:

3945 if (
conn
->
handshake
 == 
NULL
 || (
s
->
current
.
cipher
 = &conn->handshake->cipher.
egress
)->
aead
 == NULL)

3946 return 
NULL
;

3947 
s
->
current
.
first_byte
 = 
QUICLY_PACKET_TYPE_HANDSHAKE
;

3948 
space
 = &
conn
->
handshake
->
super
;

3950 case 
QUICLY_EPOCH_0RTT
:

3951 case 
QUICLY_EPOCH_1RTT
:

3952 if (
conn
->
application
 == 
NULL
 || conn->application->
cipher
.
egress
.
key
.
header_protection
 == NULL)

3953 return 
NULL
;

3954 if ((
epoch
 == 
QUICLY_EPOCH_0RTT
) == 
conn
->
application
->
one_rtt_writable
)

3955 return 
NULL
;

3956 
s
->
current
.
cipher
 = &
conn
->
application
->cipher.
egress
.
key
;

3957 
s
->
current
.
first_byte
 = 
epoch
 == 
QUICLY_EPOCH_0RTT
 ? 
QUICLY_PACKET_TYPE_0RTT
 : 
QUICLY_QUIC_BIT
;

3958 
space
 = &
conn
->
application
->
super
;

3961 
	`assert
(!"logic flaw");

3965 return 
space
;

3966 
	}
}

3968 static int 
	$send_handshake_flow
(
quicly_conn_t
 *
conn
, 
size_t
 
epoch
, 
quicly_send_context_t
 *
s
, int 
ack_only
, int 
send_probe
)

3970 struct 
st_quicly_pn_space_t
 *
space
;

3971 int 
ret
 = 0;

3974 if ((
space
 = 
	`setup_send_space
(
conn
, 
epoch
, 
s
)) == 
NULL
)

3978 if (
space
 != 
NULL
 && (space->
unacked_count
 != 0 || 
send_probe
))

3979 if ((
ret
 = 
	`send_ack
(
conn
, 
space
, 
s
)) != 0)

3980 goto 
Exit
;

3982 if (!
ack_only
) {

3984 while ((
conn
->
egress
.
pending_flows
 & (
uint8_t
)(1 << 
epoch
)) != 0) {

3985 
quicly_stream_t
 *
stream
 = 
	`quicly_get_stream
(
conn
, -(
quicly_stream_id_t
)(1 + 
epoch
));

3986 
	`assert
(
stream
 != 
NULL
);

3987 if ((
ret
 = 
	`quicly_send_stream
(
stream
, 
s
)) != 0)

3988 goto 
Exit
;

3989 
	`resched_stream_data
(
stream
);

3990 
send_probe
 = 0;

3994 if (
send_probe
) {

3995 if ((
ret
 = 
	`_do_allocate_frame
(
conn
, 
s
, 1, 1)) != 0)

3996 goto 
Exit
;

3997 *
s
->
dst
++ = 
QUICLY_FRAME_TYPE_PING
;

3998 
conn
->
egress
.
last_retransmittable_sent_at
 = conn->
stash
.
now
;

3999 ++
conn
->
super
.
stats
.
num_frames_sent
.
ping
;

4000 
	`QUICLY_PROBE
(
PING_SEND
, 
conn
, conn->
stash
.
now
);

4004 
Exit
:

4005 return 
ret
;

4006 
	}
}

4008 static int 
	$send_connection_close
(
quicly_conn_t
 *
conn
, 
size_t
 
epoch
, 
quicly_send_context_t
 *
s
)

4010 
uint64_t
 
error_code
, 
offending_frame_type
;

4011 const char *
reason_phrase
;

4012 int 
ret
;

4015 if (
	`setup_send_space
(
conn
, 
epoch
, 
s
) == 
NULL
)

4019 
error_code
 = 
conn
->
egress
.
connection_close
.error_code;

4020 
offending_frame_type
 = 
conn
->
egress
.
connection_close
.
frame_type
;

4021 
reason_phrase
 = 
conn
->
egress
.
connection_close
.reason_phrase;

4022 if (
offending_frame_type
 == 
UINT64_MAX
) {

4023 switch (
	`get_epoch
(
s
->
current
.
first_byte
)) {

4024 case 
QUICLY_EPOCH_INITIAL
:

4025 case 
QUICLY_EPOCH_HANDSHAKE
:

4026 
error_code
 = 
QUICLY_TRANSPORT_ERROR_APPLICATION
;

4027 
offending_frame_type
 = 
QUICLY_FRAME_TYPE_PADDING
;

4028 
reason_phrase
 = "";

4034 if ((
ret
 = 
	`allocate_frame
(
conn
, 
s
, 
	`quicly_close_frame_capacity
(
error_code
, 
offending_frame_type
, 
reason_phrase
))) != 0)

4035 return 
ret
;

4036 
s
->
dst
 = 
	`quicly_encode_close_frame
(s->dst, 
error_code
, 
offending_frame_type
, 
reason_phrase
);

4039 if (
offending_frame_type
 != 
UINT64_MAX
) {

4040 ++
conn
->
super
.
stats
.
num_frames_sent
.
transport_close
;

4041 
	`QUICLY_PROBE
(
TRANSPORT_CLOSE_SEND
, 
conn
, conn->
stash
.
now
, 
error_code
, 
offending_frame_type
, 
reason_phrase
);

4043 ++
conn
->
super
.
stats
.
num_frames_sent
.
application_close
;

4044 
	`QUICLY_PROBE
(
APPLICATION_CLOSE_SEND
, 
conn
, conn->
stash
.
now
, 
error_code
, 
reason_phrase
);

4048 
	}
}

4050 static int 
	$send_new_connection_id
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
, struct 
st_quicly_local_cid_t
 *
new_cid
)

4052 int 
ret
;

4053 
quicly_sent_t
 *
sent
;

4054 
uint64_t
 
retire_prior_to
 = 0;

4056 
ret
 = 
	`allocate_ack_eliciting_frame
(

4057 
conn
, 
s
, 
	`quicly_new_connection_id_frame_capacity
(
new_cid
->
sequence
, 
retire_prior_to
, new_cid->
cid
.
len
), &
sent
,

4058 
on_ack_new_connection_id
);

4059 if (
ret
 != 0)

4060 return 
ret
;

4061 
sent
->
data
.
new_connection_id
.
sequence
 = 
new_cid
->sequence;

4063 
s
->
dst
 = 
	`quicly_encode_new_connection_id_frame
(s->dst, 
new_cid
->
sequence
, 
retire_prior_to
, new_cid->
cid
.cid, new_cid->cid.
len
,

4064 
new_cid
->
stateless_reset_token
);

4066 ++
conn
->
super
.
stats
.
num_frames_sent
.
new_connection_id
;

4067 
	`QUICLY_PROBE
(
NEW_CONNECTION_ID_SEND
, 
conn
, conn->
stash
.
now
, 
new_cid
->
sequence
, 
retire_prior_to
,

4068 
	`QUICLY_PROBE_HEXDUMP
(
new_cid
->
cid
.cid, new_cid->cid.
len
),

4069 
	`QUICLY_PROBE_HEXDUMP
(
new_cid
->
stateless_reset_token
, 
QUICLY_STATELESS_RESET_TOKEN_LEN
));

4072 
	}
}

4074 static int 
	$send_retire_connection_id
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
, 
uint64_t
 
sequence
)

4076 int 
ret
;

4077 
quicly_sent_t
 *
sent
;

4079 
ret
 = 
	`allocate_ack_eliciting_frame
(
conn
, 
s
, 
	`quicly_retire_connection_id_frame_capacity
(
sequence
), &
sent
,

4080 
on_ack_retire_connection_id
);

4081 if (
ret
 != 0)

4082 return 
ret
;

4083 
sent
->
data
.
retire_connection_id
.
sequence
 = sequence;

4085 
s
->
dst
 = 
	`quicly_encode_retire_connection_id_frame
(s->dst, 
sequence
);

4087 ++
conn
->
super
.
stats
.
num_frames_sent
.
retire_connection_id
;

4088 
	`QUICLY_PROBE
(
RETIRE_CONNECTION_ID_SEND
, 
conn
, conn->
stash
.
now
, 
sequence
);

4091 
	}
}

4093 static int 
	$update_traffic_key_cb
(
ptls_update_traffic_key_t
 *
self
, 
ptls_t
 *
tls
, int 
is_enc
, 
size_t
 
epoch
, const void *
secret
)

4095 
quicly_conn_t
 *
conn
 = *
	`ptls_get_data_ptr
(
tls
);

4096 
ptls_context_t
 *
tlsctx
 = 
	`ptls_get_context
(
tls
);

4097 
ptls_cipher_suite_t
 *
cipher
 = 
	`ptls_get_cipher
(
tls
);

4098 
ptls_cipher_context_t
 **
hp_slot
;

4099 
ptls_aead_context_t
 **
aead_slot
;

4100 int 
ret
;

4101 static const char *
log_labels
[2][4] = {

4102 {
NULL
, "CLIENT_EARLY_TRAFFIC_SECRET", "CLIENT_HANDSHAKE_TRAFFIC_SECRET", "CLIENT_TRAFFIC_SECRET_0"},

4103 {
NULL
, NULL, "SERVER_HANDSHAKE_TRAFFIC_SECRET", "SERVER_TRAFFIC_SECRET_0"}};

4104 const char *
log_label
 = 
log_labels
[
	`ptls_is_server
(
tls
) == 
is_enc
][
epoch
];

4106 
	`QUICLY_PROBE
(
CRYPTO_UPDATE_SECRET
, 
conn
, conn->
stash
.
now
, 
is_enc
, 
epoch
, 
log_label
,

4107 
	`QUICLY_PROBE_HEXDUMP
(
secret
, 
cipher
->
hash
->
digest_size
));

4109 if (
tlsctx
->
log_event
 != 
NULL
) {

4110 char 
hexbuf
[
PTLS_MAX_DIGEST_SIZE
 * 2 + 1];

4111 
	`ptls_hexdump
(
hexbuf
, 
secret
, 
cipher
->
hash
->
digest_size
);

4112 
tlsctx
->
log_event
->
	`cb
(tlsctx->log_event, 
tls
, 
log_label
, "%s", 
hexbuf
);

4115 #define 
	#SELECT_CIPHER_CONTEXT
(
p
) \

4117 
hp_slot
 = &(
p
)->
header_protection
; \

4118 
aead_slot
 = &(
p
)->
aead
; \

4119 } while (0)

	)

4121 switch (
epoch
) {

4122 case 
QUICLY_EPOCH_0RTT
:

4123 
	`assert
(
is_enc
 == 
	`quicly_is_client
(
conn
));

4124 if (
conn
->
application
 == 
NULL
 && (
ret
 = 
	`setup_application_space
(conn)) != 0)

4125 return 
ret
;

4126 if (
is_enc
) {

4127 
	`SELECT_CIPHER_CONTEXT
(&
conn
->
application
->
cipher
.
egress
.
key
);

4129 
hp_slot
 = &
conn
->
application
->
cipher
.
ingress
.
header_protection
.
zero_rtt
;

4130 
aead_slot
 = &
conn
->
application
->
cipher
.
ingress
.
aead
[1];

4133 case 
QUICLY_EPOCH_HANDSHAKE
:

4134 if (
conn
->
handshake
 == 
NULL
 && (
ret
 = 
	`setup_handshake_space_and_flow
(conn, 
QUICLY_EPOCH_HANDSHAKE
)) != 0)

4135 return 
ret
;

4136 
	`SELECT_CIPHER_CONTEXT
(
is_enc
 ? &
conn
->
handshake
->
cipher
.
egress
 : &conn->handshake->cipher.
ingress
);

4138 case 
QUICLY_EPOCH_1RTT
: {

4139 if (
is_enc
)

4140 if ((
ret
 = 
	`apply_remote_transport_params
(
conn
)) != 0)

4141 return 
ret
;

4142 if (
conn
->
application
 == 
NULL
 && (
ret
 = 
	`setup_application_space
(conn)) != 0)

4143 return 
ret
;

4144 
uint8_t
 *
secret_store
;

4145 if (
is_enc
) {

4146 if (
conn
->
application
->
cipher
.
egress
.
key
.
aead
 != 
NULL
)

4147 
	`dispose_cipher
(&
conn
->
application
->
cipher
.
egress
.
key
);

4148 
	`SELECT_CIPHER_CONTEXT
(&
conn
->
application
->
cipher
.
egress
.
key
);

4149 
secret_store
 = 
conn
->
application
->
cipher
.
egress
.
secret
;

4151 
hp_slot
 = &
conn
->
application
->
cipher
.
ingress
.
header_protection
.
one_rtt
;

4152 
aead_slot
 = &
conn
->
application
->
cipher
.
ingress
.
aead
[0];

4153 
secret_store
 = 
conn
->
application
->
cipher
.
ingress
.
secret
;

4155 
	`memcpy
(
secret_store
, 
secret
, 
cipher
->
hash
->
digest_size
);

4158 
	`assert
(!"logic flaw");

4162 #undef 
SELECT_CIPHER_CONTEXT


4164 if ((
ret
 = 
	`setup_cipher
(
conn
, 
epoch
, 
is_enc
, 
hp_slot
, 
aead_slot
, 
cipher
->
aead
, cipher->
hash
, 
secret
)) != 0)

4165 return 
ret
;

4167 if (
epoch
 == 
QUICLY_EPOCH_1RTT
 && 
is_enc
) {

4169 
conn
->
application
->
one_rtt_writable
 = 1;

4170 
	`open_blocked_streams
(
conn
, 1);

4171 
	`open_blocked_streams
(
conn
, 0);

4173 if (!
	`quicly_is_client
(
conn
) && conn->
super
.
ctx
->
generate_resumption_token
 != 
NULL
) {

4174 
ret
 = 
	`quicly_send_resumption_token
(
conn
);

4175 
	`assert
(
ret
 == 0);

4179 
size_t
 
size
 = 
	`local_cid_size
(
conn
);

4180 if (
	`quicly_local_cid_set_size
(&
conn
->
super
.
local
.
cid_set
, 
size
))

4181 
conn
->
egress
.
pending_flows
 |= 
QUICLY_PENDING_FLOW_CID_FRAME_BIT
;

4185 
	}
}

4187 static int 
	$do_send
(
quicly_conn_t
 *
conn
, 
quicly_send_context_t
 *
s
)

4189 int 
restrict_sending
 = 0, 
ack_only
 = 0, 
ret
;

4190 
size_t
 
min_packets_to_send
 = 0;

4193 if (
conn
->
idle_timeout
.
at
 <= conn->
stash
.
now
) {

4194 
	`QUICLY_PROBE
(
IDLE_TIMEOUT
, 
conn
, conn->
stash
.
now
);

4195 
conn
->
super
.
state
 = 
QUICLY_STATE_DRAINING
;

4196 
	`destroy_all_streams
(
conn
, 0, 0);

4197 return 
QUICLY_ERROR_FREE_CONNECTION
;

4199 if (
conn
->
egress
.
loss
.
alarm_at
 <= conn->
stash
.
now
) {

4200 if ((
ret
 = 
	`quicly_loss_on_alarm
(&
conn
->
egress
.
loss
, conn->
stash
.
now
, conn->
super
.
remote
.
transport_params
.
max_ack_delay
,

4201 
conn
->
initial
 == 
NULL
 && conn->
handshake
 == NULL, &
min_packets_to_send
, &
restrict_sending
,

4202 
on_loss_detected
)) != 0)

4203 goto 
Exit
;

4204 
	`assert
(
min_packets_to_send
 > 0);

4205 
	`assert
(
min_packets_to_send
 <= 
s
->
max_datagrams
);

4207 if (
restrict_sending
) {

4211 
	`QUICLY_PROBE
(
PTO
, 
conn
, conn->
stash
.
now
, conn->
egress
.
loss
.
sentmap
.
bytes_in_flight
, conn->egress.
cc
.
cwnd
,

4212 
conn
->
egress
.
loss
.
pto_count
);

4213 ++
conn
->
super
.
stats
.
num_ptos
;

4214 
size_t
 
bytes_to_mark
 = 
min_packets_to_send
 * 
conn
->
egress
.
max_udp_payload_size
;

4215 if (
conn
->
initial
 != 
NULL
 && (
ret
 = 
	`mark_frames_on_pto
(conn, 
QUICLY_EPOCH_INITIAL
, &
bytes_to_mark
)) != 0)

4216 goto 
Exit
;

4217 if (
bytes_to_mark
 != 0 && 
conn
->
handshake
 != 
NULL
 &&

4218 (
ret
 = 
	`mark_frames_on_pto
(
conn
, 
QUICLY_EPOCH_HANDSHAKE
, &
bytes_to_mark
)) != 0)

4219 goto 
Exit
;

4221 if (
bytes_to_mark
 != 0 && !
	`scheduler_can_send
(
conn
) &&

4222 (
ret
 = 
	`mark_frames_on_pto
(
conn
, 
QUICLY_EPOCH_1RTT
, &
bytes_to_mark
)) != 0)

4223 goto 
Exit
;

4227 
s
->
send_window
 = 
	`calc_send_window
(
conn
, 
min_packets_to_send
 * conn->
egress
.
max_udp_payload_size
,

4228 
	`calc_amplification_limit_allowance
(
conn
), 
restrict_sending
);

4229 if (
s
->
send_window
 == 0)

4230 
ack_only
 = 1;

4236 if ((
ret
 = 
	`send_handshake_flow
(
conn
, 
QUICLY_EPOCH_INITIAL
, 
s
, 
ack_only
,

4237 
min_packets_to_send
 != 0 && (!
	`quicly_is_client
(
conn
) || conn->
handshake
 == 
NULL
))) != 0)

4238 goto 
Exit
;

4239 if ((
ret
 = 
	`send_handshake_flow
(
conn
, 
QUICLY_EPOCH_HANDSHAKE
, 
s
, 
ack_only
, 
min_packets_to_send
 != 0)) != 0)

4240 goto 
Exit
;

4244 if (
	`setup_send_space
(
conn
, 
QUICLY_EPOCH_1RTT
, 
s
) != 
NULL
 || setup_send_space(conn, 
QUICLY_EPOCH_0RTT
, s) != NULL) {

4246 if (
conn
->
application
->
one_rtt_writable
 && conn->
egress
.
send_ack_at
 <= conn->
stash
.
now
 &&

4247 
conn
->
application
->
super
.
unacked_count
 != 0) {

4248 if ((
ret
 = 
	`send_ack
(
conn
, &conn->
application
->
super
, 
s
)) != 0)

4249 goto 
Exit
;

4256 if (
	`should_send_datagram_frame
(
conn
)) {

4257 for (
size_t
 
i
 = 0; i != 
conn
->
egress
.
datagram_frame_payloads
.
count
; ++i) {

4258 
ptls_iovec_t
 *
payload
 = 
conn
->
egress
.
datagram_frame_payloads
.
payloads
 + 
i
;

4259 
size_t
 
required_space
 = 
	`quicly_datagram_frame_capacity
(*
payload
);

4260 if ((
ret
 = 
	`_do_allocate_frame
(
conn
, 
s
, 
required_space
, 1)) != 0)

4261 goto 
Exit
;

4262 if (
s
->
dst_end
 - s->
dst
 >= 
required_space
) {

4263 
s
->
dst
 = 
	`quicly_encode_datagram_frame
(s->dst, *
payload
);

4264 
	`QUICLY_PROBE
(
DATAGRAM_SEND
, 
conn
, conn->
stash
.
now
, 
payload
->
base
, payload->
len
);

4268 *
s
->
dst
++ = 
QUICLY_FRAME_TYPE_PADDING
;

4272 if (!
ack_only
) {

4274 if (
min_packets_to_send
 != 0) {

4275 if ((
ret
 = 
	`_do_allocate_frame
(
conn
, 
s
, 1, 1)) != 0)

4276 goto 
Exit
;

4277 *
s
->
dst
++ = 
QUICLY_FRAME_TYPE_PING
;

4278 ++
conn
->
super
.
stats
.
num_frames_sent
.
ping
;

4279 
	`QUICLY_PROBE
(
PING_SEND
, 
conn
, conn->
stash
.
now
);

4282 if (
conn
->
application
->
one_rtt_writable
) {

4284 if ((
conn
->
egress
.
pending_flows
 & 
QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT
) != 0 &&

4285 (
ret
 = 
	`send_handshake_done
(
conn
, 
s
)) != 0)

4286 goto 
Exit
;

4288 if ((
conn
->
egress
.
pending_flows
 & (
uint8_t
)(1 << 
QUICLY_EPOCH_1RTT
)) != 0) {

4289 
quicly_stream_t
 *
stream
 = 
	`quicly_get_stream
(
conn
, -(1 + 
QUICLY_EPOCH_1RTT
));

4290 
	`assert
(
stream
 != 
NULL
);

4291 if ((
ret
 = 
	`quicly_send_stream
(
stream
, 
s
)) != 0)

4292 goto 
Exit
;

4293 
	`resched_stream_data
(
stream
);

4296 if (
conn
->
egress
.
path_challenge
.
head
 != 
NULL
) {

4298 struct 
st_quicly_pending_path_challenge_t
 *
c
 = 
conn
->
egress
.
path_challenge
.
head
;

4299 if ((
ret
 = 
	`allocate_frame
(
conn
, 
s
, 
QUICLY_PATH_CHALLENGE_FRAME_CAPACITY
)) != 0)

4300 goto 
Exit
;

4301 
s
->
dst
 = 
	`quicly_encode_path_challenge_frame
(s->dst, 
c
->
is_response
, c->
data
);

4302 if (
c
->
is_response
) {

4303 ++
conn
->
super
.
stats
.
num_frames_sent
.
path_response
;

4305 ++
conn
->
super
.
stats
.
num_frames_sent
.
path_challenge
;

4307 
conn
->
egress
.
path_challenge
.
head
 = 
c
->
next
;

4308 
	`free
(
c
);

4309 } while (
conn
->
egress
.
path_challenge
.
head
 != 
NULL
);

4310 
conn
->
egress
.
path_challenge
.
tail_ref
 = &conn->egress.path_challenge.
head
;

4313 if ((
ret
 = 
	`send_max_streams
(
conn
, 1, 
s
)) != 0)

4314 goto 
Exit
;

4315 if ((
ret
 = 
	`send_max_streams
(
conn
, 0, 
s
)) != 0)

4316 goto 
Exit
;

4318 if (
	`should_send_max_data
(
conn
)) {

4319 
quicly_sent_t
 *
sent
;

4320 if ((
ret
 = 
	`allocate_ack_eliciting_frame
(
conn
, 
s
, 
QUICLY_MAX_DATA_FRAME_CAPACITY
, &
sent
, 
on_ack_max_data
)) != 0)

4321 goto 
Exit
;

4322 
uint64_t
 
new_value
 = 
conn
->
ingress
.
max_data
.
bytes_consumed
 + conn->
super
.
ctx
->
transport_params
.max_data;

4323 
s
->
dst
 = 
	`quicly_encode_max_data_frame
(s->dst, 
new_value
);

4324 
	`quicly_maxsender_record
(&
conn
->
ingress
.
max_data
.
sender
, 
new_value
, &
sent
->
data
.max_data.
args
);

4325 ++
conn
->
super
.
stats
.
num_frames_sent
.
max_data
;

4326 
	`QUICLY_PROBE
(
MAX_DATA_SEND
, 
conn
, conn->
stash
.
now
, 
new_value
);

4328 if (
conn
->
egress
.
data_blocked
 == 
QUICLY_SENDER_STATE_SEND
 && (
ret
 = 
	`send_data_blocked
(conn, 
s
)) != 0)

4329 goto 
Exit
;

4331 if ((
ret
 = 
	`send_streams_blocked
(
conn
, 1, 
s
)) != 0)

4332 goto 
Exit
;

4333 if ((
ret
 = 
	`send_streams_blocked
(
conn
, 0, 
s
)) != 0)

4334 goto 
Exit
;

4336 if ((
conn
->
egress
.
pending_flows
 & 
QUICLY_PENDING_FLOW_NEW_TOKEN_BIT
) != 0 &&

4337 (
ret
 = 
	`send_resumption_token
(
conn
, 
s
)) != 0)

4338 goto 
Exit
;

4339 if ((
conn
->
egress
.
pending_flows
 & 
QUICLY_PENDING_FLOW_CID_FRAME_BIT
) != 0) {

4341 
size_t
 
i
;

4342 
size_t
 
size
 = 
	`quicly_local_cid_get_size
(&
conn
->
super
.
local
.
cid_set
);

4343 for (
i
 = 0; i < 
size
; i++) {

4345 struct 
st_quicly_local_cid_t
 *
c
 = &
conn
->
super
.
local
.
cid_set
.
cids
[
i
];

4346 if (
c
->
state
 != 
QUICLY_LOCAL_CID_STATE_PENDING
)

4348 if ((
ret
 = 
	`send_new_connection_id
(
conn
, 
s
, 
c
)) != 0)

4351 
	`quicly_local_cid_on_sent
(&
conn
->
super
.
local
.
cid_set
, 
i
);

4352 if (
ret
 != 0)

4353 goto 
Exit
;

4355 
size
 = 
	`quicly_retire_cid_get_num_pending
(&
conn
->
egress
.
retire_cid
);

4356 for (
i
 = 0; i < 
size
; i++) {

4357 
uint64_t
 
sequence
 = 
conn
->
egress
.
retire_cid
.
sequences
[
i
];

4358 if ((
ret
 = 
	`send_retire_connection_id
(
conn
, 
s
, 
sequence
)) != 0)

4361 
	`quicly_retire_cid_shift
(&
conn
->
egress
.
retire_cid
, 
i
);

4362 if (
ret
 != 0)

4363 goto 
Exit
;

4364 
conn
->
egress
.
pending_flows
 &= ~
QUICLY_PENDING_FLOW_CID_FRAME_BIT
;

4368 if ((
ret
 = 
	`send_stream_control_frames
(
conn
, 
s
)) != 0)

4369 goto 
Exit
;

4371 if ((
ret
 = 
conn
->
super
.
ctx
->
stream_scheduler
->
	`do_send
(conn->super.ctx->stream_scheduler, conn, 
s
)) != 0)

4372 goto 
Exit
;

4374 if ((
ret
 = 
	`send_stream_control_frames
(
conn
, 
s
)) != 0)

4375 goto 
Exit
;

4379 
Exit
:

4380 if (
ret
 == 
QUICLY_ERROR_SENDBUF_FULL
)

4381 
ret
 = 0;

4382 if (
ret
 == 0 && 
s
->
target
.
first_byte_at
 != 
NULL
) {

4384 enum 
en_quicly_send_packet_mode_t
 
commit_mode
 = 
QUICLY_COMMIT_SEND_PACKET_MODE_SMALL
;

4385 if ((
s
->
payload_buf
.
datagram
[0] & 
QUICLY_PACKET_TYPE_BITMASK
) == 
QUICLY_PACKET_TYPE_INITIAL
 &&

4386 (
	`quicly_is_client
(
conn
) || !
ack_only
))

4387 
commit_mode
 = 
QUICLY_COMMIT_SEND_PACKET_MODE_FULL_SIZE
;

4388 
	`commit_send_packet
(
conn
, 
s
, 
commit_mode
);

4390 if (
ret
 == 0) {

4391 if (
conn
->
application
 == 
NULL
 || conn->application->
super
.
unacked_count
 == 0)

4392 
conn
->
egress
.
send_ack_at
 = 
INT64_MAX
;

4393 
	`update_loss_alarm
(
conn
, 1);

4394 if (
s
->
num_datagrams
 != 0)

4395 
	`update_idle_timeout
(
conn
, 0);

4397 return 
ret
;

4398 
	}
}

4400 void 
	$quicly_send_datagram_frames
(
quicly_conn_t
 *
conn
, 
ptls_iovec_t
 *
datagrams
, 
size_t
 
num_datagrams
)

4402 for (
size_t
 
i
 = 0; i != 
num_datagrams
; ++i) {

4403 if (
conn
->
egress
.
datagram_frame_payloads
.
count
 == 
	`PTLS_ELEMENTSOF
(conn->egress.datagram_frame_payloads.
payloads
))

4405 void *
copied
;

4406 if ((
copied
 = 
	`malloc
(
datagrams
[
i
].
len
)) == 
NULL
)

4408 
	`memcpy
(
copied
, 
datagrams
[
i
].
base
, datagrams[i].
len
);

4409 
conn
->
egress
.
datagram_frame_payloads
.
payloads
[conn->egress.datagram_frame_payloads.
count
++] =

4410 
	`ptls_iovec_init
(
copied
, 
datagrams
[
i
].
len
);

4412 
	}
}

4414 int 
	$quicly_send
(
quicly_conn_t
 *
conn
, 
quicly_address_t
 *
dest
, quicly_address_t *
src
, struct 
iovec
 *
datagrams
, 
size_t
 *
num_datagrams
,

4415 void *
buf
, 
size_t
 
bufsize
)

4417 
quicly_send_context_t
 
s
 = {{
NULL
, -1}, {}, 
datagrams
, *
num_datagrams
, 0, {
buf
, (
uint8_t
 *)buf + 
bufsize
}};

4418 int 
ret
;

4420 
	`lock_now
(
conn
, 0);

4423 if (
conn
->
stash
.
now
 < 
	`quicly_get_first_timeout
(conn)) {

4424 
ret
 = 0;

4425 goto 
Exit
;

4428 
	`QUICLY_PROBE
(
SEND
, 
conn
, conn->
stash
.
now
, conn->
super
.
state
,

4429 
	`QUICLY_PROBE_HEXDUMP
(
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
.cid, conn->super.remote.cid_set.cids[0].cid.
len
));

4431 if (
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
) {

4432 
quicly_sentmap_iter_t
 
iter
;

4433 
	`init_acks_iter
(
conn
, &
iter
);

4435 if (
conn
->
super
.
state
 == 
QUICLY_STATE_DRAINING
 ||

4436 
conn
->
super
.
stats
.
num_frames_sent
.
transport_close
 + conn->super.stats.num_frames_sent.
application_close
 != 0) {

4437 if (
	`quicly_sentmap_get
(&
iter
)->
packet_number
 == 
UINT64_MAX
) {

4438 
	`assert
(
	`quicly_num_streams
(
conn
) == 0);

4439 
ret
 = 
QUICLY_ERROR_FREE_CONNECTION
;

4440 goto 
Exit
;

4443 if (
conn
->
super
.
state
 == 
QUICLY_STATE_CLOSING
 && conn->
egress
.
send_ack_at
 <= conn->
stash
.
now
) {

4446 
	`destroy_all_streams
(
conn
, 0, 0);

4448 for (
size_t
 
epoch
 = 0; epoch < 
QUICLY_NUM_EPOCHS
; ++epoch) {

4449 if ((
ret
 = 
	`send_connection_close
(
conn
, 
epoch
, &
s
)) != 0)

4450 goto 
Exit
;

4452 if ((
ret
 = 
	`commit_send_packet
(
conn
, &
s
, 
QUICLY_COMMIT_SEND_PACKET_MODE_SMALL
)) != 0)

4453 goto 
Exit
;

4456 if ((
conn
->
egress
.
send_ack_at
 = 
	`quicly_sentmap_get
(&
iter
)->
sent_at
 + 
	`get_sentmap_expiration_time
(conn)) <= conn->
stash
.
now
)

4457 
conn
->
egress
.
send_ack_at
 = conn->
stash
.
now
 + 1;

4458 
ret
 = 0;

4459 goto 
Exit
;

4463 if ((
ret
 = 
	`do_send
(
conn
, &
s
)) != 0)

4464 goto 
Exit
;

4466 
	`assert_consistency
(
conn
, 1);

4468 
Exit
:

4469 
	`clear_datagram_frame_payloads
(
conn
);

4470 if (
s
.
num_datagrams
 != 0) {

4471 *
dest
 = 
conn
->
super
.
remote
.
address
;

4472 *
src
 = 
conn
->
super
.
local
.
address
;

4474 *
num_datagrams
 = 
s
.num_datagrams;

4475 
	`unlock_now
(
conn
);

4476 return 
ret
;

4477 
	}
}

4479 
size_t
 
	$quicly_send_close_invalid_token
(
quicly_context_t
 *
ctx
, 
uint32_t
 
protocol_version
, 
ptls_iovec_t
 
dest_cid
,

4480 
ptls_iovec_t
 
src_cid
, const char *
err_desc
, void *
datagram
)

4482 struct 
st_quicly_cipher_context_t
 
egress
 = {};

4483 const struct 
st_ptls_salt_t
 *
salt
;

4486 if ((
salt
 = 
	`get_salt
(
protocol_version
)) == 
NULL
)

4487 return 
SIZE_MAX
;

4488 if (
	`setup_initial_encryption
(
	`get_aes128gcmsha256
(
ctx
), 
NULL
, &
egress
, 
src_cid
, 0,

4489 
	`ptls_iovec_init
(
salt
->
initial
, sizeof(salt->initial)), 
NULL
) != 0)

4490 return 
SIZE_MAX
;

4492 
uint8_t
 *
dst
 = 
datagram
, *
length_at
;

4495 
	`PTLS_BUILD_ASSERT
(
QUICLY_SEND_PN_SIZE
 == 2);

4496 *
dst
++ = 
QUICLY_PACKET_TYPE_INITIAL
 | 0x1 ;

4497 
dst
 = 
	`quicly_encode32
(dst, 
protocol_version
);

4498 *
dst
++ = 
dest_cid
.
len
;

4499 
	`memcpy
(
dst
, 
dest_cid
.
base
, dest_cid.
len
);

4500 
dst
 += 
dest_cid
.
len
;

4501 *
dst
++ = 
src_cid
.
len
;

4502 
	`memcpy
(
dst
, 
src_cid
.
base
, src_cid.
len
);

4503 
dst
 += 
src_cid
.
len
;

4504 *
dst
++ = 0;

4505 
length_at
 = 
dst
++;

4506 *
dst
++ = 0;

4507 *
dst
++ = 0;

4508 
uint8_t
 *
payload_from
 = 
dst
;

4509 
dst
 = 
	`quicly_encode_close_frame
(dst, 
	`QUICLY_ERROR_GET_ERROR_CODE
(
QUICLY_TRANSPORT_ERROR_INVALID_TOKEN
),

4510 
QUICLY_FRAME_TYPE_PADDING
, 
err_desc
);

4513 
dst
 += 
egress
.
aead
->
algo
->
tag_size
;

4514 
	`assert
(
dst
 - (
uint8_t
 *)
datagram
 <= 
QUICLY_MIN_CLIENT_INITIAL_SIZE
);

4515 
	`assert
(
dst
 - 
length_at
 - 1 < 64);

4516 *
length_at
 = 
dst
 - length_at - 1;

4517 
size_t
 
datagram_len
 = 
dst
 - (
uint8_t
 *)
datagram
;

4520 
quicly_default_crypto_engine
.
	`encrypt_packet
(&quicly_default_crypto_engine, 
NULL
, 
egress
.
header_protection
, egress.
aead
,

4521 
	`ptls_iovec_init
(
datagram
, 
datagram_len
), 0, 
payload_from
 - (
uint8_t
 *)datagram, 0,

4524 
	`dispose_cipher
(&
egress
);

4525 return 
datagram_len
;

4526 
	}
}

4528 
size_t
 
	$quicly_send_stateless_reset
(
quicly_context_t
 *
ctx
, const void *
src_cid
, void *
payload
)

4530 
uint8_t
 *
base
 = 
payload
;

4533 
ctx
->
tls
->
	`random_bytes
(
base
, 
QUICLY_STATELESS_RESET_PACKET_MIN_LEN
 - 
QUICLY_STATELESS_RESET_TOKEN_LEN
);

4534 
base
[0] = (base[0] & ~
QUICLY_LONG_HEADER_BIT
) | 
QUICLY_QUIC_BIT
;

4535 if (!
ctx
->
cid_encryptor
->
	`generate_stateless_reset_token
(

4536 
ctx
->
cid_encryptor
, 
base
 + 
QUICLY_STATELESS_RESET_PACKET_MIN_LEN
 - 
QUICLY_STATELESS_RESET_TOKEN_LEN
, 
src_cid
))

4537 return 
SIZE_MAX
;

4539 return 
QUICLY_STATELESS_RESET_PACKET_MIN_LEN
;

4540 
	}
}

4542 int 
	$quicly_send_resumption_token
(
quicly_conn_t
 *
conn
)

4544 if (
conn
->
super
.
state
 <= 
QUICLY_STATE_CONNECTED
) {

4545 ++
conn
->
egress
.
new_token
.
generation
;

4546 
conn
->
egress
.
pending_flows
 |= 
QUICLY_PENDING_FLOW_NEW_TOKEN_BIT
;

4549 
	}
}

4551 static int 
	$on_end_closing
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

4554 
	`assert
(!
acked
);

4556 
	}
}

4558 static int 
	$enter_close
(
quicly_conn_t
 *
conn
, int 
local_is_initiating
, int 
wait_draining
)

4560 int 
ret
;

4562 
	`assert
(
conn
->
super
.
state
 < 
QUICLY_STATE_CLOSING
);

4565 if ((
ret
 = 
	`discard_sentmap_by_epoch
(
conn
, ~0u)) != 0)

4566 return 
ret
;

4567 if ((
ret
 = 
	`quicly_sentmap_prepare
(&
conn
->
egress
.
loss
.
sentmap
, conn->egress.
packet_number
, conn->
stash
.
now
,

4568 
QUICLY_EPOCH_INITIAL
)) != 0)

4569 return 
ret
;

4570 if (
	`quicly_sentmap_allocate
(&
conn
->
egress
.
loss
.
sentmap
, 
on_end_closing
) == 
NULL
)

4571 return 
PTLS_ERROR_NO_MEMORY
;

4572 
	`quicly_sentmap_commit
(&
conn
->
egress
.
loss
.
sentmap
, 0);

4573 ++
conn
->
egress
.
packet_number
;

4575 if (
local_is_initiating
) {

4576 
conn
->
super
.
state
 = 
QUICLY_STATE_CLOSING
;

4577 
conn
->
egress
.
send_ack_at
 = 0;

4579 
conn
->
super
.
state
 = 
QUICLY_STATE_DRAINING
;

4580 
conn
->
egress
.
send_ack_at
 = 
wait_draining
 ? conn->
stash
.
now
 + 
	`get_sentmap_expiration_time
(conn) : 0;

4583 
	`update_loss_alarm
(
conn
, 0);

4586 
	}
}

4588 int 
	$initiate_close
(
quicly_conn_t
 *
conn
, int 
err
, 
uint64_t
 
frame_type
, const char *
reason_phrase
)

4590 
uint16_t
 
quic_error_code
;

4592 if (
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
)

4595 if (
reason_phrase
 == 
NULL
)

4596 
reason_phrase
 = "";

4599 if (
err
 == 0) {

4600 
quic_error_code
 = 0;

4601 
frame_type
 = 
QUICLY_FRAME_TYPE_PADDING
;

4602 } else if (
	`QUICLY_ERROR_IS_QUIC_TRANSPORT
(
err
)) {

4603 
quic_error_code
 = 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
);

4604 } else if (
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
)) {

4605 
quic_error_code
 = 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
);

4606 
frame_type
 = 
UINT64_MAX
;

4607 } else if (
	`PTLS_ERROR_GET_CLASS
(
err
) == 
PTLS_ERROR_CLASS_SELF_ALERT
) {

4608 
quic_error_code
 = 
QUICLY_TRANSPORT_ERROR_TLS_ALERT_BASE
 + 
	`PTLS_ERROR_TO_ALERT
(
err
);

4610 
quic_error_code
 = 
	`QUICLY_ERROR_GET_ERROR_CODE
(
QUICLY_TRANSPORT_ERROR_INTERNAL
);

4613 
conn
->
egress
.
connection_close
.
error_code
 = 
quic_error_code
;

4614 
conn
->
egress
.
connection_close
.
frame_type
 = frame_type;

4615 
conn
->
egress
.
connection_close
.
reason_phrase
 = reason_phrase;

4616 return 
	`enter_close
(
conn
, 1, 0);

4617 
	}
}

4619 int 
	$quicly_close
(
quicly_conn_t
 *
conn
, int 
err
, const char *
reason_phrase
)

4621 int 
ret
;

4623 
	`assert
(
err
 == 0 || 
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(err) || 
	`QUICLY_ERROR_IS_CONCEALED
(err));

4625 
	`lock_now
(
conn
, 1);

4626 
ret
 = 
	`initiate_close
(
conn
, 
err
, 
QUICLY_FRAME_TYPE_PADDING
 , 
reason_phrase
);

4627 
	`unlock_now
(
conn
);

4629 return 
ret
;

4630 
	}
}

4632 int 
	$quicly_get_or_open_stream
(
quicly_conn_t
 *
conn
, 
uint64_t
 
stream_id
, 
quicly_stream_t
 **
stream
)

4634 int 
ret
 = 0;

4636 if ((*
stream
 = 
	`quicly_get_stream
(
conn
, 
stream_id
)) != 
NULL
)

4637 goto 
Exit
;

4639 if (
	`quicly_stream_is_client_initiated
(
stream_id
) != 
	`quicly_is_client
(
conn
)) {

4641 if (
stream_id
 / 4 >= 
	`quicly_get_ingress_max_streams
(
conn
, 
	`quicly_stream_is_unidirectional
(stream_id))) {

4642 
ret
 = 
QUICLY_TRANSPORT_ERROR_STREAM_LIMIT
;

4643 goto 
Exit
;

4646 struct 
st_quicly_conn_streamgroup_state_t
 *
group
 = 
	`get_streamgroup_state
(
conn
, 
stream_id
);

4647 if (
group
->
next_stream_id
 <= 
stream_id
) {

4648 
uint64_t
 
max_stream_data_local
, 
max_stream_data_remote
;

4649 if (
	`quicly_stream_is_unidirectional
(
stream_id
)) {

4650 
max_stream_data_local
 = 
conn
->
super
.
ctx
->
transport_params
.
max_stream_data
.
uni
;

4651 
max_stream_data_remote
 = 0;

4653 
max_stream_data_local
 = 
conn
->
super
.
ctx
->
transport_params
.
max_stream_data
.
bidi_remote
;

4654 
max_stream_data_remote
 = 
conn
->
super
.
remote
.
transport_params
.
max_stream_data
.
bidi_local
;

4657 if ((*
stream
 = 
	`open_stream
(
conn
, 
group
->
next_stream_id
, (
uint32_t
)
max_stream_data_local
, 
max_stream_data_remote
)) ==

4658 
NULL
) {

4659 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

4660 goto 
Exit
;

4662 
	`QUICLY_PROBE
(
STREAM_ON_OPEN
, 
conn
, conn->
stash
.
now
, *
stream
);

4663 if ((
ret
 = 
conn
->
super
.
ctx
->
stream_open
->
	`cb
(conn->super.ctx->stream_open, *
stream
)) != 0) {

4664 *
stream
 = 
NULL
;

4665 goto 
Exit
;

4667 ++
group
->
num_streams
;

4668 
group
->
next_stream_id
 += 4;

4669 } while (
stream_id
 != (*
stream
)->stream_id);

4673 
Exit
:

4674 return 
ret
;

4675 
	}
}

4677 static int 
	$handle_crypto_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4679 
quicly_stream_frame_t
 
frame
;

4680 
quicly_stream_t
 *
stream
;

4681 int 
ret
;

4683 if ((
ret
 = 
	`quicly_decode_crypto_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

4684 return 
ret
;

4685 
stream
 = 
	`quicly_get_stream
(
conn
, -(
quicly_stream_id_t
)(1 + 
state
->
epoch
));

4686 
	`assert
(
stream
 != 
NULL
);

4687 return 
	`apply_stream_frame
(
stream
, &
frame
);

4688 
	}
}

4690 static int 
	$handle_stream_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4692 
quicly_stream_frame_t
 
frame
;

4693 
quicly_stream_t
 *
stream
;

4694 int 
ret
;

4696 if ((
ret
 = 
	`quicly_decode_stream_frame
(
state
->
frame_type
, &state->
src
, state->
end
, &
frame
)) != 0)

4697 return 
ret
;

4698 
	`QUICLY_PROBE
(
QUICTRACE_RECV_STREAM
, 
conn
, conn->
stash
.
now
, 
frame
.
stream_id
, frame.
offset
, frame.
data
.
len
, (int)frame.
is_fin
);

4699 if ((
ret
 = 
	`quicly_get_or_open_stream
(
conn
, 
frame
.
stream_id
, &
stream
)) != 0 || stream == 
NULL
)

4700 return 
ret
;

4701 return 
	`apply_stream_frame
(
stream
, &
frame
);

4702 
	}
}

4704 static int 
	$handle_reset_stream_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4706 
quicly_reset_stream_frame_t
 
frame
;

4707 
quicly_stream_t
 *
stream
;

4708 int 
ret
;

4710 if ((
ret
 = 
	`quicly_decode_reset_stream_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

4711 return 
ret
;

4713 if ((
ret
 = 
	`quicly_get_or_open_stream
(
conn
, 
frame
.
stream_id
, &
stream
)) != 0 || stream == 
NULL
)

4714 return 
ret
;

4716 if (!
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
)) {

4717 
uint64_t
 
bytes_missing
;

4718 if ((
ret
 = 
	`quicly_recvstate_reset
(&
stream
->
recvstate
, 
frame
.
final_size
, &
bytes_missing
)) != 0)

4719 return 
ret
;

4720 
stream
->
conn
->
ingress
.
max_data
.
bytes_consumed
 += 
bytes_missing
;

4721 int 
err
 = 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(
frame
.
app_error_code
);

4722 
	`QUICLY_PROBE
(
STREAM_ON_RECEIVE_RESET
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream, 
err
);

4723 
stream
->
callbacks
->
	`on_receive_reset
(stream, 
err
);

4724 if (
stream
->
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
)

4725 return 
QUICLY_ERROR_IS_CLOSING
;

4726 if (
	`stream_is_destroyable
(
stream
))

4727 
	`destroy_stream
(
stream
, 0);

4731 
	}
}

4733 static int 
	$handle_ack_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4735 
quicly_ack_frame_t
 
frame
;

4736 
quicly_sentmap_iter_t
 
iter
;

4738 
uint64_t
 
pn
;

4739 
int64_t
 
sent_at
;

4740 } 
largest_newly_acked
 = {
UINT64_MAX
, 
INT64_MAX
};

4741 
size_t
 
bytes_acked
 = 0;

4742 int 
includes_ack_eliciting
 = 0, 
ret
;

4744 if ((
ret
 = 
	`quicly_decode_ack_frame
(&
state
->
src
, state->
end
, &
frame
, state->
frame_type
 == 
QUICLY_FRAME_TYPE_ACK_ECN
)) != 0)

4745 return 
ret
;

4747 
uint64_t
 
pn_acked
 = 
frame
.
smallest_acknowledged
;

4749 switch (
state
->
epoch
) {

4750 case 
QUICLY_EPOCH_0RTT
:

4751 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

4752 case 
QUICLY_EPOCH_HANDSHAKE
:

4753 
conn
->
super
.
remote
.
address_validation
.
send_probe
 = 0;

4759 
	`init_acks_iter
(
conn
, &
iter
);

4763 
size_t
 
gap_index
 = 
frame
.
num_gaps
;

4765 
	`assert
(
frame
.
ack_block_lengths
[
gap_index
] != 0);

4768 
uint64_t
 
pn_block_max
 = 
pn_acked
 + 
frame
.
ack_block_lengths
[
gap_index
] - 1;

4769 
	`QUICLY_PROBE
(
ACK_BLOCK_RECEIVED
, 
conn
, conn->
stash
.
now
, 
pn_acked
, 
pn_block_max
);

4770 while (
	`quicly_sentmap_get
(&
iter
)->
packet_number
 < 
pn_acked
)

4771 
	`quicly_sentmap_skip
(&
iter
);

4773 const 
quicly_sent_packet_t
 *
sent
 = 
	`quicly_sentmap_get
(&
iter
);

4774 
uint64_t
 
pn_sent
 = 
sent
->
packet_number
;

4775 
	`assert
(
pn_acked
 <= 
pn_sent
);

4776 if (
pn_acked
 < 
pn_sent
) {

4778 if (
pn_sent
 <= 
pn_block_max
) {

4779 
pn_acked
 = 
pn_sent
;

4781 
pn_acked
 = 
pn_block_max
 + 1;

4786 if (
state
->
epoch
 != 
sent
->
ack_epoch
)

4787 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

4788 int 
is_late_ack
 = 0;

4789 if (
sent
->
ack_eliciting
) {

4790 
includes_ack_eliciting
 = 1;

4791 if (
sent
->
cc_bytes_in_flight
 == 0) {

4792 
is_late_ack
 = 1;

4793 ++
conn
->
super
.
stats
.
num_packets
.
late_acked
;

4796 ++
conn
->
super
.
stats
.
num_packets
.
ack_received
;

4797 
largest_newly_acked
.
pn
 = 
pn_acked
;

4798 
largest_newly_acked
.
sent_at
 = 
sent
->sent_at;

4799 
	`QUICLY_PROBE
(
PACKET_ACKED
, 
conn
, conn->
stash
.
now
, 
pn_acked
, 
is_late_ack
);

4800 if (
sent
->
cc_bytes_in_flight
 != 0) {

4801 
bytes_acked
 += 
sent
->
cc_bytes_in_flight
;

4803 if ((
ret
 = 
	`quicly_sentmap_update
(&
conn
->
egress
.
loss
.
sentmap
, &
iter
, 
QUICLY_SENTMAP_EVENT_ACKED
)) != 0)

4804 return 
ret
;

4805 if (
state
->
epoch
 == 
QUICLY_EPOCH_1RTT
) {

4806 struct 
st_quicly_application_space_t
 *
space
 = 
conn
->
application
;

4807 if (
space
->
cipher
.
egress
.
key_update_pn
.
last
 <= 
pn_acked
) {

4808 
space
->
cipher
.
egress
.
key_update_pn
.
last
 = 
UINT64_MAX
;

4809 
space
->
cipher
.
egress
.
key_update_pn
.
next
 = 
conn
->egress.
packet_number
 + conn->
super
.
ctx
->
max_packets_per_key
;

4810 
	`QUICLY_PROBE
(
CRYPTO_SEND_KEY_UPDATE_CONFIRMED
, 
conn
, conn->
stash
.
now
, 
space
->
cipher
.
egress
.
key_update_pn
.
next
);

4813 ++
pn_acked
;

4814 } while (
pn_acked
 <= 
pn_block_max
);

4815 
	`assert
(
pn_acked
 == 
pn_block_max
 + 1);

4816 if (
gap_index
-- == 0)

4818 
pn_acked
 += 
frame
.
gaps
[
gap_index
];

4821 if ((
ret
 = 
	`on_ack_stream_ack_cached
(
conn
)) != 0)

4822 return 
ret
;

4824 
	`QUICLY_PROBE
(
ACK_DELAY_RECEIVED
, 
conn
, conn->
stash
.
now
, 
frame
.
ack_delay
);

4828 
	`quicly_loss_on_ack_received
(&
conn
->
egress
.
loss
, 
largest_newly_acked
.
pn
, 
state
->
epoch
, conn->
stash
.
now
,

4829 
largest_newly_acked
.
sent_at
, 
frame
.
ack_delay
, 
includes_ack_eliciting
);

4832 if (
bytes_acked
 > 0) {

4833 
conn
->
egress
.
cc
.
type
->
	`cc_on_acked
(&conn->egress.cc, &conn->egress.
loss
, (
uint32_t
)
bytes_acked
, 
frame
.
largest_acknowledged
,

4834 (
uint32_t
)(
conn
->
egress
.
loss
.
sentmap
.
bytes_in_flight
 + 
bytes_acked
), conn->
stash
.
now
,

4835 
conn
->
egress
.
max_udp_payload_size
);

4836 
	`QUICLY_PROBE
(
QUICTRACE_CC_ACK
, 
conn
, conn->
stash
.
now
, &conn->
egress
.
loss
.
rtt
, conn->egress.
cc
.
cwnd
,

4837 
conn
->
egress
.
loss
.
sentmap
.
bytes_in_flight
);

4840 
	`QUICLY_PROBE
(
CC_ACK_RECEIVED
, 
conn
, conn->
stash
.
now
, 
frame
.
largest_acknowledged
, 
bytes_acked
, conn->
egress
.
cc
.
cwnd
,

4841 
conn
->
egress
.
loss
.
sentmap
.
bytes_in_flight
);

4844 if ((
ret
 = 
	`quicly_loss_detect_loss
(&
conn
->
egress
.
loss
, conn->
stash
.
now
, conn->
super
.
remote
.
transport_params
.
max_ack_delay
,

4845 
conn
->
initial
 == 
NULL
 && conn->
handshake
 == NULL, 
on_loss_detected
)) != 0)

4846 return 
ret
;

4847 
	`update_loss_alarm
(
conn
, 0);

4850 
	}
}

4852 static int 
	$handle_max_stream_data_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4854 
quicly_max_stream_data_frame_t
 
frame
;

4855 
quicly_stream_t
 *
stream
;

4856 int 
ret
;

4858 if ((
ret
 = 
	`quicly_decode_max_stream_data_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

4859 return 
ret
;

4861 
	`QUICLY_PROBE
(
MAX_STREAM_DATA_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
stream_id
, frame.
max_stream_data
);

4863 if (!
	`quicly_stream_has_send_side
(
	`quicly_is_client
(
conn
), 
frame
.
stream_id
))

4864 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

4866 if ((
stream
 = 
	`quicly_get_stream
(
conn
, 
frame
.
stream_id
)) == 
NULL
)

4869 if (
frame
.
max_stream_data
 < 
stream
->
_send_aux
.max_stream_data)

4871 
stream
->
_send_aux
.
max_stream_data
 = 
frame
.max_stream_data;

4872 
stream
->
_send_aux
.
blocked
 = 
QUICLY_SENDER_STATE_NONE
;

4874 if (
stream
->
_send_aux
.
reset_stream
.
sender_state
 == 
QUICLY_SENDER_STATE_NONE
)

4875 
	`resched_stream_data
(
stream
);

4878 
	}
}

4880 static int 
	$handle_data_blocked_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4882 
quicly_data_blocked_frame_t
 
frame
;

4883 int 
ret
;

4885 if ((
ret
 = 
	`quicly_decode_data_blocked_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

4886 return 
ret
;

4888 
	`QUICLY_PROBE
(
DATA_BLOCKED_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
offset
);

4890 
	`quicly_maxsender_request_transmit
(&
conn
->
ingress
.
max_data
.
sender
);

4891 if (
	`should_send_max_data
(
conn
))

4892 
conn
->
egress
.
send_ack_at
 = 0;

4895 
	}
}

4897 static int 
	$handle_stream_data_blocked_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4899 
quicly_stream_data_blocked_frame_t
 
frame
;

4900 
quicly_stream_t
 *
stream
;

4901 int 
ret
;

4903 if ((
ret
 = 
	`quicly_decode_stream_data_blocked_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

4904 return 
ret
;

4906 
	`QUICLY_PROBE
(
STREAM_DATA_BLOCKED_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
stream_id
, frame.
offset
);

4908 if (!
	`quicly_stream_has_receive_side
(
	`quicly_is_client
(
conn
), 
frame
.
stream_id
))

4909 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

4911 if ((
stream
 = 
	`quicly_get_stream
(
conn
, 
frame
.
stream_id
)) != 
NULL
) {

4912 
	`quicly_maxsender_request_transmit
(&
stream
->
_send_aux
.
max_stream_data_sender
);

4913 if (
	`should_send_max_stream_data
(
stream
))

4914 
	`sched_stream_control
(
stream
);

4918 
	}
}

4920 static int 
	$handle_streams_blocked_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4922 
quicly_streams_blocked_frame_t
 
frame
;

4923 int 
uni
 = 
state
->
frame_type
 == 
QUICLY_FRAME_TYPE_STREAMS_BLOCKED_UNI
, 
ret
;

4925 if ((
ret
 = 
	`quicly_decode_streams_blocked_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

4926 return 
ret
;

4928 
	`QUICLY_PROBE
(
STREAMS_BLOCKED_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
count
, 
uni
);

4930 if (
	`should_send_max_streams
(
conn
, 
uni
)) {

4931 
quicly_maxsender_t
 *
maxsender
 = 
uni
 ? &
conn
->
ingress
.
max_streams
.uni : &conn->ingress.max_streams.
bidi
;

4932 
	`quicly_maxsender_request_transmit
(
maxsender
);

4933 
conn
->
egress
.
send_ack_at
 = 0;

4937 
	}
}

4939 static int 
	$handle_max_streams_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
, int 
uni
)

4941 
quicly_max_streams_frame_t
 
frame
;

4942 int 
ret
;

4944 if ((
ret
 = 
	`quicly_decode_max_streams_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

4945 return 
ret
;

4947 
	`QUICLY_PROBE
(
MAX_STREAMS_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
count
, 
uni
);

4949 if ((
ret
 = 
	`update_max_streams
(
uni
 ? &
conn
->
egress
.
max_streams
.uni : &conn->egress.max_streams.
bidi
, 
frame
.
count
)) != 0)

4950 return 
ret
;

4952 
	`open_blocked_streams
(
conn
, 
uni
);

4955 
	}
}

4957 static int 
	$handle_max_streams_bidi_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4959 return 
	`handle_max_streams_frame
(
conn
, 
state
, 0);

4960 
	}
}

4962 static int 
	$handle_max_streams_uni_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4964 return 
	`handle_max_streams_frame
(
conn
, 
state
, 1);

4965 
	}
}

4967 static int 
	$handle_path_challenge_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4969 
quicly_path_challenge_frame_t
 
frame
;

4970 int 
ret
;

4972 if ((
ret
 = 
	`quicly_decode_path_challenge_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

4973 return 
ret
;

4974 return 
	`schedule_path_challenge_frame
(
conn
, 1, 
frame
.
data
);

4975 
	}
}

4977 static int 
	$handle_path_response_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4979 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

4980 
	}
}

4982 static int 
	$handle_new_token_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4984 
quicly_new_token_frame_t
 
frame
;

4985 int 
ret
;

4987 if ((
ret
 = 
	`quicly_decode_new_token_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

4988 return 
ret
;

4989 
	`QUICLY_PROBE
(
NEW_TOKEN_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
token
.
base
, frame.token.
len
);

4990 if (
conn
->
super
.
ctx
->
save_resumption_token
 == 
NULL
)

4992 return 
conn
->
super
.
ctx
->
save_resumption_token
->
	`cb
(conn->super.ctx->save_resumption_token, conn, 
frame
.
token
);

4993 
	}
}

4995 static int 
	$handle_stop_sending_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

4997 
quicly_stop_sending_frame_t
 
frame
;

4998 
quicly_stream_t
 *
stream
;

4999 int 
ret
;

5001 if ((
ret
 = 
	`quicly_decode_stop_sending_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

5002 return 
ret
;

5004 if ((
ret
 = 
	`quicly_get_or_open_stream
(
conn
, 
frame
.
stream_id
, &
stream
)) != 0 || stream == 
NULL
)

5005 return 
ret
;

5007 if (
	`quicly_sendstate_is_open
(&
stream
->
sendstate
)) {

5009 int 
err
 = 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(
frame
.
app_error_code
);

5010 
	`quicly_reset_stream
(
stream
, 
err
);

5011 
	`QUICLY_PROBE
(
STREAM_ON_SEND_STOP
, 
stream
->
conn
, stream->conn->
stash
.
now
, stream, 
err
);

5012 
stream
->
callbacks
->
	`on_send_stop
(stream, 
err
);

5013 if (
stream
->
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
)

5014 return 
QUICLY_ERROR_IS_CLOSING
;

5018 
	}
}

5020 static int 
	$handle_max_data_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5022 
quicly_max_data_frame_t
 
frame
;

5023 int 
ret
;

5025 if ((
ret
 = 
	`quicly_decode_max_data_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

5026 return 
ret
;

5028 
	`QUICLY_PROBE
(
MAX_DATA_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
max_data
);

5030 if (
frame
.
max_data
 <= 
conn
->
egress
.max_data.
permitted
)

5032 
conn
->
egress
.
max_data
.
permitted
 = 
frame
.max_data;

5033 
conn
->
egress
.
data_blocked
 = 
QUICLY_SENDER_STATE_UNACKED
;

5036 
	}
}

5038 static int 
	$negotiate_using_version
(
quicly_conn_t
 *
conn
, 
uint32_t
 
version
)

5040 int 
ret
;

5043 
conn
->
super
.
version
 = version;

5044 
	`QUICLY_PROBE
(
VERSION_SWITCH
, 
conn
, conn->
stash
.
now
, 
version
);

5047 if ((
ret
 = 
	`reinstall_initial_encryption
(
conn
, 
PTLS_ERROR_LIBRARY
)) != 0)

5048 return 
ret
;

5051 if ((
ret
 = 
	`discard_sentmap_by_epoch
(
conn
, ~0u)) != 0)

5052 return 
ret
;

5055 
	}
}

5057 static int 
	$handle_version_negotiation_packet
(
quicly_conn_t
 *
conn
, 
quicly_decoded_packet_t
 *
packet
)

5059 const 
uint8_t
 *
src
 = 
packet
->
octets
.
base
 + packet->
encrypted_off
, *
end
 = packet->octets.base + packet->octets.
len
;

5060 
uint32_t
 
selected_version
 = 0;

5062 if (
src
 == 
end
 || (end - src) % 4 != 0)

5063 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

5066 while (
src
 != 
end
) {

5067 
uint32_t
 
supported_version
 = 
	`quicly_decode32
(&
src
);

5068 switch (
supported_version
) {

5069 case 
QUICLY_PROTOCOL_VERSION_CURRENT
:

5070 
selected_version
 = 
QUICLY_PROTOCOL_VERSION_CURRENT
;

5072 case 
QUICLY_PROTOCOL_VERSION_DRAFT27
:

5073 if (
selected_version
 == 0)

5074 
selected_version
 = 
QUICLY_PROTOCOL_VERSION_DRAFT27
;

5078 if (
selected_version
 == 0)

5079 return 
	`handle_close
(
conn
, 
QUICLY_ERROR_NO_COMPATIBLE_VERSION
, 
UINT64_MAX
, 
	`ptls_iovec_init
("", 0));

5081 return 
	`negotiate_using_version
(
conn
, 
selected_version
);

5082 
	}
}

5084 static int 
	$compare_socket_address
(struct 
sockaddr
 *
x
, struct sockaddr *
y
)

5086 #define 
	#CMP
(
a
, 
b
) \

5087 if (
a
 != 
b
) \

5088 return 
a
 < 
b
 ? -1 : 1

	)

5090 
	`CMP
(
x
->
sa_family
, 
y
->sa_family);

5092 if (
x
->
sa_family
 == 
AF_INET
) {

5093 struct 
sockaddr_in
 *
xin
 = (void *)
x
, *
yin
 = (void *)
y
;

5094 
	`CMP
(
	`ntohl
(
xin
->
sin_addr
.
s_addr
), ntohl(
yin
->sin_addr.s_addr));

5095 
	`CMP
(
	`ntohs
(
xin
->
sin_port
), ntohs(
yin
->sin_port));

5096 } else if (
x
->
sa_family
 == 
AF_INET6
) {

5097 struct 
sockaddr_in6
 *
xin6
 = (void *)
x
, *
yin6
 = (void *)
y
;

5098 int 
r
 = 
	`memcmp
(
xin6
->
sin6_addr
.
s6_addr
, 
yin6
->sin6_addr.s6_addr, sizeof(xin6->sin6_addr.s6_addr));

5099 if (
r
 != 0)

5100 return 
r
;

5101 
	`CMP
(
	`ntohs
(
xin6
->
sin6_port
), ntohs(
yin6
->sin6_port));

5102 
	`CMP
(
xin6
->
sin6_flowinfo
, 
yin6
->sin6_flowinfo);

5103 
	`CMP
(
xin6
->
sin6_scope_id
, 
yin6
->sin6_scope_id);

5104 } else if (
x
->
sa_family
 == 
AF_UNSPEC
) {

5107 
	`assert
(!"unknown sa_family");

5110 #undef 
CMP


5112 
	}
}

5114 static int 
	$is_stateless_reset
(
quicly_conn_t
 *
conn
, 
quicly_decoded_packet_t
 *
decoded
)

5116 switch (
decoded
->
_is_stateless_reset_cached
) {

5117 case 
QUICLY__DECODED_PACKET_CACHED_IS_STATELESS_RESET
:

5119 case 
QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET
:

5125 if (!
conn
->
super
.
remote
.
cid_set
.
cids
[0].
is_active
)

5127 if (
decoded
->
octets
.
len
 < 
QUICLY_STATELESS_RESET_PACKET_MIN_LEN
)

5129 if (
	`memcmp
(
decoded
->
octets
.
base
 + decoded->octets.
len
 - 
QUICLY_STATELESS_RESET_TOKEN_LEN
,

5130 
conn
->
super
.
remote
.
cid_set
.
cids
[0].
stateless_reset_token
, 
QUICLY_STATELESS_RESET_TOKEN_LEN
) != 0)

5134 
	}
}

5136 int 
	$quicly_is_destination
(
quicly_conn_t
 *
conn
, struct 
sockaddr
 *
dest_addr
, struct sockaddr *
src_addr
,

5137 
quicly_decoded_packet_t
 *
decoded
)

5139 if (
	`QUICLY_PACKET_IS_LONG_HEADER
(
decoded
->
octets
.
base
[0])) {

5141 if (
	`compare_socket_address
(&
conn
->
super
.
remote
.
address
.
sa
, 
src_addr
) != 0)

5143 if (
conn
->
super
.
local
.
address
.
sa
.
sa_family
 != 
AF_UNSPEC
 &&

5144 
	`compare_socket_address
(&
conn
->
super
.
local
.
address
.
sa
, 
dest_addr
) != 0)

5147 if (!
	`quicly_is_client
(
conn
) && 
decoded
->
cid
.
dest
.
might_be_client_generated
) {

5148 const 
quicly_cid_t
 *
odcid
 = 
	`is_retry
(
conn
) ? &conn->
retry_scid
 : &conn->
super
.
original_dcid
;

5149 if (
	`quicly_cid_is_equal
(
odcid
, 
decoded
->
cid
.
dest
.
encrypted
))

5150 goto 
Found
;

5154 if (
conn
->
super
.
ctx
->
cid_encryptor
 != 
NULL
) {

5160 if (
conn
->
super
.
local
.
cid_set
.
plaintext
.
master_id
 == 
decoded
->
cid
.
dest
.plaintext.master_id &&

5161 
conn
->
super
.
local
.
cid_set
.
plaintext
.
thread_id
 == 
decoded
->
cid
.
dest
.plaintext.thread_id &&

5162 
conn
->
super
.
local
.
cid_set
.
plaintext
.
node_id
 == 
decoded
->
cid
.
dest
.plaintext.node_id)

5163 goto 
Found
;

5164 if (
	`is_stateless_reset
(
conn
, 
decoded
))

5165 goto 
Found_StatelessReset
;

5167 if (
	`compare_socket_address
(&
conn
->
super
.
remote
.
address
.
sa
, 
src_addr
) == 0)

5168 goto 
Found
;

5169 if (
conn
->
super
.
local
.
address
.
sa
.
sa_family
 != 
AF_UNSPEC
 &&

5170 
	`compare_socket_address
(&
conn
->
super
.
local
.
address
.
sa
, 
dest_addr
) != 0)

5177 
Found
:

5178 
decoded
->
_is_stateless_reset_cached
 = 
QUICLY__DECODED_PACKET_CACHED_NOT_STATELESS_RESET
;

5181 
Found_StatelessReset
:

5182 
decoded
->
_is_stateless_reset_cached
 = 
QUICLY__DECODED_PACKET_CACHED_IS_STATELESS_RESET
;

5184 
	}
}

5186 int 
	$handle_close
(
quicly_conn_t
 *
conn
, int 
err
, 
uint64_t
 
frame_type
, 
ptls_iovec_t
 
reason_phrase
)

5188 int 
ret
;

5190 if (
conn
->
super
.
state
 >= 
QUICLY_STATE_CLOSING
)

5194 if ((
ret
 = 
	`enter_close
(
conn
, 0,

5195 !(
err
 == 
QUICLY_ERROR_RECEIVED_STATELESS_RESET
 || err == 
QUICLY_ERROR_NO_COMPATIBLE_VERSION
))) != 0)

5196 return 
ret
;

5197 if (
conn
->
super
.
ctx
->
closed_by_remote
 != 
NULL
)

5198 
conn
->
super
.
ctx
->
closed_by_remote
->
	`cb
(conn->super.ctx->closed_by_remote, conn, 
err
, 
frame_type
,

5199 (const char *)
reason_phrase
.
base
, reason_phrase.
len
);

5200 
	`destroy_all_streams
(
conn
, 
err
, 0);

5203 
	}
}

5205 static int 
	$handle_transport_close_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5207 
quicly_transport_close_frame_t
 
frame
;

5208 int 
ret
;

5210 if ((
ret
 = 
	`quicly_decode_transport_close_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

5211 return 
ret
;

5213 
	`QUICLY_PROBE
(
TRANSPORT_CLOSE_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
error_code
, frame.
frame_type
,

5214 
	`QUICLY_PROBE_ESCAPE_UNSAFE_STRING
(
frame
.
reason_phrase
.
base
, frame.reason_phrase.
len
));

5215 return 
	`handle_close
(
conn
, 
	`QUICLY_ERROR_FROM_TRANSPORT_ERROR_CODE
(
frame
.
error_code
), frame.
frame_type
, frame.
reason_phrase
);

5216 
	}
}

5218 static int 
	$handle_application_close_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5220 
quicly_application_close_frame_t
 
frame
;

5221 int 
ret
;

5223 if ((
ret
 = 
	`quicly_decode_application_close_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

5224 return 
ret
;

5226 
	`QUICLY_PROBE
(
APPLICATION_CLOSE_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
error_code
,

5227 
	`QUICLY_PROBE_ESCAPE_UNSAFE_STRING
(
frame
.
reason_phrase
.
base
, frame.reason_phrase.
len
));

5228 return 
	`handle_close
(
conn
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(
frame
.
error_code
), 
UINT64_MAX
, frame.
reason_phrase
);

5229 
	}
}

5231 static int 
	$handle_padding_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5234 
	}
}

5236 static int 
	$handle_ping_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5238 
	`QUICLY_PROBE
(
PING_RECEIVE
, 
conn
, conn->
stash
.
now
);

5241 
	}
}

5243 static int 
	$handle_new_connection_id_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5245 int 
ret
;

5246 
quicly_new_connection_id_frame_t
 
frame
;

5250 if ((
ret
 = 
	`quicly_decode_new_connection_id_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

5251 return 
ret
;

5253 
	`QUICLY_PROBE
(
NEW_CONNECTION_ID_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
sequence
, frame.
retire_prior_to
,

5254 
	`QUICLY_PROBE_HEXDUMP
(
frame
.
cid
.
base
, frame.cid.
len
),

5255 
	`QUICLY_PROBE_HEXDUMP
(
frame
.
stateless_reset_token
, 
QUICLY_STATELESS_RESET_TOKEN_LEN
));

5257 if (
frame
.
sequence
 < 
conn
->
super
.
remote
.
largest_retire_prior_to
) {

5263 
	`schedule_retire_connection_id_frame
(
conn
, 
frame
.
sequence
);

5268 
uint64_t
 
unregistered_seqs
[
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
];

5269 
size_t
 
num_unregistered_seqs
;

5270 if ((
ret
 = 
	`quicly_remote_cid_register
(&
conn
->
super
.
remote
.
cid_set
, 
frame
.
sequence
, frame.
cid
.
base
, frame.cid.
len
,

5271 
frame
.
stateless_reset_token
, frame.
retire_prior_to
, 
unregistered_seqs
,

5272 &
num_unregistered_seqs
)) != 0)

5273 return 
ret
;

5275 for (
size_t
 
i
 = 0; i < 
num_unregistered_seqs
; i++)

5276 
	`schedule_retire_connection_id_frame
(
conn
, 
unregistered_seqs
[
i
]);

5278 if (
frame
.
retire_prior_to
 > 
conn
->
super
.
remote
.
largest_retire_prior_to
)

5279 
conn
->
super
.
remote
.
largest_retire_prior_to
 = 
frame
.
retire_prior_to
;

5282 
	}
}

5284 static int 
	$handle_retire_connection_id_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5286 int 
ret
, 
has_pending
;

5287 
quicly_retire_connection_id_frame_t
 
frame
;

5289 if ((
ret
 = 
	`quicly_decode_retire_connection_id_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

5290 return 
ret
;

5292 
	`QUICLY_PROBE
(
RETIRE_CONNECTION_ID_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
sequence
);

5294 if (
frame
.
sequence
 >= 
conn
->
super
.
local
.
cid_set
.
plaintext
.
path_id
) {

5297 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

5300 if ((
ret
 = 
	`quicly_local_cid_retire
(&
conn
->
super
.
local
.
cid_set
, 
frame
.
sequence
, &
has_pending
)) != 0)

5301 return 
ret
;

5302 if (
has_pending
)

5303 
conn
->
egress
.
pending_flows
 |= 
QUICLY_PENDING_FLOW_CID_FRAME_BIT
;

5306 
	}
}

5308 static int 
	$handle_handshake_done_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5310 int 
ret
;

5312 
	`QUICLY_PROBE
(
HANDSHAKE_DONE_RECEIVE
, 
conn
, conn->
stash
.
now
);

5314 if (!
	`quicly_is_client
(
conn
))

5315 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

5317 
	`assert
(
conn
->
initial
 == 
NULL
);

5318 if (
conn
->
handshake
 == 
NULL
)

5321 
conn
->
super
.
remote
.
address_validation
.
send_probe
 = 0;

5322 if ((
ret
 = 
	`discard_handshake_context
(
conn
, 
QUICLY_EPOCH_HANDSHAKE
)) != 0)

5323 return 
ret
;

5324 
	`update_loss_alarm
(
conn
, 0);

5326 
	}
}

5328 static int 
	$handle_datagram_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5330 
quicly_datagram_frame_t
 
frame
;

5331 int 
ret
;

5334 if (
conn
->
super
.
ctx
->
transport_params
.
max_datagram_frame_size
 == 0)

5335 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

5338 if ((
ret
 = 
	`quicly_decode_datagram_frame
(
state
->
frame_type
, &state->
src
, state->
end
, &
frame
)) != 0)

5339 return 
ret
;

5340 
	`QUICLY_PROBE
(
DATAGRAM_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
payload
.
base
, frame.payload.
len
);

5343 
conn
->
super
.
ctx
->
receive_datagram_frame
->
	`cb
(conn->super.ctx->receive_datagram_frame, conn, 
frame
.
payload
);

5346 
	}
}

5348 static int 
	$handle_ack_frequency_frame
(
quicly_conn_t
 *
conn
, struct 
st_quicly_handle_payload_state_t
 *
state
)

5350 
quicly_ack_frequency_frame_t
 
frame
;

5351 int 
ret
;

5354 if (!
	`recognize_delayed_ack
(
conn
))

5355 return 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

5357 if ((
ret
 = 
	`quicly_decode_ack_frequency_frame
(&
state
->
src
, state->
end
, &
frame
)) != 0)

5358 return 
ret
;

5360 
	`QUICLY_PROBE
(
ACK_FREQUENCY_RECEIVE
, 
conn
, conn->
stash
.
now
, 
frame
.
sequence
, frame.
packet_tolerance
, frame.
max_ack_delay
,

5361 
frame
.
ignore_order
);

5365 if (
frame
.
max_ack_delay
 != 
QUICLY_LOCAL_MAX_ACK_DELAY
 * 1000)

5366 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

5368 if (
frame
.
sequence
 >= 
conn
->
ingress
.
ack_frequency
.
next_sequence
) {

5369 
conn
->
ingress
.
ack_frequency
.
next_sequence
 = 
frame
.
sequence
 + 1;

5370 
conn
->
application
->
super
.
packet_tolerance
 =

5371 (
uint32_t
)(
frame
.
packet_tolerance
 < 
QUICLY_MAX_PACKET_TOLERANCE
 ? frame.packet_tolerance : QUICLY_MAX_PACKET_TOLERANCE);

5372 
conn
->
application
->
super
.
ignore_order
 = 
frame
.ignore_order;

5376 
	}
}

5378 static int 
	$handle_payload
(
quicly_conn_t
 *
conn
, 
size_t
 
epoch
, const 
uint8_t
 *
_src
, size_t 
_len
, 
uint64_t
 *
offending_frame_type
,

5379 int *
is_ack_only
)

5384 static const struct 
	sst_quicly_frame_handler_t
 {

5385 int (*
cb
)(
quicly_conn_t
 *, struct 
st_quicly_handle_payload_state_t
 *);

5386 
uint8_t
 
permitted_epochs
;

5387 
uint8_t
 
ack_eliciting
;

5388 
size_t
 
counter_offset
;

5389 } 
frame_handlers
[] = {

5390 #define 
	#FRAME
(
n
, 
i
, 
z
, 
h
, 
o
, 
ae
) \

5392 
handle_
##
n
##
_frame
, \

5393 (
i
 << 
QUICLY_EPOCH_INITIAL
) | (
z
 << 
QUICLY_EPOCH_0RTT
) | (
h
 << 
QUICLY_EPOCH_HANDSHAKE
) | (
o
 << 
QUICLY_EPOCH_1RTT
), \

5394 
ae
, \

5395 
	`offsetof
(
quicly_conn_t
, 
super
.
stats
.
num_frames_received
.
n
) \

5396 }

	)

5402 
	`FRAME
( 
padding
 , 1 , 1 , 1 , 1 , 0 ),

5403 
	`FRAME
( 
ping
 , 1 , 1 , 1 , 1 , 1 ),

5404 
	`FRAME
( 
ack
 , 1 , 0 , 1 , 1 , 0 ),

5405 
	`FRAME
( 
ack
 , 1 , 0 , 1 , 1 , 0 ),

5406 
	`FRAME
( 
reset_stream
 , 0 , 1 , 0 , 1 , 1 ),

5407 
	`FRAME
( 
stop_sending
 , 0 , 1 , 0 , 1 , 1 ),

5408 
	`FRAME
( 
crypto
 , 1 , 0 , 1 , 1 , 1 ),

5409 
	`FRAME
( 
new_token
 , 0 , 0 , 0 , 1 , 1 ),

5410 
	`FRAME
( 
stream
 , 0 , 1 , 0 , 1 , 1 ),

5411 
	`FRAME
( 
stream
 , 0 , 1 , 0 , 1 , 1 ),

5412 
	`FRAME
( 
stream
 , 0 , 1 , 0 , 1 , 1 ),

5413 
	`FRAME
( 
stream
 , 0 , 1 , 0 , 1 , 1 ),

5414 
	`FRAME
( 
stream
 , 0 , 1 , 0 , 1 , 1 ),

5415 
	`FRAME
( 
stream
 , 0 , 1 , 0 , 1 , 1 ),

5416 
	`FRAME
( 
stream
 , 0 , 1 , 0 , 1 , 1 ),

5417 
	`FRAME
( 
stream
 , 0 , 1 , 0 , 1 , 1 ),

5418 
	`FRAME
( 
max_data
 , 0 , 1 , 0 , 1 , 1 ),

5419 
	`FRAME
( 
max_stream_data
 , 0 , 1 , 0 , 1 , 1 ),

5420 
	`FRAME
( 
max_streams_bidi
 , 0 , 1 , 0 , 1 , 1 ),

5421 
	`FRAME
( 
max_streams_uni
 , 0 , 1 , 0 , 1 , 1 ),

5422 
	`FRAME
( 
data_blocked
 , 0 , 1 , 0 , 1 , 1 ),

5423 
	`FRAME
( 
stream_data_blocked
 , 0 , 1 , 0 , 1 , 1 ),

5424 
	`FRAME
( 
streams_blocked
 , 0 , 1 , 0 , 1 , 1 ),

5425 
	`FRAME
( 
streams_blocked
 , 0 , 1 , 0 , 1 , 1 ),

5426 
	`FRAME
( 
new_connection_id
 , 0 , 1 , 0 , 1 , 1 ),

5427 
	`FRAME
( 
retire_connection_id
 , 0 , 0 , 0 , 1 , 1 ),

5428 
	`FRAME
( 
path_challenge
 , 0 , 1 , 0 , 1 , 1 ),

5429 
	`FRAME
( 
path_response
 , 0 , 0 , 0 , 1 , 1 ),

5430 
	`FRAME
( 
transport_close
 , 1 , 1 , 1 , 1 , 0 ),

5431 
	`FRAME
( 
application_close
 , 0 , 1 , 0 , 1 , 0 ),

5432 
	`FRAME
( 
handshake_done
 , 0, 0 , 0 , 1 , 1 ),

5434 #undef 
FRAME


5437 
uint64_t
 
type
;

5438 struct 
st_quicly_frame_handler_t
 
_
;

5439 } 
ex_frame_handlers
[] = {

5440 #define 
	#FRAME
(
uc
, 
lc
, 
i
, 
z
, 
h
, 
o
, 
ae
) \

5442 
QUICLY_FRAME_TYPE_
##
uc
, \

5444 
handle_
##
lc
##
_frame
, \

5445 (
i
 << 
QUICLY_EPOCH_INITIAL
) | (
z
 << 
QUICLY_EPOCH_0RTT
) | (
h
 << 
QUICLY_EPOCH_HANDSHAKE
) | (
o
 << 
QUICLY_EPOCH_1RTT
), \

5446 
ae
, \

5447 
	`offsetof
(
quicly_conn_t
, 
super
.
stats
.
num_frames_received
.
lc
) \

5449 }

	)

5455 
	`FRAME
( 
DATAGRAM_NOLEN
 , 
datagram
 , 0 , 1, 0, 1 , 1 ),

5456 
	`FRAME
( 
DATAGRAM_WITHLEN
 , 
datagram
 , 0 , 1, 0, 1 , 1 ),

5457 
	`FRAME
( 
ACK_FREQUENCY
 , 
ack_frequency
 , 0 , 0 , 0 , 1 , 1 ),

5459 #undef 
FRAME


5460 {
UINT64_MAX
},

5464 struct 
st_quicly_handle_payload_state_t
 
state
 = {
_src
, _src + 
_len
, 
epoch
};

5465 
size_t
 
num_frames_ack_eliciting
 = 0;

5466 int 
ret
;

5470 const struct 
st_quicly_frame_handler_t
 *
frame_handler
;

5471 
state
.
frame_type
 = *state.
src
++;

5472 if (
state
.
frame_type
 < 
	`PTLS_ELEMENTSOF
(
frame_handlers
)) {

5473 
frame_handler
 = 
frame_handlers
 + 
state
.
frame_type
;

5476 --
state
.
src
;

5477 if ((
state
.
frame_type
 = 
	`quicly_decodev
(&state.
src
, state.
end
)) == 
UINT64_MAX
) {

5478 
state
.
frame_type
 =

5479 
QUICLY_FRAME_TYPE_PADDING
;

5480 
ret
 = 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

5483 
size_t
 
i
;

5484 for (
i
 = 0; 
ex_frame_handlers
[i].
type
 < 
state
.
frame_type
; ++i)

5486 if (
ex_frame_handlers
[
i
].
type
 != 
state
.
frame_type
) {

5487 
ret
 = 
QUICLY_TRANSPORT_ERROR_FRAME_ENCODING
;

5490 
frame_handler
 = &
ex_frame_handlers
[
i
].
_
;

5493 if ((
frame_handler
->
permitted_epochs
 & (1 << 
epoch
)) == 0) {

5494 
ret
 = 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

5497 ++*(
uint64_t
 *)((
uint8_t
 *)
conn
 + 
frame_handler
->
counter_offset
);

5498 
num_frames_ack_eliciting
 += 
frame_handler
->
ack_eliciting
;

5499 if ((
ret
 = 
frame_handler
->
	`cb
(
conn
, &
state
)) != 0)

5501 } while (
state
.
src
 != state.
end
);

5503 *
is_ack_only
 = 
num_frames_ack_eliciting
 == 0;

5504 if (
ret
 != 0)

5505 *
offending_frame_type
 = 
state
.
frame_type
;

5506 return 
ret
;

5507 
	}
}

5509 static int 
	$handle_stateless_reset
(
quicly_conn_t
 *
conn
)

5511 
	`QUICLY_PROBE
(
STATELESS_RESET_RECEIVE
, 
conn
, conn->
stash
.
now
);

5512 return 
	`handle_close
(
conn
, 
QUICLY_ERROR_RECEIVED_STATELESS_RESET
, 
UINT64_MAX
, 
	`ptls_iovec_init
("", 0));

5513 
	}
}

5515 static int 
	$validate_retry_tag
(
quicly_decoded_packet_t
 *
packet
, 
quicly_cid_t
 *
odcid
, 
ptls_aead_context_t
 *
retry_aead
)

5517 
size_t
 
pseudo_packet_len
 = 1 + 
odcid
->
len
 + 
packet
->
encrypted_off
;

5518 
uint8_t
 
pseudo_packet
[
pseudo_packet_len
];

5519 
pseudo_packet
[0] = 
odcid
->
len
;

5520 
	`memcpy
(
pseudo_packet
 + 1, 
odcid
->
cid
, odcid->
len
);

5521 
	`memcpy
(
pseudo_packet
 + 1 + 
odcid
->
len
, 
packet
->
octets
.
base
, packet->
encrypted_off
);

5522 return 
	`ptls_aead_decrypt
(
retry_aead
, 
packet
->
octets
.
base
 + packet->
encrypted_off
, packet->octets.base + packet->encrypted_off,

5523 
PTLS_AESGCM_TAG_SIZE
, 0, 
pseudo_packet
, 
pseudo_packet_len
) == 0;

5524 
	}
}

5526 int 
	$quicly_accept
(
quicly_conn_t
 **
conn
, 
quicly_context_t
 *
ctx
, struct 
sockaddr
 *
dest_addr
, struct sockaddr *
src_addr
,

5527 
quicly_decoded_packet_t
 *
packet
, 
quicly_address_token_plaintext_t
 *
address_token
,

5528 const 
quicly_cid_plaintext_t
 *
new_cid
, 
ptls_handshake_properties_t
 *
handshake_properties
)

5530 const struct 
st_ptls_salt_t
 *
salt
;

5532 struct 
st_quicly_cipher_context_t
 
ingress
, 
egress
;

5533 int 
alive
;

5534 } 
cipher
 = {};

5535 
ptls_iovec_t
 
payload
;

5536 
uint64_t
 
next_expected_pn
, 
pn
, 
offending_frame_type
 = 
QUICLY_FRAME_TYPE_PADDING
;

5537 int 
is_ack_only
, 
ret
;

5539 *
conn
 = 
NULL
;

5542 if ((
packet
->
octets
.
base
[0] & 
QUICLY_PACKET_TYPE_BITMASK
) != 
QUICLY_PACKET_TYPE_INITIAL
) {

5543 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5544 goto 
Exit
;

5546 if ((
salt
 = 
	`get_salt
(
packet
->
version
)) == 
NULL
) {

5547 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5548 goto 
Exit
;

5550 if (
packet
->
datagram_size
 < 
QUICLY_MIN_CLIENT_INITIAL_SIZE
) {

5551 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5552 goto 
Exit
;

5554 if (
packet
->
cid
.
dest
.
encrypted
.
len
 < 8) {

5555 
ret
 = 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

5556 goto 
Exit
;

5558 if ((
ret
 = 
	`setup_initial_encryption
(
	`get_aes128gcmsha256
(
ctx
), &
cipher
.
ingress
, &cipher.
egress
, 
packet
->
cid
.
dest
.
encrypted
, 0,

5559 
	`ptls_iovec_init
(
salt
->
initial
, sizeof(salt->initial)), 
NULL
)) != 0)

5560 goto 
Exit
;

5561 
cipher
.
alive
 = 1;

5562 
next_expected_pn
 = 0;

5563 if ((
ret
 = 
	`decrypt_packet
(
cipher
.
ingress
.
header_protection
, 
aead_decrypt_fixed_key
, cipher.ingress.
aead
, &
next_expected_pn
,

5564 
packet
, &
pn
, &
payload
)) != 0) {

5565 
ret
 = 
QUICLY_ERROR_DECRYPTION_FAILED
;

5566 goto 
Exit
;

5570 if ((*
conn
 = 
	`create_connection
(

5571 
ctx
, 
packet
->
version
, 
NULL
, 
src_addr
, 
dest_addr
, &packet->
cid
.
src
, 
new_cid
, 
handshake_properties
,

5572 
	`quicly_cc_calc_initial_cwnd
(
ctx
->
initcwnd_packets
, ctx->
transport_params
.
max_udp_payload_size
))) == 
NULL
) {

5573 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

5574 goto 
Exit
;

5576 (*
conn
)->
super
.
state
 = 
QUICLY_STATE_ACCEPTING
;

5577 
	`quicly_set_cid
(&(*
conn
)->
super
.
original_dcid
, 
packet
->
cid
.
dest
.
encrypted
);

5578 if (
address_token
 != 
NULL
) {

5579 (*
conn
)->
super
.
remote
.
address_validation
.
validated
 = 1;

5580 if (
address_token
->
type
 == 
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
) {

5581 (*
conn
)->
retry_scid
 = (*conn)->
super
.
original_dcid
;

5582 (*
conn
)->
super
.
original_dcid
 = 
address_token
->
retry
.original_dcid;

5585 if ((
ret
 = 
	`setup_handshake_space_and_flow
(*
conn
, 
QUICLY_EPOCH_INITIAL
)) != 0)

5586 goto 
Exit
;

5587 (*
conn
)->
initial
->
super
.
next_expected_packet_number
 = 
next_expected_pn
;

5588 (*
conn
)->
initial
->
cipher
.
ingress
 = cipher.ingress;

5589 (*
conn
)->
initial
->
cipher
.
egress
 = cipher.egress;

5590 
cipher
.
alive
 = 0;

5591 (*
conn
)->
crypto
.
handshake_properties
.
collected_extensions
 = 
server_collected_extensions
;

5592 (*
conn
)->
initial
->
largest_ingress_udp_payload_size
 = 
packet
->
datagram_size
;

5594 
	`QUICLY_PROBE
(
ACCEPT
, *
conn
, (*conn)->
stash
.
now
,

5595 
	`QUICLY_PROBE_HEXDUMP
(
packet
->
cid
.
dest
.
encrypted
.
base
, packet->cid.dest.encrypted.
len
), 
address_token
);

5596 
	`QUICLY_PROBE
(
PACKET_RECEIVED
, *
conn
, (*conn)->
stash
.
now
, 
pn
, 
payload
.
base
, payload.
len
, 
	`get_epoch
(
packet
->
octets
.base[0]));

5599 (*
conn
)->
super
.
stats
.
num_packets
.
received
 += 1;

5600 (*
conn
)->
super
.
stats
.
num_bytes
.
received
 += 
packet
->
datagram_size
;

5601 if ((
ret
 = 
	`handle_payload
(*
conn
, 
QUICLY_EPOCH_INITIAL
, 
payload
.
base
, payload.
len
, &
offending_frame_type
, &
is_ack_only
)) != 0)

5602 goto 
Exit
;

5603 if ((
ret
 = 
	`record_receipt
(&(*
conn
)->
initial
->
super
, 
pn
, 0, (*conn)->
stash
.
now
, &(*conn)->
egress
.
send_ack_at
)) != 0)

5604 goto 
Exit
;

5606 
Exit
:

5607 if (*
conn
 != 
NULL
) {

5608 if (
ret
 == 0) {

5609 (*
conn
)->
super
.
state
 = 
QUICLY_STATE_CONNECTED
;

5611 
	`initiate_close
(*
conn
, 
ret
, 
offending_frame_type
, "");

5612 
ret
 = 0;

5614 
	`unlock_now
(*
conn
);

5616 if (
cipher
.
alive
) {

5617 
	`dispose_cipher
(&
cipher
.
ingress
);

5618 
	`dispose_cipher
(&
cipher
.
egress
);

5620 return 
ret
;

5621 
	}
}

5623 int 
	$quicly_receive
(
quicly_conn_t
 *
conn
, struct 
sockaddr
 *
dest_addr
, struct sockaddr *
src_addr
, 
quicly_decoded_packet_t
 *
packet
)

5625 
ptls_cipher_context_t
 *
header_protection
;

5627 int (*
cb
)(void *, 
uint64_t
, 
quicly_decoded_packet_t
 *, 
size_t
, size_t *);

5628 void *
ctx
;

5629 } 
aead
;

5630 struct 
st_quicly_pn_space_t
 **
space
;

5631 
size_t
 
epoch
;

5632 
ptls_iovec_t
 
payload
;

5633 
uint64_t
 
pn
, 
offending_frame_type
 = 
QUICLY_FRAME_TYPE_PADDING
;

5634 int 
is_ack_only
, 
ret
;

5636 
	`assert
(
src_addr
->
sa_family
 == 
AF_INET
 || src_addr->sa_family == 
AF_INET6
);

5638 
	`lock_now
(
conn
, 0);

5640 
	`QUICLY_PROBE
(
RECEIVE
, 
conn
, conn->
stash
.
now
,

5641 
	`QUICLY_PROBE_HEXDUMP
(
packet
->
cid
.
dest
.
encrypted
.
base
, packet->cid.dest.encrypted.
len
), packet->
octets
.base,

5642 
packet
->
octets
.
len
);

5644 if (
	`is_stateless_reset
(
conn
, 
packet
)) {

5645 
ret
 = 
	`handle_stateless_reset
(
conn
);

5646 goto 
Exit
;

5652 
conn
->
super
.
stats
.
num_bytes
.
received
 += 
packet
->
datagram_size
;

5654 switch (
conn
->
super
.
state
) {

5655 case 
QUICLY_STATE_CLOSING
:

5656 ++
conn
->
egress
.
connection_close
.
num_packets_received
;

5658 if (
	`__builtin_popcountl
(
conn
->
egress
.
connection_close
.
num_packets_received
) == 1)

5659 
conn
->
egress
.
send_ack_at
 = 0;

5660 
ret
 = 0;

5661 goto 
Exit
;

5662 case 
QUICLY_STATE_DRAINING
:

5663 
ret
 = 0;

5664 goto 
Exit
;

5669 if (
	`QUICLY_PACKET_IS_LONG_HEADER
(
packet
->
octets
.
base
[0])) {

5670 if (
conn
->
super
.
state
 == 
QUICLY_STATE_FIRSTFLIGHT
) {

5671 if (
packet
->
version
 == 0) {

5672 
ret
 = 
	`handle_version_negotiation_packet
(
conn
, 
packet
);

5673 goto 
Exit
;

5676 if (
packet
->
version
 != 
conn
->
super
.version) {

5677 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5678 goto 
Exit
;

5680 switch (
packet
->
octets
.
base
[0] & 
QUICLY_PACKET_TYPE_BITMASK
) {

5681 case 
QUICLY_PACKET_TYPE_RETRY
: {

5682 
	`assert
(
packet
->
encrypted_off
 + 
PTLS_AESGCM_TAG_SIZE
 == packet->
octets
.
len
);

5684 if (!
	`quicly_is_client
(
conn
)) {

5685 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5686 goto 
Exit
;

5689 if (
	`quicly_cid_is_equal
(&
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
, 
packet
->cid.
src
)) {

5690 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5691 goto 
Exit
;

5694 if (
	`is_retry
(
conn
)) {

5695 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5696 goto 
Exit
;

5698 
ptls_aead_context_t
 *
retry_aead
 = 
	`create_retry_aead
(
conn
->
super
.
ctx
, conn->super.
version
, 0);

5699 int 
retry_ok
 = 
	`validate_retry_tag
(
packet
, &
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
, 
retry_aead
);

5700 
	`ptls_aead_free
(
retry_aead
);

5701 if (!
retry_ok
) {

5702 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5703 goto 
Exit
;

5706 if (
packet
->
token
.
len
 > 
QUICLY_MAX_TOKEN_LEN
) {

5707 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5708 goto 
Exit
;

5711 
	`free
(
conn
->
token
.
base
);

5712 if ((
conn
->
token
.
base
 = 
	`malloc
(
packet
->token.
len
)) == 
NULL
) {

5713 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

5714 goto 
Exit
;

5716 
	`memcpy
(
conn
->
token
.
base
, 
packet
->token.base, packet->token.
len
);

5717 
conn
->
token
.
len
 = 
packet
->token.len;

5719 
	`quicly_set_cid
(&
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
, 
packet
->cid.
src
);

5720 
conn
->
retry_scid
 = conn->
super
.
remote
.
cid_set
.
cids
[0].
cid
;

5722 if ((
ret
 = 
	`reinstall_initial_encryption
(
conn
, 
QUICLY_ERROR_PACKET_IGNORED
)) != 0)

5723 goto 
Exit
;

5725 
ret
 = 
	`discard_sentmap_by_epoch
(
conn
, ~0u);

5726 goto 
Exit
;

5728 case 
QUICLY_PACKET_TYPE_INITIAL
:

5729 if (
conn
->
initial
 == 
NULL
 || (
header_protection
 = conn->initial->
cipher
.
ingress
.header_protection) == NULL) {

5730 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5731 goto 
Exit
;

5733 if (
	`quicly_is_client
(
conn
)) {

5735 if (
conn
->
super
.
state
 == 
QUICLY_STATE_FIRSTFLIGHT
)

5736 
	`quicly_set_cid
(&
conn
->
super
.
remote
.
cid_set
.
cids
[0].
cid
, 
packet
->cid.
src
);

5739 if (
packet
->
datagram_size
 < 
QUICLY_MIN_CLIENT_INITIAL_SIZE
) {

5740 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5741 goto 
Exit
;

5744 
aead
.
cb
 = 
aead_decrypt_fixed_key
;

5745 
aead
.
ctx
 = 
conn
->
initial
->
cipher
.
ingress
.aead;

5746 
space
 = (void *)&
conn
->
initial
;

5747 
epoch
 = 
QUICLY_EPOCH_INITIAL
;

5749 case 
QUICLY_PACKET_TYPE_HANDSHAKE
:

5750 if (
conn
->
handshake
 == 
NULL
 || (
header_protection
 = conn->handshake->
cipher
.
ingress
.header_protection) == NULL) {

5751 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5752 goto 
Exit
;

5754 
aead
.
cb
 = 
aead_decrypt_fixed_key
;

5755 
aead
.
ctx
 = 
conn
->
handshake
->
cipher
.
ingress
.aead;

5756 
space
 = (void *)&
conn
->
handshake
;

5757 
epoch
 = 
QUICLY_EPOCH_HANDSHAKE
;

5759 case 
QUICLY_PACKET_TYPE_0RTT
:

5760 if (
	`quicly_is_client
(
conn
)) {

5761 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5762 goto 
Exit
;

5764 if (
conn
->
application
 == 
NULL
 ||

5765 (
header_protection
 = 
conn
->
application
->
cipher
.
ingress
.header_protection.
zero_rtt
) == 
NULL
) {

5766 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5767 goto 
Exit
;

5769 
aead
.
cb
 = 
aead_decrypt_fixed_key
;

5770 
aead
.
ctx
 = 
conn
->
application
->
cipher
.
ingress
.aead[1];

5771 
space
 = (void *)&
conn
->
application
;

5772 
epoch
 = 
QUICLY_EPOCH_0RTT
;

5775 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5776 goto 
Exit
;

5780 if (
conn
->
application
 == 
NULL
 ||

5781 (
header_protection
 = 
conn
->
application
->
cipher
.
ingress
.header_protection.
one_rtt
) == 
NULL
) {

5782 
ret
 = 
QUICLY_ERROR_PACKET_IGNORED
;

5783 goto 
Exit
;

5785 
aead
.
cb
 = 
aead_decrypt_1rtt
;

5786 
aead
.
ctx
 = 
conn
;

5787 
space
 = (void *)&
conn
->
application
;

5788 
epoch
 = 
QUICLY_EPOCH_1RTT
;

5792 if ((
ret
 = 
	`decrypt_packet
(
header_protection
, 
aead
.
cb
, aead.
ctx
, &(*
space
)->
next_expected_packet_number
, 
packet
, &
pn
,

5793 &
payload
)) != 0) {

5794 ++
conn
->
super
.
stats
.
num_packets
.
decryption_failed
;

5795 
	`QUICLY_PROBE
(
PACKET_DECRYPTION_FAILED
, 
conn
, conn->
stash
.
now
, 
pn
);

5796 goto 
Exit
;

5799 
	`QUICLY_PROBE
(
PACKET_RECEIVED
, 
conn
, conn->
stash
.
now
, 
pn
, 
payload
.
base
, payload.
len
, 
	`get_epoch
(
packet
->
octets
.base[0]));

5802 if (
conn
->
super
.
state
 == 
QUICLY_STATE_FIRSTFLIGHT
)

5803 
conn
->
super
.
state
 = 
QUICLY_STATE_CONNECTED
;

5804 
conn
->
super
.
stats
.
num_packets
.
received
 += 1;

5807 switch (
epoch
) {

5808 case 
QUICLY_EPOCH_INITIAL
:

5810 if (
conn
->
initial
->
largest_ingress_udp_payload_size
 < 
packet
->
datagram_size
)

5811 
conn
->
initial
->
largest_ingress_udp_payload_size
 = 
packet
->
datagram_size
;

5813 case 
QUICLY_EPOCH_HANDSHAKE
:

5816 if (
conn
->
initial
 != 
NULL
) {

5817 if ((
ret
 = 
	`discard_handshake_context
(
conn
, 
QUICLY_EPOCH_INITIAL
)) != 0)

5818 goto 
Exit
;

5819 
	`update_loss_alarm
(
conn
, 0);

5820 
conn
->
super
.
remote
.
address_validation
.
validated
 = 1;

5828 if ((
ret
 = 
	`handle_payload
(
conn
, 
epoch
, 
payload
.
base
, payload.
len
, &
offending_frame_type
, &
is_ack_only
)) != 0)

5829 goto 
Exit
;

5830 if (*
space
 != 
NULL
 && 
conn
->
super
.
state
 < 
QUICLY_STATE_CLOSING
) {

5831 if ((
ret
 = 
	`record_receipt
(*
space
, 
pn
, 
is_ack_only
, 
conn
->
stash
.
now
, &conn->
egress
.
send_ack_at
)) != 0)

5832 goto 
Exit
;

5836 switch (
epoch
) {

5837 case 
QUICLY_EPOCH_INITIAL
:

5838 
	`assert
(
conn
->
initial
 != 
NULL
);

5839 if (
	`quicly_is_client
(
conn
) && conn->
handshake
 != 
NULL
 && conn->handshake->
cipher
.
egress
.
aead
 != NULL) {

5840 if ((
ret
 = 
	`discard_handshake_context
(
conn
, 
QUICLY_EPOCH_INITIAL
)) != 0)

5841 goto 
Exit
;

5842 
	`update_loss_alarm
(
conn
, 0);

5845 case 
QUICLY_EPOCH_HANDSHAKE
:

5846 if (
	`quicly_is_client
(
conn
)) {

5849 if (
conn
->
super
.
local
.
address
.
sa
.
sa_family
 == 
AF_UNSPEC
 && 
dest_addr
 != 
NULL
 && dest_addr->sa_family != AF_UNSPEC &&

5850 
	`ptls_handshake_is_complete
(
conn
->
crypto
.
tls
) && conn->
super
.
remote
.
transport_params
.
disable_active_migration
)

5851 
	`set_address
(&
conn
->
super
.
local
.
address
, 
dest_addr
);

5855 if (
	`ptls_handshake_is_complete
(
conn
->
crypto
.
tls
)) {

5856 if ((
ret
 = 
	`discard_handshake_context
(
conn
, 
QUICLY_EPOCH_HANDSHAKE
)) != 0)

5857 goto 
Exit
;

5858 
	`assert
(
conn
->
handshake
 == 
NULL
);

5859 
conn
->
egress
.
pending_flows
 |= 
QUICLY_PENDING_FLOW_HANDSHAKE_DONE_BIT
;

5860 
	`update_loss_alarm
(
conn
, 0);

5864 case 
QUICLY_EPOCH_1RTT
:

5865 if (!
is_ack_only
 && 
	`should_send_max_data
(
conn
))

5866 
conn
->
egress
.
send_ack_at
 = 0;

5872 
	`update_idle_timeout
(
conn
, 1);

5874 
Exit
:

5875 switch (
ret
) {

5881 if (
conn
->
egress
.
loss
.
alarm_at
 < conn->
stash
.
now
)

5882 
conn
->
egress
.
loss
.
alarm_at
 = conn->
stash
.
now
;

5883 
	`assert_consistency
(
conn
, 0);

5885 case 
PTLS_ERROR_NO_MEMORY
:

5886 case 
QUICLY_ERROR_STATE_EXHAUSTION
:

5887 case 
QUICLY_ERROR_PACKET_IGNORED
:

5890 
	`initiate_close
(
conn
, 
ret
, 
offending_frame_type
, "");

5891 
ret
 = 0;

5894 
	`unlock_now
(
conn
);

5895 return 
ret
;

5896 
	}
}

5898 int 
	$quicly_open_stream
(
quicly_conn_t
 *
conn
, 
quicly_stream_t
 **
_stream
, int 
uni
)

5900 
quicly_stream_t
 *
stream
;

5901 struct 
st_quicly_conn_streamgroup_state_t
 *
group
;

5902 
uint64_t
 *
max_stream_count
;

5903 
uint32_t
 
max_stream_data_local
;

5904 
uint64_t
 
max_stream_data_remote
;

5905 int 
ret
;

5908 if (
uni
) {

5909 
group
 = &
conn
->
super
.
local
.
uni
;

5910 
max_stream_count
 = &
conn
->
egress
.
max_streams
.
uni
.
count
;

5911 
max_stream_data_local
 = 0;

5912 
max_stream_data_remote
 = 
conn
->
super
.
remote
.
transport_params
.
max_stream_data
.
uni
;

5914 
group
 = &
conn
->
super
.
local
.
bidi
;

5915 
max_stream_count
 = &
conn
->
egress
.
max_streams
.
bidi
.
count
;

5916 
max_stream_data_local
 = (
uint32_t
)
conn
->
super
.
ctx
->
transport_params
.
max_stream_data
.
bidi_local
;

5917 
max_stream_data_remote
 = 
conn
->
super
.
remote
.
transport_params
.
max_stream_data
.
bidi_remote
;

5921 if ((
stream
 = 
	`open_stream
(
conn
, 
group
->
next_stream_id
, 
max_stream_data_local
, 
max_stream_data_remote
)) == 
NULL
)

5922 return 
PTLS_ERROR_NO_MEMORY
;

5923 ++
group
->
num_streams
;

5924 
group
->
next_stream_id
 += 4;

5927 if (
stream
->
stream_id
 / 4 >= *
max_stream_count
) {

5928 
stream
->
streams_blocked
 = 1;

5929 
	`quicly_linklist_insert
((
uni
 ? &
conn
->
egress
.
pending_streams
.
blocked
.uni : &conn->egress.pending_streams.blocked.
bidi
)->
prev
,

5930 &
stream
->
_send_aux
.
pending_link
.
control
);

5934 
	`QUICLY_PROBE
(
STREAM_ON_OPEN
, 
conn
, conn->
stash
.
now
, 
stream
);

5935 if ((
ret
 = 
conn
->
super
.
ctx
->
stream_open
->
	`cb
(conn->super.ctx->stream_open, 
stream
)) != 0)

5936 return 
ret
;

5938 *
_stream
 = 
stream
;

5940 
	}
}

5942 void 
	$quicly_reset_stream
(
quicly_stream_t
 *
stream
, int 
err
)

5944 
	`assert
(
	`quicly_stream_has_send_side
(
	`quicly_is_client
(
stream
->
conn
), stream->
stream_id
));

5945 
	`assert
(
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
));

5946 
	`assert
(
stream
->
_send_aux
.
reset_stream
.
sender_state
 == 
QUICLY_SENDER_STATE_NONE
);

5947 
	`assert
(!
	`quicly_sendstate_transfer_complete
(&
stream
->
sendstate
));

5950 
	`quicly_sendstate_reset
(&
stream
->
sendstate
);

5953 
stream
->
_send_aux
.
reset_stream
.
sender_state
 = 
QUICLY_SENDER_STATE_SEND
;

5954 
stream
->
_send_aux
.
reset_stream
.
error_code
 = 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
);

5957 
	`sched_stream_control
(
stream
);

5958 
	`resched_stream_data
(
stream
);

5959 
	}
}

5961 void 
	$quicly_request_stop
(
quicly_stream_t
 *
stream
, int 
err
)

5963 
	`assert
(
	`quicly_stream_has_receive_side
(
	`quicly_is_client
(
stream
->
conn
), stream->
stream_id
));

5964 
	`assert
(
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
));

5967 if (
stream
->
recvstate
.
eos
 == 
UINT64_MAX
 && stream->
_send_aux
.
stop_sending
.
sender_state
 == 
QUICLY_SENDER_STATE_NONE
) {

5968 
stream
->
_send_aux
.
stop_sending
.
sender_state
 = 
QUICLY_SENDER_STATE_SEND
;

5969 
stream
->
_send_aux
.
stop_sending
.
error_code
 = 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
);

5970 
	`sched_stream_control
(
stream
);

5972 
	}
}

5974 
socklen_t
 
	$quicly_get_socklen
(struct 
sockaddr
 *
sa
)

5976 switch (
sa
->
sa_family
) {

5977 case 
AF_INET
:

5978 return sizeof(struct 
sockaddr_in
);

5979 case 
AF_INET6
:

5980 return sizeof(struct 
sockaddr_in6
);

5982 
	`assert
(!"unexpected socket type");

5985 
	}
}

5987 char *
	$quicly_escape_unsafe_string
(char *
buf
, const void *
bytes
, 
size_t
 
len
)

5989 char *
dst
 = 
buf
;

5990 const char *
src
 = 
bytes
, *
end
 = src + 
len
;

5992 for (; 
src
 != 
end
; ++src) {

5993 if ((0x20 <= *
src
 && *src <= 0x7e) && !(*src == '"' || *src == '\'' || *src == '\\')) {

5994 *
dst
++ = *
src
;

5996 *
dst
++ = '\\';

5997 *
dst
++ = 'x';

5998 
	`quicly_byte_to_hex
(
dst
, (
uint8_t
)*
src
);

5999 
dst
 += 2;

6002 *
dst
 = '\0';

6004 return 
buf
;

6005 
	}
}

6007 char *
	$quicly_hexdump
(const 
uint8_t
 *
bytes
, 
size_t
 
len
, size_t 
indent
)

6009 
size_t
 
i
, 
line
, 
row
, 
bufsize
 = 
indent
 == 
SIZE_MAX
 ? 
len
 * 2 + 1 : (indent + 5 + 3 * 16 + 2 + 16 + 1) * ((len + 15) / 16) + 1;

6010 char *
buf
, *
p
;

6012 if ((
buf
 = 
	`malloc
(
bufsize
)) == 
NULL
)

6013 return 
NULL
;

6014 
p
 = 
buf
;

6015 if (
indent
 == 
SIZE_MAX
) {

6016 for (
i
 = 0; i != 
len
; ++i) {

6017 
	`quicly_byte_to_hex
(
p
, 
bytes
[
i
]);

6018 
p
 += 2;

6021 for (
line
 = 0; line * 16 < 
len
; ++line) {

6022 for (
i
 = 0; i < 
indent
; ++i)

6023 *
p
++ = ' ';

6024 
	`quicly_byte_to_hex
(
p
, (
line
 >> 4) & 0xff);

6025 
p
 += 2;

6026 
	`quicly_byte_to_hex
(
p
, (
line
 << 4) & 0xff);

6027 
p
 += 2;

6028 *
p
++ = ' ';

6029 for (
row
 = 0; row < 16; ++row) {

6030 *
p
++ = 
row
 == 8 ? '-' : ' ';

6031 if (
line
 * 16 + 
row
 < 
len
) {

6032 
	`quicly_byte_to_hex
(
p
, 
bytes
[
line
 * 16 + 
row
]);

6033 
p
 += 2;

6035 *
p
++ = ' ';

6036 *
p
++ = ' ';

6039 *
p
++ = ' ';

6040 *
p
++ = ' ';

6041 for (
row
 = 0; row < 16; ++row) {

6042 if (
line
 * 16 + 
row
 < 
len
) {

6043 int 
ch
 = 
bytes
[
line
 * 16 + 
row
];

6044 *
p
++ = 0x20 <= 
ch
 && ch < 0x7f ? ch : '.';

6046 *
p
++ = ' ';

6049 *
p
++ = '\n';

6052 *
p
++ = '\0';

6054 
	`assert
(
p
 - 
buf
 <= 
bufsize
);

6056 return 
buf
;

6057 
	}
}

6059 void 
	$quicly_amend_ptls_context
(
ptls_context_t
 *
ptls
)

6061 static 
ptls_update_traffic_key_t
 
update_traffic_key
 = {
update_traffic_key_cb
};

6063 
ptls
->
omit_end_of_early_data
 = 1;

6064 
ptls
->
update_traffic_key
 = &update_traffic_key;

6067 if (
ptls
->
max_early_data_size
 != 0)

6068 
ptls
->
max_early_data_size
 = 
UINT32_MAX
;

6069 
	}
}

6071 int 
	$quicly_encrypt_address_token
(void (*
random_bytes
)(void *, 
size_t
), 
ptls_aead_context_t
 *
aead
, 
ptls_buffer_t
 *
buf
,

6072 
size_t
 
start_off
, const 
quicly_address_token_plaintext_t
 *
plaintext
)

6074 int 
ret
;

6077 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 1 + 
aead
->
algo
->
iv_size
)) != 0)

6078 goto 
Exit
;

6079 
buf
->
base
[buf->
off
++] = 
plaintext
->
type
;

6080 
	`random_bytes
(
buf
->
base
 + buf->
off
, 
aead
->
algo
->
iv_size
);

6081 
buf
->
off
 += 
aead
->
algo
->
iv_size
;

6083 
size_t
 
enc_start
 = 
buf
->
off
;

6086 
	`ptls_buffer_push64
(
buf
, 
plaintext
->
issued_at
);

6088 
uint16_t
 
port
;

6089 
	`ptls_buffer_push_block
(
buf
, 1, {

6090 switch (
plaintext
->
remote
.
sa
.
sa_family
) {

6091 case 
AF_INET
:

6092 
	`ptls_buffer_pushv
(
buf
, &
plaintext
->
remote
.
sin
.
sin_addr
.
s_addr
, 4);

6093 
port
 = 
	`ntohs
(
plaintext
->
remote
.
sin
.
sin_port
);

6095 case 
AF_INET6
:

6096 
	`ptls_buffer_pushv
(
buf
, &
plaintext
->
remote
.
sin6
.
sin6_addr
, 16);

6097 
port
 = 
	`ntohs
(
plaintext
->
remote
.
sin6
.
sin6_port
);

6100 
	`assert
(!"unspported address type");

6104 
	`ptls_buffer_push16
(
buf
, 
port
);

6106 switch (
plaintext
->
type
) {

6107 case 
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
:

6108 
	`ptls_buffer_push_block
(
buf
, 1,

6109 { 
	`ptls_buffer_pushv
(
buf
, 
plaintext
->
retry
.
original_dcid
.
cid
, plaintext->retry.original_dcid.
len
); });

6110 
	`ptls_buffer_push_block
(
buf
, 1,

6111 { 
	`ptls_buffer_pushv
(
buf
, 
plaintext
->
retry
.
client_cid
.
cid
, plaintext->retry.client_cid.
len
); });

6112 
	`ptls_buffer_push_block
(
buf
, 1,

6113 { 
	`ptls_buffer_pushv
(
buf
, 
plaintext
->
retry
.
server_cid
.
cid
, plaintext->retry.server_cid.
len
); });

6115 case 
QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION
:

6116 
	`ptls_buffer_push_block
(
buf
, 1, { 
	`ptls_buffer_pushv
(buf, 
plaintext
->
resumption
.
bytes
, plaintext->resumption.
len
); });

6119 
	`assert
(!"unexpected token type");

6120 
	`abort
();

6122 
	`ptls_buffer_push_block
(
buf
, 1, { 
	`ptls_buffer_pushv
(buf, 
plaintext
->
appdata
.
bytes
, plaintext->appdata.
len
); });

6125 if ((
ret
 = 
	`ptls_buffer_reserve
(
buf
, 
aead
->
algo
->
tag_size
)) != 0)

6126 goto 
Exit
;

6127 
aead
->
algo
->
	`setup_crypto
(aead, 1, 
NULL
, 
buf
->
base
 + 
enc_start
 - aead->algo->
iv_size
);

6128 
	`ptls_aead_encrypt
(
aead
, 
buf
->
base
 + 
enc_start
, buf->base + enc_start, buf->
off
 - enc_start, 0, buf->base + 
start_off
,

6129 
enc_start
 - 
start_off
);

6130 
buf
->
off
 += 
aead
->
algo
->
tag_size
;

6132 
Exit
:

6133 return 
ret
;

6134 
	}
}

6136 int 
	$quicly_decrypt_address_token
(
ptls_aead_context_t
 *
aead
, 
quicly_address_token_plaintext_t
 *
plaintext
, const void *
_token
,

6137 
size_t
 
len
, size_t 
prefix_len
, const char **
err_desc
)

6139 const 
uint8_t
 *const 
token
 = 
_token
;

6140 
uint8_t
 
ptbuf
[
QUICLY_MIN_CLIENT_INITIAL_SIZE
];

6141 
size_t
 
ptlen
;

6143 *
err_desc
 = 
NULL
;

6146 if (
len
 < 
prefix_len
 + 1 + 
aead
->
algo
->
iv_size
 + aead->algo->
tag_size
) {

6147 *
err_desc
 = "token too small";

6148 return 
PTLS_ALERT_DECODE_ERROR
;

6150 if (
prefix_len
 + 1 + 
aead
->
algo
->
iv_size
 + sizeof(
ptbuf
) + aead->algo->
tag_size
 < 
len
) {

6151 *
err_desc
 = "token too large";

6152 return 
PTLS_ALERT_DECODE_ERROR
;

6156 switch (
token
[
prefix_len
]) {

6157 case 
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
:

6158 
plaintext
->
type
 = 
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
;

6160 case 
QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION
:

6161 
plaintext
->
type
 = 
QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION
;

6164 *
err_desc
 = "unknown token type";

6165 return 
PTLS_ALERT_DECODE_ERROR
;

6169 int 
ret
;

6172 
aead
->
algo
->
	`setup_crypto
(aead, 0, 
NULL
, 
token
 + 
prefix_len
 + 1);

6173 if ((
ptlen
 = 
	`ptls_aead_decrypt
(
aead
, 
ptbuf
, 
token
 + 
prefix_len
 + 1 + aead->
algo
->
iv_size
,

6174 
len
 - (
prefix_len
 + 1 + 
aead
->
algo
->
iv_size
), 0, 
token
, prefix_len + 1 + aead->algo->iv_size)) ==

6175 
SIZE_MAX
) {

6176 
ret
 = 
PTLS_ALERT_DECRYPT_ERROR
;

6177 *
err_desc
 = "token decryption failure";

6178 goto 
Exit
;

6182 const 
uint8_t
 *
src
 = 
ptbuf
, *
end
 = src + 
ptlen
;

6183 if ((
ret
 = 
	`ptls_decode64
(&
plaintext
->
issued_at
, &
src
, 
end
)) != 0)

6184 goto 
Exit
;

6186 
in_port_t
 *
portaddr
;

6187 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

6188 switch (
end
 - 
src
) {

6190 
plaintext
->
remote
.
sin
.
sin_family
 = 
AF_INET
;

6191 
	`memcpy
(&
plaintext
->
remote
.
sin
.
sin_addr
.
s_addr
, 
src
, 4);

6192 
portaddr
 = &
plaintext
->
remote
.
sin
.
sin_port
;

6195 
plaintext
->
remote
.
sin6
.
sin6_family
 = 
AF_INET6
;

6196 
	`memcpy
(&
plaintext
->
remote
.
sin6
.
sin6_addr
, 
src
, 16);

6197 
portaddr
 = &
plaintext
->
remote
.
sin6
.
sin6_port
;

6200 
ret
 = 
PTLS_ALERT_DECODE_ERROR
;

6201 goto 
Exit
;

6203 
src
 = 
end
;

6205 
uint16_t
 
port
;

6206 if ((
ret
 = 
	`ptls_decode16
(&
port
, &
src
, 
end
)) != 0)

6207 goto 
Exit
;

6208 *
portaddr
 = 
	`htons
(
port
);

6210 switch (
plaintext
->
type
) {

6211 case 
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
:

6212 #define 
	#DECODE_CID
(
field
) \

6214 
	`ptls_decode_open_block
(
src
, 
end
, 1, { \

6215 if (
end
 - 
src
 > sizeof(
plaintext
->
retry
.
field
.
cid
)) { \

6216 
ret
 = 
PTLS_ALERT_DECODE_ERROR
; \

6217 goto 
Exit
; \

6219 
	`quicly_set_cid
(&
plaintext
->
retry
.
field
, 
	`ptls_iovec_init
(
src
, 
end
 - src)); \

6220 
src
 = 
end
; \

6222 } while (0)

	)

6223 
	`DECODE_CID
(
original_dcid
);

6224 
	`DECODE_CID
(
client_cid
);

6225 
	`DECODE_CID
(
server_cid
);

6226 #undef 
DECODE_CID


6228 case 
QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION
:

6229 
	`ptls_decode_open_block
(
src
, 
end
, 1, {

6230 
	`PTLS_BUILD_ASSERT
(sizeof(
plaintext
->
resumption
.
bytes
) >= 256);

6231 
plaintext
->
resumption
.
len
 = 
end
 - 
src
;

6232 
	`memcpy
(
plaintext
->
resumption
.
bytes
, 
src
, plaintext->resumption.
len
);

6233 
src
 = 
end
;

6237 
	`assert
(!"unexpected token type");

6238 
	`abort
();

6240 
	`ptls_decode_block
(
src
, 
end
, 1, {

6241 
	`PTLS_BUILD_ASSERT
(sizeof(
plaintext
->
appdata
.
bytes
) >= 256);

6242 
plaintext
->
appdata
.
len
 = 
end
 - 
src
;

6243 
	`memcpy
(
plaintext
->
appdata
.
bytes
, 
src
, plaintext->appdata.
len
);

6244 
src
 = 
end
;

6246 
ret
 = 0;

6248 
Exit
:

6249 if (
ret
 != 0) {

6250 if (*
err_desc
 == 
NULL
)

6251 *
err_desc
 = "token decode error";

6253 if (
plaintext
->
type
 == 
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
)

6254 
ret
 = 
QUICLY_TRANSPORT_ERROR_INVALID_TOKEN
;

6256 return 
ret
;

6257 
	}
}

6259 int 
	$quicly_build_session_ticket_auth_data
(
ptls_buffer_t
 *
auth_data
, const 
quicly_context_t
 *
ctx
)

6261 int 
ret
;

6263 #define 
	#PUSH_TP
(
id
, 
block
) \

6265 
	`ptls_buffer_push_quicint
(
auth_data
, 
id
); \

6266 
	`ptls_buffer_push_block
(
auth_data
, -1, 
block
); \

6267 } while (0)

	)

6269 
	`ptls_buffer_push_block
(
auth_data
, -1, {

6270 
	`PUSH_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_ACTIVE_CONNECTION_ID_LIMIT
,

6271 { 
	`ptls_buffer_push_quicint
(
auth_data
, 
ctx
->
transport_params
.
active_connection_id_limit
); });

6272 
	`PUSH_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_DATA
,

6273 { 
	`ptls_buffer_push_quicint
(
auth_data
, 
ctx
->
transport_params
.
max_data
); });

6274 
	`PUSH_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL
,

6275 { 
	`ptls_buffer_push_quicint
(
auth_data
, 
ctx
->
transport_params
.
max_stream_data
.
bidi_local
); });

6276 
	`PUSH_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE
,

6277 { 
	`ptls_buffer_push_quicint
(
auth_data
, 
ctx
->
transport_params
.
max_stream_data
.
bidi_remote
); });

6278 
	`PUSH_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAM_DATA_UNI
,

6279 { 
	`ptls_buffer_push_quicint
(
auth_data
, 
ctx
->
transport_params
.
max_stream_data
.
uni
); });

6280 
	`PUSH_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_BIDI
,

6281 { 
	`ptls_buffer_push_quicint
(
auth_data
, 
ctx
->
transport_params
.
max_streams_bidi
); });

6282 
	`PUSH_TP
(
QUICLY_TRANSPORT_PARAMETER_ID_INITIAL_MAX_STREAMS_UNI
,

6283 { 
	`ptls_buffer_push_quicint
(
auth_data
, 
ctx
->
transport_params
.
max_streams_uni
); });

6286 #undef 
PUSH_TP


6288 
ret
 = 0;

6289 
Exit
:

6290 return 
ret
;

6291 
	}
}

6293 void 
	$quicly_stream_noop_on_destroy
(
quicly_stream_t
 *
stream
, int 
err
)

6295 
	}
}

6297 void 
	$quicly_stream_noop_on_send_shift
(
quicly_stream_t
 *
stream
, 
size_t
 
delta
)

6299 
	}
}

6301 void 
	$quicly_stream_noop_on_send_emit
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, void *
dst
, size_t *
len
, int *
wrote_all
)

6303 
	}
}

6305 void 
	$quicly_stream_noop_on_send_stop
(
quicly_stream_t
 *
stream
, int 
err
)

6307 
	}
}

6309 void 
	$quicly_stream_noop_on_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
)

6311 
	}
}

6313 void 
	$quicly_stream_noop_on_receive_reset
(
quicly_stream_t
 *
stream
, int 
err
)

6315 
	}
}

6317 const 
quicly_stream_callbacks_t
 
	gquicly_stream_noop_callbacks
 = {

6318 
quicly_stream_noop_on_destroy
, 
quicly_stream_noop_on_send_shift
, 
quicly_stream_noop_on_send_emit
,

6319 
quicly_stream_noop_on_send_stop
, 
quicly_stream_noop_on_receive
, 
quicly_stream_noop_on_receive_reset
};

6321 void 
	$quicly__debug_printf
(
quicly_conn_t
 *
conn
, const char *
function
, int 
line
, const char *
fmt
, ...)

6323 #if 
QUICLY_USE_EMBEDDED_PROBES
 || 
QUICLY_USE_DTRACE


6324 char 
buf
[1024];

6325 
va_list
 
args
;

6327 if (!
	`QUICLY_DEBUG_MESSAGE_ENABLED
())

6330 
	`va_start
(
args
, 
fmt
);

6331 
	`vsnprintf
(
buf
, sizeof(buf), 
fmt
, 
args
);

6332 
	`va_end
(
args
);

6334 
	`QUICLY_DEBUG_MESSAGE
(
conn
, 
function
, 
line
, 
buf
);

6336 
	}
}

6338 const 
uint32_t
 
	gquicly_supported_versions
[] = {
QUICLY_PROTOCOL_VERSION_CURRENT
, 
QUICLY_PROTOCOL_VERSION_DRAFT27
, 0};

	@lib/ranges.c

22 #include 
	~<assert.h
>

23 #include 
	~<stdlib.h
>

24 #include 
	~<string.h
>

25 #include 
	~"picotls.h
"

26 #include 
	~"quicly/constants.h
"

27 #include 
	~"quicly/ranges.h
"

29 #define 
	#COPY
(
dst
, 
src
, 
n
) \

31 
size_t
 
_n
 = (
n
); \

32 if (
_n
 != 0) \

33 
	`memcpy
((
dst
), (
src
), sizeof(
quicly_range_t
) * 
_n
); \

34 } while (0)

	)

35 #define 
	#MOVE
(
dst
, 
src
, 
n
) \

37 
size_t
 
_n
 = (
n
); \

38 if (
_n
 != 0) \

39 
	`memmove
((
dst
), (
src
), sizeof(
quicly_range_t
) * 
_n
); \

40 } while (0)

	)

42 static int 
	$insert_at
(
quicly_ranges_t
 *
ranges
, 
uint64_t
 
start
, uint64_t 
end
, 
size_t
 
slot
)

44 if (
ranges
->
num_ranges
 == ranges->
capacity
) {

45 
size_t
 
new_capacity
 = 
ranges
->
capacity
 < 4 ? 4 : ranges->capacity * 2;

46 
quicly_range_t
 *
new_ranges
 = 
	`malloc
(
new_capacity
 * sizeof(*new_ranges));

47 if (
new_ranges
 == 
NULL
)

48 return 
PTLS_ERROR_NO_MEMORY
;

49 
	`COPY
(
new_ranges
, 
ranges
->ranges, 
slot
);

50 
	`COPY
(
new_ranges
 + 
slot
 + 1, 
ranges
->ranges + slot, ranges->
num_ranges
 - slot);

51 if (
ranges
->ranges != &ranges->
_initial
)

52 
	`free
(
ranges
->ranges);

53 
ranges
->ranges = 
new_ranges
;

54 
ranges
->
capacity
 = 
new_capacity
;

56 
	`MOVE
(
ranges
->ranges + 
slot
 + 1, ranges->ranges + slot, ranges->
num_ranges
 - slot);

58 
ranges
->ranges[
slot
] = (
quicly_range_t
){
start
, 
end
};

59 ++
ranges
->
num_ranges
;

61 
	}
}

63 void 
	$quicly_ranges_drop_by_range_indices
(
quicly_ranges_t
 *
ranges
, 
size_t
 
begin_range_index
, size_t 
end_range_index
)

65 
	`assert
(
begin_range_index
 < 
end_range_index
);

67 
	`MOVE
(
ranges
->ranges + 
begin_range_index
, ranges->ranges + 
end_range_index
, ranges->
num_ranges
 - end_range_index);

68 
ranges
->
num_ranges
 -= 
end_range_index
 - 
begin_range_index
;

69 if (
ranges
->
capacity
 > 4 && ranges->
num_ranges
 * 3 <= ranges->capacity) {

70 
size_t
 
new_capacity
 = 
ranges
->
capacity
 / 2;

71 
quicly_range_t
 *
new_ranges
 = 
	`realloc
(
ranges
->ranges, 
new_capacity
 * sizeof(*new_ranges));

72 if (
new_ranges
 != 
NULL
) {

73 
ranges
->ranges = 
new_ranges
;

74 
ranges
->
capacity
 = 
new_capacity
;

77 
	}
}

79 static 
inline
 int 
	$merge_update
(
quicly_ranges_t
 *
ranges
, 
uint64_t
 
start
, uint64_t 
end
, 
size_t
 
slot
, size_t 
end_slot
)

81 if (
start
 < 
ranges
->ranges[
slot
].start)

82 
ranges
->ranges[
slot
].
start
 = start;

83 
ranges
->ranges[
slot
].
end
 = end < ranges->ranges[
end_slot
].end ? ranges->ranges[end_slot].end : end;

85 if (
slot
 != 
end_slot
)

86 
	`quicly_ranges_drop_by_range_indices
(
ranges
, 
slot
 + 1, 
end_slot
 + 1);

89 
	}
}

91 int 
	$quicly_ranges_init_with_range
(
quicly_ranges_t
 *
ranges
, 
uint64_t
 
start
, uint64_t 
end
)

93 
	`quicly_ranges_init
(
ranges
);

94 return 
	`insert_at
(
ranges
, 
start
, 
end
, 0);

95 
	}
}

97 int 
	$quicly_ranges_add
(
quicly_ranges_t
 *
ranges
, 
uint64_t
 
start
, uint64_t 
end
)

99 
size_t
 
slot
, 
end_slot
;

101 
	`assert
(
start
 <= 
end
);

103 if (
start
 == 
end
)

106 if (
ranges
->
num_ranges
 == 0) {

107 return 
	`insert_at
(
ranges
, 
start
, 
end
, 0);

108 } else if (
ranges
->ranges[ranges->
num_ranges
 - 1].
end
 < 
start
) {

109 return 
	`insert_at
(
ranges
, 
start
, 
end
, ranges->
num_ranges
);

113 for (
slot
 = 
ranges
->
num_ranges
 - 1;; --slot) {

114 if (
ranges
->ranges[
slot
].
start
 <= 
end
)

116 if (
slot
 == 0)

117 return 
	`insert_at
(
ranges
, 
start
, 
end
, 0);

119 
end_slot
 = 
slot
;

123 if (
ranges
->ranges[
slot
].
end
 == 
start
) {

124 return 
	`merge_update
(
ranges
, 
start
, 
end
, 
slot
, 
end_slot
);

125 } else if (
ranges
->ranges[
slot
].
end
 < 
start
) {

126 if (
slot
++ == 
end_slot
) {

127 return 
	`insert_at
(
ranges
, 
start
, 
end
, 
slot
);

129 return 
	`merge_update
(
ranges
, 
start
, 
end
, 
slot
, 
end_slot
);

132 } while (
slot
-- != 0);

134 return 
	`merge_update
(
ranges
, 
start
, 
end
, 0, 
end_slot
);

135 
	}
}

137 int 
	$quicly_ranges_subtract
(
quicly_ranges_t
 *
ranges
, 
uint64_t
 
start
, uint64_t 
end
)

139 
size_t
 
shrink_from
, 
slot
;

141 
	`assert
(
start
 <= 
end
);

143 if (
start
 == 
end
)

146 if (
ranges
->
num_ranges
 == 0) {

148 } else if (
end
 <= 
ranges
->ranges[0].
start
) {

150 } else if (
ranges
->ranges[ranges->
num_ranges
 - 1].
end
 <= 
start
) {

155 for (
slot
 = 0; 
ranges
->ranges[slot].
end
 < 
start
; ++slot)

158 if (
end
 <= 
ranges
->ranges[
slot
].end) {

160 if (
end
 <= 
ranges
->ranges[
slot
].
start
)

162 if (
start
 <= 
ranges
->ranges[
slot
].start) {

163 
ranges
->ranges[
slot
].
start
 = 
end
;

164 } else if (
end
 == 
ranges
->ranges[
slot
].end) {

165 
ranges
->ranges[
slot
].
end
 = 
start
;

168 int 
ret
;

169 if ((
ret
 = 
	`insert_at
(
ranges
, 
end
, ranges->ranges[
slot
].end, slot + 1)) != 0)

170 return 
ret
;

171 
ranges
->ranges[
slot
].
end
 = 
start
;

175 if (
ranges
->ranges[
slot
].
start
 == ranges->ranges[slot].
end
)

176 
	`quicly_ranges_drop_by_range_indices
(
ranges
, 
slot
, slot + 1);

181 if (
start
 <= 
ranges
->ranges[
slot
].start) {

182 
shrink_from
 = 
slot
;

184 
ranges
->ranges[
slot
].
end
 = 
start
;

185 
shrink_from
 = 
slot
 + 1;

189 for (++
slot
; slot != 
ranges
->
num_ranges
; ++slot) {

190 if (
end
 <= 
ranges
->ranges[
slot
].
start
)

192 if (
end
 < 
ranges
->ranges[
slot
].end) {

193 
ranges
->ranges[
slot
].
start
 = 
end
;

199 if (
shrink_from
 != 
slot
)

200 
	`quicly_ranges_drop_by_range_indices
(
ranges
, 
shrink_from
, 
slot
);

203 
	}
}

	@lib/recvstate.c

22 #include 
	~"quicly/constants.h
"

23 #include 
	~"quicly/recvstate.h
"

25 void 
	$quicly_recvstate_init
(
quicly_recvstate_t
 *
state
)

27 
	`quicly_ranges_init_with_range
(&
state
->
received
, 0, 0);

28 
state
->
data_off
 = 0;

29 
state
->
eos
 = 
UINT64_MAX
;

30 
	}
}

32 void 
	$quicly_recvstate_init_closed
(
quicly_recvstate_t
 *
state
)

34 
	`quicly_ranges_init
(&
state
->
received
);

35 
state
->
data_off
 = 0;

36 
state
->
eos
 = 0;

37 
	}
}

39 void 
	$quicly_recvstate_dispose
(
quicly_recvstate_t
 *
state
)

41 
	`quicly_ranges_clear
(&
state
->
received
);

42 
	}
}

44 int 
	$quicly_recvstate_update
(
quicly_recvstate_t
 *
state
, 
uint64_t
 
off
, 
size_t
 *
len
, int 
is_fin
, size_t 
max_ranges
)

46 int 
ret
;

48 
	`assert
(!
	`quicly_recvstate_transfer_complete
(
state
));

51 if (
state
->
eos
 == 
UINT64_MAX
) {

52 if (
is_fin
) {

53 
state
->
eos
 = 
off
 + *
len
;

54 if (
state
->
eos
 < state->
received
.
ranges
[state->received.
num_ranges
 - 1].
end
)

55 return 
QUICLY_TRANSPORT_ERROR_FINAL_SIZE
;

58 if (
off
 + *
len
 > 
state
->
eos
)

59 return 
QUICLY_TRANSPORT_ERROR_FINAL_SIZE
;

63 if (
off
 + *
len
 <= 
state
->
data_off
) {

64 *
len
 = 0;

65 if (
state
->
received
.
ranges
[0].
end
 == state->
eos
)

66 goto 
Complete
;

71 if (
off
 < 
state
->
data_off
) {

72 
size_t
 
delta
 = 
state
->
data_off
 - 
off
;

73 
off
 += 
delta
;

74 *
len
 -= 
delta
;

78 if (*
len
 != 0) {

79 if ((
ret
 = 
	`quicly_ranges_add
(&
state
->
received
, 
off
, off + *
len
)) != 0)

80 return 
ret
;

81 if (
state
->
received
.
num_ranges
 > 
max_ranges
)

82 return 
QUICLY_ERROR_STATE_EXHAUSTION
;

84 if (
state
->
received
.
num_ranges
 == 1 && state->received.
ranges
[0].
start
 == 0 && state->received.ranges[0].
end
 == state->
eos
)

85 goto 
Complete
;

89 
Complete
:

90 
	`quicly_ranges_clear
(&
state
->
received
);

92 
	}
}

94 int 
	$quicly_recvstate_reset
(
quicly_recvstate_t
 *
state
, 
uint64_t
 
eos_at
, uint64_t *
bytes_missing
)

96 
	`assert
(!
	`quicly_recvstate_transfer_complete
(
state
));

99 if (
state
->
eos
 != 
UINT64_MAX
 && state->eos != 
eos_at
)

100 return 
QUICLY_TRANSPORT_ERROR_FINAL_SIZE
;

101 if (
eos_at
 < 
state
->
received
.
ranges
[state->received.
num_ranges
 - 1].
end
)

102 return 
QUICLY_TRANSPORT_ERROR_FINAL_SIZE
;

105 *
bytes_missing
 = 
eos_at
 - 
state
->
received
.
ranges
[state->received.
num_ranges
 - 1].
end
;

108 
	`quicly_ranges_clear
(&
state
->
received
);

111 
	}
}

	@lib/remote_cid.c

22 #include 
	~<assert.h
>

23 #include 
	~"quicly/constants.h
"

24 #include 
	~"quicly/remote_cid.h
"

26 void 
	$quicly_remote_cid_init_set
(
quicly_remote_cid_set_t
 *
set
, 
ptls_iovec_t
 *
initial_cid
, void (*
random_bytes
)(void *, 
size_t
))

28 
set
->
cids
[0] = (
quicly_remote_cid_t
){

29 .
is_active
 = 1,

30 .
sequence
 = 0,

32 if (
initial_cid
 != 
NULL
) {

33 
	`quicly_set_cid
(&
set
->
cids
[0].
cid
, *
initial_cid
);

35 
	`random_bytes
(
set
->
cids
[0].
cid
.cid, 
QUICLY_MIN_INITIAL_DCID_LEN
);

36 
set
->
cids
[0].
cid
.
len
 = 
QUICLY_MIN_INITIAL_DCID_LEN
;

38 
	`random_bytes
(
set
->
cids
[0].
stateless_reset_token
, sizeof(set->cids[0].stateless_reset_token));

40 for (
size_t
 
i
 = 1; i < 
	`PTLS_ELEMENTSOF
(
set
->
cids
); i++)

41 
set
->
cids
[
i
] = (
quicly_remote_cid_t
){

42 .
is_active
 = 0,

43 .
sequence
 = 
i
,

46 
set
->
_largest_sequence_expected
 = 
	`PTLS_ELEMENTSOF
(set->
cids
) - 1;

47 
	}
}

53 static void 
	$promote_cid
(
quicly_remote_cid_set_t
 *
set
, 
size_t
 
idx_to_promote
)

55 
uint64_t
 
seq_tmp
 = 
set
->
cids
[0].
sequence
;

57 
	`assert
(
idx_to_promote
 > 0);

58 
	`assert
(!
set
->
cids
[0].
is_active
);

60 
set
->
cids
[0] = set->cids[
idx_to_promote
];

61 
set
->
cids
[
idx_to_promote
].
is_active
 = 0;

62 
set
->
cids
[
idx_to_promote
].
sequence
 = 
seq_tmp
;

63 
	}
}

65 static int 
	$do_register
(
quicly_remote_cid_set_t
 *
set
, 
uint64_t
 
sequence
, const 
uint8_t
 *
cid
, 
size_t
 
cid_len
,

66 const 
uint8_t
 
srt
[
QUICLY_STATELESS_RESET_TOKEN_LEN
])

68 int 
was_stored
 = 0;

70 if (
set
->
_largest_sequence_expected
 < 
sequence
)

71 return 
QUICLY_TRANSPORT_ERROR_CONNECTION_ID_LIMIT
;

73 for (
size_t
 
i
 = 0; i < 
	`PTLS_ELEMENTSOF
(
set
->
cids
); i++) {

74 if (
set
->
cids
[
i
].
is_active
) {

82 if (
	`quicly_cid_is_equal
(&
set
->
cids
[
i
].
cid
, 
	`ptls_iovec_init
(cid, 
cid_len
))) {

83 if (
set
->
cids
[
i
].
sequence
 == sequence &&

84 
	`memcmp
(
set
->
cids
[
i
].
stateless_reset_token
, 
srt
, 
QUICLY_STATELESS_RESET_TOKEN_LEN
) == 0) {

89 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

93 if (
set
->
cids
[
i
].
sequence
 == sequence)

94 return 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
;

95 } else if (
set
->
cids
[
i
].
sequence
 == sequence) {

96 
	`assert
(!
was_stored
);

97 
set
->
cids
[
i
].
sequence
 = sequence;

98 
	`quicly_set_cid
(&
set
->
cids
[
i
].
cid
, 
	`ptls_iovec_init
(cid, 
cid_len
));

99 
	`memcpy
(
set
->
cids
[
i
].
stateless_reset_token
, 
srt
, 
QUICLY_STATELESS_RESET_TOKEN_LEN
);

100 
set
->
cids
[
i
].
is_active
 = 1;

101 
was_stored
 = 1;

102 if (
i
 > 0 && !
set
->
cids
[0].
is_active
) {

104 
	`promote_cid
(
set
, 
i
);

112 
	}
}

114 static void 
	$do_unregister
(
quicly_remote_cid_set_t
 *
set
, 
size_t
 
idx_to_unreg
)

116 
	`assert
(
set
->
cids
[
idx_to_unreg
].
is_active
);

118 
set
->
cids
[
idx_to_unreg
].
is_active
 = 0;

119 
set
->
cids
[
idx_to_unreg
].
sequence
 = ++set->
_largest_sequence_expected
;

120 
	}
}

122 int 
	$quicly_remote_cid_unregister
(
quicly_remote_cid_set_t
 *
set
, 
uint64_t
 
sequence
)

124 
uint64_t
 
min_seq
 = 
UINT64_MAX
;

125 
size_t
 
min_seq_idx
 = 
SIZE_MAX
;

126 for (
size_t
 
i
 = 0; i < 
	`PTLS_ELEMENTSOF
(
set
->
cids
); i++) {

127 if (
sequence
 == 
set
->
cids
[
i
].sequence) {

128 
	`do_unregister
(
set
, 
i
);

129 if (
i
 != 0)

132 if (
set
->
cids
[
i
].
is_active
 && 
min_seq
 > set->cids[i].
sequence
) {

134 
min_seq
 = 
set
->
cids
[
i
].
sequence
;

135 
min_seq_idx
 = 
i
;

139 if (!
set
->
cids
[0].
is_active
) {

141 if (
min_seq_idx
 != 
SIZE_MAX
)

142 
	`promote_cid
(
set
, 
min_seq_idx
);

148 
	}
}

150 static 
size_t
 
	$unregister_prior_to
(
quicly_remote_cid_set_t
 *
set
, 
uint64_t
 
seq_unreg_prior_to
,

151 
uint64_t
 
unregistered_seqs
[
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
])

153 
uint64_t
 
min_seq
 = 
UINT64_MAX
, 
min_seq_idx
 = UINT64_MAX;

154 
size_t
 
num_unregistered
 = 0;

155 for (
size_t
 
i
 = 0; i < 
	`PTLS_ELEMENTSOF
(
set
->
cids
); i++) {

156 if (
set
->
cids
[
i
].
is_active
) {

157 if (
set
->
cids
[
i
].
sequence
 < 
seq_unreg_prior_to
) {

158 
unregistered_seqs
[
num_unregistered
++] = 
set
->
cids
[
i
].
sequence
;

159 
	`do_unregister
(
set
, 
i
);

162 if (
min_seq
 > 
set
->
cids
[
i
].
sequence
) {

164 
min_seq
 = 
set
->
cids
[
i
].
sequence
;

165 
min_seq_idx
 = 
i
;

170 if (!
set
->
cids
[0].
is_active
) {

172 if (
min_seq_idx
 != 
UINT64_MAX
)

173 
	`promote_cid
(
set
, 
min_seq_idx
);

176 return 
num_unregistered
;

177 
	}
}

179 int 
	$quicly_remote_cid_register
(
quicly_remote_cid_set_t
 *
set
, 
uint64_t
 
sequence
, const 
uint8_t
 *
cid
, 
size_t
 
cid_len
,

180 const 
uint8_t
 
srt
[
QUICLY_STATELESS_RESET_TOKEN_LEN
], 
uint64_t
 
retire_prior_to
,

181 
uint64_t
 
unregistered_seqs
[
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
], 
size_t
 *
num_unregistered_seqs
)

183 
quicly_remote_cid_t
 
backup_cid
 = 
set
->
cids
[0];

184 int 
ret
;

186 
	`assert
(
sequence
 >= 
retire_prior_to
);

190 *
num_unregistered_seqs
 = 
	`unregister_prior_to
(
set
, 
retire_prior_to
, 
unregistered_seqs
);

193 if ((
ret
 = 
	`do_register
(
set
, 
sequence
, 
cid
, 
cid_len
, 
srt
)) != 0) {

195 if (!
set
->
cids
[0].
is_active
)

196 
set
->
cids
[0] = 
backup_cid
;

197 return 
ret
;

200 return 
ret
;

201 
	}
}

	@lib/retire_cid.c

23 #include 
	~"quicly/retire_cid.h
"

25 void 
	$quicly_retire_cid_init
(
quicly_retire_cid_set_t
 *
set
)

27 
set
->
_num_pending
 = 0;

28 
	}
}

30 void 
	$quicly_retire_cid_push
(
quicly_retire_cid_set_t
 *
set
, 
uint64_t
 
sequence
)

32 if (
set
->
_num_pending
 == 
	`PTLS_ELEMENTSOF
(set->
sequences
)) {

37 for (
size_t
 
i
 = 0; i < 
set
->
_num_pending
; i++) {

38 if (
set
->
sequences
[
i
] == 
sequence
) {

44 
set
->
sequences
[set->
_num_pending
] = 
sequence
;

45 
set
->
_num_pending
++;

46 
	}
}

48 void 
	$quicly_retire_cid_shift
(
quicly_retire_cid_set_t
 *
set
, 
size_t
 
num_shift
)

50 
	`assert
(
num_shift
 <= 
	`PTLS_ELEMENTSOF
(
set
->
sequences
));

51 
	`assert
(
num_shift
 <= 
set
->
_num_pending
);

53 
	`memmove
(
set
->
sequences
, set->sequences + 
num_shift
, sizeof(set->sequences[0]) * (set->
_num_pending
 - num_shift));

54 
set
->
_num_pending
 -= 
num_shift
;

55 
	}
}

	@lib/sendstate.c

22 #include 
	~<assert.h
>

23 #include 
	~<stdlib.h
>

24 #include 
	~<string.h
>

25 #include 
	~"picotls.h
"

26 #include 
	~"quicly/constants.h
"

27 #include 
	~"quicly/sendstate.h
"

29 void 
	$quicly_sendstate_init
(
quicly_sendstate_t
 *
state
)

31 
	`quicly_ranges_init_with_range
(&
state
->
acked
, 0, 0);

32 
	`quicly_ranges_init
(&
state
->
pending
);

33 
state
->
size_inflight
 = 0;

34 
state
->
final_size
 = 
UINT64_MAX
;

35 
	}
}

37 void 
	$quicly_sendstate_init_closed
(
quicly_sendstate_t
 *
state
)

39 
	`quicly_sendstate_init
(
state
);

40 
state
->
acked
.
ranges
[0].
end
 = 1;

41 
state
->
final_size
 = 0;

42 
	}
}

44 void 
	$quicly_sendstate_dispose
(
quicly_sendstate_t
 *
state
)

46 
	`quicly_ranges_clear
(&
state
->
acked
);

47 
	`quicly_ranges_clear
(&
state
->
pending
);

48 
state
->
final_size
 = 0;

49 
state
->
size_inflight
 = 0;

50 
	}
}

52 int 
	$quicly_sendstate_activate
(
quicly_sendstate_t
 *
state
)

54 
uint64_t
 
end_off
 = 
state
->
final_size
;

57 if (
end_off
 != 
UINT64_MAX
)

58 ++
end_off
;

61 if (
state
->
pending
.
num_ranges
 != 0 && state->pending.
ranges
[state->pending.num_ranges - 1].
end
 == 
end_off
)

64 return 
	`quicly_ranges_add
(&
state
->
pending
, state->
size_inflight
, 
end_off
);

65 
	}
}

67 int 
	$quicly_sendstate_shutdown
(
quicly_sendstate_t
 *
state
, 
uint64_t
 
final_size
)

69 int 
ret
;

71 
	`assert
(
	`quicly_sendstate_is_open
(
state
));

72 
	`assert
(
state
->
size_inflight
 <= 
final_size
);

74 if (
state
->
pending
.
num_ranges
 != 0 && state->pending.
ranges
[state->pending.num_ranges - 1].
end
 == 
UINT64_MAX
) {

75 
state
->
pending
.
ranges
[state->pending.
num_ranges
 - 1].
end
 = 
final_size
 + 1;

77 if ((
ret
 = 
	`quicly_ranges_add
(&
state
->
pending
, state->
size_inflight
, 
final_size
 + 1)) != 0)

78 return 
ret
;

81 
state
->
final_size
 = final_size;

83 
	}
}

85 void 
	$quicly_sendstate_reset
(
quicly_sendstate_t
 *
state
)

87 int 
ret
;

89 if (
state
->
final_size
 == 
UINT64_MAX
)

90 
state
->
final_size
 = state->
size_inflight
;

92 
ret
 = 
	`quicly_ranges_add
(&
state
->
acked
, 0, state->
final_size
 + 1);

93 
	`assert
(
ret
 == 0 && "guaranteed to succeed, because the numebr of ranges never increases");

94 
	`quicly_ranges_clear
(&
state
->
pending
);

95 
	}
}

97 static int 
	$check_amount_of_state
(
quicly_sendstate_t
 *
state
)

99 
size_t
 
num_ranges
 = 
state
->
acked
.num_ranges + state->
pending
.num_ranges;

106 if (
	`PTLS_LIKELY
(
num_ranges
 < 256))

113 
int64_t
 
bytes_buffered
 = (int64_t)
state
->
size_inflight
 - (int64_t)state->
acked
.
ranges
[0].
end
;

114 if ((
int64_t
)
num_ranges
 * 128 > 
bytes_buffered
)

115 return 
QUICLY_ERROR_STATE_EXHAUSTION
;

118 
	}
}

120 int 
	$quicly_sendstate_acked
(
quicly_sendstate_t
 *
state
, 
quicly_sendstate_sent_t
 *
args
, 
size_t
 *
bytes_to_shift
)

122 
uint64_t
 
prev_sent_upto
 = 
state
->
acked
.
ranges
[0].
end
;

123 int 
ret
;

126 if ((
ret
 = 
	`quicly_ranges_add
(&
state
->
acked
, 
args
->
start
, args->
end
)) != 0)

127 return 
ret
;

128 if ((
ret
 = 
	`quicly_ranges_subtract
(&
state
->
pending
, 
args
->
start
, args->
end
)) != 0)

129 return 
ret
;

130 
	`assert
(
state
->
pending
.
num_ranges
 == 0 || state->
acked
.
ranges
[0].
end
 <= state->pending.ranges[0].
start
);

133 if (
prev_sent_upto
 != 
state
->
acked
.
ranges
[0].
end
) {

134 
uint64_t
 
sent_upto
 = 
state
->
acked
.
ranges
[0].
end
;

135 if (
sent_upto
 > 
state
->
final_size
) {

137 
	`assert
(
sent_upto
 == 
state
->
final_size
 + 1);

138 --
sent_upto
;

140 *
bytes_to_shift
 = 
sent_upto
 - 
prev_sent_upto
;

142 *
bytes_to_shift
 = 0;

145 return 
	`check_amount_of_state
(
state
);

146 
	}
}

148 int 
	$quicly_sendstate_lost
(
quicly_sendstate_t
 *
state
, 
quicly_sendstate_sent_t
 *
args
)

150 
uint64_t
 
start
 = 
args
->start, 
end
 = args->end;

151 
size_t
 
acked_slot
 = 0;

152 int 
ret
;

154 while (
start
 < 
end
) {

155 if (
start
 < 
state
->
acked
.
ranges
[
acked_slot
].
end
)

156 
start
 = 
state
->
acked
.
ranges
[
acked_slot
].
end
;

157 ++
acked_slot
;

158 if (
acked_slot
 == 
state
->
acked
.
num_ranges
 || 
end
 <= state->acked.
ranges
[acked_slot].
start
) {

159 if (
start
 < 
end
) {

160 if ((
ret
 = 
	`quicly_ranges_add
(&
state
->
pending
, 
start
, 
end
)) != 0)

161 return 
ret
;

163 goto 
Exit
;

165 if (
start
 < 
state
->
acked
.
ranges
[
acked_slot
].start) {

166 if ((
ret
 = 
	`quicly_ranges_add
(&
state
->
pending
, 
start
, state->
acked
.
ranges
[
acked_slot
].start)) != 0)

167 return 
ret
;

171 
Exit
:

172 
	`assert
(
state
->
pending
.
num_ranges
 == 0 || state->
acked
.
ranges
[0].
end
 <= state->pending.ranges[0].
start
);

173 return 
	`check_amount_of_state
(
state
);

174 
	}
}

	@lib/sentmap.c

22 #include 
	~<assert.h
>

23 #include 
	~<stdlib.h
>

24 #include 
	~"picotls.h
"

25 #include 
	~"quicly/sentmap.h
"

27 const 
quicly_sent_t
 
	gquicly_sentmap__end_iter
 = {
quicly_sentmap__type_packet
, {{
UINT64_MAX
, 
INT64_MAX
}}};

29 static void 
	$next_entry
(
quicly_sentmap_iter_t
 *
iter
)

31 if (--
iter
->
count
 != 0) {

32 ++
iter
->
p
;

33 } else if (*(
iter
->
ref
 = &(*iter->ref)->
next
) == 
NULL
) {

34 
iter
->
p
 = (
quicly_sent_t
 *)&
quicly_sentmap__end_iter
;

35 
iter
->
count
 = 0;

38 
	`assert
((*
iter
->
ref
)->
num_entries
 != 0);

39 
iter
->
count
 = (*iter->
ref
)->
num_entries
;

40 
iter
->
p
 = (*iter->
ref
)->
entries
;

42 while (
iter
->
p
->
acked
 == 
NULL
)

43 ++
iter
->
p
;

44 
	}
}

46 static struct 
st_quicly_sent_block_t
 **
	$free_block
(
quicly_sentmap_t
 *
map
, struct 
st_quicly_sent_block_t
 **
ref
)

48 static const struct 
st_quicly_sent_block_t
 
dummy
 = {
NULL
};

49 static const struct 
st_quicly_sent_block_t
 *const 
dummy_ref
 = &
dummy
;

50 struct 
st_quicly_sent_block_t
 *
block
 = *
ref
;

52 if (
block
->
next
 != 
NULL
) {

53 *
ref
 = 
block
->
next
;

54 
	`assert
((*
ref
)->
num_entries
 != 0);

56 
	`assert
(
block
 == 
map
->
tail
);

57 if (
ref
 == &
map
->
head
) {

58 
map
->
head
 = 
NULL
;

59 
map
->
tail
 = 
NULL
;

61 
map
->
tail
 = (void *)((char *)
ref
 - 
	`offsetof
(struct 
st_quicly_sent_block_t
, 
next
));

62 
map
->
tail
->
next
 = 
NULL
;

64 
ref
 = (struct 
st_quicly_sent_block_t
 **)&
dummy_ref
;

67 
	`free
(
block
);

68 return 
ref
;

69 
	}
}

71 static void 
	$discard_entry
(
quicly_sentmap_t
 *
map
, 
quicly_sentmap_iter_t
 *
iter
)

73 
	`assert
(
iter
->
p
->
acked
 != 
NULL
);

74 
iter
->
p
->
acked
 = 
NULL
;

76 struct 
st_quicly_sent_block_t
 *
block
 = *
iter
->
ref
;

77 if (--
block
->
num_entries
 == 0) {

78 
iter
->
ref
 = 
	`free_block
(
map
, iter->ref);

79 
block
 = *
iter
->
ref
;

80 
iter
->
p
 = 
block
->
entries
 - 1;

81 
iter
->
count
 = 
block
->
num_entries
 + 1;

83 
	}
}

85 void 
	$quicly_sentmap_dispose
(
quicly_sentmap_t
 *
map
)

87 struct 
st_quicly_sent_block_t
 *
block
;

89 while ((
block
 = 
map
->
head
) != 
NULL
) {

90 
map
->
head
 = 
block
->
next
;

91 
	`free
(
block
);

93 
	}
}

95 int 
	$quicly_sentmap_prepare
(
quicly_sentmap_t
 *
map
, 
uint64_t
 
packet_number
, 
int64_t
 
now
, 
uint8_t
 
ack_epoch
)

97 
	`assert
(
map
->
_pending_packet
 == 
NULL
);

99 if ((
map
->
_pending_packet
 = 
	`quicly_sentmap_allocate
(map, 
quicly_sentmap__type_packet
)) == 
NULL
)

100 return 
PTLS_ERROR_NO_MEMORY
;

101 
map
->
_pending_packet
->
data
.
packet
 = (
quicly_sent_packet_t
){
packet_number
, 
now
, 
ack_epoch
};

103 
	}
}

105 struct 
st_quicly_sent_block_t
 *
	$quicly_sentmap__new_block
(
quicly_sentmap_t
 *
map
)

107 struct 
st_quicly_sent_block_t
 *
block
;

109 if ((
block
 = 
	`malloc
(sizeof(*block))) == 
NULL
)

110 return 
NULL
;

112 
block
->
next
 = 
NULL
;

113 
block
->
num_entries
 = 0;

114 
block
->
next_insert_at
 = 0;

115 if (
map
->
tail
 != 
NULL
) {

116 
map
->
tail
->
next
 = 
block
;

117 
map
->
tail
 = 
block
;

119 
map
->
head
 = map->
tail
 = 
block
;

122 return 
block
;

123 
	}
}

125 void 
	$quicly_sentmap_skip
(
quicly_sentmap_iter_t
 *
iter
)

128 
	`next_entry
(
iter
);

129 } while (
iter
->
p
->
acked
 != 
quicly_sentmap__type_packet
);

130 
	}
}

132 int 
	$quicly_sentmap_update
(
quicly_sentmap_t
 *
map
, 
quicly_sentmap_iter_t
 *
iter
, 
quicly_sentmap_event_t
 
event
)

134 
quicly_sent_packet_t
 
packet
;

135 int 
ret
 = 0;

137 
	`assert
(
iter
->
p
 != &
quicly_sentmap__end_iter
);

138 
	`assert
(
iter
->
p
->
acked
 == 
quicly_sentmap__type_packet
);

141 
packet
 = 
iter
->
p
->
data
.packet;

144 if (
packet
.
cc_bytes_in_flight
 != 0 && 
event
 != 
QUICLY_SENTMAP_EVENT_PTO
) {

145 
	`assert
(
map
->
bytes_in_flight
 >= 
packet
.
cc_bytes_in_flight
);

146 
map
->
bytes_in_flight
 -= 
packet
.
cc_bytes_in_flight
;

147 
iter
->
p
->
data
.
packet
.
cc_bytes_in_flight
 = 0;

149 
iter
->
p
->
data
.
packet
.
frames_in_flight
 = 0;

151 int 
should_notify
 = 
event
 == 
QUICLY_SENTMAP_EVENT_ACKED
 || 
packet
.
frames_in_flight
,

152 
should_discard
 = 
event
 == 
QUICLY_SENTMAP_EVENT_ACKED
 || event == 
QUICLY_SENTMAP_EVENT_EXPIRED
;

157 if (
should_discard
) {

158 
	`discard_entry
(
map
, 
iter
);

159 --
map
->
num_packets
;

161 for (
	`next_entry
(
iter
); iter->
p
->
acked
 != 
quicly_sentmap__type_packet
; next_entry(iter)) {

162 if (
should_notify
 && (
ret
 = 
iter
->
p
->
	`acked
(
map
, &
packet
, 
event
 == 
QUICLY_SENTMAP_EVENT_ACKED
, iter->p)) != 0)

163 goto 
Exit
;

164 if (
should_discard
)

165 
	`discard_entry
(
map
, 
iter
);

168 
Exit
:

169 return 
ret
;

170 
	}
}

172 int 
	$quicly_sentmap__type_packet
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

174 
	`assert
(!"quicly_sentmap__type_packet cannot be called");

175 return 
QUICLY_TRANSPORT_ERROR_INTERNAL
;

176 
	}
}

	@lib/streambuf.c

22 #include 
	~<assert.h
>

23 #include 
	~<stdlib.h
>

24 #include 
	~<string.h
>

25 #include 
	~"quicly/streambuf.h
"

27 static void 
	$convert_error
(
quicly_stream_t
 *
stream
, int 
err
)

29 
	`assert
(
err
 != 0);

30 if (
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
)) {

31 if (
	`quicly_stream_has_send_side
(
	`quicly_is_client
(
stream
->
conn
), stream->
stream_id
) &&

32 
	`quicly_sendstate_is_open
(&
stream
->
sendstate
))

33 
	`quicly_reset_stream
(
stream
, 
err
);

34 if (
	`quicly_stream_has_receive_side
(
	`quicly_is_client
(
stream
->
conn
), stream->
stream_id
))

35 
	`quicly_request_stop
(
stream
, 
err
);

37 
	`quicly_close
(
stream
->
conn
, 
	`QUICLY_ERROR_IS_QUIC_TRANSPORT
(
err
) ? err : 
QUICLY_TRANSPORT_ERROR_INTERNAL
, 
NULL
);

39 
	}
}

41 void 
	$quicly_sendbuf_dispose
(
quicly_sendbuf_t
 *
sb
)

43 
size_t
 
i
;

45 for (
i
 = 0; i != 
sb
->
vecs
.
size
; ++i) {

46 
quicly_sendbuf_vec_t
 *
vec
 = 
sb
->
vecs
.
entries
 + 
i
;

47 if (
vec
->
cb
->
discard_vec
 != 
NULL
)

48 
vec
->
cb
->
	`discard_vec
(vec);

50 
	`free
(
sb
->
vecs
.
entries
);

51 
	}
}

53 void 
	$quicly_sendbuf_shift
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_t
 *
sb
, 
size_t
 
delta
)

55 
size_t
 
i
;

57 for (
i
 = 0; 
delta
 != 0; ++i) {

58 
	`assert
(
i
 < 
sb
->
vecs
.
size
);

59 
quicly_sendbuf_vec_t
 *
first_vec
 = 
sb
->
vecs
.
entries
 + 
i
;

60 
size_t
 
bytes_in_first_vec
 = 
first_vec
->
len
 - 
sb
->
off_in_first_vec
;

61 if (
delta
 < 
bytes_in_first_vec
) {

62 
sb
->
off_in_first_vec
 += 
delta
;

65 
delta
 -= 
bytes_in_first_vec
;

66 if (
first_vec
->
cb
->
discard_vec
 != 
NULL
)

67 
first_vec
->
cb
->
	`discard_vec
(first_vec);

68 
sb
->
off_in_first_vec
 = 0;

70 if (
i
 != 0) {

71 if (
sb
->
vecs
.
size
 != 
i
) {

72 
	`memmove
(
sb
->
vecs
.
entries
, sb->vecs.entries + 
i
, (sb->vecs.
size
 - i) * sizeof(*sb->vecs.entries));

73 
sb
->
vecs
.
size
 -= 
i
;

75 
	`free
(
sb
->
vecs
.
entries
);

76 
sb
->
vecs
.
entries
 = 
NULL
;

77 
sb
->
vecs
.
size
 = 0;

78 
sb
->
vecs
.
capacity
 = 0;

81 
	`quicly_stream_sync_sendbuf
(
stream
, 0);

82 
	}
}

84 void 
	$quicly_sendbuf_emit
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_t
 *
sb
, 
size_t
 
off
, void *
dst
, size_t *
len
, int *
wrote_all
)

86 
size_t
 
vec_index
, 
capacity
 = *
len
;

87 int 
ret
;

89 
off
 += 
sb
->
off_in_first_vec
;

90 for (
vec_index
 = 0; 
capacity
 != 0 && vec_index < 
sb
->
vecs
.
size
; ++vec_index) {

91 
quicly_sendbuf_vec_t
 *
vec
 = 
sb
->
vecs
.
entries
 + 
vec_index
;

92 if (
off
 < 
vec
->
len
) {

93 
size_t
 
bytes_flatten
 = 
vec
->
len
 - 
off
;

94 int 
partial
 = 0;

95 if (
capacity
 < 
bytes_flatten
) {

96 
bytes_flatten
 = 
capacity
;

97 
partial
 = 1;

99 if ((
ret
 = 
vec
->
cb
->
	`flatten_vec
(vec, 
dst
, 
off
, 
bytes_flatten
)) != 0) {

100 
	`convert_error
(
stream
, 
ret
);

103 
dst
 = (
uint8_t
 *)dst + 
bytes_flatten
;

104 
capacity
 -= 
bytes_flatten
;

105 
off
 = 0;

106 if (
partial
)

109 
off
 -= 
vec
->
len
;

113 if (
capacity
 == 0 && 
vec_index
 < 
sb
->
vecs
.
size
) {

114 *
wrote_all
 = 0;

116 *
len
 = *len - 
capacity
;

117 *
wrote_all
 = 1;

119 
	}
}

121 static int 
	$flatten_raw
(
quicly_sendbuf_vec_t
 *
vec
, void *
dst
, 
size_t
 
off
, size_t 
len
)

123 
	`memcpy
(
dst
, (
uint8_t
 *)
vec
->
cbdata
 + 
off
, 
len
);

125 
	}
}

127 static void 
	$discard_raw
(
quicly_sendbuf_vec_t
 *
vec
)

129 
	`free
(
vec
->
cbdata
);

130 
	}
}

132 int 
	$quicly_sendbuf_write
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_t
 *
sb
, const void *
src
, 
size_t
 
len
)

134 static const 
quicly_streambuf_sendvec_callbacks_t
 
raw_callbacks
 = {
flatten_raw
, 
discard_raw
};

135 
quicly_sendbuf_vec_t
 
vec
 = {&
raw_callbacks
, 
len
, 
NULL
};

136 int 
ret
;

138 
	`assert
(
	`quicly_sendstate_is_open
(&
stream
->
sendstate
));

140 if ((
vec
.
cbdata
 = 
	`malloc
(
len
)) == 
NULL
) {

141 
ret
 = 
PTLS_ERROR_NO_MEMORY
;

142 goto 
Error
;

144 
	`memcpy
(
vec
.
cbdata
, 
src
, 
len
);

145 if ((
ret
 = 
	`quicly_sendbuf_write_vec
(
stream
, 
sb
, &
vec
)) != 0)

146 goto 
Error
;

149 
Error
:

150 
	`free
(
vec
.
cbdata
);

151 return 
ret
;

152 
	}
}

154 int 
	$quicly_sendbuf_write_vec
(
quicly_stream_t
 *
stream
, 
quicly_sendbuf_t
 *
sb
, 
quicly_sendbuf_vec_t
 *
vec
)

156 
	`assert
(
sb
->
vecs
.
size
 <= sb->vecs.
capacity
);

158 if (
sb
->
vecs
.
size
 == sb->vecs.
capacity
) {

159 
quicly_sendbuf_vec_t
 *
new_entries
;

160 
size_t
 
new_capacity
 = 
sb
->
vecs
.
capacity
 == 0 ? 4 : sb->vecs.capacity * 2;

161 if ((
new_entries
 = 
	`realloc
(
sb
->
vecs
.
entries
, 
new_capacity
 * sizeof(*sb->vecs.entries))) == 
NULL
)

162 return 
PTLS_ERROR_NO_MEMORY
;

163 
sb
->
vecs
.
entries
 = 
new_entries
;

164 
sb
->
vecs
.
capacity
 = 
new_capacity
;

166 
sb
->
vecs
.
entries
[sb->vecs.
size
++] = *
vec
;

167 
sb
->
bytes_written
 += 
vec
->
len
;

169 return 
	`quicly_stream_sync_sendbuf
(
stream
, 1);

170 
	}
}

172 void 
	$quicly_recvbuf_shift
(
quicly_stream_t
 *
stream
, 
ptls_buffer_t
 *
rb
, 
size_t
 
delta
)

174 
	`assert
(
delta
 <= 
rb
->
off
);

175 
rb
->
off
 -= 
delta
;

176 
	`memmove
(
rb
->
base
, rb->base + 
delta
, rb->
off
);

178 
	`quicly_stream_sync_recvbuf
(
stream
, 
delta
);

179 
	}
}

181 
ptls_iovec_t
 
	$quicly_recvbuf_get
(
quicly_stream_t
 *
stream
, 
ptls_buffer_t
 *
rb
)

183 
size_t
 
avail
;

185 if (
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
)) {

186 
avail
 = 
rb
->
off
;

187 } else if (
stream
->
recvstate
.
data_off
 < stream->recvstate.
received
.
ranges
[0].
end
) {

188 
avail
 = 
stream
->
recvstate
.
received
.
ranges
[0].
end
 - stream->recvstate.
data_off
;

190 
avail
 = 0;

193 return 
	`ptls_iovec_init
(
rb
->
base
, 
avail
);

194 
	}
}

196 int 
	$quicly_recvbuf_receive
(
quicly_stream_t
 *
stream
, 
ptls_buffer_t
 *
rb
, 
size_t
 
off
, const void *
src
, size_t 
len
)

198 if (
len
 != 0) {

199 int 
ret
;

200 if ((
ret
 = 
	`ptls_buffer_reserve
(
rb
, 
off
 + 
len
 - rb->off)) != 0) {

201 
	`convert_error
(
stream
, 
ret
);

204 
	`memcpy
(
rb
->
base
 + 
off
, 
src
, 
len
);

205 if (
rb
->
off
 < off + 
len
)

206 
rb
->
off
 = off + 
len
;

209 
	}
}

211 int 
	$quicly_streambuf_create
(
quicly_stream_t
 *
stream
, 
size_t
 
sz
)

213 
quicly_streambuf_t
 *
sbuf
;

215 
	`assert
(
sz
 >= sizeof(*
sbuf
));

216 
	`assert
(
stream
->
data
 == 
NULL
);

218 if ((
sbuf
 = 
	`malloc
(
sz
)) == 
NULL
)

219 return 
PTLS_ERROR_NO_MEMORY
;

220 
	`quicly_sendbuf_init
(&
sbuf
->
egress
);

221 
	`ptls_buffer_init
(&
sbuf
->
ingress
, "", 0);

222 if (
sz
 != sizeof(*
sbuf
))

223 
	`memset
((char *)
sbuf
 + sizeof(*sbuf), 0, 
sz
 - sizeof(*sbuf));

225 
stream
->
data
 = 
sbuf
;

227 
	}
}

229 void 
	$quicly_streambuf_destroy
(
quicly_stream_t
 *
stream
, int 
err
)

231 
quicly_streambuf_t
 *
sbuf
 = 
stream
->
data
;

233 
	`quicly_sendbuf_dispose
(&
sbuf
->
egress
);

234 
	`ptls_buffer_dispose
(&
sbuf
->
ingress
);

235 
	`free
(
sbuf
);

236 
stream
->
data
 = 
NULL
;

237 
	}
}

239 void 
	$quicly_streambuf_egress_emit
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, void *
dst
, size_t *
len
, int *
wrote_all
)

241 
quicly_streambuf_t
 *
sbuf
 = 
stream
->
data
;

242 
	`quicly_sendbuf_emit
(
stream
, &
sbuf
->
egress
, 
off
, 
dst
, 
len
, 
wrote_all
);

243 
	}
}

245 int 
	$quicly_streambuf_egress_shutdown
(
quicly_stream_t
 *
stream
)

247 
quicly_streambuf_t
 *
sbuf
 = 
stream
->
data
;

248 
	`quicly_sendstate_shutdown
(&
stream
->
sendstate
, 
sbuf
->
egress
.
bytes_written
);

249 return 
	`quicly_stream_sync_sendbuf
(
stream
, 1);

250 
	}
}

252 int 
	$quicly_streambuf_ingress_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
)

254 
quicly_streambuf_t
 *
sbuf
 = 
stream
->
data
;

255 return 
	`quicly_recvbuf_receive
(
stream
, &
sbuf
->
ingress
, 
off
, 
src
, 
len
);

256 
	}
}

	@quicly-tracer.h

1 #ifndef 
callback_probes_h


2 #define 
	#callback_probes_h


	)

5 #define 
	#QUICLY_TRACER_CONNECT
(...)

	)

7 #define 
	#QUICLY_TRACER_ACCEPT
(...)

	)

9 #define 
	#QUICLY_TRACER_FREE
(...)

	)

11 #define 
	#QUICLY_TRACER_SEND
(...)

	)

13 #define 
	#QUICLY_TRACER_RECEIVE
(...)

	)

15 #define 
	#QUICLY_TRACER_VERSION_SWITCH
(...)

	)

17 #define 
	#QUICLY_TRACER_IDLE_TIMEOUT
(...)

	)

19 #define 
	#QUICLY_TRACER_STATELESS_RESET_RECEIVE
(...)

	)

21 #define 
	#QUICLY_TRACER_CRYPTO_HANDSHAKE
(...)

	)

23 #define 
	#QUICLY_TRACER_CRYPTO_UPDATE_SECRET
(...)

	)

25 #define 
	#QUICLY_TRACER_CRYPTO_SEND_KEY_UPDATE
(...)

	)

27 #define 
	#QUICLY_TRACER_CRYPTO_SEND_KEY_UPDATE_CONFIRMED
(...)

	)

29 #define 
	#QUICLY_TRACER_CRYPTO_RECEIVE_KEY_UPDATE
(...)

	)

31 #define 
	#QUICLY_TRACER_CRYPTO_RECEIVE_KEY_UPDATE_PREPARE
(...)

	)

33 static 
inline
 void 
	$QUICLY_TRACER_PACKET_SENT
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, 
size_t
 
arg3
, 
uint8_t
 
arg4
, int 
arg5
)

35 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

36 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"packet-sent\", \"time\":%lld, \"pn\":%llu, \"len\":%llu, \"packet-type\":%llu, \"ack-only\":%lld}\n", (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (long long)
arg5
);

37 
	}
}

39 static 
inline
 void 
	$QUICLY_TRACER_PACKET_RECEIVED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, const void * 
arg3
, 
size_t
 
arg4
, 
uint8_t
 
arg5
)

41 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

42 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"packet-received\", \"time\":%lld, \"pn\":%llu, \"decrypted\":\"0x%llx\", \"decrypted-len\":%llu, \"packet-type\":%llu}\n", (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (unsigned long long)
arg5
);

43 
	}
}

45 #define 
	#QUICLY_TRACER_PACKET_PREPARE
(...)

	)

47 static 
inline
 void 
	$QUICLY_TRACER_PACKET_ACKED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, int 
arg3
)

49 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

50 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"packet-acked\", \"time\":%lld, \"pn\":%llu, \"is-late-ack\":%lld}\n", (long long)
arg1
, (unsigned long long)
arg2
, (long long)
arg3
);

51 
	}
}

53 static 
inline
 void 
	$QUICLY_TRACER_PACKET_LOST
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, 
uint8_t
 
arg3
)

55 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

56 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"packet-lost\", \"time\":%lld, \"pn\":%llu, \"packet-type\":%llu}\n", (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
);

57 
	}
}

59 static 
inline
 void 
	$QUICLY_TRACER_PACKET_DECRYPTION_FAILED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

61 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

62 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"packet-decryption-failed\", \"time\":%lld, \"pn\":%llu}\n", (long long)
arg1
, (unsigned long long)
arg2
);

63 
	}
}

65 static 
inline
 void 
	$QUICLY_TRACER_PTO
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
size_t
 
arg2
, 
uint32_t
 
arg3
, 
int8_t
 
arg4
)

67 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

68 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"pto\", \"time\":%lld, \"inflight\":%llu, \"cwnd\":%llu, \"pto-count\":%lld}\n", (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (long long)
arg4
);

69 
	}
}

71 static 
inline
 void 
	$QUICLY_TRACER_CC_ACK_RECEIVED
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, 
size_t
 
arg3
, 
uint32_t
 
arg4
, size_t 
arg5
)

73 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

74 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"cc-ack-received\", \"time\":%lld, \"largest-acked\":%llu, \"bytes-acked\":%llu, \"cwnd\":%llu, \"inflight\":%llu}\n", (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
, (unsigned long long)
arg5
);

75 
	}
}

77 static 
inline
 void 
	$QUICLY_TRACER_CC_CONGESTION
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, 
size_t
 
arg3
, 
uint32_t
 
arg4
)

79 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

80 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"cc-congestion\", \"time\":%lld, \"max-lost-pn\":%llu, \"inflight\":%llu, \"cwnd\":%llu}\n", (long long)
arg1
, (unsigned long long)
arg2
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

81 
	}
}

83 #define 
	#QUICLY_TRACER_ACK_BLOCK_RECEIVED
(...)

	)

85 #define 
	#QUICLY_TRACER_ACK_DELAY_RECEIVED
(...)

	)

87 #define 
	#QUICLY_TRACER_ACK_SEND
(...)

	)

89 #define 
	#QUICLY_TRACER_PING_SEND
(...)

	)

91 #define 
	#QUICLY_TRACER_PING_RECEIVE
(...)

	)

93 #define 
	#QUICLY_TRACER_TRANSPORT_CLOSE_SEND
(...)

	)

95 #define 
	#QUICLY_TRACER_TRANSPORT_CLOSE_RECEIVE
(...)

	)

97 #define 
	#QUICLY_TRACER_APPLICATION_CLOSE_SEND
(...)

	)

99 #define 
	#QUICLY_TRACER_APPLICATION_CLOSE_RECEIVE
(...)

	)

101 #define 
	#QUICLY_TRACER_STREAM_SEND
(...)

	)

103 #define 
	#QUICLY_TRACER_STREAM_RECEIVE
(...)

	)

105 #define 
	#QUICLY_TRACER_STREAM_ACKED
(...)

	)

107 #define 
	#QUICLY_TRACER_STREAM_LOST
(...)

	)

109 static 
inline
 void 
	$QUICLY_TRACER_MAX_DATA_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

111 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

112 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"max-data-send\", \"time\":%lld, \"maximum\":%llu}\n", (long long)
arg1
, (unsigned long long)
arg2
);

113 
	}
}

115 static 
inline
 void 
	$QUICLY_TRACER_MAX_DATA_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
)

117 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

118 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"max-data-receive\", \"time\":%lld, \"maximum\":%llu}\n", (long long)
arg1
, (unsigned long long)
arg2
);

119 
	}
}

121 #define 
	#QUICLY_TRACER_MAX_STREAMS_SEND
(...)

	)

123 #define 
	#QUICLY_TRACER_MAX_STREAMS_RECEIVE
(...)

	)

125 static 
inline
 void 
	$QUICLY_TRACER_MAX_STREAM_DATA_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, 
uint64_t
 
arg3
)

127 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

128 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"max-stream-data-send\", \"time\":%lld, \"stream-id\":%d, \"maximum\":%llu}\n", (long long)
arg1
, (int)
arg2
->
stream_id
, (unsigned long long)
arg3
);

129 
	}
}

131 static 
inline
 void 
	$QUICLY_TRACER_MAX_STREAM_DATA_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, int64_t 
arg2
, 
uint64_t
 
arg3
)

133 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

134 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"max-stream-data-receive\", \"time\":%lld, \"stream-id\":%lld, \"maximum\":%llu}\n", (long long)
arg1
, (long long)
arg2
, (unsigned long long)
arg3
);

135 
	}
}

137 #define 
	#QUICLY_TRACER_NEW_TOKEN_SEND
(...)

	)

139 #define 
	#QUICLY_TRACER_NEW_TOKEN_ACKED
(...)

	)

141 #define 
	#QUICLY_TRACER_NEW_TOKEN_RECEIVE
(...)

	)

143 #define 
	#QUICLY_TRACER_HANDSHAKE_DONE_SEND
(...)

	)

145 #define 
	#QUICLY_TRACER_HANDSHAKE_DONE_RECEIVE
(...)

	)

147 static 
inline
 void 
	$QUICLY_TRACER_STREAMS_BLOCKED_SEND
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, int 
arg3
)

149 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

150 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"streams-blocked-send\", \"time\":%lld, \"maximum\":%llu, \"is-unidirectional\":%lld}\n", (long long)
arg1
, (unsigned long long)
arg2
, (long long)
arg3
);

151 
	}
}

153 static 
inline
 void 
	$QUICLY_TRACER_STREAMS_BLOCKED_RECEIVE
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, 
uint64_t
 
arg2
, int 
arg3
)

155 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

156 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"streams-blocked-receive\", \"time\":%lld, \"maximum\":%llu, \"is-unidirectional\":%lld}\n", (long long)
arg1
, (unsigned long long)
arg2
, (long long)
arg3
);

157 
	}
}

159 #define 
	#QUICLY_TRACER_NEW_CONNECTION_ID_SEND
(...)

	)

161 #define 
	#QUICLY_TRACER_NEW_CONNECTION_ID_RECEIVE
(...)

	)

163 #define 
	#QUICLY_TRACER_RETIRE_CONNECTION_ID_SEND
(...)

	)

165 #define 
	#QUICLY_TRACER_RETIRE_CONNECTION_ID_RECEIVE
(...)

	)

167 #define 
	#QUICLY_TRACER_DATA_BLOCKED_SEND
(...)

	)

169 #define 
	#QUICLY_TRACER_DATA_BLOCKED_RECEIVE
(...)

	)

171 #define 
	#QUICLY_TRACER_STREAM_DATA_BLOCKED_SEND
(...)

	)

173 #define 
	#QUICLY_TRACER_STREAM_DATA_BLOCKED_RECEIVE
(...)

	)

175 #define 
	#QUICLY_TRACER_DATAGRAM_SEND
(...)

	)

177 #define 
	#QUICLY_TRACER_DATAGRAM_RECEIVE
(...)

	)

179 #define 
	#QUICLY_TRACER_ACK_FREQUENCY_RECEIVE
(...)

	)

181 #define 
	#QUICLY_TRACER_QUICTRACE_SEND_STREAM
(...)

	)

183 #define 
	#QUICLY_TRACER_QUICTRACE_RECV_STREAM
(...)

	)

185 static 
inline
 void 
	$QUICLY_TRACER_QUICTRACE_CC_ACK
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
quicly_rtt_t
 * 
arg2
, 
uint32_t
 
arg3
, 
size_t
 
arg4
)

187 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

188 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"quictrace-cc-ack\", \"time\":%lld, \"min-rtt\":%u, \"smoothed-rtt\":%u, \"latest-rtt\":%u, \"cwnd\":%llu, \"inflight\":%llu}\n", (long long)
arg1
, 
arg2
->
minimum
, arg2->
smoothed
, arg2->
latest
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

189 
	}
}

191 static 
inline
 void 
	$QUICLY_TRACER_QUICTRACE_CC_LOST
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
quicly_rtt_t
 * 
arg2
, 
uint32_t
 
arg3
, 
size_t
 
arg4
)

193 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

194 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"quictrace-cc-lost\", \"time\":%lld, \"min-rtt\":%u, \"smoothed-rtt\":%u, \"latest-rtt\":%u, \"cwnd\":%llu, \"inflight\":%llu}\n", (long long)
arg1
, 
arg2
->
minimum
, arg2->
smoothed
, arg2->
latest
, (unsigned long long)
arg3
, (unsigned long long)
arg4
);

195 
	}
}

197 static 
inline
 void 
	$QUICLY_TRACER_STREAM_ON_OPEN
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
)

199 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

200 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"stream-on-open\", \"time\":%lld, \"stream-id\":%d}\n", (long long)
arg1
, (int)
arg2
->
stream_id
);

201 
	}
}

203 static 
inline
 void 
	$QUICLY_TRACER_STREAM_ON_DESTROY
(struct 
st_quicly_conn_t
 * 
arg0
, 
int64_t
 
arg1
, struct 
st_quicly_stream_t
 * 
arg2
, int 
arg3
)

205 if (
arg0
->
super
.
tracer
.
cb
 != 
NULL
)

206 
arg0
->
super
.
tracer
.
	`cb
(arg0->super.tracer.
ctx
, "{\"type\":\"stream-on-destroy\", \"time\":%lld, \"stream-id\":%d, \"err\":%lld}\n", (long long)
arg1
, (int)
arg2
->
stream_id
, (long long)
arg3
);

207 
	}
}

209 #define 
	#QUICLY_TRACER_STREAM_ON_SEND_SHIFT
(...)

	)

211 #define 
	#QUICLY_TRACER_STREAM_ON_SEND_EMIT
(...)

	)

213 #define 
	#QUICLY_TRACER_STREAM_ON_SEND_STOP
(...)

	)

215 #define 
	#QUICLY_TRACER_STREAM_ON_RECEIVE
(...)

	)

217 #define 
	#QUICLY_TRACER_STREAM_ON_RECEIVE_RESET
(...)

	)

219 #define 
	#QUICLY_TRACER_DEBUG_MESSAGE
(...)

	)

221 #define 
	#QUICLY_TRACER_CONN_STATS
(...)

	)

	@src/cli.c

22 #include 
	~<sys/select.h
>

23 #include 
	~<sys/socket.h
>

24 #include 
	~<sys/stat.h
>

25 #include 
	~<sys/time.h
>

26 #include 
	~<sys/types.h
>

27 #include 
	~<getopt.h
>

28 #include 
	~<netinet/udp.h
>

29 #include 
	~<fcntl.h
>

30 #include 
	~<netdb.h
>

31 #include 
	~<stdio.h
>

32 #include 
	~<unistd.h
>

33 #include 
	~<picotls.h
>

34 #if 
QUICLY_HAVE_FUSION


35 #include 
	~"picotls/fusion.h
"

37 #include 
	~"quicly.h
"

38 #include 
	~"quicly/defaults.h
"

39 #include 
	~"quicly/streambuf.h
"

40 #include 
	~"../deps/picotls/t/util.h
"

42 #define 
	#MAX_BURST_PACKETS
 10

	)

44 
FILE
 *
	gquicly_trace_fp
 = 
NULL
;

45 static unsigned 
	gverbosity
 = 0;

46 static int 
	gsuppress_output
 = 0, 
	gsend_datagram_frame
 = 0;

47 static 
int64_t
 
	genqueue_requests_at
 = 0, 
	grequest_interval
 = 0;

49 static void 
	$hexdump
(const char *
title
, const 
uint8_t
 *
p
, 
size_t
 
l
)

51 
	`fprintf
(
stderr
, "%s (%zu bytes):\n", 
title
, 
l
);

53 while (
l
 != 0) {

54 int 
i
;

55 
	`fputs
(" ", 
stderr
);

56 for (
i
 = 0; i < 16; ++i) {

57 
	`fprintf
(
stderr
, " %02x", *
p
++);

58 if (--
l
 == 0)

61 
	`fputc
('\n', 
stderr
);

63 
	}
}

65 static int 
save_session_ticket_cb
(
ptls_save_ticket_t
 *
_self
, 
ptls_t
 *
tls
, 
ptls_iovec_t
 
src
);

66 static int 
on_client_hello_cb
(
ptls_on_client_hello_t
 *
_self
, 
ptls_t
 *
tls
, 
ptls_on_client_hello_parameters_t
 *
params
);

68 static const char *
	gsession_file
 = 
NULL
;

69 static 
ptls_handshake_properties_t
 
	ghs_properties
;

70 static 
quicly_transport_parameters_t
 
	gresumed_transport_params
;

71 static 
ptls_iovec_t
 
	gresumption_token
;

72 static 
quicly_context_t
 
	gctx
;

73 static 
quicly_cid_plaintext_t
 
	gnext_cid
;

75 
ptls_aead_context_t
 *
	menc
, *
	mdec
;

76 } 
	gaddress_token_aead
;

77 static 
ptls_save_ticket_t
 
	gsave_session_ticket
 = {
save_session_ticket_cb
};

78 static 
ptls_on_client_hello_t
 
	gon_client_hello
 = {
on_client_hello_cb
};

79 static int 
	genforce_retry
;

81 #if 
QUICLY_HAVE_FUSION


82 static const 
ptls_cipher_suite_t
 
	gfusion_aes128gcmsha256
 = {
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
, &
ptls_fusion_aes128gcm
,

83 &
ptls_openssl_sha256
},

84 
	gfusion_aes256gcmsha384
 = {
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
, &
ptls_fusion_aes256gcm
,

85 &
ptls_openssl_sha384
};

88 static 
ptls_key_exchange_algorithm_t
 *
	gkey_exchanges
[128];

89 static 
ptls_cipher_suite_t
 *
	gcipher_suites
[128];

90 static 
ptls_context_t
 
	gtlsctx
 = {.
random_bytes
 = 
ptls_openssl_random_bytes
,

91 .
	gget_time
 = &
ptls_get_time
,

92 .
	gkey_exchanges
 = 
key_exchanges
,

93 .
	gcipher_suites
 = 
cipher_suites
,

94 .
	grequire_dhe_on_psk
 = 1,

95 .
	gsave_ticket
 = &
save_session_ticket
,

96 .
	gon_client_hello
 = &
on_client_hello
};

98 
ptls_iovec_t
 
	mlist
[16];

99 
size_t
 
	mcount
;

100 } 
	gnegotiated_protocols
;

106 const char *
	mpath
;

107 int 
	mto_file
;

108 } * 
	greqs
;

110 struct 
	sst_stream_data_t
 {

111 
quicly_streambuf_t
 
	mstreambuf
;

112 
FILE
 *
	moutfp
;

115 static void 
on_stop_sending
(
quicly_stream_t
 *
stream
, int 
err
);

116 static void 
on_receive_reset
(
quicly_stream_t
 *
stream
, int 
err
);

117 static void 
server_on_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
);

118 static void 
client_on_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
);

120 static const 
quicly_stream_callbacks_t
 
	gserver_stream_callbacks
 = {
quicly_streambuf_destroy
,

121 
quicly_streambuf_egress_shift
,

122 
quicly_streambuf_egress_emit
,

123 
on_stop_sending
,

124 
server_on_receive
,

125 
on_receive_reset
},

126 
	gclient_stream_callbacks
 = {
quicly_streambuf_destroy
,

127 
quicly_streambuf_egress_shift
,

128 
quicly_streambuf_egress_emit
,

129 
on_stop_sending
,

130 
client_on_receive
,

131 
on_receive_reset
};

133 static void 
	$dump_stats
(
FILE
 *
fp
, 
quicly_conn_t
 *
conn
)

135 
quicly_stats_t
 
stats
;

137 
	`quicly_get_stats
(
conn
, &
stats
);

138 
	`fprintf
(
fp
,

139 "packets-received: %" 
PRIu64
 ", packets-decryption-failed: %" PRIu64 ", packets-sent: %" PRIu64

140 ", packets-lost: %" 
PRIu64
 ", ack-received: %" PRIu64 ", late-acked: %" PRIu64 ", bytes-received: %" PRIu64

141 ", bytes-sent: %" 
PRIu64
 ", srtt: %" 
PRIu32
 "\n",

142 
stats
.
num_packets
.
received
, stats.num_packets.
decryption_failed
, stats.num_packets.
sent
, stats.num_packets.
lost
,

143 
stats
.
num_packets
.
ack_received
, stats.num_packets.
late_acked
, stats.
num_bytes
.
received
, stats.num_bytes.
sent
,

144 
stats
.
rtt
.
smoothed
);

145 
	}
}

147 static int 
	$validate_path
(const char *
path
)

149 if (
path
[0] != '/')

152 if (
	`strstr
(
path
, "/.") != 
NULL
)

155 
	}
}

157 static int 
	$parse_request
(
ptls_iovec_t
 
input
, char **
path
, int *
is_http1
)

159 
size_t
 
off
 = 0, 
path_start
;

161 for (
off
 = 0; off != 
input
.
len
; ++off)

162 if (
input
.
base
[
off
] == ' ')

163 goto 
EndOfMethod
;

166 
EndOfMethod
:

167 ++
off
;

168 
path_start
 = 
off
;

169 for (; 
off
 != 
input
.
len
; ++off)

170 if (
input
.
base
[
off
] == ' ' || input.base[off] == '\r' || input.base[off] == '\n')

171 goto 
EndOfPath
;

174 
EndOfPath
:

175 *
path
 = (char *)(
input
.
base
 + 
path_start
);

176 *
is_http1
 = 
input
.
base
[
off
] == ' ';

177 
input
.
base
[
off
] = '\0';

179 
	}
}

181 static void 
	$send_str
(
quicly_stream_t
 *
stream
, const char *
s
)

183 
	`quicly_streambuf_egress_write
(
stream
, 
s
, 
	`strlen
(s));

184 
	}
}

186 static void 
	$send_header
(
quicly_stream_t
 *
stream
, int 
is_http1
, int 
status
, const char *
mime_type
)

188 char 
buf
[256];

190 if (!
is_http1
)

193 
	`sprintf
(
buf
, "HTTP/1.1 %03d OK\r\nConnection: close\r\nContent-Type: %s\r\n\r\n", 
status
, 
mime_type
);

194 
	`send_str
(
stream
, 
buf
);

195 
	}
}

197 static int 
	$flatten_file_vec
(
quicly_sendbuf_vec_t
 *
vec
, void *
dst
, 
size_t
 
off
, size_t 
len
)

199 int 
fd
 = (
intptr_t
)
vec
->
cbdata
;

200 
ssize_t
 
rret
;

203 while ((
rret
 = 
	`pread
(
fd
, 
dst
, 
len
, 
off
)) == -1 && 
errno
 == 
EINTR
)

206 return 
rret
 == 
len
 ? 0 : 
QUICLY_TRANSPORT_ERROR_INTERNAL
;

207 
	}
}

209 static void 
	$discard_file_vec
(
quicly_sendbuf_vec_t
 *
vec
)

211 int 
fd
 = (
intptr_t
)
vec
->
cbdata
;

212 
	`close
(
fd
);

213 
	}
}

215 static int 
	$send_file
(
quicly_stream_t
 *
stream
, int 
is_http1
, const char *
fn
, const char *
mime_type
)

217 static const 
quicly_streambuf_sendvec_callbacks_t
 
send_file_callbacks
 = {
flatten_file_vec
, 
discard_file_vec
};

218 int 
fd
;

219 struct 
stat
 
st
;

221 if ((
fd
 = 
	`open
(
fn
, 
O_RDONLY
)) == -1)

223 if (
	`fstat
(
fd
, &
st
) != 0 || 
	`S_ISDIR
(st.
st_mode
)) {

224 
	`close
(
fd
);

228 
	`send_header
(
stream
, 
is_http1
, 200, 
mime_type
);

229 
quicly_sendbuf_vec_t
 
vec
 = {&
send_file_callbacks
, (
size_t
)
st
.
st_size
, (void *)(
intptr_t
)
fd
};

230 
	`quicly_streambuf_egress_write_vec
(
stream
, &
vec
);

232 
	}
}

238 static int 
	$flatten_sized_text
(
quicly_sendbuf_vec_t
 *
vec
, void *
dst
, 
size_t
 
off
, size_t 
len
)

240 static const char 
pattern
[] =

258 while (
len
 != 0) {

259 const char *
src
 = 
pattern
 + 
off
 % 12;

260 if (
src
 + 
len
 - 
pattern
 <= sizeof(pattern) - 1) {

261 
	`memcpy
(
dst
, 
src
, 
len
);

264 
	`memcpy
(
dst
, 
src
, sizeof(
pattern
) - 20);

265 
off
 += sizeof(
pattern
) - 20;

266 
dst
 += sizeof(
pattern
) - 20;

267 
len
 -= sizeof(
pattern
) - 20;

271 #undef 
PATTERN


272 
	}
}

274 static int 
	$send_sized_text
(
quicly_stream_t
 *
stream
, const char *
path
, int 
is_http1
)

276 
size_t
 
size
;

277 int 
lastpos
;

279 if (
	`sscanf
(
path
, "/%zu%n", &
size
, &
lastpos
) != 1)

281 if (
lastpos
 != 
	`strlen
(
path
))

284 
	`send_header
(
stream
, 
is_http1
, 200, "text/plain; charset=utf-8");

285 static const 
quicly_streambuf_sendvec_callbacks_t
 
callbacks
 = {
flatten_sized_text
};

286 
quicly_sendbuf_vec_t
 
vec
 = {&
callbacks
, 
size
, 
NULL
};

287 
	`quicly_streambuf_egress_write_vec
(
stream
, &
vec
);

289 
	}
}

291 static void 
	$on_stop_sending
(
quicly_stream_t
 *
stream
, int 
err
)

293 
	`assert
(
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
));

294 
	`fprintf
(
stderr
, "received STOP_SENDING: %" 
PRIu16
 "\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
));

295 
	}
}

297 static void 
	$on_receive_reset
(
quicly_stream_t
 *
stream
, int 
err
)

299 
	`assert
(
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
));

300 
	`fprintf
(
stderr
, "received RESET_STREAM: %" 
PRIu16
 "\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
));

301 
	}
}

303 static void 
	$server_on_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
)

305 char *
path
;

306 int 
is_http1
;

308 if (!
	`quicly_sendstate_is_open
(&
stream
->
sendstate
))

311 if (
	`quicly_streambuf_ingress_receive
(
stream
, 
off
, 
src
, 
len
) != 0)

314 if (!
	`parse_request
(
	`quicly_streambuf_ingress_get
(
stream
), &
path
, &
is_http1
)) {

315 if (!
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
))

318 
	`send_header
(
stream
, 1, 500, "text/plain; charset=utf-8");

319 
	`send_str
(
stream
, "failed to parse HTTP request\n");

320 goto 
Sent
;

322 if (!
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
))

323 
	`quicly_request_stop
(
stream
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(0));

325 if (
	`strcmp
(
path
, "/logo.jpg") == 0 && 
	`send_file
(
stream
, 
is_http1
, "assets/logo.jpg", "image/jpeg"))

326 goto 
Sent
;

327 if (
	`strcmp
(
path
, "/main.jpg") == 0 && 
	`send_file
(
stream
, 
is_http1
, "assets/main.jpg", "image/jpeg"))

328 goto 
Sent
;

329 if (
	`send_sized_text
(
stream
, 
path
, 
is_http1
))

330 goto 
Sent
;

331 if (
	`validate_path
(
path
) && 
	`send_file
(
stream
, 
is_http1
, path + 1, "text/plain"))

332 goto 
Sent
;

334 
	`send_header
(
stream
, 
is_http1
, 404, "text/plain; charset=utf-8");

335 
	`send_str
(
stream
, "not found\n");

336 
Sent
:

337 
	`quicly_streambuf_egress_shutdown
(
stream
);

338 
	`quicly_streambuf_ingress_shift
(
stream
, 
len
);

339 
	}
}

341 static void 
	$client_on_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
)

343 struct 
st_stream_data_t
 *
stream_data
 = 
stream
->
data
;

344 
ptls_iovec_t
 
input
;

346 if (
	`quicly_streambuf_ingress_receive
(
stream
, 
off
, 
src
, 
len
) != 0)

349 if ((
input
 = 
	`quicly_streambuf_ingress_get
(
stream
)).
len
 != 0) {

350 if (!
suppress_output
) {

351 
FILE
 *
out
 = (
stream_data
->
outfp
 == 
NULL
) ? 
stdout
 : stream_data->outfp;

352 
	`fwrite
(
input
.
base
, 1, input.
len
, 
out
);

353 
	`fflush
(
out
);

355 
	`quicly_streambuf_ingress_shift
(
stream
, 
input
.
len
);

358 if (
	`quicly_recvstate_transfer_complete
(&
stream
->
recvstate
)) {

359 if (
stream_data
->
outfp
 != 
NULL
)

360 
	`fclose
(
stream_data
->
outfp
);

361 static 
size_t
 
num_resp_received
;

362 ++
num_resp_received
;

363 if (
reqs
[
num_resp_received
].
path
 == 
NULL
) {

364 if (
request_interval
 != 0) {

365 
enqueue_requests_at
 = 
ctx
.
now
->
	`cb
(ctx.now) + 
request_interval
;

367 
	`dump_stats
(
stderr
, 
stream
->
conn
);

368 
	`quicly_close
(
stream
->
conn
, 0, "");

372 
	}
}

374 static int 
	$on_stream_open
(
quicly_stream_open_t
 *
self
, 
quicly_stream_t
 *
stream
)

376 int 
ret
;

378 if ((
ret
 = 
	`quicly_streambuf_create
(
stream
, sizeof(struct 
st_stream_data_t
))) != 0)

379 return 
ret
;

380 
stream
->
callbacks
 = 
ctx
.
tls
->
certificates
.
count
 != 0 ? &
server_stream_callbacks
 : &
client_stream_callbacks
;

382 
	}
}

384 static 
quicly_stream_open_t
 
	gstream_open
 = {&
on_stream_open
};

386 static void 
	$on_closed_by_remote
(
quicly_closed_by_remote_t
 *
self
, 
quicly_conn_t
 *
conn
, int 
err
, 
uint64_t
 
frame_type
,

387 const char *
reason
, 
size_t
 
reason_len
)

389 if (
	`QUICLY_ERROR_IS_QUIC_TRANSPORT
(
err
)) {

390 
	`fprintf
(
stderr
, "transport close:code=0x%" 
PRIx16
 ";frame=%" 
PRIu64
 ";reason=%.*s\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
),

391 
frame_type
, (int)
reason_len
, 
reason
);

392 } else if (
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
)) {

393 
	`fprintf
(
stderr
, "application close:code=0x%" 
PRIx16
 ";reason=%.*s\n", 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
), (int)
reason_len
,

394 
reason
);

395 } else if (
err
 == 
QUICLY_ERROR_RECEIVED_STATELESS_RESET
) {

396 
	`fprintf
(
stderr
, "stateless reset\n");

397 } else if (
err
 == 
QUICLY_ERROR_NO_COMPATIBLE_VERSION
) {

398 
	`fprintf
(
stderr
, "no compatible version\n");

400 
	`fprintf
(
stderr
, "unexpected close:code=%d\n", 
err
);

402 
	}
}

404 static 
quicly_closed_by_remote_t
 
	gclosed_by_remote
 = {&
on_closed_by_remote
};

406 static int 
	$on_generate_resumption_token
(
quicly_generate_resumption_token_t
 *
self
, 
quicly_conn_t
 *
conn
, 
ptls_buffer_t
 *
buf
,

407 
quicly_address_token_plaintext_t
 *
token
)

409 return 
	`quicly_encrypt_address_token
(
tlsctx
.
random_bytes
, 
address_token_aead
.
enc
, 
buf
, buf->
off
, 
token
);

410 
	}
}

412 static 
quicly_generate_resumption_token_t
 
	ggenerate_resumption_token
 = {&
on_generate_resumption_token
};

414 static void 
	$send_packets_default
(int 
fd
, struct 
sockaddr
 *
dest
, struct 
iovec
 *
packets
, 
size_t
 
num_packets
)

416 for (
size_t
 
i
 = 0; i != 
num_packets
; ++i) {

417 struct 
msghdr
 
mess
;

418 
	`memset
(&
mess
, 0, sizeof(mess));

419 
mess
.
msg_name
 = 
dest
;

420 
mess
.
msg_namelen
 = 
	`quicly_get_socklen
(
dest
);

421 
mess
.
msg_iov
 = &
packets
[
i
];

422 
mess
.
msg_iovlen
 = 1;

423 if (
verbosity
 >= 2)

424 
	`hexdump
("sendmsg", 
packets
[
i
].
iov_base
, packets[i].
iov_len
);

425 int 
ret
;

426 while ((
ret
 = (int)
	`sendmsg
(
fd
, &
mess
, 0)) == -1 && 
errno
 == 
EINTR
)

428 if (
ret
 == -1)

429 
	`perror
("sendmsg failed");

431 
	}
}

433 #ifdef 
__linux__


435 #ifndef 
UDP_SEGMENT


436 #define 
	#UDP_SEGMENT
 103

	)

439 static void 
	$send_packets_gso
(int 
fd
, struct 
sockaddr
 *
dest
, struct 
iovec
 *
packets
, 
size_t
 
num_packets
)

441 struct 
iovec
 
vec
 = {.
iov_base
 = (void *)
packets
[0].iov_base,

442 .
iov_len
 = 
packets
[
num_packets
 - 1].
iov_base
 + packets[num_packets - 1].iov_len - packets[0].iov_base};

443 struct 
msghdr
 
mess
 = {

444 .
msg_name
 = 
dest
,

445 .
msg_namelen
 = 
	`quicly_get_socklen
(
dest
),

446 .
msg_iov
 = &
vec
,

447 .
msg_iovlen
 = 1,

451 struct 
cmsghdr
 
hdr
;

452 char 
buf
[
	`CMSG_SPACE
(sizeof(
uint16_t
))];

453 } 
cmsg
;

454 if (
num_packets
 != 1) {

455 
cmsg
.
hdr
.
cmsg_level
 = 
SOL_UDP
;

456 
cmsg
.
hdr
.
cmsg_type
 = 
UDP_SEGMENT
;

457 
cmsg
.
hdr
.
cmsg_len
 = 
	`CMSG_LEN
(sizeof(
uint16_t
));

458 *(
uint16_t
 *)
	`CMSG_DATA
(&
cmsg
.
hdr
) = 
packets
[0].
iov_len
;

459 
mess
.
msg_control
 = &
cmsg
;

460 
mess
.
msg_controllen
 = (
socklen_t
)
	`CMSG_SPACE
(sizeof(
uint16_t
));

463 int 
ret
;

464 while ((
ret
 = 
	`sendmsg
(
fd
, &
mess
, 0)) == -1 && 
errno
 == 
EINTR
)

466 if (
ret
 == -1)

467 
	`perror
("sendmsg failed");

468 
	}
}

472 static void (*
send_packets
)(int, struct 
sockaddr
 *, struct 
iovec
 *, 
size_t
) = 
send_packets_default
;

474 static void 
	$send_one_packet
(int 
fd
, struct 
sockaddr
 *
dest
, const void *
payload
, 
size_t
 
payload_len
)

476 struct 
iovec
 
vec
 = {.
iov_base
 = (void *)
payload
, .
iov_len
 = 
payload_len
};

477 
	`send_packets
(
fd
, 
dest
, &
vec
, 1);

478 
	}
}

480 static int 
	$send_pending
(int 
fd
, 
quicly_conn_t
 *
conn
)

482 
quicly_address_t
 
dest
, 
src
;

483 struct 
iovec
 
packets
[
MAX_BURST_PACKETS
];

484 
uint8_t
 
buf
[
MAX_BURST_PACKETS
 * 
	`quicly_get_context
(
conn
)->
transport_params
.
max_udp_payload_size
];

485 
size_t
 
num_packets
 = 
MAX_BURST_PACKETS
;

486 int 
ret
;

488 if ((
ret
 = 
	`quicly_send
(
conn
, &
dest
, &
src
, 
packets
, &
num_packets
, 
buf
, sizeof(buf))) == 0 && num_packets != 0)

489 
	`send_packets
(
fd
, &
dest
.
sa
, 
packets
, 
num_packets
);

491 return 
ret
;

492 
	}
}

494 static void 
	$on_receive_datagram_frame
(
quicly_receive_datagram_frame_t
 *
self
, 
quicly_conn_t
 *
conn
, 
ptls_iovec_t
 
payload
)

496 
	`printf
("DATAGRAM: %.*s\n", (int)
payload
.
len
, payload.
base
);

498 if (!
	`quicly_is_client
(
conn
))

499 
	`quicly_send_datagram_frames
(
conn
, &
payload
, 1);

500 
	}
}

502 static void 
	$enqueue_requests
(
quicly_conn_t
 *
conn
)

504 
size_t
 
i
;

505 int 
ret
;

507 for (
i
 = 0; 
reqs
[i].
path
 != 
NULL
; ++i) {

508 char 
req
[1024], 
destfile
[1024];

509 
quicly_stream_t
 *
stream
;

510 
ret
 = 
	`quicly_open_stream
(
conn
, &
stream
, 0);

511 
	`assert
(
ret
 == 0);

512 
	`sprintf
(
req
, "GET %s\r\n", 
reqs
[
i
].
path
);

513 
	`send_str
(
stream
, 
req
);

514 
	`quicly_streambuf_egress_shutdown
(
stream
);

516 if (
reqs
[
i
].
to_file
 && !
suppress_output
) {

517 struct 
st_stream_data_t
 *
stream_data
 = 
stream
->
data
;

518 
	`sprintf
(
destfile
, "%s.downloaded", 
	`strrchr
(
reqs
[
i
].
path
, '/') + 1);

519 
stream_data
->
outfp
 = 
	`fopen
(
destfile
, "w");

520 if (
stream_data
->
outfp
 == 
NULL
) {

521 
	`fprintf
(
stderr
, "failed to open destination file:%s:%s\n", 
reqs
[
i
].
path
, 
	`strerror
(
errno
));

522 
	`exit
(1);

526 
enqueue_requests_at
 = 
INT64_MAX
;

527 
	}
}

529 static int 
	$run_client
(int 
fd
, struct 
sockaddr
 *
sa
, const char *
host
)

531 struct 
sockaddr_in
 
local
;

532 int 
ret
;

533 
quicly_conn_t
 *
conn
 = 
NULL
;

535 
	`memset
(&
local
, 0, sizeof(local));

536 
local
.
sin_family
 = 
AF_INET
;

537 if (
	`bind
(
fd
, (void *)&
local
, sizeof(local)) != 0) {

538 
	`perror
("bind(2) failed");

541 
ret
 = 
	`quicly_connect
(&
conn
, &
ctx
, 
host
, 
sa
, 
NULL
, &
next_cid
, 
resumption_token
, &
hs_properties
, &
resumed_transport_params
);

542 
	`assert
(
ret
 == 0);

543 ++
next_cid
.
master_id
;

544 
	`enqueue_requests
(
conn
);

545 
	`send_pending
(
fd
, 
conn
);

548 
fd_set
 
readfds
;

549 struct 
timeval
 *
tv
, 
tvbuf
;

551 
int64_t
 
timeout_at
 = 
conn
 != 
NULL
 ? 
	`quicly_get_first_timeout
(conn) : 
INT64_MAX
;

552 if (
enqueue_requests_at
 < 
timeout_at
)

553 
timeout_at
 = 
enqueue_requests_at
;

554 if (
timeout_at
 != 
INT64_MAX
) {

555 
quicly_context_t
 *
ctx
 = 
	`quicly_get_context
(
conn
);

556 
int64_t
 
delta
 = 
timeout_at
 - 
ctx
->
now
->
	`cb
(ctx->now);

557 if (
delta
 > 0) {

558 
tvbuf
.
tv_sec
 = 
delta
 / 1000;

559 
tvbuf
.
tv_usec
 = (
delta
 % 1000) * 1000;

561 
tvbuf
.
tv_sec
 = 0;

562 
tvbuf
.
tv_usec
 = 0;

564 
tv
 = &
tvbuf
;

566 
tv
 = 
NULL
;

568 
	`FD_ZERO
(&
readfds
);

569 
	`FD_SET
(
fd
, &
readfds
);

570 } while (
	`select
(
fd
 + 1, &
readfds
, 
NULL
, NULL, 
tv
) == -1 && 
errno
 == 
EINTR
);

571 if (
enqueue_requests_at
 <= 
ctx
.
now
->
	`cb
(ctx.now))

572 
	`enqueue_requests
(
conn
);

573 if (
	`FD_ISSET
(
fd
, &
readfds
)) {

575 
uint8_t
 
buf
[
ctx
.
transport_params
.
max_udp_payload_size
];

576 struct 
msghdr
 
mess
;

577 struct 
sockaddr
 
sa
;

578 struct 
iovec
 
vec
;

579 
	`memset
(&
mess
, 0, sizeof(mess));

580 
mess
.
msg_name
 = &
sa
;

581 
mess
.
msg_namelen
 = sizeof(
sa
);

582 
vec
.
iov_base
 = 
buf
;

583 
vec
.
iov_len
 = sizeof(
buf
);

584 
mess
.
msg_iov
 = &
vec
;

585 
mess
.
msg_iovlen
 = 1;

586 
ssize_t
 
rret
;

587 while ((
rret
 = 
	`recvmsg
(
fd
, &
mess
, 0)) == -1 && 
errno
 == 
EINTR
)

589 if (
rret
 <= 0)

591 if (
verbosity
 >= 2)

592 
	`hexdump
("recvmsg", 
buf
, 
rret
);

593 
size_t
 
off
 = 0;

594 while (
off
 != 
rret
) {

595 
quicly_decoded_packet_t
 
packet
;

596 if (
	`quicly_decode_packet
(&
ctx
, &
packet
, 
buf
, 
rret
, &
off
) == 
SIZE_MAX
)

598 
	`quicly_receive
(
conn
, 
NULL
, &
sa
, &
packet
);

599 if (
send_datagram_frame
 && 
	`quicly_connection_is_ready
(
conn
)) {

600 const char *
message
 = "hello datagram!";

601 
ptls_iovec_t
 
datagram
 = 
	`ptls_iovec_init
(
message
, 
	`strlen
(message));

602 
	`quicly_send_datagram_frames
(
conn
, &
datagram
, 1);

603 
send_datagram_frame
 = 0;

608 if (
conn
 != 
NULL
) {

609 
ret
 = 
	`send_pending
(
fd
, 
conn
);

610 if (
ret
 != 0) {

611 
	`quicly_free
(
conn
);

612 
conn
 = 
NULL
;

613 if (
ret
 == 
QUICLY_ERROR_FREE_CONNECTION
) {

616 
	`fprintf
(
stderr
, "quicly_send returned %d\n", 
ret
);

622 
	}
}

624 static 
quicly_conn_t
 **
	gconns
;

625 static 
size_t
 
	gnum_conns
 = 0;

627 static void 
	$on_signal
(int 
signo
)

629 
size_t
 
i
;

630 for (
i
 = 0; i != 
num_conns
; ++i) {

631 const 
quicly_cid_plaintext_t
 *
master_id
 = 
	`quicly_get_master_id
(
conns
[
i
]);

632 
	`fprintf
(
stderr
, "conn:%08" 
PRIu32
 ": ", 
master_id
->master_id);

633 
	`dump_stats
(
stderr
, 
conns
[
i
]);

635 if (
signo
 == 
SIGINT
)

636 
	`_exit
(0);

637 
	}
}

639 static int 
	$validate_token
(struct 
sockaddr
 *
remote
, 
ptls_iovec_t
 
client_cid
, ptls_iovec_t 
server_cid
,

640 
quicly_address_token_plaintext_t
 *
token
, const char **
err_desc
)

642 
int64_t
 
age
;

643 int 
port_is_equal
;

646 if ((
age
 = 
ctx
.
now
->
	`cb
(ctx.now) - 
token
->
issued_at
) < 0)

647 
age
 = 0;

650 if (
remote
->
sa_family
 != 
token
->remote.
sa
.sa_family)

651 goto 
AddressMismatch
;

652 switch (
remote
->
sa_family
) {

653 case 
AF_INET
: {

654 struct 
sockaddr_in
 *
sin
 = (struct sockaddr_in *)
remote
;

655 if (
sin
->
sin_addr
.
s_addr
 != 
token
->
remote
.sin.sin_addr.s_addr)

656 goto 
AddressMismatch
;

657 
port_is_equal
 = 
sin
->
sin_port
 == 
token
->
remote
.sin.sin_port;

659 case 
AF_INET6
: {

660 struct 
sockaddr_in6
 *
sin6
 = (struct sockaddr_in6 *)
remote
;

661 if (
	`memcmp
(&
sin6
->
sin6_addr
, &
token
->
remote
.sin6.sin6_addr, sizeof(sin6->sin6_addr)) != 0)

662 goto 
AddressMismatch
;

663 
port_is_equal
 = 
sin6
->
sin6_port
 == 
token
->
remote
.sin6.sin6_port;

666 goto 
UnknownAddressType
;

670 switch (
token
->
type
) {

671 case 
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
:

672 if (
age
 > 30000)

673 goto 
Expired
;

674 if (!
port_is_equal
)

675 goto 
AddressMismatch
;

676 if (!
	`quicly_cid_is_equal
(&
token
->
retry
.
client_cid
, client_cid))

677 goto 
CIDMismatch
;

678 if (!
	`quicly_cid_is_equal
(&
token
->
retry
.
server_cid
, server_cid))

679 goto 
CIDMismatch
;

681 case 
QUICLY_ADDRESS_TOKEN_TYPE_RESUMPTION
:

682 if (
age
 > 10 * 60 * 1000)

683 goto 
Expired
;

686 
	`assert
(!"unexpected token type");

687 
	`abort
();

692 *
err_desc
 = 
NULL
;

695 
AddressMismatch
:

696 *
err_desc
 = "token address mismatch";

698 
UnknownAddressType
:

699 *
err_desc
 = "unknown address type";

701 
Expired
:

702 *
err_desc
 = "token expired";

704 
CIDMismatch
:

705 *
err_desc
 = "CID mismatch";

707 
	}
}

709 static int 
	$run_server
(int 
fd
, struct 
sockaddr
 *
sa
, 
socklen_t
 
salen
)

711 
	`signal
(
SIGINT
, 
on_signal
);

712 
	`signal
(
SIGHUP
, 
on_signal
);

714 if (
	`bind
(
fd
, 
sa
, 
salen
) != 0) {

715 
	`perror
("bind(2) failed");

720 
fd_set
 
readfds
;

721 struct 
timeval
 *
tv
, 
tvbuf
;

723 
int64_t
 
timeout_at
 = 
INT64_MAX
;

724 
size_t
 
i
;

725 for (
i
 = 0; i != 
num_conns
; ++i) {

726 
int64_t
 
conn_to
 = 
	`quicly_get_first_timeout
(
conns
[
i
]);

727 if (
conn_to
 < 
timeout_at
)

728 
timeout_at
 = 
conn_to
;

730 if (
timeout_at
 != 
INT64_MAX
) {

731 
int64_t
 
delta
 = 
timeout_at
 - 
ctx
.
now
->
	`cb
(ctx.now);

732 if (
delta
 > 0) {

733 
tvbuf
.
tv_sec
 = 
delta
 / 1000;

734 
tvbuf
.
tv_usec
 = (
delta
 % 1000) * 1000;

736 
tvbuf
.
tv_sec
 = 0;

737 
tvbuf
.
tv_usec
 = 0;

739 
tv
 = &
tvbuf
;

741 
tv
 = 
NULL
;

743 
	`FD_ZERO
(&
readfds
);

744 
	`FD_SET
(
fd
, &
readfds
);

745 } while (
	`select
(
fd
 + 1, &
readfds
, 
NULL
, NULL, 
tv
) == -1 && 
errno
 == 
EINTR
);

746 if (
	`FD_ISSET
(
fd
, &
readfds
)) {

748 
uint8_t
 
buf
[
ctx
.
transport_params
.
max_udp_payload_size
];

749 struct 
msghdr
 
mess
;

750 
quicly_address_t
 
remote
;

751 struct 
iovec
 
vec
;

752 
	`memset
(&
mess
, 0, sizeof(mess));

753 
mess
.
msg_name
 = &
remote
.
sa
;

754 
mess
.
msg_namelen
 = sizeof(
remote
);

755 
vec
.
iov_base
 = 
buf
;

756 
vec
.
iov_len
 = sizeof(
buf
);

757 
mess
.
msg_iov
 = &
vec
;

758 
mess
.
msg_iovlen
 = 1;

759 
ssize_t
 
rret
;

760 while ((
rret
 = 
	`recvmsg
(
fd
, &
mess
, 0)) == -1 && 
errno
 == 
EINTR
)

762 if (
rret
 == -1)

764 if (
verbosity
 >= 2)

765 
	`hexdump
("recvmsg", 
buf
, 
rret
);

766 
size_t
 
off
 = 0;

767 while (
off
 != 
rret
) {

768 
quicly_decoded_packet_t
 
packet
;

769 if (
	`quicly_decode_packet
(&
ctx
, &
packet
, 
buf
, 
rret
, &
off
) == 
SIZE_MAX
)

771 if (
	`QUICLY_PACKET_IS_LONG_HEADER
(
packet
.
octets
.
base
[0])) {

772 if (
packet
.
version
 != 0 && !
	`quicly_is_supported_version
(packet.version)) {

773 
uint8_t
 
payload
[
ctx
.
transport_params
.
max_udp_payload_size
];

774 
size_t
 
payload_len
 = 
	`quicly_send_version_negotiation
(&
ctx
, 
packet
.
cid
.
src
, packet.cid.
dest
.
encrypted
,

775 
quicly_supported_versions
, 
payload
);

776 
	`assert
(
payload_len
 != 
SIZE_MAX
);

777 
	`send_one_packet
(
fd
, &
remote
.
sa
, 
payload
, 
payload_len
);

781 if (
packet
.
cid
.
dest
.
encrypted
.
len
 > 
QUICLY_MAX_CID_LEN_V1
 || packet.cid.
src
.len > QUICLY_MAX_CID_LEN_V1)

785 
quicly_conn_t
 *
conn
 = 
NULL
;

786 
size_t
 
i
;

787 for (
i
 = 0; i != 
num_conns
; ++i) {

788 if (
	`quicly_is_destination
(
conns
[
i
], 
NULL
, &
remote
.
sa
, &
packet
)) {

789 
conn
 = 
conns
[
i
];

793 if (
conn
 != 
NULL
) {

795 
	`quicly_receive
(
conn
, 
NULL
, &
remote
.
sa
, &
packet
);

796 } else if (
	`QUICLY_PACKET_IS_INITIAL
(
packet
.
octets
.
base
[0])) {

798 
quicly_address_token_plaintext_t
 *
token
 = 
NULL
, 
token_buf
;

799 if (
packet
.
token
.
len
 != 0) {

800 const char *
err_desc
 = 
NULL
;

801 int 
ret
 = 
	`quicly_decrypt_address_token
(
address_token_aead
.
dec
, &
token_buf
, 
packet
.
token
.
base
,

802 
packet
.
token
.
len
, 0, &
err_desc
);

803 if (
ret
 == 0 &&

804 
	`validate_token
(&
remote
.
sa
, 
packet
.
cid
.
src
, packet.cid.
dest
.
encrypted
, &
token_buf
, &
err_desc
)) {

805 
token
 = &
token_buf
;

806 } else if (
enforce_retry
 && (
ret
 == 
QUICLY_TRANSPORT_ERROR_INVALID_TOKEN
 ||

807 (
ret
 == 0 && 
token_buf
.
type
 == 
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
))) {

810 
uint8_t
 
payload
[
ctx
.
transport_params
.
max_udp_payload_size
];

811 
size_t
 
payload_len
 = 
	`quicly_send_close_invalid_token
(&
ctx
, 
packet
.
version
, packet.
cid
.
src
,

812 
packet
.
cid
.
dest
.
encrypted
, 
err_desc
, 
payload
);

813 
	`assert
(
payload_len
 != 
SIZE_MAX
);

814 
	`send_one_packet
(
fd
, &
remote
.
sa
, 
payload
, 
payload_len
);

817 if (
enforce_retry
 && 
token
 == 
NULL
 && 
packet
.
cid
.
dest
.
encrypted
.
len
 >= 8) {

821 
uint8_t
 
new_server_cid
[8], 
payload
[
ctx
.
transport_params
.
max_udp_payload_size
];

822 
	`memcpy
(
new_server_cid
, 
packet
.
cid
.
dest
.
encrypted
.
base
, sizeof(new_server_cid));

823 
new_server_cid
[0] ^= 0xff;

824 
size_t
 
payload_len
 = 
	`quicly_send_retry
(

825 &
ctx
, 
address_token_aead
.
enc
, 
packet
.
version
, &
remote
.
sa
, packet.
cid
.
src
, 
NULL
,

826 
	`ptls_iovec_init
(
new_server_cid
, sizeof(new_server_cid)), 
packet
.
cid
.
dest
.
encrypted
,

827 
	`ptls_iovec_init
(
NULL
, 0), ptls_iovec_init(NULL, 0), NULL, 
payload
);

828 
	`assert
(
payload_len
 != 
SIZE_MAX
);

829 
	`send_one_packet
(
fd
, &
remote
.
sa
, 
payload
, 
payload_len
);

833 int 
ret
 = 
	`quicly_accept
(&
conn
, &
ctx
, 
NULL
, &
remote
.
sa
, &
packet
, 
token
, &
next_cid
, NULL);

834 if (
ret
 == 0) {

835 
	`assert
(
conn
 != 
NULL
);

836 ++
next_cid
.
master_id
;

837 
conns
 = 
	`realloc
(conns, sizeof(*conns) * (
num_conns
 + 1));

838 
	`assert
(
conns
 != 
NULL
);

839 
conns
[
num_conns
++] = 
conn
;

841 
	`assert
(
conn
 == 
NULL
);

844 } else if (!
	`QUICLY_PACKET_IS_LONG_HEADER
(
packet
.
octets
.
base
[0])) {

848 if (
packet
.
cid
.
dest
.
plaintext
.
node_id
 == 0 && packet.cid.dest.plaintext.
thread_id
 == 0) {

849 
uint8_t
 
payload
[
ctx
.
transport_params
.
max_udp_payload_size
];

850 
size_t
 
payload_len
 = 
	`quicly_send_stateless_reset
(&
ctx
, 
packet
.
cid
.
dest
.
encrypted
.
base
, 
payload
);

851 
	`assert
(
payload_len
 != 
SIZE_MAX
);

852 
	`send_one_packet
(
fd
, &
remote
.
sa
, 
payload
, 
payload_len
);

859 
size_t
 
i
;

860 for (
i
 = 0; i != 
num_conns
; ++i) {

861 if (
	`quicly_get_first_timeout
(
conns
[
i
]) <= 
ctx
.
now
->
	`cb
(ctx.now)) {

862 if (
	`send_pending
(
fd
, 
conns
[
i
]) != 0) {

863 
	`dump_stats
(
stderr
, 
conns
[
i
]);

864 
	`quicly_free
(
conns
[
i
]);

865 
	`memmove
(
conns
 + 
i
, conns + i + 1, (
num_conns
 - i - 1) * sizeof(*conns));

866 --
i
;

867 --
num_conns
;

873 
	}
}

875 static void 
	$load_session
(void)

877 static 
uint8_t
 
buf
[65536];

878 
size_t
 
len
;

879 int 
ret
;

882 
FILE
 *
fp
;

883 if ((
fp
 = 
	`fopen
(
session_file
, "rb")) == 
NULL
)

885 
len
 = 
	`fread
(
buf
, 1, sizeof(buf), 
fp
);

886 if (
len
 == 0 || !
	`feof
(
fp
)) {

887 
	`fprintf
(
stderr
, "failed to load ticket from file:%s\n", 
session_file
);

888 
	`exit
(1);

890 
	`fclose
(
fp
);

894 const 
uint8_t
 *
src
 = 
buf
, *
end
 = buf + 
len
;

895 
ptls_iovec_t
 
ticket
;

896 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

897 if ((
resumption_token
.
len
 = 
end
 - 
src
) != 0) {

898 
resumption_token
.
base
 = 
	`malloc
(resumption_token.
len
);

899 
	`memcpy
(
resumption_token
.
base
, 
src
, resumption_token.
len
);

901 
src
 = 
end
;

903 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

904 
ticket
 = 
	`ptls_iovec_init
(
src
, 
end
 - src);

905 
src
 = 
end
;

907 
	`ptls_decode_open_block
(
src
, 
end
, 2, {

908 if ((
ret
 = 
	`quicly_decode_transport_parameter_list
(&
resumed_transport_params
, 
NULL
, NULL, NULL, NULL, 
src
, 
end
, 0)) != 0)

909 goto 
Exit
;

910 
src
 = 
end
;

912 
hs_properties
.
client
.
session_ticket
 = 
ticket
;

915 
Exit
:;

916 
	}
}

919 
ptls_iovec_t
 
	mtls_ticket
;

920 
ptls_iovec_t
 
	maddress_token
;

921 } 
	gsession_info
;

923 int 
	$save_session
(const 
quicly_transport_parameters_t
 *
transport_params
)

925 
ptls_buffer_t
 
buf
;

926 
FILE
 *
fp
 = 
NULL
;

927 int 
ret
;

929 if (
session_file
 == 
NULL
)

932 
	`ptls_buffer_init
(&
buf
, "", 0);

935 
	`ptls_buffer_push_block
(&
buf
, 2, { 
	`ptls_buffer_pushv
(&buf, 
session_info
.
address_token
.
base
, session_info.address_token.
len
); });

936 
	`ptls_buffer_push_block
(&
buf
, 2, { 
	`ptls_buffer_pushv
(&buf, 
session_info
.
tls_ticket
.
base
, session_info.tls_ticket.
len
); });

937 
	`ptls_buffer_push_block
(&
buf
, 2, {

938 if ((
ret
 = 
	`quicly_encode_transport_parameter_list
(&
buf
, 
transport_params
, 
NULL
, NULL, NULL, NULL, 0)) != 0)

939 goto 
Exit
;

943 if ((
fp
 = 
	`fopen
(
session_file
, "wb")) == 
NULL
) {

944 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
session_file
, 
	`strerror
(
errno
));

945 
ret
 = 
PTLS_ERROR_LIBRARY
;

946 goto 
Exit
;

948 
	`fwrite
(
buf
.
base
, 1, buf.
off
, 
fp
);

950 
ret
 = 0;

951 
Exit
:

952 if (
fp
 != 
NULL
)

953 
	`fclose
(
fp
);

954 
	`ptls_buffer_dispose
(&
buf
);

956 
	}
}

958 int 
	$save_session_ticket_cb
(
ptls_save_ticket_t
 *
_self
, 
ptls_t
 *
tls
, 
ptls_iovec_t
 
src
)

960 
	`free
(
session_info
.
tls_ticket
.
base
);

961 
session_info
.
tls_ticket
 = 
	`ptls_iovec_init
(
	`malloc
(
src
.
len
), src.len);

962 
	`memcpy
(
session_info
.
tls_ticket
.
base
, 
src
.base, src.
len
);

964 
quicly_conn_t
 *
conn
 = *
	`ptls_get_data_ptr
(
tls
);

965 return 
	`save_session
(
	`quicly_get_remote_transport_parameters
(
conn
));

966 
	}
}

968 static int 
	$save_resumption_token_cb
(
quicly_save_resumption_token_t
 *
_self
, 
quicly_conn_t
 *
conn
, 
ptls_iovec_t
 
token
)

970 
	`free
(
session_info
.
address_token
.
base
);

971 
session_info
.
address_token
 = 
	`ptls_iovec_init
(
	`malloc
(
token
.
len
), token.len);

972 
	`memcpy
(
session_info
.
address_token
.
base
, 
token
.base, token.
len
);

974 return 
	`save_session
(
	`quicly_get_remote_transport_parameters
(
conn
));

975 
	}
}

977 static 
quicly_save_resumption_token_t
 
	gsave_resumption_token
 = {
save_resumption_token_cb
};

979 static int 
	$on_client_hello_cb
(
ptls_on_client_hello_t
 *
_self
, 
ptls_t
 *
tls
, 
ptls_on_client_hello_parameters_t
 *
params
)

981 int 
ret
;

983 if (
negotiated_protocols
.
count
 != 0) {

984 
size_t
 
i
, 
j
;

985 const 
ptls_iovec_t
 *
x
, *
y
;

986 for (
i
 = 0; i != 
negotiated_protocols
.
count
; ++i) {

987 
x
 = 
negotiated_protocols
.
list
 + 
i
;

988 for (
j
 = 0; j != 
params
->
negotiated_protocols
.
count
; ++j) {

989 
y
 = 
params
->
negotiated_protocols
.
list
 + 
j
;

990 if (
x
->
len
 == 
y
->len && 
	`memcmp
(x->
base
, y->base, x->len) == 0)

991 goto 
ALPN_Found
;

994 return 
PTLS_ALERT_NO_APPLICATION_PROTOCOL
;

995 
ALPN_Found
:

996 if ((
ret
 = 
	`ptls_set_negotiated_protocol
(
tls
, (const char *)
x
->
base
, x->
len
)) != 0)

997 return 
ret
;

1001 
	}
}

1003 static void 
	$usage
(const char *
cmd
)

1005 
	`printf
("Usage: %s [options] host port\n"

1054 
cmd
);

1055 
	}
}

1057 static void 
	$push_req
(const char *
path
, int 
to_file
)

1059 
size_t
 
i
;

1060 for (
i
 = 0; 
reqs
[i].
path
 != 
NULL
; ++i)

1062 
reqs
 = 
	`realloc
(reqs, sizeof(*reqs) * (
i
 + 2));

1063 
reqs
[
i
].
path
 = path;

1064 
reqs
[
i
].
to_file
 = to_file;

1065 
	`memset
(
reqs
 + 
i
 + 1, 0, sizeof(*reqs));

1066 
	}
}

1068 int 
	$main
(int 
argc
, char **
argv
)

1070 const char *
cert_file
 = 
NULL
, *
raw_pubkey_file
 = NULL, *
host
, *
port
, *
cid_key
 = NULL;

1071 struct 
sockaddr_storage
 
sa
;

1072 
socklen_t
 
salen
;

1073 unsigned 
udpbufsize
 = 0;

1074 int 
ch
, 
fd
;

1076 
reqs
 = 
	`malloc
(sizeof(*reqs));

1077 
	`memset
(
reqs
, 0, sizeof(*reqs));

1078 
ctx
 = 
quicly_spec_context
;

1079 
ctx
.
tls
 = &
tlsctx
;

1080 
ctx
.
stream_open
 = &stream_open;

1081 
ctx
.
closed_by_remote
 = &closed_by_remote;

1082 
ctx
.
save_resumption_token
 = &save_resumption_token;

1083 
ctx
.
generate_resumption_token
 = &generate_resumption_token;

1085 
	`setup_session_cache
(
ctx
.
tls
);

1086 
	`quicly_amend_ptls_context
(
ctx
.
tls
);

1089 
uint8_t
 
secret
[
PTLS_MAX_DIGEST_SIZE
];

1090 
ctx
.
tls
->
	`random_bytes
(
secret
, 
ptls_openssl_sha256
.
digest_size
);

1091 
address_token_aead
.
enc
 = 
	`ptls_aead_new
(&
ptls_openssl_aes128gcm
, &
ptls_openssl_sha256
, 1, 
secret
, "");

1092 
address_token_aead
.
dec
 = 
	`ptls_aead_new
(&
ptls_openssl_aes128gcm
, &
ptls_openssl_sha256
, 0, 
secret
, "");

1095 while ((
ch
 = 
	`getopt
(
argc
, 
argv
, "a:b:B:c:C:Dd:k:Ee:Gi:I:K:l:M:m:NnOp:P:Rr:S:s:u:U:Vvw:W:x:X:y:h")) != -1) {

1096 switch (
ch
) {

1098 
	`assert
(
negotiated_protocols
.
count
 < 
	`PTLS_ELEMENTSOF
(negotiated_protocols.
list
));

1099 
negotiated_protocols
.
list
[negotiated_protocols.
count
++] = 
	`ptls_iovec_init
(
optarg
, 
	`strlen
(optarg));

1102 if (
	`sscanf
(
optarg
, "%u", &
udpbufsize
) != 1) {

1103 
	`fprintf
(
stderr
, "failed to parse buffer size: %s\n", 
optarg
);

1104 
	`exit
(1);

1108 
cid_key
 = 
optarg
;

1111 
cert_file
 = 
optarg
;

1114 
quicly_cc_type_t
 **
cc
;

1115 for (
cc
 = 
quicly_cc_all_types
; *cc != 
NULL
; ++cc)

1116 if (
	`strcmp
((*
cc
)->
name
, 
optarg
) == 0)

1118 if (*
cc
 != 
NULL
) {

1119 
ctx
.
init_cc
 = (*
cc
)->
cc_init
;

1121 
	`fprintf
(
stderr
, "unknown congestion controller: %s\n", 
optarg
);

1122 
	`exit
(1);

1126 #ifdef 
__linux__


1127 
send_packets
 = 
send_packets_gso
;

1129 
	`fprintf
(
stderr
, "UDP GSO only supported on linux\n");

1130 
	`exit
(1);

1134 
	`load_private_key
(
ctx
.
tls
, 
optarg
);

1137 
uint8_t
 
draft_ver
;

1138 if (
	`sscanf
(
optarg
, "%" 
SCNu8
, &
draft_ver
) != 1) {

1139 
	`fprintf
(
stderr
, "failed to parse draft number: %s\n", 
optarg
);

1140 
	`exit
(1);

1142 
ctx
.
initial_version
 = 0xff000000 | 
draft_ver
;

1145 
send_datagram_frame
 = 1;

1148 
ctx
.
expand_client_hello
 = 1;

1151 if ((
quicly_trace_fp
 = 
	`fopen
(
optarg
, "w")) == 
NULL
) {

1152 
	`fprintf
(
stderr
, "failed to open file:%s:%s\n", 
optarg
, 
	`strerror
(
errno
));

1153 
	`exit
(1);

1155 
	`setvbuf
(
quicly_trace_fp
, 
NULL
, 
_IONBF
, 0);

1158 if (
	`sscanf
(
optarg
, "%" 
SCNd64
, &
request_interval
) != 1) {

1159 
	`fprintf
(
stderr
, "failed to parse request interval: %s\n", 
optarg
);

1160 
	`exit
(1);

1164 if (
	`sscanf
(
optarg
, "%" 
SCNd64
, &
ctx
.
transport_params
.
max_idle_timeout
) != 1) {

1165 
	`fprintf
(
stderr
, "failed to parse idle timeout: %s\n", 
optarg
);

1166 
	`exit
(1);

1169 if (
	`sscanf
(
optarg
, "%" 
SCNu64
, &
ctx
.
max_packets_per_key
) != 1) {

1170 
	`fprintf
(
stderr
, "failed to parse key update interval: %s\n", 
optarg
);

1171 
	`exit
(1);

1175 
	`setup_log_event
(
ctx
.
tls
, 
optarg
);

1178 
uint64_t
 
v
;

1179 if (
	`sscanf
(
optarg
, "%" 
SCNu64
, &
v
) != 1) {

1180 
	`fprintf
(
stderr
, "failed to parse max stream data:%s\n", 
optarg
);

1181 
	`exit
(1);

1183 
ctx
.
transport_params
.
max_stream_data
.
bidi_local
 = 
v
;

1184 
ctx
.
transport_params
.
max_stream_data
.
bidi_remote
 = 
v
;

1185 
ctx
.
transport_params
.
max_stream_data
.
uni
 = 
v
;

1188 if (
	`sscanf
(
optarg
, "%" 
SCNu64
, &
ctx
.
transport_params
.
max_data
) != 1) {

1189 
	`fprintf
(
stderr
, "failed to parse max data:%s\n", 
optarg
);

1190 
	`exit
(1);

1194 
hs_properties
.
client
.
negotiate_before_key_exchange
 = 1;

1197 
ctx
.
initial_version
 = 0xabababa;

1200 
suppress_output
 = 1;

1204 if (!
	`validate_path
(
optarg
)) {

1205 
	`fprintf
(
stderr
, "invalid path:%s\n", 
optarg
);

1206 
	`exit
(1);

1208 
	`push_req
(
optarg
, 
ch
 == 'P');

1211 
enforce_retry
 = 1;

1214 if (
	`sscanf
(
optarg
, "%" 
SCNu32
, &
ctx
.
loss
.
default_initial_rtt
) != 1) {

1215 
	`fprintf
(
stderr
, "invalid argument passed to `-r`\n");

1216 
	`exit
(1);

1220 if (
	`sscanf
(
optarg
, "%" 
SCNu8
, &
ctx
.
loss
.
num_speculative_ptos
) != 1) {

1221 
	`fprintf
(
stderr
, "invalid argument passed to `-S`\n");

1222 
	`exit
(1);

1226 
session_file
 = 
optarg
;

1229 if (
	`sscanf
(
optarg
, "%" 
SCNu16
, &
ctx
.
initial_egress_max_udp_payload_size
) != 1) {

1230 
	`fprintf
(
stderr
, "invalid argument passed to `-u`\n");

1231 
	`exit
(1);

1235 if (
	`sscanf
(
optarg
, "%" 
SCNu64
, &
ctx
.
transport_params
.
max_udp_payload_size
) != 1) {

1236 
	`fprintf
(
stderr
, "invalid argument passed to `-U`\n");

1237 
	`exit
(1);

1241 
	`setup_verify_certificate
(
ctx
.
tls
, 
NULL
);

1244 ++
verbosity
;

1247 if (
	`sscanf
(
optarg
, "%" 
SCNu32
, &
ctx
.
initcwnd_packets
) != 1) {

1248 
	`fprintf
(
stderr
, "invalid argument passed to `-w`\n");

1249 
	`exit
(1);

1253 
raw_pubkey_file
 = 
optarg
;

1256 
size_t
 
i
;

1257 for (
i
 = 0; 
key_exchanges
[i] != 
NULL
; ++i)

1259 #define 
	#MATCH
(
name
) \

1260 if (
key_exchanges
[
i
] == 
NULL
 && 
	`strcasecmp
(
optarg
, #name) == 0) \

1261 
key_exchanges
[
i
] = &
ptls_openssl_
##
name


	)

1262 
	`MATCH
(
secp256r1
);

1263 #if 
PTLS_OPENSSL_HAVE_SECP384R1


1264 
	`MATCH
(
secp384r1
);

1266 #if 
PTLS_OPENSSL_HAVE_SECP521R1


1267 
	`MATCH
(
secp521r1
);

1269 #if 
PTLS_OPENSSL_HAVE_X25519


1270 
	`MATCH
(
x25519
);

1272 #undef 
MATCH


1273 if (
key_exchanges
[
i
] == 
NULL
) {

1274 
	`fprintf
(
stderr
, "unknown key exchange: %s\n", 
optarg
);

1275 
	`exit
(1);

1279 if (
	`sscanf
(
optarg
, "%" 
SCNu64
, &
ctx
.
transport_params
.
max_streams_bidi
) != 1) {

1280 
	`fprintf
(
stderr
, "failed to parse max streams count: %s\n", 
optarg
);

1281 
	`exit
(1);

1285 
size_t
 
i
;

1286 for (
i
 = 0; 
cipher_suites
[i] != 
NULL
; ++i)

1288 #define 
	#MATCH
(
name
, 
engine
) \

1289 if (
cipher_suites
[
i
] == 
NULL
 && 
	`strcasecmp
(
optarg
, #name) == 0) \

1290 
cipher_suites
[
i
] = &
engine
##
_
##
name


	)

1291 #if 
QUICLY_HAVE_FUSION


1292 
	`MATCH
(
aes128gcmsha256
, 
fusion
);

1293 
	`MATCH
(
aes256gcmsha384
, 
fusion
);

1295 
	`MATCH
(
aes128gcmsha256
, 
ptls_openssl
);

1296 
	`MATCH
(
aes256gcmsha384
, 
ptls_openssl
);

1297 #if 
PTLS_OPENSSL_HAVE_CHACHA20_POLY1305


1298 
	`MATCH
(
chacha20poly1305sha256
, 
ptls_openssl
);

1300 #undef 
MATCH


1301 if (
cipher_suites
[
i
] == 
NULL
) {

1302 
	`fprintf
(
stderr
, "unknown cipher-suite: %s\n", 
optarg
);

1303 
	`exit
(1);

1307 
	`usage
(
argv
[0]);

1308 
	`exit
(1);

1311 
argc
 -= 
optind
;

1312 
argv
 += 
optind
;

1314 if (
reqs
[0].
path
 == 
NULL
)

1315 
	`push_req
("/", 0);

1317 if (
key_exchanges
[0] == 
NULL
)

1318 
key_exchanges
[0] = &
ptls_openssl_secp256r1
;

1322 if (
cipher_suites
[0] == 
NULL
) {

1323 
size_t
 
i
;

1324 for (
i
 = 0; 
ptls_openssl_cipher_suites
[i] != 
NULL
; ++i) {

1325 
cipher_suites
[
i
] = 
ptls_openssl_cipher_suites
[i];

1326 #if 
QUICLY_HAVE_FUSION


1327 if (
cipher_suites
[
i
]->
id
 == 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
) {

1328 
cipher_suites
[
i
] = &
fusion_aes128gcmsha256
;

1329 } else if (
cipher_suites
[
i
]->
id
 == 
PTLS_CIPHER_SUITE_AES_256_GCM_SHA384
) {

1330 
cipher_suites
[
i
] = &
fusion_aes256gcmsha384
;

1335 
size_t
 
i
;

1336 for (
i
 = 0; 
cipher_suites
[i] != 
NULL
; ++i) {

1337 if (
cipher_suites
[
i
]->
id
 == 
PTLS_CIPHER_SUITE_AES_128_GCM_SHA256
)

1338 goto 
MandatoryCipherFound
;

1340 
	`fprintf
(
stderr
, "aes128gcmsha256 MUST be one of the cipher-suites specified using `-y`\n");

1342 
MandatoryCipherFound
:;

1346 if (
send_datagram_frame
) {

1347 static 
quicly_receive_datagram_frame_t
 
cb
 = {
on_receive_datagram_frame
};

1348 
ctx
.
receive_datagram_frame
 = &
cb
;

1349 
ctx
.
transport_params
.
max_datagram_frame_size
 = ctx.transport_params.
max_udp_payload_size
;

1352 if (
cert_file
 != 
NULL
 || 
ctx
.
tls
->
sign_certificate
 != NULL) {

1354 if (
cert_file
 == 
NULL
 || 
ctx
.
tls
->
sign_certificate
 == NULL) {

1355 
	`fprintf
(
stderr
, "-c and -k options must be used together\n");

1356 
	`exit
(1);

1358 if (
raw_pubkey_file
 != 
NULL
) {

1359 
ctx
.
tls
->
certificates
.
list
 = 
	`malloc
(sizeof(*ctx.tls->certificates.list));

1360 
	`load_raw_public_key
(
ctx
.
tls
->
certificates
.
list
, 
cert_file
);

1361 
ctx
.
tls
->
certificates
.
count
 = 1;

1362 
ctx
.
tls
->
use_raw_public_keys
 = 1;

1364 
	`load_certificate_chain
(
ctx
.
tls
, 
cert_file
);

1366 if (
cid_key
 == 
NULL
) {

1367 static char 
random_key
[17];

1368 
tlsctx
.
	`random_bytes
(
random_key
, sizeof(random_key) - 1);

1369 
cid_key
 = 
random_key
;

1371 
ctx
.
cid_encryptor
 = 
	`quicly_new_default_cid_encryptor
(&
ptls_openssl_bfecb
, &
ptls_openssl_aes128ecb
, &
ptls_openssl_sha256
,

1372 
	`ptls_iovec_init
(
cid_key
, 
	`strlen
(cid_key)));

1375 if (
raw_pubkey_file
 != 
NULL
) {

1376 
ptls_iovec_t
 
raw_pub_key
;

1377 
EVP_PKEY
 *
pubkey
;

1378 
	`load_raw_public_key
(&
raw_pub_key
, 
raw_pubkey_file
);

1379 
pubkey
 = 
	`d2i_PUBKEY
(
NULL
, (const unsigned char **)&
raw_pub_key
.
base
, raw_pub_key.
len
);

1380 if (
pubkey
 == 
NULL
) {

1381 
	`fprintf
(
stderr
, "Failed to create an EVP_PKEY from the key found in %s\n", 
raw_pubkey_file
);

1384 
	`setup_raw_pubkey_verify_certificate
(
ctx
.
tls
, 
pubkey
);

1385 
	`EVP_PKEY_free
(
pubkey
);

1386 
ctx
.
tls
->
use_raw_public_keys
 = 1;

1388 
hs_properties
.
client
.
negotiated_protocols
.
list
 = negotiated_protocols.list;

1389 
hs_properties
.
client
.
negotiated_protocols
.
count
 = negotiated_protocols.count;

1390 if (
session_file
 != 
NULL
)

1391 
	`load_session
();

1393 if (
argc
 != 2) {

1394 
	`fprintf
(
stderr
, "missing host and port\n");

1395 
	`exit
(1);

1397 
host
 = (--
argc
, *
argv
++);

1398 
port
 = (--
argc
, *
argv
++);

1400 if (
	`resolve_address
((void *)&
sa
, &
salen
, 
host
, 
port
, 
AF_INET
, 
SOCK_DGRAM
, 
IPPROTO_UDP
) != 0)

1401 
	`exit
(1);

1403 if ((
fd
 = 
	`socket
(
sa
.
ss_family
, 
SOCK_DGRAM
, 
IPPROTO_UDP
)) == -1) {

1404 
	`perror
("socket(2) failed");

1407 
	`fcntl
(
fd
, 
F_SETFL
, 
O_NONBLOCK
);

1409 int 
on
 = 1;

1410 if (
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_REUSEADDR
, &
on
, sizeof(on)) != 0) {

1411 
	`perror
("setsockopt(SO_REUSEADDR) failed");

1415 if (
udpbufsize
 != 0) {

1416 unsigned 
arg
 = 
udpbufsize
;

1417 if (
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_RCVBUF
, &
arg
, sizeof(arg)) != 0) {

1418 
	`perror
("setsockopt(SO_RCVBUF) failed");

1421 
arg
 = 
udpbufsize
;

1422 if (
	`setsockopt
(
fd
, 
SOL_SOCKET
, 
SO_SNDBUF
, &
arg
, sizeof(arg)) != 0) {

1423 
	`perror
("setsockopt(SO_RCVBUF) failed");

1427 #if 
	`defined
(
IP_DONTFRAG
)

1429 int 
on
 = 1;

1430 if (
	`setsockopt
(
fd
, 
IPPROTO_IP
, 
IP_DONTFRAG
, &
on
, sizeof(on)) != 0)

1431 
	`perror
("Warning: setsockopt(IP_DONTFRAG) failed");

1433 #elif 
	`defined
(
IP_PMTUDISC_DO
)

1435 int 
opt
 = 
IP_PMTUDISC_DO
;

1436 if (
	`setsockopt
(
fd
, 
IPPROTO_IP
, 
IP_MTU_DISCOVER
, &
opt
, sizeof(opt)) != 0)

1437 
	`perror
("Warning: setsockopt(IP_MTU_DISCOVER) failed");

1441 return 
ctx
.
tls
->
certificates
.
count
 != 0 ? 
	`run_server
(
fd
, (void *)&
sa
, 
salen
) : 
	`run_client
(fd, (void *)&sa, 
host
);

1442 
	}
}

	@t/frame.c

22 #include 
	~"quicly/frame.h
"

23 #include 
	~"test.h
"

25 static void 
	$test_ack_decode_underflow
(void)

27 
quicly_ack_frame_t
 
decoded
;

30 const 
uint8_t
 
pat
[] = {0, 0, 0, 0}, *
src
 = pat;

31 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
pat
 + sizeof(pat), &
decoded
, 0) == 0);

32 
	`ok
(
src
 == 
pat
 + sizeof(pat));

33 
	`ok
(
decoded
.
largest_acknowledged
 == 0);

34 
	`ok
(
decoded
.
num_gaps
 == 0);

35 
	`ok
(
decoded
.
ack_block_lengths
[0] == 1);

36 
	`ok
(
decoded
.
smallest_acknowledged
 == 0);

39 const 
uint8_t
 
pat
[] = {0, 0, 0, 1}, *
src
 = pat;

40 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
pat
 + sizeof(pat), &
decoded
, 0) != 0);

44 const 
uint8_t
 
pat
[] = {2, 0, 1, 0, 0, 0}, *
src
 = pat;

45 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
pat
 + sizeof(pat), &
decoded
, 0) == 0);

46 
	`ok
(
src
 == 
pat
 + sizeof(pat));

47 
	`ok
(
decoded
.
largest_acknowledged
 == 2);

48 
	`ok
(
decoded
.
num_gaps
 == 1);

49 
	`ok
(
decoded
.
ack_block_lengths
[0] == 1);

50 
	`ok
(
decoded
.
ack_block_lengths
[1] == 1);

51 
	`ok
(
decoded
.
smallest_acknowledged
 == 0);

55 const 
uint8_t
 
pat
[] = {2, 0, 1, 0, 0, 1}, *
src
 = pat;

56 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
pat
 + sizeof(pat), &
decoded
, 0) != 0);

59 const 
uint8_t
 
pat
[] = {2, 0, 1, 0, 3, 0}, *
src
 = pat;

60 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
pat
 + sizeof(pat), &
decoded
, 0) != 0);

62 
	}
}

64 static void 
	$test_ack_decode
(void)

67 const 
uint8_t
 
pat
[] = {0x34, 0x00, 0x00, 0x11}, *
src
 = pat;

68 
quicly_ack_frame_t
 
decoded
;

69 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
pat
 + sizeof(pat), &
decoded
, 0) == 0);

70 
	`ok
(
src
 == 
pat
 + sizeof(pat));

71 
	`ok
(
decoded
.
largest_acknowledged
 == 0x34);

72 
	`ok
(
decoded
.
num_gaps
 == 0);

73 
	`ok
(
decoded
.
ack_block_lengths
[0] == 0x12);

74 
	`ok
(
decoded
.
smallest_acknowledged
 == 0x34 - 0x12 + 1);

78 const 
uint8_t
 
pat
[] = {0x34, 0x00, 0x02, 0x00, 0x01, 0x02, 0x03, 0x04}, *
src
 = pat;

79 
quicly_ack_frame_t
 
decoded
;

80 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
pat
 + sizeof(pat), &
decoded
, 0) == 0);

81 
	`ok
(
src
 == 
pat
 + sizeof(pat));

82 
	`ok
(
decoded
.
largest_acknowledged
 == 0x34);

83 
	`ok
(
decoded
.
num_gaps
 == 2);

84 
	`ok
(
decoded
.
ack_block_lengths
[0] == 1);

85 
	`ok
(
decoded
.
gaps
[0] == 2);

86 
	`ok
(
decoded
.
ack_block_lengths
[1] == 3);

87 
	`ok
(
decoded
.
gaps
[1] == 4);

88 
	`ok
(
decoded
.
ack_block_lengths
[2] == 5);

89 
	`ok
(
decoded
.
smallest_acknowledged
 == 0x34 - 1 - 2 - 3 - 4 - 5 + 1);

93 
uint8_t
 
pat
[1024], *
end
 = pat;

94 const 
uint8_t
 *
src
 = 
pat
;

95 
uint64_t
 
i
, 
range_sum
;

96 
quicly_ack_frame_t
 
decoded
;

97 
end
 = 
	`quicly_encodev
(end, 0xFA00);

98 
end
 = 
	`quicly_encodev
(end, 0);

99 
end
 = 
	`quicly_encodev
(end, 
QUICLY_ACK_MAX_GAPS
 + 30);

100 
end
 = 
	`quicly_encodev
(end, 8);

101 for (
i
 = 0; i < 
QUICLY_ACK_MAX_GAPS
 + 30; ++i) {

102 
end
 = 
	`quicly_encodev
(end, 
i
);

103 
end
 = 
	`quicly_encodev
(end, 
i
 % 10);

106 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
end
, &
decoded
, 0) == 0);

107 
	`ok
(
decoded
.
largest_acknowledged
 == 0xFA00);

108 
	`ok
(
decoded
.
ack_delay
 == 0);

109 
	`ok
(
decoded
.
num_gaps
 == 
QUICLY_ACK_MAX_GAPS
);

110 
	`ok
(
decoded
.
ack_block_lengths
[0] == 8 + 1);

111 
range_sum
 = 
decoded
.
ack_block_lengths
[0];

112 for (
i
 = 0; i < 
decoded
.
num_gaps
; ++i) {

113 
	`ok
(
decoded
.
gaps
[
i
] == i + 1);

114 
	`ok
(
decoded
.
ack_block_lengths
[
i
 + 1] == (i % 10) + 1);

115 
range_sum
 += 
decoded
.
gaps
[
i
] + decoded.
ack_block_lengths
[i + 1];

117 
	`ok
(
src
 == 
end
);

118 
	`ok
(
decoded
.
smallest_acknowledged
 == 0xFA00 - 
range_sum
 + 1);

121 
	`subtest
("underflow", 
test_ack_decode_underflow
);

122 
	}
}

124 static void 
	$test_ack_encode
(void)

126 
quicly_ranges_t
 
ranges
;

127 
uint8_t
 
buf
[256], *
end
;

128 const 
uint8_t
 *
src
;

129 
quicly_ack_frame_t
 
decoded
;

131 
	`quicly_ranges_init
(&
ranges
);

132 
	`quicly_ranges_add
(&
ranges
, 0x12, 0x14);

135 
end
 = 
	`quicly_encode_ack_frame
(
buf
, buf + sizeof(buf), &
ranges
, 63);

136 
	`ok
(
end
 - 
buf
 == 5);

138 
src
 = 
buf
 + 1;

139 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
end
, &
decoded
, 0) == 0);

140 
	`ok
(
src
 == 
end
);

141 
	`ok
(
decoded
.
ack_delay
 == 63);

142 
	`ok
(
decoded
.
num_gaps
 == 0);

143 
	`ok
(
decoded
.
largest_acknowledged
 == 0x13);

144 
	`ok
(
decoded
.
ack_block_lengths
[0] == 2);

146 
	`quicly_ranges_add
(&
ranges
, 0x10, 0x11);

149 
end
 = 
	`quicly_encode_ack_frame
(
buf
, buf + sizeof(buf), &
ranges
, 63);

150 
	`ok
(
end
 - 
buf
 == 7);

152 
src
 = 
buf
 + 1;

153 
	`ok
(
	`quicly_decode_ack_frame
(&
src
, 
end
, &
decoded
, 0) == 0);

154 
	`ok
(
src
 == 
end
);

155 
	`ok
(
decoded
.
ack_delay
 == 63);

156 
	`ok
(
decoded
.
num_gaps
 == 1);

157 
	`ok
(
decoded
.
largest_acknowledged
 == 0x13);

158 
	`ok
(
decoded
.
ack_block_lengths
[0] == 2);

159 
	`ok
(
decoded
.
gaps
[0] == 1);

160 
	`ok
(
decoded
.
ack_block_lengths
[1] == 1);

162 
	`quicly_ranges_clear
(&
ranges
);

163 
	}
}

165 static void 
	$test_mozquic
(void)

167 
quicly_stream_frame_t
 
frame
;

168 static const char *
mess
 = "\xc5\0\0\0\0\0\0\xb6\x16\x03";

169 const 
uint8_t
 *
p
 = (void *)
mess
, 
type_flags
 = *p++;

170 
	`quicly_decode_stream_frame
(
type_flags
, &
p
, p + 9, &
frame
);

171 
	}
}

173 void 
	$test_frame
(void)

175 
	`subtest
("ack-decode", 
test_ack_decode
);

176 
	`subtest
("ack-encode", 
test_ack_encode
);

177 
	`subtest
("mozquic", 
test_mozquic
);

178 
	}
}

	@t/local_cid.c

23 #include 
	~"test.h
"

24 #include 
	~"quicly/local_cid.h
"

26 #define 
	#NUM_CIDS
 4

	)

28 static void 
	$encrypt_cid
(struct 
st_quicly_cid_encryptor_t
 *
self
, 
quicly_cid_t
 *
encrypted
, void *
stateless_reset_token
,

29 const 
quicly_cid_plaintext_t
 *
plaintext
)

31 
encrypted
->
cid
[0] = 
plaintext
->
path_id
;

32 
encrypted
->
len
 = 1;

33 
	}
}

35 static 
size_t
 
	$decrypt_cid
(struct 
st_quicly_cid_encryptor_t
 *
self
, 
quicly_cid_plaintext_t
 *
plaintext
, const void *
encrypted
,

36 
size_t
 
len
)

38 
plaintext
->
path_id
 = ((const 
uint8_t
 *)
encrypted
)[0];

40 
	}
}

42 static 
quicly_cid_encryptor_t
 
	gtest_encryptor
 = {

43 .
encrypt_cid
 = encrypt_cid,

44 .
	gdecrypt_cid
 = 
decrypt_cid
,

52 static int 
	$verify_cid
(const 
quicly_local_cid_t
 *
cid
, 
quicly_cid_encryptor_t
 *
encryptor
)

54 
quicly_cid_plaintext_t
 
plaintext
;

55 if (
cid
->
state
 == 
QUICLY_LOCAL_CID_STATE_IDLE
)

57 if (
encryptor
 == 
NULL
)

60 
encryptor
->
	`decrypt_cid
(encryptor, &
plaintext
, 
cid
->cid.cid, cid->cid.
len
);

61 return !(
cid
->
sequence
 == 
plaintext
.
path_id
);

62 
	}
}

71 static int 
	$verify_array
(const 
quicly_local_cid_set_t
 *
set
)

73 int 
allow_pending
 = 1;

74 for (
size_t
 
i
 = 0; i < 
set
->
_size
; i++) {

75 if (
allow_pending
) {

76 if (
set
->
cids
[
i
].
state
 != 
QUICLY_LOCAL_CID_STATE_PENDING
)

77 
allow_pending
 = 0;

78 } else if (
set
->
cids
[
i
].
state
 == 
QUICLY_LOCAL_CID_STATE_PENDING
) {

81 if (
	`verify_cid
(&
set
->
cids
[
i
], set->
_encryptor
) != 0)

86 
	}
}

88 static 
size_t
 
	$count_by_state
(const 
quicly_local_cid_set_t
 *
set
, enum 
en_quicly_local_cid_state_t
 
state
)

90 
size_t
 
num
 = 0;

91 for (
size_t
 
i
 = 0; i < 
	`PTLS_ELEMENTSOF
(
set
->
cids
); i++) {

92 if (
set
->
cids
[
i
].
state
 == state)

93 
num
++;

95 return 
num
;

96 
	}
}

101 static int 
	$exists_once
(const 
quicly_local_cid_set_t
 *
set
, 
uint64_t
 
sequence
, enum 
en_quicly_local_cid_state_t
 
state
)

103 
size_t
 
occurrence
 = 0;

104 for (
size_t
 
i
 = 0; i < 
set
->
_size
; i++) {

105 if (
set
->
cids
[
i
].
sequence
 == sequence) {

106 if (
set
->
cids
[
i
].
state
 != state)

108 if (
occurrence
 > 0)

110 
occurrence
++;

114 return 
occurrence
 == 1;

115 
	}
}

117 void 
	$test_local_cid
(void)

119 
	`PTLS_BUILD_ASSERT
(
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
 >= 
NUM_CIDS
);

120 
quicly_local_cid_set_t
 
set
;

121 static const 
quicly_cid_plaintext_t
 
cid_plaintext
 = {0};

124 
	`quicly_local_cid_init_set
(&
set
, &
test_encryptor
, &
cid_plaintext
);

125 
	`ok
(
	`verify_array
(&
set
) == 0);

126 
	`ok
(
	`count_by_state
(&
set
, 
QUICLY_LOCAL_CID_STATE_PENDING
) == 0);

127 
	`ok
(
	`exists_once
(&
set
, 0, 
QUICLY_LOCAL_CID_STATE_DELIVERED
));

129 
	`ok
(
	`quicly_local_cid_set_size
(&
set
, 
NUM_CIDS
) != 0);

130 
	`ok
(
	`verify_array
(&
set
) == 0);

131 
	`ok
(
	`count_by_state
(&
set
, 
QUICLY_LOCAL_CID_STATE_PENDING
) == 
NUM_CIDS
 - 1);

132 
	`ok
(
	`exists_once
(&
set
, 0, 
QUICLY_LOCAL_CID_STATE_DELIVERED
));

133 
	`ok
(
	`exists_once
(&
set
, 1, 
QUICLY_LOCAL_CID_STATE_PENDING
));

134 
	`ok
(
	`exists_once
(&
set
, 2, 
QUICLY_LOCAL_CID_STATE_PENDING
));

135 
	`ok
(
	`exists_once
(&
set
, 3, 
QUICLY_LOCAL_CID_STATE_PENDING
));

138 
	`quicly_local_cid_on_sent
(&
set
, 
NUM_CIDS
 - 1);

139 
	`ok
(
	`verify_array
(&
set
) == 0);

140 
	`ok
(
	`exists_once
(&
set
, 1, 
QUICLY_LOCAL_CID_STATE_INFLIGHT
));

141 
	`ok
(
	`exists_once
(&
set
, 2, 
QUICLY_LOCAL_CID_STATE_INFLIGHT
));

142 
	`ok
(
	`exists_once
(&
set
, 3, 
QUICLY_LOCAL_CID_STATE_INFLIGHT
));

144 
	`quicly_local_cid_on_acked
(&
set
, 1);

145 
	`quicly_local_cid_on_acked
(&
set
, 3);

146 
	`ok
(
	`quicly_local_cid_on_lost
(&
set
, 2) != 0);

147 
	`ok
(
	`verify_array
(&
set
) == 0);

148 
	`ok
(
	`count_by_state
(&
set
, 
QUICLY_LOCAL_CID_STATE_PENDING
) == 1);

149 
	`ok
(
	`exists_once
(&
set
, 1, 
QUICLY_LOCAL_CID_STATE_DELIVERED
));

150 
	`ok
(
	`exists_once
(&
set
, 2, 
QUICLY_LOCAL_CID_STATE_PENDING
));

151 
	`ok
(
	`exists_once
(&
set
, 3, 
QUICLY_LOCAL_CID_STATE_DELIVERED
));

154 
	`quicly_local_cid_on_sent
(&
set
, 1);

155 
	`ok
(
	`count_by_state
(&
set
, 
QUICLY_LOCAL_CID_STATE_PENDING
) == 0);

158 int 
has_pending
;

159 
	`ok
(
	`quicly_local_cid_retire
(&
set
, 0, &
has_pending
) == 0);

160 
	`ok
(
has_pending
);

161 
	`ok
(
	`quicly_local_cid_retire
(&
set
, 1, &
has_pending
) == 0);

162 
	`ok
(
has_pending
);

163 
	`ok
(
	`quicly_local_cid_retire
(&
set
, 2, &
has_pending
) == 0);

164 
	`ok
(
has_pending
);

165 
	`ok
(
	`quicly_local_cid_retire
(&
set
, 3, &
has_pending
) == 0);

166 
	`ok
(
has_pending
);

167 
	`ok
(
	`count_by_state
(&
set
, 
QUICLY_LOCAL_CID_STATE_PENDING
) == 4);

169 
	`quicly_local_cid_on_sent
(&
set
, 1);

170 
	`ok
(
	`verify_array
(&
set
) == 0);

171 
	`ok
(
	`count_by_state
(&
set
, 
QUICLY_LOCAL_CID_STATE_PENDING
) == 3);

172 
	`ok
(
	`exists_once
(&
set
, 4, 
QUICLY_LOCAL_CID_STATE_INFLIGHT
));

173 
	`ok
(
	`exists_once
(&
set
, 5, 
QUICLY_LOCAL_CID_STATE_PENDING
));

174 
	`ok
(
	`exists_once
(&
set
, 6, 
QUICLY_LOCAL_CID_STATE_PENDING
));

175 
	`ok
(
	`exists_once
(&
set
, 7, 
QUICLY_LOCAL_CID_STATE_PENDING
));

178 
	`ok
(
	`quicly_local_cid_retire
(&
set
, 6, &
has_pending
) == 0);

179 
	`ok
(
has_pending
);

180 
	`ok
(
	`verify_array
(&
set
) == 0);

182 
	`quicly_local_cid_on_sent
(&
set
, 2);

183 
	`ok
(
	`quicly_local_cid_on_lost
(&
set
, 4) != 0);

184 
	`quicly_local_cid_on_acked
(&
set
, 4);

185 
	`quicly_local_cid_on_acked
(&
set
, 5);

186 
	`quicly_local_cid_on_acked
(&
set
, 5);

187 
	`ok
(
	`exists_once
(&
set
, 4, 
QUICLY_LOCAL_CID_STATE_DELIVERED
));

188 
	`ok
(
	`exists_once
(&
set
, 5, 
QUICLY_LOCAL_CID_STATE_DELIVERED
));

189 
	`ok
(
	`exists_once
(&
set
, 8, 
QUICLY_LOCAL_CID_STATE_PENDING
));

192 
	`ok
(
	`quicly_local_cid_retire
(&
set
, 4, &
has_pending
) == 0);

193 
	`ok
(
has_pending
);

194 
	`ok
(
	`quicly_local_cid_retire
(&
set
, 5, &
has_pending
) == 0);

195 
	`ok
(
has_pending
);

199 
size_t
 
num_retired
 = 7;

200 
uint64_t
 
seq_to_retire
 = 7;

201 while (
num_retired
 < 
QUICLY_MAX_PATH_ID
) {

202 if (
seq_to_retire
 == 
QUICLY_MAX_PATH_ID
 - 1) {

204 
	`ok
(
	`quicly_local_cid_retire
(&
set
, 
seq_to_retire
, &
has_pending
) == 
QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION
);

206 
	`ok
(
	`quicly_local_cid_retire
(&
set
, 
seq_to_retire
, &
has_pending
) == 0);

207 
	`ok
(
has_pending
);

209 
num_retired
++;

210 
seq_to_retire
++;

214 
quicly_local_cid_set_t
 
empty_set
;

215 
	`quicly_local_cid_init_set
(&
empty_set
, 
NULL
, NULL);

216 
	`ok
(
	`quicly_local_cid_set_size
(&
empty_set
, 
NUM_CIDS
) == 0);

217 
	`ok
(
	`count_by_state
(&
empty_set
, 
QUICLY_LOCAL_CID_STATE_DELIVERED
) == 1);

218 
	`ok
(
	`count_by_state
(&
empty_set
, 
QUICLY_LOCAL_CID_STATE_IDLE
) == 
	`PTLS_ELEMENTSOF
(empty_set.
cids
) - 1);

221 
	`PTLS_BUILD_ASSERT
(
NUM_CIDS
 >= 2);

222 
quicly_cid_plaintext_t
 
cid_plaintext2
 = {0};

223 
quicly_local_cid_set_t
 
small_set
;

224 
	`quicly_local_cid_init_set
(&
small_set
, &
test_encryptor
, &
cid_plaintext2
);

225 
	`ok
(
	`quicly_local_cid_set_size
(&
small_set
, 
NUM_CIDS
 - 1) != 0);

226 
	`ok
(
	`verify_array
(&
small_set
) == 0);

227 
	`ok
(
	`count_by_state
(&
small_set
, 
QUICLY_LOCAL_CID_STATE_PENDING
) == 
NUM_CIDS
 - 2);

228 
	`ok
(
	`exists_once
(&
small_set
, 0, 
QUICLY_LOCAL_CID_STATE_DELIVERED
));

229 
	`ok
(
	`exists_once
(&
small_set
, 1, 
QUICLY_LOCAL_CID_STATE_PENDING
));

230 
	`ok
(
	`exists_once
(&
small_set
, 2, 
QUICLY_LOCAL_CID_STATE_PENDING
));

231 
	`ok
(!
	`exists_once
(&
small_set
, 3, 
QUICLY_LOCAL_CID_STATE_PENDING
));

232 
	`ok
(
	`quicly_local_cid_retire
(&
small_set
, 0, &
has_pending
) == 0);

233 
	`ok
(
has_pending
);

234 
	`ok
(
	`exists_once
(&
small_set
, 3, 
QUICLY_LOCAL_CID_STATE_PENDING
));

235 
	}
}

	@t/loss.c

22 #include 
	~"quicly/loss.h
"

23 #include 
	~"quicly/defaults.h
"

24 #include 
	~"test.h
"

26 static 
int64_t
 
	gnow
;

27 static 
uint64_t
 
	gnum_packets_lost
 = 0;

29 static void 
	$on_loss_detected
(
quicly_loss_t
 *
loss
, const 
quicly_sent_packet_t
 *
lost_packet
, int 
is_time_threshold
)

31 ++
num_packets_lost
;

32 
	}
}

34 static void 
	$acked
(
quicly_loss_t
 *
loss
, 
uint64_t
 
pn
, 
size_t
 
epoch
)

36 
quicly_sentmap_iter_t
 
iter
;

37 const 
quicly_sent_packet_t
 *
sent
;

39 
	`quicly_loss_init_sentmap_iter
(
loss
, &
iter
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0);

40 while ((
sent
 = 
	`quicly_sentmap_get
(&
iter
))->
packet_number
 != 
pn
) {

41 
	`assert
(
sent
->
packet_number
 != 
UINT64_MAX
);

42 
	`quicly_sentmap_skip
(&
iter
);

44 
int64_t
 
sent_at
 = 
sent
->sent_at;

45 
	`ok
(
	`quicly_sentmap_update
(&
loss
->
sentmap
, &
iter
, 
QUICLY_SENTMAP_EVENT_ACKED
) == 0);

47 
	`quicly_loss_on_ack_received
(
loss
, 
pn
, 
epoch
, 
now
, 
sent_at
, 0, 1);

48 
	}
}

50 static void 
	$test_time_detection
(void)

52 
quicly_loss_t
 
loss
;

54 
now
 = 0;

55 
num_packets_lost
 = 0;

57 
	`quicly_loss_init
(&
loss
, &
quicly_spec_context
.loss, 20, &quicly_spec_context.
transport_params
.
max_ack_delay
,

58 &
quicly_spec_context
.
transport_params
.
ack_delay_exponent
);

59 
	`ok
(
loss
.
loss_time
 == 
INT64_MAX
);

62 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 0, 
now
, 
QUICLY_EPOCH_INITIAL
) == 0);

63 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

64 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 1, 
now
, 
QUICLY_EPOCH_INITIAL
) == 0);

65 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

66 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 2, 
now
, 
QUICLY_EPOCH_INITIAL
) == 0);

67 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

68 
	`ok
(
	`quicly_loss_detect_loss
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, 
on_loss_detected
) == 0);

69 
	`ok
(
loss
.
loss_time
 == 
INT64_MAX
);

71 
now
 += 10;

74 
	`acked
(&
loss
, 0, 
QUICLY_EPOCH_INITIAL
);

75 
	`ok
(
	`quicly_loss_detect_loss
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, 
on_loss_detected
) == 0);

76 
	`ok
(
loss
.
loss_time
 == 
INT64_MAX
);

78 
now
 += 10;

81 
	`acked
(&
loss
, 2, 
QUICLY_EPOCH_INITIAL
);

82 
	`ok
(
	`quicly_loss_detect_loss
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, 
on_loss_detected
) == 0);

83 
	`ok
(
loss
.
loss_time
 != 
INT64_MAX
);

84 
	`ok
(
num_packets_lost
 == 0);

86 
now
 = 
loss
.
loss_time
;

87 
	`ok
(
	`quicly_loss_detect_loss
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, 
on_loss_detected
) == 0);

88 
	`ok
(
loss
.
loss_time
 == 
INT64_MAX
);

89 
	`ok
(
num_packets_lost
 == 1);

91 
	`quicly_loss_dispose
(&
loss
);

92 
	}
}

94 static void 
	$test_pn_detection
(void)

96 
quicly_loss_t
 
loss
;

98 
now
 = 0;

99 
num_packets_lost
 = 0;

101 
	`quicly_loss_init
(&
loss
, &
quicly_spec_context
.loss, 20, &quicly_spec_context.
transport_params
.
max_ack_delay
,

102 &
quicly_spec_context
.
transport_params
.
ack_delay_exponent
);

103 
	`ok
(
loss
.
loss_time
 == 
INT64_MAX
);

106 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 0, 
now
, 
QUICLY_EPOCH_INITIAL
) == 0);

107 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

108 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 1, 
now
, 
QUICLY_EPOCH_INITIAL
) == 0);

109 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

110 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 2, 
now
, 
QUICLY_EPOCH_INITIAL
) == 0);

111 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

112 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 3, 
now
, 
QUICLY_EPOCH_INITIAL
) == 0);

113 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

114 
	`ok
(
	`quicly_loss_detect_loss
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, 
on_loss_detected
) == 0);

115 
	`ok
(
loss
.
loss_time
 == 
INT64_MAX
);

118 
	`acked
(&
loss
, 2, 
QUICLY_EPOCH_INITIAL
);

119 
	`ok
(
	`quicly_loss_detect_loss
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, 
on_loss_detected
) == 0);

120 
	`ok
(
loss
.
loss_time
 != 
INT64_MAX
);

121 
	`ok
(
num_packets_lost
 == 0);

124 
	`acked
(&
loss
, 3, 
QUICLY_EPOCH_INITIAL
);

125 
	`ok
(
	`quicly_loss_detect_loss
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, 
on_loss_detected
) == 0);

126 
	`ok
(
loss
.
loss_time
 != 
INT64_MAX
);

127 
	`ok
(
num_packets_lost
 == 1);

129 
	`quicly_loss_dispose
(&
loss
);

130 
	}
}

132 static void 
	$test_slow_cert_verify
(void)

134 
quicly_loss_t
 
loss
;

135 
int64_t
 
last_retransmittable_sent_at
;

136 
size_t
 
min_packets_to_send
;

137 int 
restrict_sending
;

139 
now
 = 0;

140 
num_packets_lost
 = 0;

142 
	`quicly_loss_init
(&
loss
, &
quicly_spec_context
.loss, 20, &quicly_spec_context.
transport_params
.
max_ack_delay
,

143 &
quicly_spec_context
.
transport_params
.
ack_delay_exponent
);

144 
	`ok
(
loss
.
loss_time
 == 
INT64_MAX
);

147 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 1, 
now
, 
QUICLY_EPOCH_HANDSHAKE
) == 0);

148 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

149 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 2, 
now
, 
QUICLY_EPOCH_1RTT
) == 0);

150 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

151 
last_retransmittable_sent_at
 = 
now
;

152 
	`quicly_loss_update_alarm
(&
loss
, 
now
, 
last_retransmittable_sent_at
, 1, 0, 1, 0, 1);

154 
now
 += 10;

157 
	`acked
(&
loss
, 1, 
QUICLY_EPOCH_HANDSHAKE
);

158 
	`ok
(
	`quicly_loss_detect_loss
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, 
on_loss_detected
) == 0);

159 
	`ok
(
loss
.
loss_time
 == 
INT64_MAX
);

160 
	`ok
(
num_packets_lost
 == 0);

163 
now
 = 
loss
.
alarm_at
;

164 
	`ok
(
	`quicly_loss_on_alarm
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, &
min_packets_to_send
,

165 &
restrict_sending
, 
on_loss_detected
) == 0);

166 
	`ok
(
restrict_sending
);

167 
	`ok
(
min_packets_to_send
 == 2);

168 
	`ok
(
num_packets_lost
 == 0);

171 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 3, 
now
, 
QUICLY_EPOCH_HANDSHAKE
) == 0);

172 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

173 
	`ok
(
	`quicly_sentmap_prepare
(&
loss
.
sentmap
, 4, 
now
, 
QUICLY_EPOCH_1RTT
) == 0);

174 
	`quicly_sentmap_commit
(&
loss
.
sentmap
, 10);

176 
now
 += 10;

179 
	`acked
(&
loss
, 3, 
QUICLY_EPOCH_HANDSHAKE
);

180 
	`ok
(
	`quicly_loss_detect_loss
(&
loss
, 
now
, 
quicly_spec_context
.
transport_params
.
max_ack_delay
, 0, 
on_loss_detected
) == 0);

181 
	`ok
(
loss
.
loss_time
 == 
INT64_MAX
);

182 
	`ok
(
num_packets_lost
 == 0);

184 
	`quicly_loss_dispose
(&
loss
);

185 
	}
}

187 void 
	$test_loss
(void)

189 
	`subtest
("time-detection", 
test_time_detection
);

190 
	`subtest
("pn-detection", 
test_pn_detection
);

191 
	`subtest
("slow-cert-verify", 
test_slow_cert_verify
);

192 
	}
}

	@t/lossy.c

22 #include 
	~<string.h
>

23 #include 
	~"picotls/openssl.h
"

24 #include 
	~"quicly/defaults.h
"

25 #include 
	~"test.h
"

27 static 
quicly_conn_t
 *
	gclient
, *
	gserver
;

29 struct 
	sloss_cond_t
 {

30 int (*
	mcb
)(struct 
loss_cond_t
 *
	mcond
);

33 
size_t
 
	mcnt
;

34 } 
	meven
;

37 unsigned 
	mnloss
, 
	mntotal
;

38 } 
	mratio
;

39 
uint64_t
 
	mbits
;

40 
size_t
 
	mbits_avail
;

41 } 
	mrand_
;

42 } 
	mdata
;

45 static int 
	$cond_true_
(struct 
loss_cond_t
 *
cond
)

48 
	}
}

50 static struct 
loss_cond_t
 
	gcond_true
 = {
cond_true_
};

52 static int 
	$cond_even_
(struct 
loss_cond_t
 *
cond
)

54 return 
cond
->
data
.
even
.
cnt
++ % 2 == 0;

55 
	}
}

57 static void 
	$init_cond_even
(struct 
loss_cond_t
 *
cond
)

59 *
cond
 = (struct 
loss_cond_t
){
cond_even_
};

60 
	}
}

62 static int 
	$cond_rand_
(struct 
loss_cond_t
 *
cond
)

64 static 
ptls_cipher_context_t
 *
c
;

66 if (
cond
->
data
.
rand_
.
bits_avail
 == 0) {

67 if (
c
 == 
NULL
) {

69 static 
uint64_t
 
key
[2];

70 
c
 = 
	`ptls_cipher_new
(&
ptls_openssl_aes128ctr
, 1, &
key
);

71 ++
key
[0];

74 
cond
->
data
.
rand_
.
bits
 = 0;

75 unsigned 
num_bits_set
;

76 for (
num_bits_set
 = 0; num_bits_set != 
cond
->
data
.
rand_
.
ratio
.
nloss
; ++num_bits_set) {

78 
uint64_t
 
mask
;

80 
uint32_t
 
v
;

81 
	`ptls_cipher_encrypt
(
c
, &
v
, "01234567", 4);

82 
mask
 = (
uint64_t
)1 << (
v
 % 
cond
->
data
.
rand_
.
ratio
.
ntotal
);

83 } while ((
cond
->
data
.
rand_
.
bits
 & 
mask
) != 0);

85 
cond
->
data
.
rand_
.
bits
 |= 
mask
;

87 
cond
->
data
.
rand_
.
bits_avail
 = cond->data.rand_.
ratio
.
ntotal
;

92 return ((
cond
->
data
.
rand_
.
bits
 >> --cond->data.rand_.
bits_avail
) & 1) == 0;

93 
	}
}

98 static void 
	$init_cond_rand
(struct 
loss_cond_t
 *
cond
, unsigned 
nloss
, unsigned 
ntotal
)

100 *
cond
 = (struct 
loss_cond_t
){
cond_rand_
};

101 
cond
->
data
.
rand_
.
ratio
.
nloss
 = nloss;

102 
cond
->
data
.
rand_
.
ratio
.
ntotal
 = ntotal;

103 
	}
}

105 static int 
	$transmit_cond
(
quicly_conn_t
 *
src
, quicly_conn_t *
dst
, 
size_t
 *
num_sent
, size_t *
num_received
, struct 
loss_cond_t
 *
cond
,

106 
int64_t
 
latency
, 
ptls_buffer_t
 *
logger
)

108 
quicly_address_t
 
destaddr
, 
srcaddr
;

109 struct 
iovec
 
packets
[32];

110 
uint8_t
 
packetsbuf
[
	`PTLS_ELEMENTSOF
(
packets
) * 
	`quicly_get_context
(
src
)->
transport_params
.
max_udp_payload_size
];

111 int 
ret
;

113 *
num_sent
 = 
	`PTLS_ELEMENTSOF
(
packets
);

114 if ((
ret
 = 
	`quicly_send
(
src
, &
destaddr
, &
srcaddr
, 
packets
, 
num_sent
, 
packetsbuf
, sizeof(packetsbuf))) != 0) {

115 
	`fprintf
(
stderr
, "%s: quicly_send: ret=%d\n", 
__FUNCTION__
, 
ret
);

116 return 
ret
;

118 
quic_now
 += 
latency
;

120 *
num_received
 = 0;

122 if (*
num_sent
 != 0) {

123 
size_t
 
i
;

124 for (
i
 = 0; i != *
num_sent
; ++i) {

125 int 
pass
 = 
cond
->
	`cb
(cond);

126 if (
logger
 != 
NULL
)

127 
	`ptls_buffer_pushv
(
logger
, 
pass
 ? " pass" : " drop", 8);

128 
quicly_decoded_packet_t
 
decoded
[4];

129 
size_t
 
num_decoded
 = 
	`decode_packets
(
decoded
, 
packets
 + 
i
, 1), 
j
;

130 
	`assert
(
num_decoded
 != 0);

131 for (
j
 = 0; j != 
num_decoded
; ++j) {

132 if (
logger
 != 
NULL
) {

133 char 
buf
[16];

134 
	`sprintf
(
buf
, "%c%02x:%zu", 
j
 == 0 ? ':' : ',', 
decoded
[j].
octets
.
base
[0], decoded[j].octets.
len
);

135 
	`ptls_buffer_pushv
(
logger
, 
buf
, 
	`strlen
(buf));

137 if (
pass
) {

138 
ret
 = 
	`quicly_receive
(
dst
, 
NULL
, &
fake_address
.
sa
, 
decoded
 + 
j
);

139 if (!(
ret
 == 0 || ret == 
QUICLY_ERROR_PACKET_IGNORED
)) {

140 
	`fprintf
(
stderr
, "%s: quicly_receive: i=%zu, j=%zu, ret=%d\n", 
__FUNCTION__
, 
i
, 
j
, 
ret
);

141 return 
ret
;

145 if (
logger
 != 
NULL
)

146 
	`ptls_buffer_push
(
logger
, '\n');

147 if (
pass
)

148 ++*
num_received
;

151 
quic_now
 += 
latency
;

153 
Exit
:

154 
	`assert
(
ret
 == 0);

156 
	}
}

158 static void 
	$test_even
(void)

160 
quicly_loss_conf_t
 
lossconf
 = 
QUICLY_LOSS_SPEC_CONF
;

161 struct 
loss_cond_t
 
cond_down
, 
cond_up
;

162 
size_t
 
num_sent
, 
num_received
;

163 int 
ret
;

165 
quic_ctx
.
loss
 = 
lossconf
;

166 
	`init_cond_even
(&
cond_down
);

167 
	`init_cond_even
(&
cond_up
);

169 
quic_now
 = 1;

172 
quicly_address_t
 
destaddr
, 
srcaddr
;

173 struct 
iovec
 
raw
;

174 
uint8_t
 
rawbuf
[
quic_ctx
.
transport_params
.
max_udp_payload_size
];

175 
size_t
 
num_packets
;

176 
quicly_decoded_packet_t
 
decoded
;

178 
ret
 = 
	`quicly_connect
(&
client
, &
quic_ctx
, "example.com", &
fake_address
.
sa
, 
NULL
, 
	`new_master_id
(), 
	`ptls_iovec_init
(NULL, 0),

179 
NULL
, NULL);

180 
	`ok
(
ret
 == 0);

181 
num_packets
 = 1;

182 
ret
 = 
	`quicly_send
(
client
, &
destaddr
, &
srcaddr
, &
raw
, &
num_packets
, 
rawbuf
, sizeof(rawbuf));

183 
	`ok
(
ret
 == 0);

184 
	`ok
(
num_packets
 == 1);

185 
	`decode_packets
(&
decoded
, &
raw
, 1);

186 
	`ok
(
num_packets
 == 1);

187 
ret
 = 
	`quicly_accept
(&
server
, &
quic_ctx
, 
NULL
, &
fake_address
.
sa
, &
decoded
, NULL, 
	`new_master_id
(), NULL);

188 
	`ok
(
ret
 == 0);

189 
cond_up
.
	`cb
(&cond_up);

193 
ret
 = 
	`transmit_cond
(
server
, 
client
, &
num_sent
, &
num_received
, &
cond_down
, 0, 
NULL
);

194 
	`ok
(
ret
 == 0);

195 
	`ok
(
num_sent
 == 2);

196 
	`ok
(
num_received
 == 1);

197 
	`ok
(
	`quicly_get_state
(
client
) == 
QUICLY_STATE_CONNECTED
);

198 
	`ok
(!
	`quicly_connection_is_ready
(
client
));

200 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

203 
ret
 = 
	`transmit_cond
(
client
, 
server
, &
num_sent
, &
num_received
, &
cond_up
, 0, 
NULL
);

204 
	`ok
(
ret
 == 0);

205 
	`ok
(
num_sent
 == 1);

206 
	`ok
(
num_received
 == 0);

208 
	`ok
(
	`quicly_get_state
(
client
) == 
QUICLY_STATE_CONNECTED
);

209 
	`ok
(!
	`quicly_connection_is_ready
(
client
));

211 
quic_now
 += 1000;

214 
ret
 = 
	`transmit_cond
(
server
, 
client
, &
num_sent
, &
num_received
, &
cond_down
, 0, 
NULL
);

215 
	`ok
(
ret
 == 0);

216 
	`ok
(
num_sent
 == 2);

217 
	`ok
(
num_received
 == 1);

218 
	`ok
(
	`quicly_get_state
(
client
) == 
QUICLY_STATE_CONNECTED
);

219 
	`ok
(!
	`quicly_connection_is_ready
(
client
));

221 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

224 
ret
 = 
	`transmit_cond
(
client
, 
server
, &
num_sent
, &
num_received
, &
cond_up
, 0, 
NULL
);

225 
	`ok
(
ret
 == 0);

226 
	`ok
(
num_sent
 == 1);

227 
	`ok
(
num_received
 == 1);

229 
quic_now
 += 1000;

232 
ret
 = 
	`transmit_cond
(
server
, 
client
, &
num_sent
, &
num_received
, &
cond_down
, 0, 
NULL
);

233 
	`ok
(
ret
 == 0);

234 
	`ok
(
num_sent
 == 1);

235 
	`ok
(
num_received
 == 1);

237 
	`ok
(
	`quicly_get_state
(
client
) == 
QUICLY_STATE_CONNECTED
);

238 
	`ok
(
	`quicly_connection_is_ready
(
client
));

241 
ret
 = 
	`transmit_cond
(
client
, 
server
, &
num_sent
, &
num_received
, &
cond_up
, 0, 
NULL
);

242 
	`ok
(
ret
 == 0);

243 
	`ok
(
num_sent
 == 1);

244 
	`ok
(
num_received
 == 0);

246 
quic_now
 += 1000;

249 
ret
 = 
	`transmit_cond
(
server
, 
client
, &
num_sent
, &
num_received
, &
cond_down
, 0, 
NULL
);

250 
	`ok
(
ret
 == 0);

251 
	`ok
(
num_sent
 == 1);

252 
	`ok
(
num_received
 == 0);

254 
quic_now
 += 1000;

257 
ret
 = 
	`transmit_cond
(
client
, 
server
, &
num_sent
, &
num_received
, &
cond_up
, 0, 
NULL
);

258 
	`ok
(
ret
 == 0);

259 
	`ok
(
num_sent
 == 1);

260 
	`ok
(
num_received
 == 1);

262 
	`ok
(
	`quicly_get_state
(
server
) == 
QUICLY_STATE_CONNECTED
);

263 
	`ok
(
	`quicly_connection_is_ready
(
server
));

265 
quic_ctx
.
loss
 = (
quicly_loss_conf_t
)
QUICLY_LOSS_SPEC_CONF
;

266 
	}
}

268 struct 
loss_cond_t
 
	gloss_cond_down
, 
	gloss_cond_up
;

269 static unsigned 
	gnum_failures_in_loss_core
;

271 static void 
	$loss_core
(void)

273 
size_t
 
num_sent_up
, 
num_sent_down
, 
num_received
;

274 int 
ret
;

276 
quic_now
 = 1;

279 
quicly_address_t
 
destaddr
, 
srcaddr
;

280 struct 
iovec
 
raw
;

281 
uint8_t
 
rawbuf
[
quic_ctx
.
transport_params
.
max_udp_payload_size
];

282 
size_t
 
num_packets
;

283 
quicly_decoded_packet_t
 
decoded
;

285 
ret
 = 
	`quicly_connect
(&
client
, &
quic_ctx
, "example.com", &
fake_address
.
sa
, 
NULL
, 
	`new_master_id
(), 
	`ptls_iovec_init
(NULL, 0),

286 
NULL
, NULL);

287 
	`ok
(
ret
 == 0);

288 
num_packets
 = 1;

289 
ret
 = 
	`quicly_send
(
client
, &
destaddr
, &
srcaddr
, &
raw
, &
num_packets
, 
rawbuf
, sizeof(rawbuf));

290 
	`ok
(
ret
 == 0);

291 
	`ok
(
num_packets
 == 1);

292 
quic_now
 += 10;

293 
	`decode_packets
(&
decoded
, &
raw
, 1);

294 
	`ok
(
num_packets
 == 1);

295 
ret
 = 
	`quicly_accept
(&
server
, &
quic_ctx
, 
NULL
, &
fake_address
.
sa
, &
decoded
, NULL, 
	`new_master_id
(), NULL);

296 
	`ok
(
ret
 == 0);

297 
quic_now
 += 10;

300 
ptls_buffer_t
 
transmit_log
;

301 
	`ptls_buffer_init
(&
transmit_log
, "", 0);

304 char 
buf
[64];

305 
	`sprintf
(
buf
, "odcid: ");

306 const 
quicly_cid_t
 *
odcid
 = 
	`quicly_get_original_dcid
(
server
);

307 
	`ptls_hexdump
(
buf
 + 
	`strlen
(buf), 
odcid
->
cid
, odcid->
len
);

308 
	`strcat
(
buf
, "\n");

309 
	`ptls_buffer_pushv
(&
transmit_log
, 
buf
, 
	`strlen
(buf));

312 
quicly_stream_t
 *
client_stream
 = 
NULL
, *
server_stream
 = NULL;

313 
test_streambuf_t
 *
client_streambuf
 = 
NULL
, *
server_streambuf
 = NULL;

314 const char *
req
 = "GET / HTTP/1.0\r\n\r\n", *
resp
 = "HTTP/1.0 200 OK\r\n\r\nhello world";

315 
size_t
 
i
, 
stall_count
 = 0;

316 for (
i
 = 0; i < 100; ++i) {

317 
int64_t
 
client_timeout
 = 
	`quicly_get_first_timeout
(
client
), 
server_timeout
 = quicly_get_first_timeout(
server
),

318 
min_timeout
 = 
client_timeout
 < 
server_timeout
 ? client_timeout : server_timeout;

319 
	`assert
(
min_timeout
 != 
INT64_MAX
);

320 
	`assert
(
min_timeout
 == 0 || 
quic_now
 < min_timeout + 40);

321 if (
quic_now
 < 
min_timeout
)

322 
quic_now
 = 
min_timeout
;

323 char 
logbuf
[32];

324 
	`sprintf
(
logbuf
, "at:%" 
PRId64
 "\n down:\n", 
quic_now
);

325 
	`ptls_buffer_pushv
(&
transmit_log
, 
logbuf
, 
	`strlen
(logbuf));

326 if ((
ret
 = 
	`transmit_cond
(
server
, 
client
, &
num_sent_down
, &
num_received
, &
loss_cond_down
, 10, &
transmit_log
)) != 0)

327 goto 
Fail
;

328 
server_timeout
 = 
	`quicly_get_first_timeout
(
server
);

329 
	`assert
(
server_timeout
 > 
quic_now
 - 20);

330 if (
	`quicly_get_state
(
client
) == 
QUICLY_STATE_CONNECTED
 && 
	`quicly_connection_is_ready
(client)) {

331 if (
client_stream
 == 
NULL
) {

332 if ((
ret
 = 
	`quicly_open_stream
(
client
, &
client_stream
, 0)) != 0) {

333 
	`fprintf
(
stderr
, "%s: quicly_open_stream: ret=%d\n", 
__FUNCTION__
, 
ret
);

334 goto 
Fail
;

336 
client_streambuf
 = 
client_stream
->
data
;

337 
	`quicly_streambuf_egress_write
(
client_stream
, 
req
, 
	`strlen
(req));

338 
	`quicly_streambuf_egress_shutdown
(
client_stream
);

339 } else if (
client_streambuf
->
is_detached
 || 
	`quicly_recvstate_transfer_complete
(&
client_stream
->
recvstate
)) {

340 
	`ok
(
	`buffer_is
(&
client_streambuf
->
super
.
ingress
, 
resp
));

341 
	`ok
(
	`max_data_is_equal
(
client
, 
server
));

342 
	`ptls_buffer_dispose
(&
transmit_log
);

346 
	`ptls_buffer_pushv
(&
transmit_log
, " up:\n", 6);

347 if ((
ret
 = 
	`transmit_cond
(
client
, 
server
, &
num_sent_up
, &
num_received
, &
loss_cond_up
, 10, &
transmit_log
)) != 0)

348 goto 
Fail
;

349 
client_timeout
 = 
	`quicly_get_first_timeout
(
client
);

350 
	`assert
(
client_timeout
 > 
quic_now
 - 20);

351 if (
client_stream
 != 
NULL
 && (
server_stream
 = 
	`quicly_get_stream
(
server
, client_stream->
stream_id
)) != NULL) {

352 if (
server_streambuf
 == 
NULL
 && 
	`quicly_recvstate_transfer_complete
(&
server_stream
->
recvstate
)) {

353 
server_streambuf
 = 
server_stream
->
data
;

354 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, 
req
));

355 
	`quicly_streambuf_egress_write
(
server_stream
, 
resp
, 
	`strlen
(resp));

356 
	`quicly_streambuf_egress_shutdown
(
server_stream
);

359 if (
num_sent_up
 + 
num_sent_down
 == 0) {

360 ++
stall_count
;

361 if (
stall_count
 >= 10) {

362 
	`fprintf
(
stderr
, "%s: stall_count exceeds max\n", 
__FUNCTION__
);

363 goto 
Fail
;

366 
stall_count
 = 0;

370 
Fail
:

371 
	`fprintf
(
stderr
, "%s: i=%zu\n", 
__FUNCTION__
, 
i
);

372 
	`fwrite
(
transmit_log
.
base
, 1, transmit_log.
off
, 
stderr
);

373 
	`ptls_buffer_dispose
(&
transmit_log
);

374 ++
num_failures_in_loss_core
;

376 
Exit
:

377 
	`fprintf
(
stderr
, "no memory\n");

378 
	`abort
();

379 
	}
}

381 static int 
	$cmp_int64
(const void *
_x
, const void *
_y
)

383 const 
int64_t
 *
x
 = 
_x
, *
y
 = 
_y
;

384 if (*
x
 < *
y
)

386 if (*
x
 > *
y
)

389 
	}
}

391 static void 
	$loss_check_stats
(
int64_t
 *
time_spent
, unsigned 
max_failures
, double 
expected_time_mean
, double 
expected_time_median
,

392 double 
expected_time_90th
)

394 
int64_t
 
sum
 = 0;

395 for (
size_t
 
i
 = 0; i < 100; ++i)

396 
sum
 += 
time_spent
[
i
];

398 double 
time_mean
 = 
sum
 / 100.;

400 
	`qsort
(
time_spent
, 100, sizeof(time_spent[0]), 
cmp_int64
);

401 double 
time_median
 = (
time_spent
[49] + time_spent[50]) / 2.;

402 double 
time_90th
 = (double)
time_spent
[89];

404 
	`printf
("fail: %u, times: mean: %.1f, median: %.1f, 90th: %.1f\n", 
num_failures_in_loss_core
, 
time_mean
, 
time_median
, 
time_90th
);

405 
	`ok
(
num_failures_in_loss_core
 <= 
max_failures
);

406 
	`ok
(
time_mean
 >= 
expected_time_mean
 * 0.6);

407 
	`ok
(
time_mean
 <= 
expected_time_mean
 * 1.2);

408 
	`ok
(
time_median
 >= 
expected_time_median
 * 0.6);

409 
	`ok
(
time_median
 <= 
expected_time_median
 * 1.2);

411 
	`ok
(
time_90th
 <= 
expected_time_90th
 * 1.2);

413 
num_failures_in_loss_core
 = 0;

414 
	}
}

416 static void 
	$test_downstream
(void)

418 
int64_t
 
time_spent
[100];

419 
size_t
 
i
;

421 
loss_cond_up
 = 
cond_true
;

423 
num_failures_in_loss_core
 = 0;

424 for (
i
 = 0; i != 100; ++i) {

425 
	`init_cond_rand
(&
loss_cond_down
, 3, 4);

426 
	`subtest
("75%", 
loss_core
);

427 
time_spent
[
i
] = 
quic_now
 - 1;

429 
	`loss_check_stats
(
time_spent
, 4, 14193, 3610, 17579);

431 for (
i
 = 0; i != 100; ++i) {

432 
	`init_cond_rand
(&
loss_cond_down
, 1, 2);

433 
	`subtest
("50%", 
loss_core
);

434 
time_spent
[
i
] = 
quic_now
 - 1;

436 
	`loss_check_stats
(
time_spent
, 0, 2220, 608, 2779);

438 for (
i
 = 0; i != 100; ++i) {

439 
	`init_cond_rand
(&
loss_cond_down
, 1, 4);

440 
	`subtest
("25%", 
loss_core
);

441 
time_spent
[
i
] = 
quic_now
 - 1;

443 
	`loss_check_stats
(
time_spent
, 0, 228.7, 230, 408);

445 for (
i
 = 0; i != 100; ++i) {

446 
	`init_cond_rand
(&
loss_cond_down
, 1, 10);

447 
	`subtest
("10%", 
loss_core
);

448 
time_spent
[
i
] = 
quic_now
 - 1;

450 
	`loss_check_stats
(
time_spent
, 0, 140.2, 80, 298);

452 for (
i
 = 0; i != 100; ++i) {

453 
	`init_cond_rand
(&
loss_cond_down
, 1, 20);

454 
	`subtest
("5%", 
loss_core
);

455 
time_spent
[
i
] = 
quic_now
 - 1;

457 
	`loss_check_stats
(
time_spent
, 0, 99.9, 80, 230);

459 for (
i
 = 0; i != 100; ++i) {

460 
	`init_cond_rand
(&
loss_cond_down
, 1, 40);

461 
	`subtest
("2.5%", 
loss_core
);

462 
time_spent
[
i
] = 
quic_now
 - 1;

464 
	`loss_check_stats
(
time_spent
, 0, 90.8, 80, 80);

466 for (
i
 = 0; i != 100; ++i) {

467 
	`init_cond_rand
(&
loss_cond_down
, 1, 64);

468 
	`subtest
("1.6%", 
loss_core
);

469 
time_spent
[
i
] = 
quic_now
 - 1;

471 
	`loss_check_stats
(
time_spent
, 0, 91.1, 80, 80);

472 
	}
}

474 static void 
	$test_bidirectional
(void)

476 
int64_t
 
time_spent
[100];

477 
size_t
 
i
;

479 
num_failures_in_loss_core
 = 0;

480 for (
i
 = 0; i != 100; ++i) {

481 
	`init_cond_rand
(&
loss_cond_down
, 3, 4);

482 
	`init_cond_rand
(&
loss_cond_up
, 3, 4);

483 
	`subtest
("75%", 
loss_core
);

484 
time_spent
[
i
] = 
quic_now
 - 1;

486 
	`loss_check_stats
(
time_spent
, 20, 240012.7, 126541, 652328);

488 for (
i
 = 0; i != 100; ++i) {

489 
	`init_cond_rand
(&
loss_cond_down
, 1, 2);

490 
	`init_cond_rand
(&
loss_cond_up
, 1, 2);

491 
	`subtest
("50%", 
loss_core
);

492 
time_spent
[
i
] = 
quic_now
 - 1;

494 
	`loss_check_stats
(
time_spent
, 0, 2286.9, 1175, 6424);

496 for (
i
 = 0; i != 100; ++i) {

497 
	`init_cond_rand
(&
loss_cond_down
, 1, 4);

498 
	`init_cond_rand
(&
loss_cond_up
, 1, 4);

499 
	`subtest
("25%", 
loss_core
);

500 
time_spent
[
i
] = 
quic_now
 - 1;

502 
	`loss_check_stats
(
time_spent
, 0, 328.7, 237, 530);

504 for (
i
 = 0; i != 100; ++i) {

505 
	`init_cond_rand
(&
loss_cond_down
, 1, 10);

506 
	`init_cond_rand
(&
loss_cond_up
, 1, 10);

507 
	`subtest
("10%", 
loss_core
);

508 
time_spent
[
i
] = 
quic_now
 - 1;

510 
	`loss_check_stats
(
time_spent
, 0, 150.1, 80, 298);

512 for (
i
 = 0; i != 100; ++i) {

513 
	`init_cond_rand
(&
loss_cond_down
, 1, 20);

514 
	`init_cond_rand
(&
loss_cond_up
, 1, 20);

515 
	`subtest
("5%", 
loss_core
);

516 
time_spent
[
i
] = 
quic_now
 - 1;

518 
	`loss_check_stats
(
time_spent
, 0, 103.5, 80, 192);

520 for (
i
 = 0; i != 100; ++i) {

521 
	`init_cond_rand
(&
loss_cond_down
, 1, 40);

522 
	`init_cond_rand
(&
loss_cond_up
, 1, 40);

523 
	`subtest
("2.5%", 
loss_core
);

524 
time_spent
[
i
] = 
quic_now
 - 1;

526 
	`loss_check_stats
(
time_spent
, 0, 96.7, 80, 80);

528 for (
i
 = 0; i != 100; ++i) {

529 
	`init_cond_rand
(&
loss_cond_down
, 1, 64);

530 
	`init_cond_rand
(&
loss_cond_up
, 1, 64);

531 
	`subtest
("1.6%", 
loss_core
);

532 
time_spent
[
i
] = 
quic_now
 - 1;

534 
	`loss_check_stats
(
time_spent
, 0, 96.7, 80, 190);

535 
	}
}

537 void 
	$test_lossy
(void)

539 
	`subtest
("even", 
test_even
);

541 
uint64_t
 
idle_timeout_backup
 = 
quic_ctx
.
transport_params
.
max_idle_timeout
;

542 
quic_ctx
.
transport_params
.
max_idle_timeout
 = (
uint64_t
)600 * 1000;

543 
	`subtest
("downstream", 
test_downstream
);

544 
quic_ctx
.
transport_params
.
max_idle_timeout
 = (
uint64_t
)600 * 1000;

545 
	`subtest
("bidirectional", 
test_bidirectional
);

546 
quic_ctx
.
transport_params
.
max_idle_timeout
 = 
idle_timeout_backup
;

547 
	}
}

	@t/maxsender.c

22 #include 
	~"quicly/maxsender.h
"

23 #include 
	~"test.h
"

25 static void 
	$test_basic
(void)

27 
quicly_maxsender_t
 
m
;

28 
quicly_maxsender_sent_t
 
ackargs
;

30 
	`quicly_maxsender_init
(&
m
, 100);

33 
	`ok
(!
	`quicly_maxsender_should_send_max
(&
m
, 0, 100, 512));

34 
	`ok
(
	`quicly_maxsender_should_send_max
(&
m
, 0, 100, 1024));

35 
	`ok
(!
	`quicly_maxsender_should_send_max
(&
m
, 99, 100, 0));

36 
	`ok
(
	`quicly_maxsender_should_send_max
(&
m
, 100, 100, 0));

39 
	`ok
(!
	`quicly_maxsender_should_send_max
(&
m
, 24, 100, 768));

40 
	`ok
(
	`quicly_maxsender_should_send_max
(&
m
, 25, 100, 768));

41 
	`quicly_maxsender_record
(&
m
, 125, &
ackargs
);

42 
	`ok
(!
	`quicly_maxsender_should_send_max
(&
m
, 49, 100, 768));

43 
	`ok
(
	`quicly_maxsender_should_send_max
(&
m
, 50, 100, 768));

44 
	`quicly_maxsender_acked
(&
m
, &
ackargs
);

45 
	`ok
(!
	`quicly_maxsender_should_send_max
(&
m
, 49, 100, 768));

46 
	`ok
(
	`quicly_maxsender_should_send_max
(&
m
, 50, 100, 768));

47 
	`quicly_maxsender_record
(&
m
, 150, &
ackargs
);

48 
	`ok
(!
	`quicly_maxsender_should_send_max
(&
m
, 74, 100, 768));

49 
	`quicly_maxsender_lost
(&
m
, &
ackargs
);

50 
	`ok
(
	`quicly_maxsender_should_send_max
(&
m
, 74, 100, 768));

51 
	}
}

53 void 
	$test_maxsender
(void)

55 
	`subtest
("basic", 
test_basic
);

56 
	}
}

	@t/ranges.c

22 #include 
	~"quicly/ranges.h
"

23 #include 
	~"test.h
"

25 #define 
	#CHECK
(...) \

27 static const struct 
st_quicly_range_t
 
expected
[] = {
__VA_ARGS__
}; \

28 
	`ok
(
ranges
.
num_ranges
 == 
	`PTLS_ELEMENTSOF
(
expected
)); \

29 
size_t
 
i
; \

30 for (
i
 = 0; i != 
ranges
.
num_ranges
; ++i) { \

31 
	`ok
(
ranges
.ranges[
i
].
start
 == 
expected
[i].start); \

32 
	`ok
(
ranges
.ranges[
i
].
end
 == 
expected
[i].end); \

34 } while (0)

	)

36 static void 
	$test_add
(void)

38 
quicly_ranges_t
 
ranges
;

39 int 
ret
;

41 
	`quicly_ranges_init
(&
ranges
);

42 
	`ok
(
ranges
.
num_ranges
 == 0);

44 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 40, 100);

45 
	`ok
(
ret
 == 0);

46 
	`CHECK
({40, 100});

48 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 30, 40);

49 
	`ok
(
ret
 == 0);

50 
	`CHECK
({30, 100});

52 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 0, 10);

53 
	`ok
(
ret
 == 0);

54 
	`CHECK
({0, 10}, {30, 100});

56 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 10, 30);

57 
	`ok
(
ret
 == 0);

58 
	`CHECK
({0, 100});

60 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 200, 300);

61 
	`ok
(
ret
 == 0);

62 
	`CHECK
({0, 100}, {200, 300});

64 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 100, 110);

65 
	`ok
(
ret
 == 0);

66 
	`CHECK
({0, 110}, {200, 300});

68 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 190, 200);

69 
	`ok
(
ret
 == 0);

70 
	`CHECK
({0, 110}, {190, 300});

72 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 100, 120);

73 
	`ok
(
ret
 == 0);

74 
	`CHECK
({0, 120}, {190, 300});

76 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 180, 200);

77 
	`ok
(
ret
 == 0);

78 
	`CHECK
({0, 120}, {180, 300});

80 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 130, 150);

81 
	`ok
(
ret
 == 0);

82 
	`CHECK
({0, 120}, {130, 150}, {180, 300});

84 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 160, 170);

85 
	`ok
(
ret
 == 0);

86 
	`CHECK
({0, 120}, {130, 150}, {160, 170}, {180, 300});

88 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 170, 180);

89 
	`ok
(
ret
 == 0);

90 
	`CHECK
({0, 120}, {130, 150}, {160, 300});

92 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 110, 180);

93 
	`ok
(
ret
 == 0);

94 
	`CHECK
({0, 300});

95 
	}
}

97 static void 
	$test_subtract
(void)

99 
quicly_ranges_t
 
ranges
;

100 int 
ret
;

102 
	`quicly_ranges_init
(&
ranges
);

104 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 100, 200);

105 
	`ok
(
ret
 == 0);

107 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 0, 50);

108 
	`ok
(
ret
 == 0);

109 
	`CHECK
({100, 200});

111 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 0, 100);

112 
	`ok
(
ret
 == 0);

113 
	`CHECK
({100, 200});

115 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 250, 300);

116 
	`ok
(
ret
 == 0);

117 
	`CHECK
({100, 200});

119 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 200, 300);

120 
	`ok
(
ret
 == 0);

121 
	`CHECK
({100, 200});

123 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 100, 110);

124 
	`ok
(
ret
 == 0);

125 
	`CHECK
({110, 200});

127 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 120, 130);

128 
	`ok
(
ret
 == 0);

129 
	`CHECK
({110, 120}, {130, 200});

131 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 120, 130);

132 
	`ok
(
ret
 == 0);

133 
	`CHECK
({110, 120}, {130, 200});

135 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 121, 129);

136 
	`ok
(
ret
 == 0);

137 
	`CHECK
({110, 120}, {130, 200});

139 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 119, 120);

140 
	`ok
(
ret
 == 0);

141 
	`CHECK
({110, 119}, {130, 200});

143 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 118, 120);

144 
	`ok
(
ret
 == 0);

145 
	`CHECK
({110, 118}, {130, 200});

147 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 130, 132);

148 
	`ok
(
ret
 == 0);

149 
	`CHECK
({110, 118}, {132, 200});

151 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 130, 133);

152 
	`ok
(
ret
 == 0);

153 
	`CHECK
({110, 118}, {133, 200});

155 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 118, 134);

156 
	`ok
(
ret
 == 0);

157 
	`CHECK
({110, 118}, {134, 200});

159 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 117, 134);

160 
	`ok
(
ret
 == 0);

161 
	`CHECK
({110, 117}, {134, 200});

163 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 116, 135);

164 
	`ok
(
ret
 == 0);

165 
	`CHECK
({110, 116}, {135, 200});

167 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 110, 140);

168 
	`ok
(
ret
 == 0);

169 
	`CHECK
({140, 200});

171 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 100, 120);

172 
	`ok
(
ret
 == 0);

173 
	`CHECK
({100, 120}, {140, 200});

175 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 80, 150);

176 
	`ok
(
ret
 == 0);

177 
	`CHECK
({150, 200});

179 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 100, 120);

180 
	`ok
(
ret
 == 0);

181 
	`CHECK
({100, 120}, {150, 200});

183 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 118, 200);

184 
	`ok
(
ret
 == 0);

185 
	`CHECK
({100, 118});

187 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 140, 200);

188 
	`ok
(
ret
 == 0);

189 
	`CHECK
({100, 118}, {140, 200});

191 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 118, 240);

192 
	`ok
(
ret
 == 0);

193 
	`CHECK
({100, 118});

195 
ret
 = 
	`quicly_ranges_add
(&
ranges
, 140, 200);

196 
	`ok
(
ret
 == 0);

197 
	`CHECK
({100, 118}, {140, 200});

199 
ret
 = 
	`quicly_ranges_subtract
(&
ranges
, 117, 240);

200 
	`ok
(
ret
 == 0);

201 
	`CHECK
({100, 117});

202 
	}
}

204 void 
	$test_ranges
(void)

206 
	`subtest
("add", 
test_add
);

207 
	`subtest
("subtract", 
test_subtract
);

208 
	}
}

	@t/remote_cid.c

23 #include 
	~"test.h
"

24 #include 
	~"quicly/remote_cid.h
"

26 #define 
	#CID_LEN
 8

	)

29 static 
uint8_t
 
	gcids
[][
CID_LEN
] = {

41 static 
uint8_t
 
	gsrts
[][
QUICLY_STATELESS_RESET_TOKEN_LEN
] = {

54 void 
	$test_received_cid
(void)

56 
quicly_remote_cid_set_t
 
set
;

57 
uint64_t
 
unregistered_seqs
[
QUICLY_LOCAL_ACTIVE_CONNECTION_ID_LIMIT
];

58 
size_t
 
num_unregistered
;

60 
	`quicly_remote_cid_init_set
(&
set
, 
NULL
, 
quic_ctx
.
tls
->
random_bytes
);

62 for (int 
i
 = 1; i < 4; i++) {

63 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 
i
, 
cids
[i], 
CID_LEN
, 
srts
[i], 0, 
unregistered_seqs
, &
num_unregistered
) == 0);

64 
	`ok
(
num_unregistered
 == 0);

69 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 1, 
cids
[1], 
CID_LEN
, 
srts
[1], 0, 
unregistered_seqs
, &
num_unregistered
) == 0);

70 
	`ok
(
num_unregistered
 == 0);

72 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 0, 
cids
[1], 
CID_LEN
, 
srts
[1], 0, 
unregistered_seqs
, &
num_unregistered
) != 0);

73 
	`ok
(
num_unregistered
 == 0);

75 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 4, 
cids
[4], 
CID_LEN
, 
srts
[4], 0, 
unregistered_seqs
, &
num_unregistered
) ==

76 
QUICLY_TRANSPORT_ERROR_CONNECTION_ID_LIMIT
);

77 
	`ok
(
set
.
cids
[0].
is_active
 && "we have CID to send error");

80 
	`ok
(
	`quicly_remote_cid_unregister
(&
set
, 255) != 0);

82 
	`ok
(
	`quicly_remote_cid_unregister
(&
set
, 0) == 0);

84 
	`ok
(
set
.
cids
[0].
is_active
);

85 
	`ok
(
set
.
cids
[0].
sequence
 == 1);

86 
	`ok
(
	`memcmp
(
set
.
cids
[0].
cid
.cid, cids[1], 
CID_LEN
) == 0);

87 
	`ok
(
	`memcmp
(
set
.
cids
[0].
stateless_reset_token
, 
srts
[1], 
QUICLY_STATELESS_RESET_TOKEN_LEN
) == 0);

89 
	`ok
(
	`quicly_remote_cid_unregister
(&
set
, 0) != 0);

91 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 255, 
cids
[4], 
CID_LEN
, 
srts
[4], 0, 
unregistered_seqs
, &
num_unregistered
) ==

92 
QUICLY_TRANSPORT_ERROR_CONNECTION_ID_LIMIT
);

93 
	`ok
(
set
.
cids
[0].
is_active
 && "we have CID to send error");

96 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 0, 
cids
[0], 
CID_LEN
, 
srts
[0], 0, 
unregistered_seqs
, &
num_unregistered
) == 0);

97 
	`ok
(
num_unregistered
 == 0);

100 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 4, 
cids
[4], 
CID_LEN
, 
srts
[4], 0, 
unregistered_seqs
, &
num_unregistered
) == 0);

101 
	`ok
(
num_unregistered
 == 0);

105 
	`ok
(
	`quicly_remote_cid_unregister
(&
set
, 2) == 0);

107 
	`ok
(
set
.
cids
[0].
is_active
);

108 
	`ok
(
set
.
cids
[0].
sequence
 == 1);

111 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 5, 
cids
[5], 
CID_LEN
, 
srts
[5], 5, 
unregistered_seqs
, &
num_unregistered
) == 0);

113 
	`ok
(
num_unregistered
 == 3);

116 char 
expected
[5] = {0, 1, 0, 1, 1};

117 char 
seqset
[5] = {0};

118 for (
size_t
 
i
 = 0; i < 
num_unregistered
; i++) {

119 if (
unregistered_seqs
[
i
] < sizeof(
seqset
))

120 
seqset
[
unregistered_seqs
[
i
]] = 1;

122 
	`ok
(
	`memcmp
(
seqset
, 
expected
, sizeof(seqset)) == 0);

125 
	`ok
(
set
.
cids
[0].
is_active
);

126 
	`ok
(
set
.
cids
[0].
sequence
 == 5);

127 
	`ok
(
	`memcmp
(
set
.
cids
[0].
cid
.cid, cids[5], 
CID_LEN
) == 0);

128 
	`ok
(
	`memcmp
(
set
.
cids
[0].
stateless_reset_token
, 
srts
[5], 
QUICLY_STATELESS_RESET_TOKEN_LEN
) == 0);

131 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 8, 
cids
[8], 
CID_LEN
, 
srts
[8], 5, 
unregistered_seqs
, &
num_unregistered
) == 0);

132 
	`ok
(
num_unregistered
 == 0);

134 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 7, 
cids
[7], 
CID_LEN
, 
srts
[7], 5, 
unregistered_seqs
, &
num_unregistered
) == 0);

136 
	`ok
(
set
.
cids
[0].
is_active
);

137 
	`ok
(
set
.
cids
[0].
sequence
 == 5);

140 
	`ok
(
	`quicly_remote_cid_register
(&
set
, 8, 
cids
[8], 
CID_LEN
, 
srts
[8], 8, 
unregistered_seqs
, &
num_unregistered
) == 0);

142 
	`ok
(
num_unregistered
 == 2);

145 char 
expected
[8] = {0, 0, 0, 0, 0, 1, 0, 1};

146 char 
seqset
[8] = {0};

147 for (
size_t
 
i
 = 0; i < 
num_unregistered
; i++) {

148 if (
unregistered_seqs
[
i
] < sizeof(
seqset
))

149 
seqset
[
unregistered_seqs
[
i
]] = 1;

151 
	`ok
(
	`memcmp
(
seqset
, 
expected
, sizeof(seqset)) == 0);

153 
	`ok
(
set
.
cids
[0].
is_active
);

154 
	`ok
(
set
.
cids
[0].
sequence
 == 8);

155 
	}
}

	@t/retire_cid.c

23 #include 
	~"test.h
"

24 #include 
	~"picotls.h
"

25 #include 
	~"quicly/retire_cid.h
"

31 static int 
	$verify
(const 
quicly_retire_cid_set_t
 *
set
, const 
uint64_t
 
expected_seqs
[], 
size_t
 
num_seqs
)

33 
size_t
 
i
;

35 if (
set
->
_num_pending
 != 
num_seqs
)

38 for (
i
 = 0; i < 
num_seqs
 && i < 
	`PTLS_ELEMENTSOF
(
set
->
sequences
); i++) {

39 if (
set
->
sequences
[
i
] != 
expected_seqs
[i])

44 
	}
}

46 void 
	$test_retire_cid
(void)

48 
uint64_t
 
sequence
 = 0;

50 
quicly_retire_cid_set_t
 
set
;

51 
	`quicly_retire_cid_init
(&
set
);

54 
	`ok
(
	`verify
(&
set
, 
NULL
, 0) == 0);

57 
	`quicly_retire_cid_push
(&
set
, 
sequence
);

59 
uint64_t
 
seqs
[] = {
sequence
};

60 
	`ok
(
	`verify
(&
set
, 
seqs
, 
	`PTLS_ELEMENTSOF
(seqs)) == 0);

63 
sequence
++;

66 
	`quicly_retire_cid_shift
(&
set
, 1);

67 
	`ok
(
	`verify
(&
set
, 
NULL
, 0) == 0);

71 
uint64_t
 
seqs
[
	`PTLS_ELEMENTSOF
(
set
.
sequences
)];

72 for (
size_t
 
i
 = 0; i < 
	`PTLS_ELEMENTSOF
(
set
.
sequences
); i++) {

73 
seqs
[
i
] = 
sequence
;

74 
	`quicly_retire_cid_push
(&
set
, 
sequence
);

75 
sequence
++;

77 
	`ok
(
	`verify
(&
set
, 
seqs
, 
	`PTLS_ELEMENTSOF
(seqs)) == 0);

79 
	`quicly_retire_cid_push
(&
set
, 
seqs
[0]);

80 
	`ok
(
	`verify
(&
set
, 
seqs
, 
	`PTLS_ELEMENTSOF
(seqs)) == 0);

82 
	`quicly_retire_cid_push
(&
set
, 
sequence
 + 1);

83 
	`ok
(
	`verify
(&
set
, 
seqs
, 
	`PTLS_ELEMENTSOF
(seqs)) == 0);

85 
	`quicly_retire_cid_shift
(&
set
, 0);

87 
size_t
 
num_shift
 = 
	`PTLS_ELEMENTSOF
(
seqs
) / 2;

88 
	`quicly_retire_cid_shift
(&
set
, 
num_shift
);

89 
	`ok
(
	`verify
(&
set
, 
seqs
 + 
num_shift
, 
	`PTLS_ELEMENTSOF
(seqs) - num_shift) == 0);

91 
	`quicly_retire_cid_shift
(&
set
, 0);

92 
	`ok
(
	`verify
(&
set
, 
seqs
 + 
num_shift
, 
	`PTLS_ELEMENTSOF
(seqs) - num_shift) == 0);

94 
	`quicly_retire_cid_shift
(&
set
, 
	`PTLS_ELEMENTSOF
(
seqs
) - 
num_shift
);

95 
	`ok
(
	`verify
(&
set
, 
NULL
, 0) == 0);

97 
	}
}

	@t/sentmap.c

22 #include 
	~"quicly/sentmap.h
"

23 #include 
	~"test.h
"

25 static int 
	gon_acked_callcnt
, 
	gon_acked_ackcnt
;

27 static int 
	$on_acked
(
quicly_sentmap_t
 *
map
, const 
quicly_sent_packet_t
 *
packet
, int 
acked
, 
quicly_sent_t
 *
sent
)

29 ++
on_acked_callcnt
;

30 if (
acked
)

31 ++
on_acked_ackcnt
;

33 
	}
}

35 static 
size_t
 
	$num_blocks
(
quicly_sentmap_t
 *
map
)

37 struct 
st_quicly_sent_block_t
 *
block
;

38 
size_t
 
n
 = 0;

40 for (
block
 = 
map
->
head
; block != 
NULL
; block = block->
next
)

41 ++
n
;

43 return 
n
;

44 
	}
}

46 static void 
	$test_basic
(void)

48 
quicly_sentmap_t
 
map
;

49 
uint64_t
 
at
;

50 
size_t
 
i
;

51 
quicly_sentmap_iter_t
 
iter
;

52 const 
quicly_sent_packet_t
 *
sent
;

54 
	`quicly_sentmap_init
(&
map
);

57 for (
at
 = 0; at < 10; ++at) {

58 for (
i
 = 1; i <= 5; ++i) {

59 
	`quicly_sentmap_prepare
(&
map
, 
at
 * 5 + 
i
, at, 
QUICLY_EPOCH_INITIAL
);

60 
	`quicly_sentmap_allocate
(&
map
, 
on_acked
);

61 
	`quicly_sentmap_allocate
(&
map
, 
on_acked
);

62 
	`quicly_sentmap_commit
(&
map
, 1);

67 
	`quicly_sentmap_init_iter
(&
map
, &
iter
);

68 for (
at
 = 0; at < 10; ++at) {

69 for (
i
 = 1; i <= 5; ++i) {

70 const 
quicly_sent_packet_t
 *
sent
 = 
	`quicly_sentmap_get
(&
iter
);

71 
	`ok
(
sent
->
packet_number
 == 
at
 * 5 + 
i
);

72 
	`ok
(
sent
->
sent_at
 == 
at
);

73 
	`ok
(
sent
->
ack_epoch
 == 
QUICLY_EPOCH_INITIAL
);

74 
	`ok
(
sent
->
cc_bytes_in_flight
 == 1);

75 
	`quicly_sentmap_skip
(&
iter
);

78 
	`ok
(
	`quicly_sentmap_get
(&
iter
)->
packet_number
 == 
UINT64_MAX
);

79 
	`ok
(
	`num_blocks
(&
map
) == 150 / 16 + 1);

82 
	`quicly_sentmap_init_iter
(&
map
, &
iter
);

83 while (
	`quicly_sentmap_get
(&
iter
)->
packet_number
 <= 10)

84 
	`quicly_sentmap_skip
(&
iter
);

85 
	`assert
(
	`quicly_sentmap_get
(&
iter
)->
packet_number
 == 11);

86 while (
	`quicly_sentmap_get
(&
iter
)->
packet_number
 <= 40)

87 
	`quicly_sentmap_update
(&
map
, &
iter
, 
QUICLY_SENTMAP_EVENT_EXPIRED
);

88 
	`ok
(
on_acked_callcnt
 == 30 * 2);

89 
	`ok
(
on_acked_ackcnt
 == 0);

91 
size_t
 
cnt
 = 0;

92 for (
	`quicly_sentmap_init_iter
(&
map
, &
iter
); (
sent
 = 
	`quicly_sentmap_get
(&iter))->
packet_number
 != 
UINT64_MAX
;

93 
	`quicly_sentmap_skip
(&
iter
)) {

94 
	`ok
(
sent
->
cc_bytes_in_flight
 != 0);

95 
	`ok
(
sent
->
packet_number
 <= 10 || 40 < sent->packet_number);

96 ++
cnt
;

98 
	`ok
(
cnt
 == 20);

99 
	`ok
(
	`num_blocks
(&
map
) == 30 / 16 + 1 + 1 + 30 / 16 + 1);

101 
	`quicly_sentmap_dispose
(&
map
);

102 
	}
}

104 static void 
	$test_late_ack
(void)

106 
quicly_sentmap_t
 
map
;

107 
quicly_sentmap_iter_t
 
iter
;

108 const 
quicly_sent_packet_t
 *
sent
;

110 
on_acked_callcnt
 = 0;

111 
on_acked_ackcnt
 = 0;

113 
	`quicly_sentmap_init
(&
map
);

116 
	`quicly_sentmap_prepare
(&
map
, 1, 0, 
QUICLY_EPOCH_INITIAL
);

117 
	`quicly_sentmap_allocate
(&
map
, 
on_acked
);

118 
	`quicly_sentmap_commit
(&
map
, 10);

119 
	`quicly_sentmap_prepare
(&
map
, 2, 0, 
QUICLY_EPOCH_INITIAL
);

120 
	`quicly_sentmap_allocate
(&
map
, 
on_acked
);

121 
	`quicly_sentmap_commit
(&
map
, 20);

122 
	`ok
(
map
.
bytes_in_flight
 == 30);

125 
	`quicly_sentmap_init_iter
(&
map
, &
iter
);

126 
sent
 = 
	`quicly_sentmap_get
(&
iter
);

127 
	`assert
(
sent
->
packet_number
 == 1);

128 
	`ok
(
	`quicly_sentmap_update
(&
map
, &
iter
, 
QUICLY_SENTMAP_EVENT_LOST
) == 0);

129 
	`ok
(
on_acked_callcnt
 == 1);

130 
	`ok
(
on_acked_ackcnt
 == 0);

131 
	`ok
(
map
.
bytes_in_flight
 == 20);

134 
	`quicly_sentmap_init_iter
(&
map
, &
iter
);

135 
sent
 = 
	`quicly_sentmap_get
(&
iter
);

136 
	`assert
(
sent
->
packet_number
 == 1);

137 
	`ok
(
	`quicly_sentmap_update
(&
map
, &
iter
, 
QUICLY_SENTMAP_EVENT_ACKED
) == 0);

138 
sent
 = 
	`quicly_sentmap_get
(&
iter
);

139 
	`assert
(
sent
->
packet_number
 == 2);

140 
	`ok
(
	`quicly_sentmap_update
(&
map
, &
iter
, 
QUICLY_SENTMAP_EVENT_ACKED
) == 0);

141 
	`ok
(
on_acked_callcnt
 == 3);

142 
	`ok
(
on_acked_ackcnt
 == 2);

143 
	`ok
(
map
.
bytes_in_flight
 == 0);

145 
	`quicly_sentmap_dispose
(&
map
);

146 
	}
}

148 static void 
	$test_pto
(void)

150 
quicly_sentmap_t
 
map
;

151 
quicly_sentmap_iter_t
 
iter
;

152 const 
quicly_sent_packet_t
 *
sent
;

154 
on_acked_callcnt
 = 0;

155 
on_acked_ackcnt
 = 0;

157 
	`quicly_sentmap_init
(&
map
);

160 
	`quicly_sentmap_prepare
(&
map
, 1, 0, 
QUICLY_EPOCH_INITIAL
);

161 
	`quicly_sentmap_allocate
(&
map
, 
on_acked
);

162 
	`quicly_sentmap_commit
(&
map
, 10);

163 
	`quicly_sentmap_prepare
(&
map
, 2, 0, 
QUICLY_EPOCH_INITIAL
);

164 
	`quicly_sentmap_allocate
(&
map
, 
on_acked
);

165 
	`quicly_sentmap_commit
(&
map
, 20);

166 
	`ok
(
map
.
bytes_in_flight
 == 30);

169 
	`quicly_sentmap_init_iter
(&
map
, &
iter
);

170 
sent
 = 
	`quicly_sentmap_get
(&
iter
);

171 
	`assert
(
sent
->
packet_number
 == 1);

172 
	`ok
(
	`quicly_sentmap_update
(&
map
, &
iter
, 
QUICLY_SENTMAP_EVENT_PTO
) == 0);

173 
	`ok
(
on_acked_callcnt
 == 1);

174 
	`ok
(
on_acked_ackcnt
 == 0);

175 
	`ok
(
map
.
bytes_in_flight
 == 30);

178 
	`quicly_sentmap_init_iter
(&
map
, &
iter
);

179 
sent
 = 
	`quicly_sentmap_get
(&
iter
);

180 
	`assert
(
sent
->
packet_number
 == 1);

181 
	`ok
(
	`quicly_sentmap_update
(&
map
, &
iter
, 
QUICLY_SENTMAP_EVENT_ACKED
) == 0);

182 
sent
 = 
	`quicly_sentmap_get
(&
iter
);

183 
	`assert
(
sent
->
packet_number
 == 2);

184 
	`ok
(
	`quicly_sentmap_update
(&
map
, &
iter
, 
QUICLY_SENTMAP_EVENT_ACKED
) == 0);

185 
	`ok
(
on_acked_callcnt
 == 3);

186 
	`ok
(
on_acked_ackcnt
 == 2);

187 
	`ok
(
map
.
bytes_in_flight
 == 0);

189 
	`quicly_sentmap_dispose
(&
map
);

190 
	}
}

192 void 
	$test_sentmap
(void)

194 
	`subtest
("basic", 
test_basic
);

195 
	`subtest
("late-ack", 
test_late_ack
);

196 
	`subtest
("pto", 
test_pto
);

197 
	}
}

	@t/simple.c

22 #include 
	~<string.h
>

23 #include 
	~"quicly/streambuf.h
"

24 #include 
	~"test.h
"

26 static 
quicly_conn_t
 *
	gclient
, *
	gserver
;

28 static void 
	$test_handshake
(void)

30 
quicly_address_t
 
dest
, 
src
;

31 struct 
iovec
 
packets
[8];

32 
uint8_t
 
packetsbuf
[
	`PTLS_ELEMENTSOF
(
packets
) * 
quic_ctx
.
transport_params
.
max_udp_payload_size
];

33 
size_t
 
num_packets
, 
num_decoded
;

34 
quicly_decoded_packet_t
 
decoded
[
	`PTLS_ELEMENTSOF
(
packets
) * 4];

35 int 
ret
, 
i
;

38 
ret
 = 
	`quicly_connect
(&
client
, &
quic_ctx
, "example.com", &
fake_address
.
sa
, 
NULL
, 
	`new_master_id
(), 
	`ptls_iovec_init
(NULL, 0), NULL,

39 
NULL
);

40 
	`ok
(
ret
 == 0);

41 
num_packets
 = 
	`PTLS_ELEMENTSOF
(
packets
);

42 
ret
 = 
	`quicly_send
(
client
, &
dest
, &
src
, 
packets
, &
num_packets
, 
packetsbuf
, sizeof(packetsbuf));

43 
	`ok
(
ret
 == 0);

44 
	`ok
(
num_packets
 == 1);

45 
	`ok
(
packets
[0].
iov_len
 == 1280);

48 
num_decoded
 = 
	`decode_packets
(
decoded
, 
packets
, 
num_packets
);

49 
	`ok
(
num_decoded
 == 1);

50 
ret
 = 
	`quicly_accept
(&
server
, &
quic_ctx
, 
NULL
, &
fake_address
.
sa
, 
decoded
, NULL, 
	`new_master_id
(), NULL);

51 
	`ok
(
ret
 == 0);

52 
	`ok
(
	`quicly_get_state
(
server
) == 
QUICLY_STATE_CONNECTED
);

53 
	`ok
(
	`quicly_connection_is_ready
(
server
));

54 
num_packets
 = 
	`PTLS_ELEMENTSOF
(
packets
);

55 
ret
 = 
	`quicly_send
(
server
, &
dest
, &
src
, 
packets
, &
num_packets
, 
packetsbuf
, sizeof(packetsbuf));

56 
	`ok
(
ret
 == 0);

57 
	`ok
(
num_packets
 != 0);

60 
num_decoded
 = 
	`decode_packets
(
decoded
, 
packets
, 
num_packets
);

61 for (
i
 = 0; i != 
num_decoded
; ++i) {

62 
ret
 = 
	`quicly_receive
(
client
, 
NULL
, &
fake_address
.
sa
, 
decoded
 + 
i
);

63 
	`ok
(
ret
 == 0);

65 
	`ok
(
	`quicly_get_state
(
client
) == 
QUICLY_STATE_CONNECTED
);

66 
	`ok
(
	`quicly_connection_is_ready
(
client
));

67 
num_packets
 = 
	`PTLS_ELEMENTSOF
(
packets
);

68 
ret
 = 
	`quicly_send
(
client
, &
dest
, &
src
, 
packets
, &
num_packets
, 
packetsbuf
, sizeof(packetsbuf));

69 
	`ok
(
ret
 == 0);

70 
	`ok
(
num_packets
 != 0);

71 
	`ok
(
	`ptls_handshake_is_complete
(
	`quicly_get_tls
(
client
)));

74 
num_decoded
 = 
	`decode_packets
(
decoded
, 
packets
, 
num_packets
);

75 for (
i
 = 0; i != 
num_decoded
; ++i) {

76 
ret
 = 
	`quicly_receive
(
server
, 
NULL
, &
fake_address
.
sa
, 
decoded
 + 
i
);

77 
	`ok
(
ret
 == 0);

79 
	`ok
(
	`quicly_get_state
(
server
) == 
QUICLY_STATE_CONNECTED
);

80 
	`ok
(
	`ptls_handshake_is_complete
(
	`quicly_get_tls
(
server
)));

81 
num_packets
 = 
	`PTLS_ELEMENTSOF
(
packets
);

82 
ret
 = 
	`quicly_send
(
server
, &
dest
, &
src
, 
packets
, &
num_packets
, 
packetsbuf
, sizeof(packetsbuf));

83 
	`ok
(
ret
 == 0);

84 
	`ok
(
num_packets
 != 0);

87 
num_decoded
 = 
	`decode_packets
(
decoded
, 
packets
, 
num_packets
);

88 for (
i
 = 0; i != 
num_decoded
; ++i) {

89 
ret
 = 
	`quicly_receive
(
client
, 
NULL
, &
fake_address
.
sa
, 
decoded
 + 
i
);

90 
	`ok
(
ret
 == 0);

92 
	`ok
(
	`quicly_get_state
(
client
) == 
QUICLY_STATE_CONNECTED
);

93 
	`ok
(
	`quicly_get_first_timeout
(
client
) == 
quic_now
 + 
QUICLY_DELAYED_ACK_TIMEOUT
);

94 
quic_now
 = 
	`quicly_get_first_timeout
(
client
);

95 
num_packets
 = 
	`PTLS_ELEMENTSOF
(
packets
);

96 
ret
 = 
	`quicly_send
(
client
, &
dest
, &
src
, 
packets
, &
num_packets
, 
packetsbuf
, sizeof(packetsbuf));

97 
	`ok
(
ret
 == 0);

98 
	`ok
(
num_packets
 != 0);

101 
num_decoded
 = 
	`decode_packets
(
decoded
, 
packets
, 
num_packets
);

102 for (
i
 = 0; i != 
num_decoded
; ++i) {

103 
ret
 = 
	`quicly_receive
(
server
, 
NULL
, &
fake_address
.
sa
, 
decoded
 + 
i
);

104 
	`ok
(
ret
 == 0);

106 
	`ok
(
	`quicly_get_state
(
server
) == 
QUICLY_STATE_CONNECTED
);

109 
	`ok
(
	`quicly_get_first_timeout
(
server
) == 
quic_now
 + 
quic_ctx
.
transport_params
.
max_idle_timeout
);

110 
	`ok
(
	`quicly_get_first_timeout
(
client
) == 
quic_now
 + 
quic_ctx
.
transport_params
.
max_idle_timeout
);

111 
	}
}

113 static void 
	$simple_http
(void)

115 const char *
req
 = "GET / HTTP/1.0\r\n\r\n", *
resp
 = "HTTP/1.0 200 OK\r\n\r\nhello world";

116 
quicly_stream_t
 *
client_stream
, *
server_stream
;

117 
test_streambuf_t
 *
client_streambuf
, *
server_streambuf
;

118 int 
ret
;

120 
ret
 = 
	`quicly_open_stream
(
client
, &
client_stream
, 0);

121 
	`ok
(
ret
 == 0);

122 
	`ok
(
client_stream
->
stream_id
 == 0);

123 
client_streambuf
 = 
client_stream
->
data
;

125 
	`quicly_streambuf_egress_write
(
client_stream
, 
req
, 
	`strlen
(req));

126 
	`quicly_streambuf_egress_shutdown
(
client_stream
);

127 
	`ok
(
	`quicly_num_streams
(
client
) == 1);

129 
	`transmit
(
client
, 
server
);

131 
server_stream
 = 
	`quicly_get_stream
(
server
, 
client_stream
->
stream_id
);

132 
	`ok
(
server_stream
 != 
NULL
);

133 
server_streambuf
 = 
server_stream
->
data
;

134 
	`ok
(
	`quicly_recvstate_transfer_complete
(&
server_stream
->
recvstate
));

135 
	`ok
(
server_streambuf
->
error_received
.
reset_stream
 == -1);

136 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, 
req
));

137 
	`quicly_streambuf_egress_write
(
server_stream
, 
resp
, 
	`strlen
(resp));

138 
	`quicly_streambuf_egress_shutdown
(
server_stream
);

139 
	`ok
(
	`quicly_num_streams
(
server
) == 1);

141 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

142 
	`transmit
(
server
, 
client
);

144 
	`ok
(
client_streambuf
->
is_detached
);

145 
	`ok
(
client_streambuf
->
error_received
.
reset_stream
 == -1);

146 
	`ok
(
	`buffer_is
(&
client_streambuf
->
super
.
ingress
, 
resp
));

147 
	`ok
(
	`quicly_num_streams
(
client
) == 0);

148 
	`ok
(!
server_streambuf
->
is_detached
);

150 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

151 
	`transmit
(
client
, 
server
);

153 
	`ok
(
server_streambuf
->
is_detached
);

154 
	`ok
(
	`quicly_num_streams
(
server
) == 0);

155 
	}
}

157 static void 
	$test_reset_then_close
(void)

159 
quicly_stream_t
 *
client_stream
, *
server_stream
;

160 
test_streambuf_t
 *
client_streambuf
, *
server_streambuf
;

161 
uint64_t
 
stream_id
;

162 int 
ret
;

165 
ret
 = 
	`quicly_open_stream
(
client
, &
client_stream
, 0);

166 
	`ok
(
ret
 == 0);

167 
stream_id
 = 
client_stream
->stream_id;

168 
client_streambuf
 = 
client_stream
->
data
;

169 
	`quicly_reset_stream
(
client_stream
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(12345));

170 
	`quicly_request_stop
(
client_stream
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(54321));

172 
	`transmit
(
client
, 
server
);

175 
	`ok
(
	`quicly_num_streams
(
server
) == 1);

176 
server_stream
 = 
	`quicly_get_stream
(
server
, 
stream_id
);

177 
	`ok
(
server_stream
 != 
NULL
);

178 
server_streambuf
 = 
server_stream
->
data
;

179 
	`ok
(
	`quicly_sendstate_transfer_complete
(&
server_stream
->
sendstate
));

180 
	`ok
(
	`quicly_recvstate_transfer_complete
(&
server_stream
->
recvstate
));

181 
	`ok
(
server_streambuf
->
error_received
.
reset_stream
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(12345));

182 
	`ok
(
server_streambuf
->
error_received
.
stop_sending
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(54321));

184 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

185 
	`transmit
(
server
, 
client
);

188 
	`ok
(
client_streambuf
->
is_detached
);

189 
	`ok
(
client_streambuf
->
error_received
.
stop_sending
 == -1);

190 
	`ok
(
client_streambuf
->
error_received
.
reset_stream
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(54321));

191 
	`ok
(
	`quicly_num_streams
(
client
) == 0);

193 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

194 
	`transmit
(
client
, 
server
);

196 
	`ok
(
server_streambuf
->
is_detached
);

197 
	`ok
(
	`quicly_num_streams
(
server
) == 0);

198 
	}
}

200 static void 
	$test_send_then_close
(void)

202 
quicly_stream_t
 *
client_stream
, *
server_stream
;

203 
test_streambuf_t
 *
client_streambuf
, *
server_streambuf
;

204 int 
ret
;

206 
ret
 = 
	`quicly_open_stream
(
client
, &
client_stream
, 0);

207 
	`ok
(
ret
 == 0);

208 
client_streambuf
 = 
client_stream
->
data
;

209 
	`quicly_streambuf_egress_write
(
client_stream
, "hello", 5);

211 
	`transmit
(
client
, 
server
);

213 
server_stream
 = 
	`quicly_get_stream
(
server
, 
client_stream
->
stream_id
);

214 
	`assert
(
server_stream
 != 
NULL
);

215 
server_streambuf
 = 
server_stream
->
data
;

216 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, "hello"));

217 
	`quicly_streambuf_ingress_shift
(
server_stream
, 5);

219 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

220 
	`transmit
(
server
, 
client
);

222 
	`ok
(
client_stream
->
sendstate
.
acked
.
num_ranges
 == 1);

223 
	`ok
(
client_stream
->
sendstate
.
acked
.
ranges
[0].
start
 == 0);

224 
	`ok
(
client_stream
->
sendstate
.
acked
.
ranges
[0].
end
 == 5);

225 
	`quicly_streambuf_egress_shutdown
(
client_stream
);

227 
	`transmit
(
client
, 
server
);

229 
	`ok
(
	`quicly_recvstate_transfer_complete
(&
server_stream
->
recvstate
));

230 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, ""));

231 
	`quicly_streambuf_egress_shutdown
(
server_stream
);

233 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

234 
	`transmit
(
server
, 
client
);

236 
	`ok
(
client_streambuf
->
is_detached
);

237 
	`ok
(!
server_streambuf
->
is_detached
);

239 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

240 
	`transmit
(
client
, 
server
);

242 
	`ok
(
server_streambuf
->
is_detached
);

243 
	}
}

245 static void 
	$test_reset_after_close
(void)

247 
quicly_stream_t
 *
client_stream
, *
server_stream
;

248 
test_streambuf_t
 *
client_streambuf
, *
server_streambuf
;

249 int 
ret
;

251 
ret
 = 
	`quicly_open_stream
(
client
, &
client_stream
, 0);

252 
	`ok
(
ret
 == 0);

253 
client_streambuf
 = 
client_stream
->
data
;

254 
	`quicly_streambuf_egress_write
(
client_stream
, "hello", 5);

256 
	`transmit
(
client
, 
server
);

257 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

258 
	`transmit
(
server
, 
client
);

260 
server_stream
 = 
	`quicly_get_stream
(
server
, 
client_stream
->
stream_id
);

261 
	`assert
(
server_stream
 != 
NULL
);

262 
server_streambuf
 = 
server_stream
->
data
;

263 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, "hello"));

264 
	`quicly_streambuf_ingress_shift
(
server_stream
, 5);

266 
	`quicly_streambuf_egress_write
(
client_stream
, "world", 5);

267 
	`quicly_streambuf_egress_shutdown
(
client_stream
);

268 
	`quicly_reset_stream
(
client_stream
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(

272 
	`transmit
(
client
, 
server
);

274 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, ""));

275 
	`ok
(
	`quicly_recvstate_transfer_complete
(&
server_stream
->
recvstate
));

277 
	`quicly_streambuf_egress_shutdown
(
server_stream
);

279 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

280 
	`transmit
(
server
, 
client
);

282 
	`ok
(
client_streambuf
->
is_detached
);

284 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

285 
	`transmit
(
client
, 
server
);

287 
	`ok
(
server_streambuf
->
is_detached
);

288 
	}
}

290 static void 
	$tiny_stream_window
(void)

292 
quicly_max_stream_data_t
 
max_stream_data_orig
 = 
quic_ctx
.
transport_params
.
max_stream_data
;

293 
quicly_stream_t
 *
client_stream
, *
server_stream
;

294 
test_streambuf_t
 *
client_streambuf
, *
server_streambuf
;

295 
quicly_stats_t
 
stats
;

296 int 
ret
;

298 
quic_ctx
.
transport_params
.
max_stream_data
 = (
quicly_max_stream_data_t
){4, 4, 4};

300 
	`ok
(
	`max_data_is_equal
(
client
, 
server
));

302 
ret
 = 
	`quicly_open_stream
(
client
, &
client_stream
, 0);

303 
	`ok
(
ret
 == 0);

304 
client_streambuf
 = 
client_stream
->
data
;

305 
client_stream
->
_send_aux
.
max_stream_data
 = 4;

307 
	`quicly_streambuf_egress_write
(
client_stream
, "hello world", 11);

308 
	`quicly_streambuf_egress_shutdown
(
client_stream
);

310 
	`transmit
(
client
, 
server
);

312 
	`quicly_get_stats
(
client
, &
stats
);

313 
	`ok
(
stats
.
num_frames_sent
.
stream_data_blocked
 == 1);

314 
	`ok
(
stats
.
num_frames_sent
.
data_blocked
 == 0);

315 
	`quicly_get_stats
(
server
, &
stats
);

316 
	`ok
(
stats
.
num_frames_received
.
stream_data_blocked
 == 1);

317 
	`ok
(
stats
.
num_frames_received
.
data_blocked
 == 0);

319 
server_stream
 = 
	`quicly_get_stream
(
server
, 
client_stream
->
stream_id
);

320 
	`ok
(
server_stream
 != 
NULL
);

321 
server_streambuf
 = 
server_stream
->
data
;

322 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, "hell"));

323 
	`quicly_streambuf_ingress_shift
(
server_stream
, 3);

325 
	`transmit
(
server
, 
client
);

326 
	`transmit
(
client
, 
server
);

328 
	`quicly_get_stats
(
client
, &
stats
);

329 
	`ok
(
stats
.
num_frames_sent
.
stream_data_blocked
 == 2);

331 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, "lo w"));

332 
	`quicly_streambuf_ingress_shift
(
server_stream
, 4);

334 
	`transmit
(
server
, 
client
);

335 
	`transmit
(
client
, 
server
);

337 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, "orld"));

338 
	`ok
(
	`quicly_recvstate_transfer_complete
(&
server_stream
->
recvstate
));

340 
	`quicly_request_stop
(
client_stream
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(12345));

342 
	`transmit
(
client
, 
server
);

344 
	`quicly_get_stats
(
client
, &
stats
);

345 
	`ok
(
stats
.
num_frames_sent
.
stream_data_blocked
 == 2);

348 
	`ok
(
	`quicly_num_streams
(
client
) == 1);

349 
	`ok
(!
server_streambuf
->
is_detached
);

350 
	`ok
(
server_streambuf
->
error_received
.
stop_sending
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(12345));

351 
	`ok
(
	`quicly_sendstate_transfer_complete
(&
server_stream
->
sendstate
));

353 
	`transmit
(
server
, 
client
);

356 
	`ok
(
client_streambuf
->
is_detached
);

357 
	`ok
(
client_streambuf
->
error_received
.
reset_stream
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(12345));

358 
	`ok
(
client_streambuf
->
error_received
.
stop_sending
 == -1);

359 
	`ok
(
	`quicly_num_streams
(
client
) == 0);

360 
	`ok
(
	`quicly_num_streams
(
server
) == 1);

362 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

363 
	`transmit
(
client
, 
server
);

366 
	`ok
(
server_streambuf
->
is_detached
);

367 
	`ok
(
	`quicly_num_streams
(
server
) == 0);

369 
	`ok
(
	`max_data_is_equal
(
client
, 
server
));

371 
quic_ctx
.
transport_params
.
max_stream_data
 = 
max_stream_data_orig
;

372 
	}
}

374 static void 
	$test_reset_during_loss
(void)

376 
quicly_max_stream_data_t
 
max_stream_data_orig
 = 
quic_ctx
.
transport_params
.
max_stream_data
;

377 
quicly_stream_t
 *
client_stream
, *
server_stream
;

378 
test_streambuf_t
 *
client_streambuf
, *
server_streambuf
;

379 struct 
iovec
 
reordered_packet
;

380 
uint8_t
 
reordered_packet_buf
[
quic_ctx
.
transport_params
.
max_udp_payload_size
];

381 int 
ret
;

382 
uint64_t
 
max_data_at_start
, 
tmp
;

384 
quic_ctx
.
transport_params
.
max_stream_data
 = (
quicly_max_stream_data_t
){4, 4, 4};

386 
	`ok
(
	`max_data_is_equal
(
client
, 
server
));

387 
	`quicly_get_max_data
(
client
, 
NULL
, &
max_data_at_start
, NULL);

389 
ret
 = 
	`quicly_open_stream
(
client
, &
client_stream
, 0);

390 
	`ok
(
ret
 == 0);

391 
client_streambuf
 = 
client_stream
->
data
;

392 
client_stream
->
_send_aux
.
max_stream_data
 = 4;

393 
	`quicly_streambuf_egress_write
(
client_stream
, "hello world", 11);

396 
	`transmit
(
client
, 
server
);

397 
server_stream
 = 
	`quicly_get_stream
(
server
, 
client_stream
->
stream_id
);

398 
	`ok
(
server_stream
 != 
NULL
);

399 
server_streambuf
 = 
server_stream
->
data
;

400 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, "hell"));

401 
	`quicly_streambuf_ingress_shift
(
server_stream
, 4);

404 
	`transmit
(
server
, 
client
);

407 
quicly_address_t
 
dest
, 
src
;

408 
size_t
 
cnt
 = 1;

409 
ret
 = 
	`quicly_send
(
client
, &
dest
, &
src
, &
reordered_packet
, &
cnt
, 
reordered_packet_buf
, sizeof(reordered_packet_buf));

410 
	`ok
(
ret
 == 0);

411 
	`ok
(
cnt
 == 1);

415 
	`quicly_reset_stream
(
client_stream
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(12345));

416 
	`ok
(
	`quicly_sendstate_transfer_complete
(&
client_stream
->
sendstate
));

417 
	`transmit
(
client
, 
server
);

419 
	`ok
(
	`quicly_recvstate_transfer_complete
(&
server_stream
->
recvstate
));

420 
	`ok
(
server_streambuf
->
error_received
.
reset_stream
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(12345));

421 
	`quicly_reset_stream
(
server_stream
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(54321));

422 
	`ok
(!
server_streambuf
->
is_detached
);

423 
	`ok
(
	`quicly_sendstate_transfer_complete
(&
server_stream
->
sendstate
));

425 
	`quicly_get_max_data
(
client
, 
NULL
, &
tmp
, NULL);

426 
	`ok
(
tmp
 == 
max_data_at_start
 + 8);

427 
	`quicly_get_max_data
(
server
, 
NULL
, NULL, &
tmp
);

428 
	`ok
(
tmp
 == 
max_data_at_start
 + 8);

431 
quicly_decoded_packet_t
 
decoded
[4];

432 
size_t
 
i
, 
num_decoded
 = 
	`decode_packets
(
decoded
, &
reordered_packet
, 1);

433 
	`ok
(
num_decoded
 != 0);

434 for (
i
 = 0; i < 
num_decoded
; ++i) {

435 
ret
 = 
	`quicly_receive
(
server
, 
NULL
, &
fake_address
.
sa
, 
decoded
 + 
i
);

436 
	`ok
(
ret
 == 0 || ret == 
QUICLY_ERROR_PACKET_IGNORED
);

440 
	`quicly_get_max_data
(
server
, 
NULL
, NULL, &
tmp
);

441 
	`ok
(
tmp
 == 
max_data_at_start
 + 8);

444 
	`transmit
(
server
, 
client
);

445 
	`ok
(
client_streambuf
->
error_received
.
reset_stream
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(54321));

446 
	`ok
(
client_streambuf
->
is_detached
);

447 
	`ok
(
	`quicly_num_streams
(
client
) == 0);

448 
	`ok
(
	`quicly_num_streams
(
server
) == 1);

449 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

450 
	`transmit
(
client
, 
server
);

451 
	`ok
(
server_streambuf
->
is_detached
);

452 
	`ok
(
	`quicly_num_streams
(
server
) == 0);

454 
	`quicly_get_max_data
(
server
, 
NULL
, NULL, &
tmp
);

455 
	`ok
(
tmp
 == 
max_data_at_start
 + 8);

456 
	`ok
(
	`max_data_is_equal
(
client
, 
server
));

458 
quic_ctx
.
transport_params
.
max_stream_data
 = 
max_stream_data_orig
;

459 
	}
}

461 static 
uint16_t
 
	gtest_close_error_code
;

463 static void 
	$test_closed_by_remote
(
quicly_closed_by_remote_t
 *
self
, 
quicly_conn_t
 *
conn
, int 
err
, 
uint64_t
 
frame_type
,

464 const char *
reason
, 
size_t
 
reason_len
)

466 
	`ok
(
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
));

467 
test_close_error_code
 = 
	`QUICLY_ERROR_GET_ERROR_CODE
(
err
);

468 
	`ok
(
frame_type
 == 
UINT64_MAX
);

469 
	`ok
(
reason_len
 == 8);

470 
	`ok
(
	`memcmp
(
reason
, "good bye", 8) == 0);

471 
	}
}

473 static void 
	$test_close
(void)

475 
quicly_closed_by_remote_t
 
closed_by_remote
 = {
test_closed_by_remote
}, *
orig_closed_by_remote
 = 
quic_ctx
.closed_by_remote;

476 
quicly_address_t
 
dest
, 
src
;

477 struct 
iovec
 
datagram
;

478 
uint8_t
 
datagram_buf
[
quic_ctx
.
transport_params
.
max_udp_payload_size
];

479 
size_t
 
num_datagrams
;

480 
int64_t
 
client_timeout
, 
server_timeout
;

481 int 
ret
;

483 
quic_ctx
.
closed_by_remote
 = &closed_by_remote;

486 
ret
 = 
	`quicly_close
(
client
, 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(12345), "good bye");

487 
	`ok
(
ret
 == 0);

488 
	`ok
(
	`quicly_get_state
(
client
) == 
QUICLY_STATE_CLOSING
);

489 
	`ok
(
	`quicly_get_first_timeout
(
client
) <= 
quic_now
);

490 
num_datagrams
 = 1;

491 
ret
 = 
	`quicly_send
(
client
, &
dest
, &
src
, &
datagram
, &
num_datagrams
, 
datagram_buf
, sizeof(datagram_buf));

492 
	`assert
(
num_datagrams
 == 1);

493 
client_timeout
 = 
	`quicly_get_first_timeout
(
client
);

494 
	`ok
(
quic_now
 < 
client_timeout
 && client_timeout < quic_now + 1000);

497 
quicly_decoded_packet_t
 
decoded
;

498 
	`decode_packets
(&
decoded
, &
datagram
, 1);

499 
ret
 = 
	`quicly_receive
(
server
, 
NULL
, &
fake_address
.
sa
, &
decoded
);

500 
	`ok
(
ret
 == 0);

501 
	`ok
(
test_close_error_code
 == 12345);

502 
	`ok
(
	`quicly_get_state
(
server
) == 
QUICLY_STATE_DRAINING
);

503 
server_timeout
 = 
	`quicly_get_first_timeout
(
server
);

504 
	`ok
(
quic_now
 < 
server_timeout
 && server_timeout < quic_now + 1000);

508 
num_datagrams
 = 1;

509 
ret
 = 
	`quicly_send
(
server
, &
dest
, &
src
, &
datagram
, &
num_datagrams
, 
datagram_buf
, sizeof(datagram_buf));

510 
	`ok
(
ret
 == 0);

511 
	`ok
(
num_datagrams
 == 0);

514 
quic_now
 = 
client_timeout
 < 
server_timeout
 ? server_timeout : client_timeout;

515 
num_datagrams
 = 1;

516 
ret
 = 
	`quicly_send
(
client
, &
dest
, &
src
, &
datagram
, &
num_datagrams
, 
datagram_buf
, sizeof(datagram_buf));

517 
	`ok
(
ret
 == 
QUICLY_ERROR_FREE_CONNECTION
);

518 
	`quicly_free
(
client
);

519 
num_datagrams
 = 1;

520 
ret
 = 
	`quicly_send
(
server
, &
dest
, &
src
, &
datagram
, &
num_datagrams
, 
datagram_buf
, sizeof(datagram_buf));

521 
	`ok
(
ret
 == 
QUICLY_ERROR_FREE_CONNECTION
);

522 
	`quicly_free
(
server
);

524 
client
 = 
NULL
;

525 
server
 = 
NULL
;

526 
quic_ctx
.
closed_by_remote
 = 
orig_closed_by_remote
;

527 
	}
}

529 static void 
	$tiny_connection_window
(void)

531 
uint64_t
 
max_data_orig
 = 
quic_ctx
.
transport_params
.
max_data
;

532 
quicly_stream_t
 *
client_stream
, *
server_stream
;

533 
test_streambuf_t
 *
client_streambuf
, *
server_streambuf
;

534 
size_t
 
i
;

535 int 
ret
;

536 char 
testdata
[1025];

538 
quic_ctx
.
transport_params
.
max_data
 = 1024;

539 for (
i
 = 0; i < 1024 / 16; ++i)

540 
	`strcpy
(
testdata
 + 
i
 * 16, "0123456789abcdef");

541 
testdata
[1024] = '\0';

544 
quicly_address_t
 
dest
, 
src
;

545 struct 
iovec
 
raw
;

546 
uint8_t
 
rawbuf
[
quic_ctx
.
transport_params
.
max_udp_payload_size
];

547 
size_t
 
num_packets
;

548 
quicly_decoded_packet_t
 
decoded
;

550 
ret
 = 
	`quicly_connect
(&
client
, &
quic_ctx
, "example.com", &
fake_address
.
sa
, 
NULL
, 
	`new_master_id
(), 
	`ptls_iovec_init
(NULL, 0),

551 
NULL
, NULL);

552 
	`ok
(
ret
 == 0);

553 
num_packets
 = 1;

554 
ret
 = 
	`quicly_send
(
client
, &
dest
, &
src
, &
raw
, &
num_packets
, 
rawbuf
, sizeof(rawbuf));

555 
	`ok
(
ret
 == 0);

556 
	`ok
(
num_packets
 == 1);

557 
	`ok
(
	`quicly_get_first_timeout
(
client
) > 
quic_ctx
.
now
->
	`cb
(quic_ctx.now));

558 
	`decode_packets
(&
decoded
, &
raw
, 1);

559 
	`ok
(
num_packets
 == 1);

560 
ret
 = 
	`quicly_accept
(&
server
, &
quic_ctx
, 
NULL
, &
fake_address
.
sa
, &
decoded
, NULL, 
	`new_master_id
(), NULL);

561 
	`ok
(
ret
 == 0);

564 
	`transmit
(
server
, 
client
);

565 
	`ok
(
	`quicly_get_state
(
client
) == 
QUICLY_STATE_CONNECTED
);

566 
	`ok
(
	`quicly_connection_is_ready
(
client
));

568 
ret
 = 
	`quicly_open_stream
(
client
, &
client_stream
, 0);

569 
	`ok
(
ret
 == 0);

570 
client_streambuf
 = 
client_stream
->
data
;

571 for (
i
 = 0; i < 16; ++i)

572 
	`quicly_streambuf_egress_write
(
client_stream
, 
testdata
, 
	`strlen
(testdata));

574 
	`transmit
(
client
, 
server
);

576 
server_stream
 = 
	`quicly_get_stream
(
server
, 
client_stream
->
stream_id
);

577 
	`ok
(
server_stream
 != 
NULL
);

578 
server_streambuf
 = 
server_stream
->
data
;

579 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, 
testdata
));

580 
	`quicly_streambuf_ingress_shift
(
server_stream
, 
	`strlen
(
testdata
));

582 for (
i
 = 1; i < 16; ++i) {

583 
	`transmit
(
server
, 
client
);

584 
	`transmit
(
client
, 
server
);

585 
	`ok
(
	`buffer_is
(&
server_streambuf
->
super
.
ingress
, 
testdata
));

586 
	`quicly_streambuf_ingress_shift
(
server_stream
, 
	`strlen
(
testdata
));

589 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

590 
	`transmit
(
server
, 
client
);

592 
	`ok
(
client_streambuf
->
super
.
egress
.
vecs
.
size
 == 0);

594 
quic_ctx
.
transport_params
.
max_data
 = 
max_data_orig
;

595 
	}
}

597 void 
	$test_simple
(void)

599 
	`subtest
("handshake", 
test_handshake
);

600 
	`subtest
("simple-http", 
simple_http
);

601 
	`subtest
("reset-then-close", 
test_reset_then_close
);

602 
	`subtest
("send-then-close", 
test_send_then_close
);

603 
	`subtest
("reset-after-close", 
test_reset_after_close
);

604 
	`subtest
("tiny-stream-window", 
tiny_stream_window
);

605 
	`subtest
("reset-during-loss", 
test_reset_during_loss
);

606 
	`subtest
("close", 
test_close
);

607 
	`subtest
("tiny-connection-window", 
tiny_connection_window
);

608 
	}
}

	@t/stream-concurrency.c

22 #include 
	~<string.h
>

23 #include 
	~"quicly/streambuf.h
"

24 #include 
	~"test.h
"

26 void 
	$test_stream_concurrency
(void)

28 
quicly_conn_t
 *
client
, *
server
;

29 
size_t
 
limit
 = 
quic_ctx
.
transport_params
.
max_streams_bidi
;

30 
quicly_stream_t
 *
client_streams
[
limit
 + 2], *
server_stream
;

31 
test_streambuf_t
 *
client_streambufs
[
limit
 + 1], *
server_streambuf
;

32 
size_t
 
i
;

33 int 
ret
;

36 
quicly_address_t
 
dest
, 
src
;

37 struct 
iovec
 
raw
;

38 
uint8_t
 
rawbuf
[
quic_ctx
.
transport_params
.
max_udp_payload_size
];

39 
size_t
 
num_packets
;

40 
quicly_decoded_packet_t
 
decoded
;

42 
ret
 = 
	`quicly_connect
(&
client
, &
quic_ctx
, "example.com", &
fake_address
.
sa
, 
NULL
, 
	`new_master_id
(), 
	`ptls_iovec_init
(NULL, 0),

43 
NULL
, NULL);

44 
	`ok
(
ret
 == 0);

45 
num_packets
 = 1;

46 
ret
 = 
	`quicly_send
(
client
, &
dest
, &
src
, &
raw
, &
num_packets
, 
rawbuf
, sizeof(rawbuf));

47 
	`ok
(
ret
 == 0);

48 
	`ok
(
num_packets
 == 1);

49 
	`ok
(
	`decode_packets
(&
decoded
, &
raw
, 1) == 1);

50 
	`ok
(
num_packets
 == 1);

51 
ret
 = 
	`quicly_accept
(&
server
, &
quic_ctx
, 
NULL
, &
fake_address
.
sa
, &
decoded
, NULL, 
	`new_master_id
(), NULL);

52 
	`ok
(
ret
 == 0);

53 
	`transmit
(
server
, 
client
);

57 for (
i
 = 0; i < 
limit
 + 1; ++i) {

58 
ret
 = 
	`quicly_open_stream
(
client
, 
client_streams
 + 
i
, 0);

59 
	`assert
(
ret
 == 0);

60 
client_streambufs
[
i
] = 
client_streams
[i]->
data
;

61 if (
client_streams
[
i
]->
streams_blocked
)

63 
ret
 = 
	`quicly_streambuf_egress_write
(
client_streams
[
i
], "hello", 5);

64 
	`assert
(
ret
 == 0);

66 
	`ok
(
i
 == 
limit
);

68 
	`transmit
(
client
, 
server
);

69 
	`transmit
(
server
, 
client
);

72 
	`ok
(
client_streams
[
i
]->
streams_blocked
);

75 
server_stream
 = 
	`quicly_get_stream
(
server
, 
client_streams
[
i
 - 1]->
stream_id
);

76 
	`ok
(
server_stream
 != 
NULL
);

77 
server_streambuf
 = 
server_stream
->
data
;

78 
	`quicly_reset_stream
(
client_streams
[
i
 - 1], 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(123));

79 
	`quicly_request_stop
(
client_streams
[
i
 - 1], 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(456));

80 
	`transmit
(
client
, 
server
);

81 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

82 
	`transmit
(
server
, 
client
);

83 
	`ok
(
server_streambuf
->
error_received
.
reset_stream
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(123));

84 
	`ok
(
server_streambuf
->
error_received
.
stop_sending
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(456));

85 
	`ok
(!
server_streambuf
->
is_detached
);

86 
	`ok
(
client_streambufs
[
i
 - 1]->
error_received
.
reset_stream
 == 
	`QUICLY_ERROR_FROM_APPLICATION_ERROR_CODE
(456));

87 
	`ok
(
client_streambufs
[
i
 - 1]->
is_detached
);

90 
	`ok
(
client_streams
[
i
]->
streams_blocked
);

92 
quic_now
 += 
QUICLY_DELAYED_ACK_TIMEOUT
;

93 
	`transmit
(
client
, 
server
);

94 
	`transmit
(
server
, 
client
);

97 
	`ok
(
server_streambuf
->
is_detached
);

98 
	`ok
(!
client_streams
[
i
]->
streams_blocked
);

99 ++
i
;

102 
ret
 = 
	`quicly_open_stream
(
client
, 
client_streams
 + 
i
, 0);

103 
	`ok
(
ret
 == 0);

104 
	`ok
(
client_streams
[
i
]->
streams_blocked
);

106 
	`quicly_free
(
client
);

107 
	`quicly_free
(
server
);

108 
	}
}

	@t/test.c

22 #include 
	~<string.h
>

23 #include 
	~<stdio.h
>

24 #include 
	~<stdlib.h
>

25 #include 
	~<openssl/bio.h
>

26 #include 
	~<openssl/crypto.h
>

27 #include 
	~<openssl/engine.h
>

28 #include 
	~<openssl/err.h
>

29 #include 
	~<openssl/pem.h
>

30 #include 
	~"picotls.h
"

31 #include 
	~"picotls/openssl.h
"

32 #include 
	~"quicly.h
"

33 #include 
	~"quicly/defaults.h
"

34 #include 
	~"quicly/streambuf.h
"

35 #include 
	~"../lib/quicly.c
"

36 #include 
	~"test.h
"

38 #define 
	#RSA_PRIVATE_KEY
 \

65 "-----END RSA PRIVATE KEY-----\n"

	)

67 #define 
	#RSA_CERTIFICATE
 \

87 "-----END CERTIFICATE-----\n"

	)

89 static void 
on_destroy
(
quicly_stream_t
 *
stream
, int 
err
);

90 static void 
on_egress_stop
(
quicly_stream_t
 *
stream
, int 
err
);

91 static void 
on_ingress_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
);

92 static void 
on_ingress_reset
(
quicly_stream_t
 *
stream
, int 
err
);

94 
quicly_address_t
 
	gfake_address
;

95 
int64_t
 
	gquic_now
 = 1;

96 
quicly_context_t
 
	gquic_ctx
;

97 
quicly_stream_callbacks_t
 
	gstream_callbacks
 = {

98 
on_destroy
, 
quicly_streambuf_egress_shift
, 
quicly_streambuf_egress_emit
, 
on_egress_stop
, 
on_ingress_receive
, 
on_ingress_reset
};

99 
size_t
 
	gon_destroy_callcnt
;

101 static 
int64_t
 
	$get_now_cb
(
quicly_now_t
 *
self
)

103 return 
quic_now
;

104 
	}
}

106 static 
quicly_now_t
 
	gget_now
 = {
get_now_cb
};

108 void 
	$on_destroy
(
quicly_stream_t
 *
stream
, int 
err
)

110 
test_streambuf_t
 *
sbuf
 = 
stream
->
data
;

111 
sbuf
->
is_detached
 = 1;

112 ++
on_destroy_callcnt
;

113 
	}
}

115 void 
	$on_egress_stop
(
quicly_stream_t
 *
stream
, int 
err
)

117 
	`assert
(
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
));

118 
test_streambuf_t
 *
sbuf
 = 
stream
->
data
;

119 
sbuf
->
error_received
.
stop_sending
 = 
err
;

120 
	}
}

122 void 
	$on_ingress_receive
(
quicly_stream_t
 *
stream
, 
size_t
 
off
, const void *
src
, size_t 
len
)

124 
	`quicly_streambuf_ingress_receive
(
stream
, 
off
, 
src
, 
len
);

125 
	}
}

127 void 
	$on_ingress_reset
(
quicly_stream_t
 *
stream
, int 
err
)

129 
	`assert
(
	`QUICLY_ERROR_IS_QUIC_APPLICATION
(
err
));

130 
test_streambuf_t
 *
sbuf
 = 
stream
->
data
;

131 
sbuf
->
error_received
.
reset_stream
 = 
err
;

132 
	}
}

134 const 
quicly_cid_plaintext_t
 *
	$new_master_id
(void)

136 static 
quicly_cid_plaintext_t
 
master
 = {
UINT32_MAX
};

137 ++
master
.
master_id
;

138 return &
master
;

139 
	}
}

141 static int 
	$on_stream_open
(
quicly_stream_open_t
 *
self
, 
quicly_stream_t
 *
stream
)

143 
test_streambuf_t
 *
sbuf
;

144 int 
ret
;

146 
ret
 = 
	`quicly_streambuf_create
(
stream
, sizeof(*
sbuf
));

147 
	`assert
(
ret
 == 0);

148 
sbuf
 = 
stream
->
data
;

149 
sbuf
->
error_received
.
stop_sending
 = -1;

150 
sbuf
->
error_received
.
reset_stream
 = -1;

151 
stream
->
callbacks
 = &
stream_callbacks
;

154 
	}
}

156 
quicly_stream_open_t
 
	gstream_open
 = {
on_stream_open
};

158 static void 
	$test_vector
(void)

160 static const 
uint8_t
 
expected_payload
[] = {

171 
uint8_t
 
datagram
[] = {

232 
quicly_decoded_packet_t
 
packet
;

233 struct 
st_quicly_cipher_context_t
 
ingress
, 
egress
;

234 
uint64_t
 
pn
, 
next_expected_pn
 = 0;

235 
ptls_iovec_t
 
payload
;

236 int 
ret
;

239 
size_t
 
off
 = 0;

240 
	`ok
(
	`quicly_decode_packet
(&
quic_ctx
, &
packet
, 
datagram
, sizeof(datagram), &
off
) == sizeof(datagram));

241 
	`ok
(
off
 == sizeof(
datagram
));

244 const struct 
st_ptls_salt_t
 *
salt
 = 
	`get_salt
(
QUICLY_PROTOCOL_VERSION_CURRENT
);

245 
ret
 = 
	`setup_initial_encryption
(&
ptls_openssl_aes128gcmsha256
, &
ingress
, &
egress
, 
packet
.
cid
.
dest
.
encrypted
, 0,

246 
	`ptls_iovec_init
(
salt
->
initial
, sizeof(salt->initial)), 
NULL
);

247 
	`ok
(
ret
 == 0);

248 
	`ok
(
	`decrypt_packet
(
ingress
.
header_protection
, 
aead_decrypt_fixed_key
, ingress.
aead
, &
next_expected_pn
, &
packet
, &
pn
, &
payload
) ==

250 
	`ok
(
pn
 == 2);

251 
	`ok
(sizeof(
expected_payload
) <= 
payload
.
len
);

252 
	`ok
(
	`memcmp
(
expected_payload
, 
payload
.
base
, sizeof(expected_payload)) == 0);

254 
	`dispose_cipher
(&
ingress
);

255 
	`dispose_cipher
(&
egress
);

256 
	}
}

258 static void 
	$test_retry_aead
(void)

260 
quicly_cid_t
 
odcid
 = {{0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08}, 8};

261 
uint8_t
 
packet_bytes
[] = {0xff, 0xff, 0x00, 0x00, 0x1d, 0x00, 0x08, 0xf0, 0x67, 0xa5, 0x50, 0x2a,

266 
quicly_decoded_packet_t
 
decoded
;

267 
size_t
 
off
 = 0, 
decoded_len
 = 
	`quicly_decode_packet
(&
quic_ctx
, &
decoded
, 
packet_bytes
, sizeof(packet_bytes), &off);

268 
	`ok
(
decoded_len
 == sizeof(
packet_bytes
));

269 
	`ok
(
off
 == sizeof(
packet_bytes
));

272 
ptls_aead_context_t
 *
retry_aead
 = 
	`create_retry_aead
(&
quic_ctx
, 
QUICLY_PROTOCOL_VERSION_CURRENT
, 0);

273 
	`ok
(
	`validate_retry_tag
(&
decoded
, &
odcid
, 
retry_aead
));

274 
	`ptls_aead_free
(
retry_aead
);

275 
	}
}

277 static void 
	$test_transport_parameters
(void)

279 
quicly_transport_parameters_t
 
decoded
;

281 static const 
uint8_t
 
valid_bytes
[] = {0x05, 0x04, 0x80, 0x10, 0x00, 0x00, 0x06, 0x04, 0x80, 0x10, 0x00, 0x00,

284 
	`memset
(&
decoded
, 0x55, sizeof(decoded));

285 
	`ok
(
	`quicly_decode_transport_parameter_list
(&
decoded
, 
NULL
, NULL, NULL, NULL, 
valid_bytes
, valid_bytes + sizeof(valid_bytes),

287 
	`ok
(
decoded
.
max_stream_data
.
bidi_local
 = 0x100000);

288 
	`ok
(
decoded
.
max_stream_data
.
bidi_remote
 = 0x100000);

289 
	`ok
(
decoded
.
max_stream_data
.
uni
 = 0x100000);

290 
	`ok
(
decoded
.
max_data
 == 0x1000000);

291 
	`ok
(
decoded
.
max_idle_timeout
 == 30000);

292 
	`ok
(
decoded
.
max_streams_bidi
 == 10);

293 
	`ok
(
decoded
.
max_streams_uni
 == 0);

294 
	`ok
(
decoded
.
ack_delay_exponent
 == 10);

295 
	`ok
(
decoded
.
max_ack_delay
 == 25);

296 
	`ok
(!
decoded
.
disable_active_migration
);

298 static const 
uint8_t
 
dup_bytes
[] = {0x05, 0x04, 0x80, 0x10, 0x00, 0x00, 0x05, 0x04, 0x80, 0x10, 0x00, 0x00};

299 
	`memset
(&
decoded
, 0x55, sizeof(decoded));

300 
	`ok
(
	`quicly_decode_transport_parameter_list
(&
decoded
, 
NULL
, NULL, NULL, NULL, 
dup_bytes
, dup_bytes + sizeof(dup_bytes), 1) ==

301 
QUICLY_TRANSPORT_ERROR_TRANSPORT_PARAMETER
);

302 
	}
}

304 
size_t
 
	$decode_packets
(
quicly_decoded_packet_t
 *
decoded
, struct 
iovec
 *
raw
, 
size_t
 
cnt
)

306 
size_t
 
ri
, 
dc
 = 0;

308 for (
ri
 = 0; ri != 
cnt
; ++ri) {

309 
size_t
 
off
 = 0;

311 
size_t
 
dl
 = 
	`quicly_decode_packet
(&
quic_ctx
, 
decoded
 + 
dc
, 
raw
[
ri
].
iov_base
, raw[ri].
iov_len
, &
off
);

312 
	`assert
(
dl
 != 
SIZE_MAX
);

313 ++
dc
;

314 } while (
off
 != 
raw
[
ri
].
iov_len
);

317 return 
dc
;

318 
	}
}

320 int 
	$buffer_is
(
ptls_buffer_t
 *
buf
, const char *
s
)

322 return 
buf
->
off
 == 
	`strlen
(
s
) && 
	`memcmp
(buf->
base
, s, buf->off) == 0;

323 
	}
}

325 
size_t
 
	$transmit
(
quicly_conn_t
 *
src
, quicly_conn_t *
dst
)

327 
quicly_address_t
 
destaddr
, 
srcaddr
;

328 struct 
iovec
 
datagrams
[32];

329 
uint8_t
 
datagramsbuf
[
	`PTLS_ELEMENTSOF
(
datagrams
) * 
	`quicly_get_context
(
src
)->
transport_params
.
max_udp_payload_size
];

330 
size_t
 
num_datagrams
, 
i
;

331 
quicly_decoded_packet_t
 
decoded
[
	`PTLS_ELEMENTSOF
(
datagrams
) * 2];

332 int 
ret
;

334 
num_datagrams
 = 
	`PTLS_ELEMENTSOF
(
datagrams
);

335 
ret
 = 
	`quicly_send
(
src
, &
destaddr
, &
srcaddr
, 
datagrams
, &
num_datagrams
, 
datagramsbuf
, sizeof(datagramsbuf));

336 
	`ok
(
ret
 == 0);

338 if (
num_datagrams
 != 0) {

339 
size_t
 
num_packets
 = 
	`decode_packets
(
decoded
, 
datagrams
, 
num_datagrams
);

340 for (
i
 = 0; i != 
num_packets
; ++i) {

341 
ret
 = 
	`quicly_receive
(
dst
, 
NULL
, &
fake_address
.
sa
, 
decoded
 + 
i
);

342 
	`ok
(
ret
 == 0 || ret == 
QUICLY_ERROR_PACKET_IGNORED
);

346 return 
num_datagrams
;

347 
	}
}

349 int 
	$max_data_is_equal
(
quicly_conn_t
 *
client
, quicly_conn_t *
server
)

351 
uint64_t
 
client_sent
, 
client_consumed
;

352 
uint64_t
 
server_sent
, 
server_consumed
;

354 
	`quicly_get_max_data
(
client
, 
NULL
, &
client_sent
, &
client_consumed
);

355 
	`quicly_get_max_data
(
server
, 
NULL
, &
server_sent
, &
server_consumed
);

357 if (
client_sent
 != 
server_consumed
)

359 if (
server_sent
 != 
client_consumed
)

363 
	}
}

365 static void 
	$test_next_packet_number
(void)

368 
uint64_t
 
n
 = 
	`quicly_determine_packet_number
(0xc0, 8, 0x139);

369 
	`ok
(
n
 == 0xc0);

370 
n
 = 
	`quicly_determine_packet_number
(0xc0, 8, 0x140);

371 
	`ok
(
n
 == 0x1c0);

372 
n
 = 
	`quicly_determine_packet_number
(0x9b32, 16, 0xa82f30eb);

373 
	`ok
(
n
 == 0xa82f9b32);

375 
n
 = 
	`quicly_determine_packet_number
(31, 16, 65259);

376 
	`ok
(
n
 == 65567);

377 
	}
}

379 static void 
	$test_address_token_codec
(void)

381 static const 
uint8_t
 
zero_key
[
PTLS_MAX_SECRET_SIZE
] = {0};

382 
ptls_aead_context_t
 *
enc
 = 
	`ptls_aead_new
(&
ptls_openssl_aes128gcm
, &
ptls_openssl_sha256
, 1, 
zero_key
, ""),

383 *
dec
 = 
	`ptls_aead_new
(&
ptls_openssl_aes128gcm
, &
ptls_openssl_sha256
, 0, 
zero_key
, "");

384 
quicly_address_token_plaintext_t
 
input
, 
output
;

385 
ptls_buffer_t
 
buf
;

386 const char *
err_desc
;

388 
input
 = (
quicly_address_token_plaintext_t
){
QUICLY_ADDRESS_TOKEN_TYPE_RETRY
, 234};

389 
input
.
remote
.
sin
.
sin_family
 = 
AF_INET
;

390 
input
.
remote
.
sin
.
sin_addr
.
s_addr
 = 
	`htonl
(0x7f000001);

391 
input
.
remote
.
sin
.
sin_port
 = 
	`htons
(443);

392 
	`quicly_set_cid
(&
input
.
retry
.
original_dcid
, 
	`ptls_iovec_init
("abcdefgh", 8));

393 
	`quicly_set_cid
(&
input
.
retry
.
client_cid
, 
	`ptls_iovec_init
("01234", 5));

394 
	`quicly_set_cid
(&
input
.
retry
.
server_cid
, 
	`ptls_iovec_init
("abcdef0123456789", 16));

395 
	`strcpy
((char *)
input
.
appdata
.
bytes
, "hello world");

396 
input
.
appdata
.
len
 = 
	`strlen
((char *)input.appdata.
bytes
);

397 
	`ptls_buffer_init
(&
buf
, "", 0);

399 
	`ok
(
	`quicly_encrypt_address_token
(
ptls_openssl_random_bytes
, 
enc
, &
buf
, 0, &
input
) == 0);

402 
	`ptls_openssl_random_bytes
(&
output
, sizeof(output));

403 
	`ok
(
	`quicly_decrypt_address_token
(
dec
, &
output
, 
buf
.
base
, buf.
off
, 0, &
err_desc
) == 0);

404 
	`ok
(
input
.
type
 == 
output
.type);

405 
	`ok
(
input
.
issued_at
 == 
output
.issued_at);

406 
	`ok
(
input
.
remote
.
sa
.
sa_family
 == 
output
.remote.sa.sa_family);

407 
	`ok
(
input
.
remote
.
sin
.
sin_addr
.
s_addr
 == 
output
.remote.sin.sin_addr.s_addr);

408 
	`ok
(
input
.
remote
.
sin
.
sin_port
 == 
output
.remote.sin.sin_port);

409 
	`ok
(
	`quicly_cid_is_equal
(&
output
.
retry
.
original_dcid
,

410 
	`ptls_iovec_init
(
input
.
retry
.
original_dcid
.
cid
, input.retry.original_dcid.
len
)));

411 
	`ok
(
	`quicly_cid_is_equal
(&
output
.
retry
.
client_cid
, 
	`ptls_iovec_init
(
input
.retry.client_cid.
cid
, input.retry.client_cid.
len
)));

412 
	`ok
(
	`quicly_cid_is_equal
(&
output
.
retry
.
server_cid
, 
	`ptls_iovec_init
(
input
.retry.server_cid.
cid
, input.retry.server_cid.
len
)));

413 
	`ok
(
input
.
appdata
.
len
 == 
output
.appdata.len);

414 
	`ok
(
	`memcmp
(
input
.
appdata
.
bytes
, 
output
.appdata.bytes, input.appdata.
len
) == 0);

417 
	`ptls_openssl_random_bytes
(&
output
, sizeof(output));

418 
buf
.
base
[buf.
off
 - 1] ^= 0x80;

419 
	`ok
(
	`quicly_decrypt_address_token
(
dec
, &
output
, 
buf
.
base
, buf.
off
, 0, &
err_desc
) == 
QUICLY_TRANSPORT_ERROR_INVALID_TOKEN
);

420 
buf
.
base
[buf.
off
 - 1] ^= 0x80;

423 
	`ptls_openssl_random_bytes
(&
output
, sizeof(output));

424 
buf
.
base
[0] ^= 0x80;

425 
	`ok
(
	`quicly_decrypt_address_token
(
dec
, &
output
, 
buf
.
base
, buf.
off
, 0, &
err_desc
) == 
PTLS_ALERT_DECODE_ERROR
);

426 
buf
.
base
[0] ^= 0x80;

428 
	`ptls_buffer_dispose
(&
buf
);

429 
	`ptls_aead_free
(
enc
);

430 
	`ptls_aead_free
(
dec
);

431 
	}
}

433 static void 
	$do_test_record_receipt
(
size_t
 
epoch
)

435 struct 
st_quicly_pn_space_t
 *
space
 =

436 
	`alloc_pn_space
(sizeof(*
space
), 
epoch
 == 
QUICLY_EPOCH_1RTT
 ? 
QUICLY_DEFAULT_PACKET_TOLERANCE
 : 1);

437 
uint64_t
 
pn
 = 0;

438 
int64_t
 
now
 = 12345, 
send_ack_at
 = 
INT64_MAX
;

440 if (
epoch
 == 
QUICLY_EPOCH_1RTT
) {

442 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 0, 
now
, &
send_ack_at
) == 0);

443 
	`ok
(
send_ack_at
 == 
now
 + 
QUICLY_DELAYED_ACK_TIMEOUT
);

444 
now
 += 1;

445 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 0, 
now
, &
send_ack_at
) == 0);

446 
	`ok
(
send_ack_at
 == 
now
);

447 
now
 += 1;

450 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 0, 
now
, &
send_ack_at
) == 0);

451 
	`ok
(
send_ack_at
 == 
now
);

452 
now
 += 1;

456 
space
->
unacked_count
 = 0;

457 
send_ack_at
 = 
INT64_MAX
;

460 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 1, 
now
, &
send_ack_at
) == 0);

461 
	`ok
(
send_ack_at
 == 
INT64_MAX
);

462 
now
 += 1;

463 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 1, 
now
, &
send_ack_at
) == 0);

464 
	`ok
(
send_ack_at
 == 
INT64_MAX
);

465 
now
 += 1;

466 
pn
++;

467 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 1, 
now
, &
send_ack_at
) == 0);

468 
	`ok
(
send_ack_at
 == 
INT64_MAX
);

469 
now
 += 1;

470 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 1, 
now
, &
send_ack_at
) == 0);

471 
	`ok
(
send_ack_at
 == 
INT64_MAX
);

472 
now
 += 1;

475 
pn
 += 1;

476 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 0, 
now
, &
send_ack_at
) == 0);

477 
	`ok
(
send_ack_at
 == 
now
);

478 
now
 += 1;

481 
space
->
unacked_count
 = 0;

482 
send_ack_at
 = 
INT64_MAX
;

485 if (
epoch
 == 
QUICLY_EPOCH_1RTT
) {

486 
space
->
ignore_order
 = 1;

487 
pn
++;

488 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 0, 
now
, &
send_ack_at
) == 0);

489 
	`ok
(
send_ack_at
 == 
now
 + 
QUICLY_DELAYED_ACK_TIMEOUT
);

490 
now
 += 1;

491 
	`ok
(
	`record_receipt
(
space
, 
pn
++, 0, 
now
, &
send_ack_at
) == 0);

492 
	`ok
(
send_ack_at
 == 
now
);

493 
now
 += 1;

496 
	`do_free_pn_space
(
space
);

497 
	}
}

499 static void 
	$test_record_receipt
(void)

501 
	`do_test_record_receipt
(
QUICLY_EPOCH_INITIAL
);

502 
	`do_test_record_receipt
(
QUICLY_EPOCH_1RTT
);

503 
	}
}

505 static void 
	$test_cid
(void)

507 
	`subtest
("received cid", 
test_received_cid
);

508 
	`subtest
("local cid", 
test_local_cid
);

509 
	`subtest
("retire cid", 
test_retire_cid
);

510 
	}
}

515 static void 
	$test_nondecryptable_initial
(void)

517 #define 
	#PACKET_LEN
 1280

	)

518 #define 
	#HEADER_LEN
 18

	)

519 #define 
	#LEN_HIGH
 (((
PACKET_LEN
 - 
HEADER_LEN
) & 0xff00) >> 8)

	)

520 #define 
	#LEN_LOW
 ((
PACKET_LEN
 - 
HEADER_LEN
) & 0xff)

	)

521 
uint8_t
 
header
[
HEADER_LEN
] = {

547 (0x40 | 
LEN_HIGH
),

548 
LEN_LOW
,

550 
quicly_conn_t
 *
server
;

551 
uint8_t
 
packetbuf
[
PACKET_LEN
];

552 struct 
iovec
 
packet
 = {.
iov_base
 = 
packetbuf
, .
iov_len
 = sizeof(packetbuf)};

553 
size_t
 
num_decoded
;

554 
quicly_decoded_packet_t
 
decoded
;

555 int 
ret
;

558 
	`memcpy
(
packetbuf
, 
header
, sizeof(header));

559 
	`memset
(
packetbuf
 + sizeof(
header
), 0, sizeof(packetbuf) - sizeof(header));

560 
num_decoded
 = 
	`decode_packets
(&
decoded
, &
packet
, 1);

561 
	`ok
(
num_decoded
 == 1);

564 
ret
 = 
	`quicly_accept
(&
server
, &
quic_ctx
, 
NULL
, &
fake_address
.
sa
, &
decoded
, NULL, 
	`new_master_id
(), NULL);

565 
	`ok
(
ret
 == 
QUICLY_ERROR_DECRYPTION_FAILED
);

566 #undef 
PACKET_LEN


567 #undef 
HEADER_LEN


568 #undef 
LEN_HIGH


569 #undef 
LEN_LOW


570 
	}
}

572 int 
	$main
(int 
argc
, char **
argv
)

574 static 
ptls_iovec_t
 
cert
;

575 static 
ptls_openssl_sign_certificate_t
 
cert_signer
;

576 static 
ptls_context_t
 
tlsctx
 = {
ptls_openssl_random_bytes
,

577 &
ptls_get_time
,

578 
ptls_openssl_key_exchanges
,

579 
ptls_openssl_cipher_suites
,

580 {&
cert
, 1},

581 
NULL
,

582 
NULL
,

583 
NULL
,

584 &
cert_signer
.
super
,

585 
NULL
,

589 
NULL
,

591 
quic_ctx
 = 
quicly_spec_context
;

592 
quic_ctx
.
tls
 = &
tlsctx
;

593 
quic_ctx
.
transport_params
.
max_streams_bidi
 = 10;

594 
quic_ctx
.
stream_open
 = &stream_open;

595 
quic_ctx
.
now
 = &
get_now
;

597 
fake_address
.
sa
.
sa_family
 = 
AF_INET
;

599 
	`ERR_load_crypto_strings
();

600 
	`OpenSSL_add_all_algorithms
();

601 #if !
	`defined
(
OPENSSL_NO_ENGINE
)

603 
	`ENGINE_load_builtin_engines
();

604 
	`ENGINE_register_all_ciphers
();

605 
	`ENGINE_register_all_digests
();

609 
BIO
 *
bio
 = 
	`BIO_new_mem_buf
(
RSA_CERTIFICATE
, 
	`strlen
(RSA_CERTIFICATE));

610 
X509
 *
x509
 = 
	`PEM_read_bio_X509
(
bio
, 
NULL
, NULL, NULL);

611 
	`assert
(
x509
 != 
NULL
 || !!"failed to load certificate");

612 
	`BIO_free
(
bio
);

613 
cert
.
len
 = 
	`i2d_X509
(
x509
, &cert.
base
);

614 
	`X509_free
(
x509
);

618 
BIO
 *
bio
 = 
	`BIO_new_mem_buf
(
RSA_PRIVATE_KEY
, 
	`strlen
(RSA_PRIVATE_KEY));

619 
EVP_PKEY
 *
pkey
 = 
	`PEM_read_bio_PrivateKey
(
bio
, 
NULL
, NULL, NULL);

620 
	`assert
(
pkey
 != 
NULL
 || !"failed to load private key");

621 
	`BIO_free
(
bio
);

622 
	`ptls_openssl_init_sign_certificate
(&
cert_signer
, 
pkey
);

623 
	`EVP_PKEY_free
(
pkey
);

626 
	`quicly_amend_ptls_context
(
quic_ctx
.
tls
);

628 
	`subtest
("next-packet-number", 
test_next_packet_number
);

629 
	`subtest
("address-token-codec", 
test_address_token_codec
);

630 
	`subtest
("ranges", 
test_ranges
);

631 
	`subtest
("record-receipt", 
test_record_receipt
);

632 
	`subtest
("frame", 
test_frame
);

633 
	`subtest
("maxsender", 
test_maxsender
);

634 
	`subtest
("sentmap", 
test_sentmap
);

635 
	`subtest
("loss", 
test_loss
);

636 
	`subtest
("test-vector", 
test_vector
);

637 
	`subtest
("test-retry-aead", 
test_retry_aead
);

638 
	`subtest
("transport-parameters", 
test_transport_parameters
);

639 
	`subtest
("cid", 
test_cid
);

640 
	`subtest
("simple", 
test_simple
);

641 
	`subtest
("stream-concurrency", 
test_stream_concurrency
);

642 
	`subtest
("lossy", 
test_lossy
);

643 
	`subtest
("test-nondecryptable-initial", 
test_nondecryptable_initial
);

645 return 
	`done_testing
();

646 
	}
}

	@t/test.h

22 #ifndef 
test_h


23 #define 
	#test_h


	)

25 #include 
	~"quicly.h
"

26 #include 
	~"quicly/streambuf.h
"

27 #include 
	~"picotest.h
"

29 typedef struct 
	sst_test_streambuf_t
 {

30 
quicly_streambuf_t
 
	msuper
;

32 int 
	mstop_sending
;

33 int 
	mreset_stream
;

34 } 
	merror_received
;

35 int 
	mis_detached
;

36 } 
	ttest_streambuf_t
;

38 extern 
quicly_address_t
 
fake_address
;

39 extern 
int64_t
 
quic_now
;

40 extern 
quicly_context_t
 
quic_ctx
;

41 extern 
quicly_stream_callbacks_t
 
stream_callbacks
;

42 extern 
size_t
 
on_destroy_callcnt
;

44 const 
quicly_cid_plaintext_t
 *
new_master_id
(void);

45 extern 
quicly_stream_open_t
 
stream_open
;

46 
size_t
 
decode_packets
(
quicly_decoded_packet_t
 *
decoded
, struct 
iovec
 *
raw
, size_t 
cnt
);

47 int 
buffer_is
(
ptls_buffer_t
 *
buf
, const char *
s
);

48 
size_t
 
transmit
(
quicly_conn_t
 *
src
, quicly_conn_t *
dst
);

49 int 
max_data_is_equal
(
quicly_conn_t
 *
client
, quicly_conn_t *
server
);

51 void 
test_ranges
(void);

52 void 
test_frame
(void);

53 void 
test_maxsender
(void);

54 void 
test_sentmap
(void);

55 void 
test_loss
(void);

56 void 
test_simple
(void);

57 void 
test_lossy
(void);

58 void 
test_stream_concurrency
(void);

59 void 
test_received_cid
(void);

60 void 
test_local_cid
(void);

61 void 
test_retire_cid
(void);

	@t/udpfw.c

22 #include 
	~<assert.h
>

23 #include 
	~<errno.h
>

24 #include 
	~<fcntl.h
>

25 #include 
	~<inttypes.h
>

26 #include 
	~<netdb.h
>

27 #include 
	~<netinet/in.h
>

28 #include 
	~<signal.h
>

29 #include 
	~<stdio.h
>

30 #include 
	~<stdlib.h
>

31 #include 
	~<string.h
>

32 #include 
	~<sys/select.h
>

33 #include 
	~<sys/socket.h
>

34 #include 
	~<sys/time.h
>

35 #include 
	~<sys/types.h
>

36 #include 
	~<unistd.h
>

38 #define 
	#MAXDROPS
 64

	)

40 struct 
	sconnection_t
 {

41 struct 
connection_t
 *
	mprev
, *
	mnext
;

42 
size_t
 
	mcid
;

43 int 
	mup_fd
;

45 struct 
sockaddr_storage
 
	mss
;

46 
socklen_t
 
	mlen
;

47 } 
	mdown_addr
;

48 
uint64_t
 
	mpacket_num_up
;

49 
uint64_t
 
	mpacket_num_down
;

52 struct 
	squeue_t
 {

54 
size_t
 
	mdepth
;

55 
size_t
 
	mhead
;

56 
size_t
 
	mtail
;

58 struct 
connection_t
 *
	mconn
;

59 
uint8_t
 
	mdata
[2048];

60 
size_t
 
	mlen
;

61 
int64_t
 
	marrival
;

62 } * 
	melements
;

63 } 
	mring
;

64 
int64_t
 
	mdelay_usec
;

65 
int64_t
 
	minterval_usec
;

66 
int64_t
 
	mcongested_until
;

67 
uint64_t
 
	mnum_forwarded
;

68 
uint64_t
 
	mnum_dropped
;

69 
uint16_t
 
	mnum_drops
;

70 
uint16_t
 
	mdrops
[
MAXDROPS
];

71 } 
	gup
 = {{16}, 0, 10, 0, 0, 0, 0}, 
	gdown
 = {{16}, 0, 10, 0, 0, 0, 0};

73 static int 
	glisten_fd
 = -1;

74 static struct 
addrinfo
 *
	gserver_addr
 = 
NULL
;

75 static struct 
connection_t
 
	gconnections
 = {&
connections
, &connections};

77 static void 
	$usage
(const char *
cmd
, int 
exit_status
)

79 
	`printf
("Usage: %s [options] <upstream-host> <upstream-port>\n"

95 
cmd
);

96 
	`exit
(
exit_status
);

97 
	}
}

99 static 
int64_t
 
	$gettime
(void)

101 struct 
timeval
 
tv
;

102 
	`gettimeofday
(&
tv
, 
NULL
);

103 return (
int64_t
)
tv
.
tv_sec
 * 1000000 + tv.
tv_usec
;

104 
	}
}

106 static int 
	$new_socket
(int 
sin_family
)

108 int 
s
 = 
	`socket
(
sin_family
, 
SOCK_DGRAM
, 
IPPROTO_UDP
);

109 
	`assert
(
s
 != -1);

110 int 
flags
 = 
	`fcntl
(
s
, 
F_GETFL
, 0);

111 
	`assert
(
flags
 != -1);

112 
	`fcntl
(
s
, 
F_SETFL
, 
flags
 | 
O_NONBLOCK
);

113 return 
s
;

114 
	}
}

116 static struct 
connection_t
 *
	$find_or_create_connection
(struct 
sockaddr
 *
sa
, 
socklen_t
 
salen
)

118 struct 
connection_t
 *
c
;

119 static 
size_t
 
cid
;

121 for (
c
 = 
connections
.
next
; c != &connections; c = c->next) {

122 if (
c
->
down_addr
.
ss
.
ss_family
 != 
sa
->
sa_family
)

124 switch (
c
->
down_addr
.
ss
.
ss_family
) {

125 case 
AF_INET
: {

126 struct 
sockaddr_in
 *
x
 = (void *)&
c
->
down_addr
, *
y
 = (void *)
sa
;

127 if (!(
	`memcmp
(&
x
->
sin_addr
, &
y
->sin_addr, sizeof(x->sin_addr)) == 0 && x->
sin_port
 == y->sin_port))

130 case 
AF_INET6
: {

131 struct 
sockaddr_in6
 *
x
 = (void *)&
c
->
down_addr
, *
y
 = (void *)
sa
;

132 if (!(
	`memcmp
(&
x
->
sin6_addr
, &
y
->sin6_addr, sizeof(x->sin6_addr)) == 0 && x->
sin6_port
 == y->sin6_port))

136 
	`assert
(!"FIXME");

139 return 
c
;

143 
c
 = 
	`malloc
(sizeof(*c));

144 
	`assert
(
c
 != 
NULL
);

145 
c
->
cid
 = cid++;

146 
c
->
up_fd
 = 
	`new_socket
(
server_addr
->
ai_family
);

147 if (
	`connect
(
c
->
up_fd
, 
server_addr
->
ai_addr
, server_addr->
ai_addrlen
) != 0) {

148 
	`fprintf
(
stderr
, "failed to connect to server:%s\n", 
	`strerror
(
errno
));

149 
	`exit
(1);

151 
	`memcpy
(&
c
->
down_addr
.
ss
, 
sa
, 
salen
);

152 
c
->
down_addr
.
len
 = 
salen
;

153 
c
->
prev
 = 
connections
.prev;

154 
c
->
next
 = &
connections
;

155 
connections
.
prev
 = 
c
;

156 
c
->
prev
->
next
 = c;

157 
c
->
packet_num_up
 = 0;

158 
c
->
packet_num_down
 = 0;

159 return 
c
;

160 
	}
}

162 static void 
	$init_queue
(struct 
queue_t
 *
q
)

164 
	`assert
(
q
->
ring
.
depth
 != 0);

165 
q
->
ring
.
head
 = 0;

166 
q
->
ring
.
tail
 = 0;

167 
q
->
ring
.
elements
 = 
	`malloc
(sizeof(q->ring.elements[0]) * q->ring.
depth
);

168 
	`assert
(
q
->
ring
.
elements
 != 
NULL
);

169 
	}
}

171 static void 
	$dequeue
(struct 
queue_t
 *
q
, int 
up
, 
int64_t
 
now
)

173 if (
q
->
ring
.
head
 == q->ring.
tail
)

175 if (
now
 < 
q
->
congested_until
)

177 if (
up
) {

178 
	`send
(
q
->
ring
.
elements
[q->ring.
head
].
conn
->
up_fd
, q->ring.elements[q->ring.head].
data
, q->ring.elements[q->ring.head].
len
,

181 
	`sendto
(
listen_fd
, 
q
->
ring
.
elements
[q->ring.
head
].
data
, q->ring.elements[q->ring.head].
len
, 0,

182 (void *)&
q
->
ring
.
elements
[q->ring.
head
].
conn
->
down_addr
.
ss
, q->ring.elements[q->ring.head].conn->down_addr.
len
);

184 
	`fprintf
(
stderr
, "%" 
PRId64
 ":%zu:%c:forward\n", 
now
, 
q
->
ring
.
elements
[q->ring.
head
].
conn
->
cid
, 
up
 ? 'u' : 'd');

185 
q
->
ring
.
head
 = (q->ring.head + 1) % q->ring.
depth
;

186 if (
q
->
ring
.
head
 == q->ring.
tail
)

188 
q
->
congested_until
 = 
now
 + q->
interval_usec
;

189 if (
q
->
ring
.
elements
[q->ring.
head
].
arrival
 + q->
delay_usec
 > 
now
)

190 
q
->
congested_until
 += q->
ring
.
elements
[q->ring.
head
].
arrival
 + q->
delay_usec
 - 
now
;

191 
	}
}

193 static int 
	$enqueue
(struct 
queue_t
 *
q
, struct 
connection_t
 *
conn
, 
int64_t
 
now
)

195 
ssize_t
 
readlen
;

196 struct 
sockaddr_storage
 
ss
;

197 
socklen_t
 
sslen
 = sizeof(
ss
);

198 int 
downstream
 = (
conn
 != 
NULL
);

200 if ((
readlen
 = 
	`recvfrom
(
downstream
 ? 
conn
->
up_fd
 : 
listen_fd
, 
q
->
ring
.
elements
[q->ring.
tail
].
data
,

201 sizeof(
q
->
ring
.
elements
[q->ring.
tail
].
data
), 0, 
downstream
 ? 
NULL
 : (void *)&
ss
,

202 
downstream
 ? 
NULL
 : &
sslen
)) <= 0)

205 if (!
downstream
) {

206 
conn
 = 
	`find_or_create_connection
((void *)&
ss
, 
sslen
);

209 
	`assert
(
conn
 != 
NULL
);

210 
uint64_t
 
packet_num
 = 
downstream
 ? ++(
conn
->
packet_num_down
) : ++(conn->
packet_num_up
);

212 if (
q
->
num_drops
 > 0 && 
packet_num
 >= q->
drops
[0] && packet_num <= q->drops[q->num_drops - 1]) {

213 int 
i
 = 0;

214 while (
i
 < 
q
->
num_drops
) {

215 if (
packet_num
 == 
q
->
drops
[
i
]) {

216 
	`fprintf
(
stderr
, "%" 
PRId64
 ":%zu:%c:droplist\n", 
now
, 
conn
->
cid
, 
downstream
 ? 'd' : 'u');

219 
i
++;

223 
q
->
ring
.
elements
[q->ring.
tail
].
len
 = 
readlen
;

224 
q
->
ring
.
elements
[q->ring.
tail
].
conn
 = conn;

225 
q
->
ring
.
elements
[q->ring.
tail
].
arrival
 = 
now
;

227 
size_t
 
next_tail
 = (
q
->
ring
.
tail
 + 1) % q->ring.
depth
;

228 
	`fprintf
(
stderr
, "%" 
PRId64
 ":%zu:%c:", 
now
, 
q
->
ring
.
elements
[q->ring.
tail
].
conn
->
cid
, 
downstream
 ? 'd' : 'u');

230 if (
next_tail
 == 
q
->
ring
.
head
) {

231 ++
q
->
num_dropped
;

232 
	`fprintf
(
stderr
, "drop\n");

237 if (
q
->
ring
.
head
 == q->ring.
tail
)

238 
q
->
congested_until
 = 
now
 + q->
delay_usec
 + q->
interval_usec
;

239 
q
->
ring
.
tail
 = 
next_tail
;

240 ++
q
->
num_forwarded
;

241 
	`fprintf
(
stderr
, "queue\n");

243 
	}
}

245 static void 
	$on_signal
(int 
signo
)

247 
	`fprintf
(
stderr
,

249 " forwarded: %" 
PRIu64
 "\n"

250 " dropped: %" 
PRIu64
 "\n"

252 " forwarded: %" 
PRIu64
 "\n"

253 " dropped: %" 
PRIu64
 "\n",

254 
up
.
num_forwarded
, up.
num_dropped
, 
down
.num_forwarded, down.num_dropped);

255 if (
signo
 == 
SIGINT
)

256 
	`_exit
(0);

257 
	}
}

259 int 
	$main
(int 
argc
, char **
argv
)

261 int 
ch
;

263 
	`signal
(
SIGINT
, 
on_signal
);

264 
	`signal
(
SIGHUP
, 
on_signal
);

266 while ((
ch
 = 
	`getopt
(
argc
, 
argv
, "b:B:i:I:p:P:l:d:D:h")) != -1) {

267 switch (
ch
) {

269 if (
	`sscanf
(
optarg
, "%zu", &
up
.
ring
.
depth
) != 1 || up.ring.depth == 0) {

270 
	`fprintf
(
stderr
, "argument to `-b` must be a positive number\n");

271 
	`exit
(1);

275 if (
	`sscanf
(
optarg
, "%zu", &
down
.
ring
.
depth
) != 1 || down.ring.depth == 0) {

276 
	`fprintf
(
stderr
, "argument to `-D` must be a positive number\n");

277 
	`exit
(1);

281 if (
	`sscanf
(
optarg
, "%" 
PRId64
, &
up
.
interval_usec
) != 1) {

282 
	`fprintf
(
stderr
, "argument to `-i` must be an unsigned number\n");

283 
	`exit
(1);

287 if (
	`sscanf
(
optarg
, "%" 
PRId64
, &
down
.
interval_usec
) != 1) {

288 
	`fprintf
(
stderr
, "argument to `-i` must be an unsigned number\n");

289 
	`exit
(1);

293 if (
	`sscanf
(
optarg
, "%" 
PRId64
, &
up
.
delay_usec
) != 1) {

294 
	`fprintf
(
stderr
, "argument to `-p` must be an unsigned number\n");

295 
	`exit
(1);

299 if (
	`sscanf
(
optarg
, "%" 
PRId64
, &
down
.
delay_usec
) != 1) {

300 
	`fprintf
(
stderr
, "argument to `-P` must be an unsigned number\n");

301 
	`exit
(1);

305 struct 
sockaddr_in
 
sin
;

306 
uint16_t
 
port
;

307 if (
	`sscanf
(
optarg
, "%" 
SCNu16
, &
port
) != 1) {

308 
	`fprintf
(
stderr
, "argument to `-l` must be a port number\n");

309 
	`exit
(1);

311 
	`memset
(&
sin
, 0, sizeof(sin));

312 
sin
.
sin_family
 = 
AF_INET
;

313 
sin
.
sin_port
 = 
	`htons
(
port
);

314 
listen_fd
 = 
	`new_socket
(
sin
.
sin_family
);

315 if (
	`bind
(
listen_fd
, (void *)&
sin
, sizeof(sin)) != 0) {

316 
	`fprintf
(
stderr
, "failed to bind to 0.0.0.0:%" 
PRIu16
 ": %s\n", 
port
, 
	`strerror
(
errno
));

317 
	`exit
(1);

321 
uint16_t
 
pnum
;

322 if (
up
.
num_drops
 >= 
MAXDROPS
)

324 if (
	`sscanf
(
optarg
, "%" 
SCNu16
, &
pnum
) != 1) {

325 
	`fprintf
(
stderr
, "argument to `-d` must be an unsigned number\n");

326 
	`exit
(1);

328 
up
.
drops
[up.
num_drops
++] = 
pnum
;

331 
uint16_t
 
pnum
;

332 if (
down
.
num_drops
 >= 
MAXDROPS
)

334 if (
	`sscanf
(
optarg
, "%" 
SCNu16
, &
pnum
) != 1) {

335 
	`fprintf
(
stderr
, "argument to `-D` must be an unsigned number\n");

336 
	`exit
(1);

338 
down
.
drops
[down.
num_drops
++] = 
pnum
;

341 
	`usage
(
argv
[0], 0);

344 
	`usage
(
argv
[0], 1);

348 
argc
 -= 
optind
;

349 
argv
 += 
optind
;

350 if (
listen_fd
 == -1) {

351 
	`fprintf
(
stderr
, "mandatory option `-l` is missing\n");

352 
	`exit
(1);

354 if (
argc
 != 2) {

355 
	`fprintf
(
stderr
, "missing host and port\n");

356 
	`exit
(1);

359 struct 
addrinfo
 
hints
;

360 int 
err
;

361 
	`memset
(&
hints
, 0, sizeof(hints));

362 
hints
.
ai_family
 = 
AF_INET
;

363 
hints
.
ai_socktype
 = 
SOCK_DGRAM
;

364 
hints
.
ai_protocol
 = 
IPPROTO_UDP
;

365 
hints
.
ai_flags
 = 
AI_ADDRCONFIG
 | 
AI_NUMERICSERV
 | 
AI_PASSIVE
;

366 if ((
err
 = 
	`getaddrinfo
(
argv
[0], argv[1], &
hints
, &
server_addr
)) != 0 || server_addr == 
NULL
) {

367 
	`fprintf
(
stderr
, "failed to resolve server address:%s:%s:%s\n", 
argv
[0], argv[1], 
err
 != 0 ? 
	`gai_strerror
(err) : "null");

368 
	`exit
(1);

372 
	`init_queue
(&
up
);

373 
	`init_queue
(&
down
);

376 struct 
connection_t
 *
c
;

378 
fd_set
 
fds
;

379 struct 
timeval
 
timeout
;

380 
	`FD_ZERO
(&
fds
);

381 
	`FD_SET
(
listen_fd
, &
fds
);

382 int 
nfds
 = 
listen_fd
 + 1;

383 for (
c
 = 
connections
.
next
; c != &connections; c = c->next) {

384 
	`FD_SET
(
c
->
up_fd
, &
fds
);

385 if (
c
->
up_fd
 >= 
nfds
)

386 
nfds
 = 
c
->
up_fd
 + 1;

388 
int64_t
 
now
 = 
	`gettime
(), 
timeout_at
 = now + 1000000000;

389 if (
up
.
ring
.
head
 != up.ring.
tail
 && up.
congested_until
 < 
timeout_at
)

390 
timeout_at
 = 
up
.
congested_until
;

391 if (
down
.
ring
.
head
 != down.ring.
tail
 && down.
congested_until
 < 
timeout_at
)

392 
timeout_at
 = 
down
.
congested_until
;

393 if (
timeout_at
 <= 
now
) {

394 
timeout
.
tv_sec
 = 0;

395 
timeout
.
tv_usec
 = 0;

397 
int64_t
 
d
 = 
timeout_at
 - 
now
;

398 
timeout
.
tv_sec
 = 
d
 / 1000000;

399 
timeout
.
tv_usec
 = 
d
 % 1000000;

401 if (
	`select
(
nfds
, &
fds
, 
NULL
, NULL, &
timeout
) <= 0)

402 
	`FD_ZERO
(&
fds
);

403 
now
 = 
	`gettime
();

405 
	`dequeue
(&
up
, 1, 
now
);

406 
	`dequeue
(&
down
, 0, 
now
);

408 if (
	`FD_ISSET
(
listen_fd
, &
fds
)) {

409 while (
	`enqueue
(&
up
, 
NULL
, 
now
))

412 for (
c
 = 
connections
.
next
; c != &connections; c = c->next) {

413 if (
	`FD_ISSET
(
c
->
up_fd
, &
fds
)) {

414 while (
	`enqueue
(&
down
, 
c
, 
now
))

423 
	}
}

	@
1
.
0
242
7276
CMakeFiles/3.22.1/CompilerIdC/CMakeCCompilerId.c
CMakeFiles/3.22.1/CompilerIdCXX/CMakeCXXCompilerId.cpp
deps/klib/bgzf.c
deps/klib/bgzf.h
deps/klib/kbit.h
deps/klib/kbtree.h
deps/klib/kdq.h
deps/klib/kexpr.c
deps/klib/kexpr.h
deps/klib/kgraph.h
deps/klib/khash.h
deps/klib/khmm.c
deps/klib/khmm.h
deps/klib/klist.h
deps/klib/kmath.c
deps/klib/kmath.h
deps/klib/knetfile.c
deps/klib/knetfile.h
deps/klib/knhx.c
deps/klib/knhx.h
deps/klib/kopen.c
deps/klib/ksa.c
deps/klib/kseq.h
deps/klib/kson.c
deps/klib/kson.h
deps/klib/ksort.h
deps/klib/kstring.c
deps/klib/kstring.h
deps/klib/ksw.c
deps/klib/ksw.h
deps/klib/kthread.c
deps/klib/kthread.h
deps/klib/kurl.c
deps/klib/kurl.h
deps/klib/kvec.h
deps/klib/test/kbit_test.c
deps/klib/test/kbtree_test.c
deps/klib/test/kgraph_test.c
deps/klib/test/khash_keith.c
deps/klib/test/khash_keith2.c
deps/klib/test/khash_test.c
deps/klib/test/klist_test.c
deps/klib/test/kmin_test.c
deps/klib/test/kseq_bench.c
deps/klib/test/kseq_bench2.c
deps/klib/test/kseq_test.c
deps/klib/test/ksort_test.c
deps/klib/test/ksort_test.cc
deps/klib/test/kstring_bench.c
deps/klib/test/kstring_bench2.c
deps/klib/test/kstring_test.c
deps/klib/test/kthread_test.c
deps/klib/test/kthread_test2.c
deps/klib/test/kvec_test.cc
deps/picotest/picotest.c
deps/picotest/picotest.h
deps/picotls/deps/cifra/extra_vecs/openssl-hash.c
deps/picotls/deps/cifra/shitlisp/sl-cifra.c
deps/picotls/deps/cifra/src/aes.c
deps/picotls/deps/cifra/src/aes.h
deps/picotls/deps/cifra/src/arm/boot.c
deps/picotls/deps/cifra/src/arm/ext/cutest.h
deps/picotls/deps/cifra/src/arm/main.c
deps/picotls/deps/cifra/src/arm/semihost.c
deps/picotls/deps/cifra/src/arm/semihost.h
deps/picotls/deps/cifra/src/arm/unacl/scalarmult.c
deps/picotls/deps/cifra/src/bitops.h
deps/picotls/deps/cifra/src/blockwise.c
deps/picotls/deps/cifra/src/blockwise.h
deps/picotls/deps/cifra/src/cbcmac.c
deps/picotls/deps/cifra/src/ccm.c
deps/picotls/deps/cifra/src/cf_config.h
deps/picotls/deps/cifra/src/chacha20.c
deps/picotls/deps/cifra/src/chacha20poly1305.c
deps/picotls/deps/cifra/src/chacha20poly1305.h
deps/picotls/deps/cifra/src/chash.c
deps/picotls/deps/cifra/src/chash.h
deps/picotls/deps/cifra/src/cmac.c
deps/picotls/deps/cifra/src/curve25519.c
deps/picotls/deps/cifra/src/curve25519.donna.c
deps/picotls/deps/cifra/src/curve25519.h
deps/picotls/deps/cifra/src/curve25519.naclref.c
deps/picotls/deps/cifra/src/curve25519.tweetnacl.c
deps/picotls/deps/cifra/src/drbg.c
deps/picotls/deps/cifra/src/drbg.h
deps/picotls/deps/cifra/src/eax.c
deps/picotls/deps/cifra/src/ext/cutest.h
deps/picotls/deps/cifra/src/ext/handy.h
deps/picotls/deps/cifra/src/gcm.c
deps/picotls/deps/cifra/src/gf128.c
deps/picotls/deps/cifra/src/gf128.h
deps/picotls/deps/cifra/src/hmac.c
deps/picotls/deps/cifra/src/hmac.h
deps/picotls/deps/cifra/src/modes.c
deps/picotls/deps/cifra/src/modes.h
deps/picotls/deps/cifra/src/norx.c
deps/picotls/deps/cifra/src/norx.h
deps/picotls/deps/cifra/src/ocb.c
deps/picotls/deps/cifra/src/pbkdf2.c
deps/picotls/deps/cifra/src/pbkdf2.h
deps/picotls/deps/cifra/src/poly1305.c
deps/picotls/deps/cifra/src/poly1305.h
deps/picotls/deps/cifra/src/prp.h
deps/picotls/deps/cifra/src/salsa20.c
deps/picotls/deps/cifra/src/salsa20.h
deps/picotls/deps/cifra/src/sha1.c
deps/picotls/deps/cifra/src/sha1.h
deps/picotls/deps/cifra/src/sha2.h
deps/picotls/deps/cifra/src/sha256.c
deps/picotls/deps/cifra/src/sha3.c
deps/picotls/deps/cifra/src/sha3.h
deps/picotls/deps/cifra/src/sha512.c
deps/picotls/deps/cifra/src/tassert.h
deps/picotls/deps/cifra/src/testaes.c
deps/picotls/deps/cifra/src/testchacha20poly1305.c
deps/picotls/deps/cifra/src/testcurve25519.c
deps/picotls/deps/cifra/src/testdrbg.c
deps/picotls/deps/cifra/src/testmodes.c
deps/picotls/deps/cifra/src/testnorx.c
deps/picotls/deps/cifra/src/testpoly1305.c
deps/picotls/deps/cifra/src/testsalsa20.c
deps/picotls/deps/cifra/src/testsha.h
deps/picotls/deps/cifra/src/testsha1.c
deps/picotls/deps/cifra/src/testsha2.c
deps/picotls/deps/cifra/src/testsha3.c
deps/picotls/deps/cifra/src/testutil.h
deps/picotls/deps/micro-ecc/test/test_compress.c
deps/picotls/deps/micro-ecc/test/test_compute.c
deps/picotls/deps/micro-ecc/test/test_ecdh.c
deps/picotls/deps/micro-ecc/test/test_ecdsa.c
deps/picotls/deps/micro-ecc/types.h
deps/picotls/deps/micro-ecc/uECC.c
deps/picotls/deps/micro-ecc/uECC.h
deps/picotls/deps/micro-ecc/uECC_vli.h
deps/picotls/deps/picotest/picotest.c
deps/picotls/deps/picotest/picotest.h
deps/picotls/fuzz/fuzz-asn1.c
deps/picotls/fuzz/fuzz-client-hello.c
deps/picotls/fuzz/fuzz-server-hello.c
deps/picotls/include/picotls.h
deps/picotls/include/picotls/asn1.h
deps/picotls/include/picotls/certificate_compression.h
deps/picotls/include/picotls/ffx.h
deps/picotls/include/picotls/fusion.h
deps/picotls/include/picotls/minicrypto.h
deps/picotls/include/picotls/openssl.h
deps/picotls/include/picotls/pembase64.h
deps/picotls/include/picotls/ptlsbcrypt.h
deps/picotls/lib/asn1.c
deps/picotls/lib/certificate_compression.c
deps/picotls/lib/cifra.c
deps/picotls/lib/cifra/aes-common.h
deps/picotls/lib/cifra/aes128.c
deps/picotls/lib/cifra/aes256.c
deps/picotls/lib/cifra/chacha20.c
deps/picotls/lib/cifra/random.c
deps/picotls/lib/cifra/x25519.c
deps/picotls/lib/ffx.c
deps/picotls/lib/fusion.c
deps/picotls/lib/minicrypto-pem.c
deps/picotls/lib/openssl.c
deps/picotls/lib/pembase64.c
deps/picotls/lib/picotls.c
deps/picotls/lib/ptlsbcrypt.c
deps/picotls/lib/uecc.c
deps/picotls/picotlsvs/bcrypt-test/bcrypt-test.c
deps/picotls/picotlsvs/picotls-core/targetver.h
deps/picotls/picotlsvs/picotls-esni/getopt.c
deps/picotls/picotlsvs/picotls-esni/getopt.h
deps/picotls/picotlsvs/picotls-minicrypto-deps/targetver.h
deps/picotls/picotlsvs/picotls-minicrypto/targetver.h
deps/picotls/picotlsvs/picotls-openssl/targetver.h
deps/picotls/picotlsvs/picotls/targetver.h
deps/picotls/picotlsvs/picotls/wincompat.h
deps/picotls/picotlsvs/picotls/wintimeofday.c
deps/picotls/picotlsvs/picotlsvs/picotlsvs.c
deps/picotls/picotlsvs/picotlsvs/targetver.h
deps/picotls/picotlsvs/pioctls-core/stdafx.cpp
deps/picotls/picotlsvs/pioctls-core/stdafx.h
deps/picotls/picotlsvs/pioctls-core/targetver.h
deps/picotls/src/esni.c
deps/picotls/t/cli.c
deps/picotls/t/fusion.c
deps/picotls/t/minicrypto.c
deps/picotls/t/openssl.c
deps/picotls/t/picotls.c
deps/picotls/t/ptlsbench.c
deps/picotls/t/test.h
deps/picotls/t/util.h
embedded-probes.h
examples/echo.c
examples/pipeclient.c
examples/pipeserver.c
fuzz/packet.cc
include/quicly.h
include/quicly/cc.h
include/quicly/cid.h
include/quicly/constants.h
include/quicly/defaults.h
include/quicly/frame.h
include/quicly/linklist.h
include/quicly/local_cid.h
include/quicly/loss.h
include/quicly/maxsender.h
include/quicly/ranges.h
include/quicly/recvstate.h
include/quicly/remote_cid.h
include/quicly/retire_cid.h
include/quicly/sendstate.h
include/quicly/sentmap.h
include/quicly/streambuf.h
lib/cc-cubic.c
lib/cc-pico.c
lib/cc-reno.c
lib/defaults.c
lib/frame.c
lib/local_cid.c
lib/loss.c
lib/quicly.c
lib/ranges.c
lib/recvstate.c
lib/remote_cid.c
lib/retire_cid.c
lib/sendstate.c
lib/sentmap.c
lib/streambuf.c
quicly-tracer.h
src/cli.c
t/frame.c
t/local_cid.c
t/loss.c
t/lossy.c
t/maxsender.c
t/ranges.c
t/remote_cid.c
t/retire_cid.c
t/sentmap.c
t/simple.c
t/stream-concurrency.c
t/test.c
t/test.h
t/udpfw.c
